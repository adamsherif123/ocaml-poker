// Generated by js_of_ocaml
//# buildInfo:effects=disabled, kind=cma, use-js-string=true, version=6.2.0

//# unitInfo: Provides: CamlinternalFormatBasics
//# shape: CamlinternalFormatBasics:[F(2),F(1),F(2)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function erase_rel(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, erase_rel(rest)];
      case 1:
       var rest$0 = param[1]; return [1, erase_rel(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, erase_rel(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, erase_rel(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, erase_rel(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, erase_rel(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, erase_rel(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, erase_rel(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1];
       return [8, ty, erase_rel(rest$7)];
      case 9:
       var rest$8 = param[3], ty1 = param[1];
       return [9, ty1, ty1, erase_rel(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, erase_rel(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, erase_rel(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, erase_rel(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, erase_rel(rest$12)];
      default: var rest$13 = param[1]; return [14, erase_rel(rest$13)];
    }
   }
   function concat_fmtty(fmtty1, fmtty2){
    if(typeof fmtty1 === "number") return fmtty2;
    switch(fmtty1[0]){
      case 0:
       var rest = fmtty1[1]; return [0, concat_fmtty(rest, fmtty2)];
      case 1:
       var rest$0 = fmtty1[1]; return [1, concat_fmtty(rest$0, fmtty2)];
      case 2:
       var rest$1 = fmtty1[1]; return [2, concat_fmtty(rest$1, fmtty2)];
      case 3:
       var rest$2 = fmtty1[1]; return [3, concat_fmtty(rest$2, fmtty2)];
      case 4:
       var rest$3 = fmtty1[1]; return [4, concat_fmtty(rest$3, fmtty2)];
      case 5:
       var rest$4 = fmtty1[1]; return [5, concat_fmtty(rest$4, fmtty2)];
      case 6:
       var rest$5 = fmtty1[1]; return [6, concat_fmtty(rest$5, fmtty2)];
      case 7:
       var rest$6 = fmtty1[1]; return [7, concat_fmtty(rest$6, fmtty2)];
      case 8:
       var rest$7 = fmtty1[2], ty = fmtty1[1];
       return [8, ty, concat_fmtty(rest$7, fmtty2)];
      case 9:
       var rest$8 = fmtty1[3], ty2 = fmtty1[2], ty1 = fmtty1[1];
       return [9, ty1, ty2, concat_fmtty(rest$8, fmtty2)];
      case 10:
       var rest$9 = fmtty1[1]; return [10, concat_fmtty(rest$9, fmtty2)];
      case 11:
       var rest$10 = fmtty1[1]; return [11, concat_fmtty(rest$10, fmtty2)];
      case 12:
       var rest$11 = fmtty1[1]; return [12, concat_fmtty(rest$11, fmtty2)];
      case 13:
       var rest$12 = fmtty1[1]; return [13, concat_fmtty(rest$12, fmtty2)];
      default:
       var rest$13 = fmtty1[1]; return [14, concat_fmtty(rest$13, fmtty2)];
    }
   }
   function concat_fmt(fmt1, fmt2){
    if(typeof fmt1 === "number") return fmt2;
    switch(fmt1[0]){
      case 0:
       var rest = fmt1[1]; return [0, concat_fmt(rest, fmt2)];
      case 1:
       var rest$0 = fmt1[1]; return [1, concat_fmt(rest$0, fmt2)];
      case 2:
       var rest$1 = fmt1[2], pad = fmt1[1];
       return [2, pad, concat_fmt(rest$1, fmt2)];
      case 3:
       var rest$2 = fmt1[2], pad$0 = fmt1[1];
       return [3, pad$0, concat_fmt(rest$2, fmt2)];
      case 4:
       var rest$3 = fmt1[4], prec = fmt1[3], pad$1 = fmt1[2], iconv = fmt1[1];
       return [4, iconv, pad$1, prec, concat_fmt(rest$3, fmt2)];
      case 5:
       var
        rest$4 = fmt1[4],
        prec$0 = fmt1[3],
        pad$2 = fmt1[2],
        iconv$0 = fmt1[1];
       return [5, iconv$0, pad$2, prec$0, concat_fmt(rest$4, fmt2)];
      case 6:
       var
        rest$5 = fmt1[4],
        prec$1 = fmt1[3],
        pad$3 = fmt1[2],
        iconv$1 = fmt1[1];
       return [6, iconv$1, pad$3, prec$1, concat_fmt(rest$5, fmt2)];
      case 7:
       var
        rest$6 = fmt1[4],
        prec$2 = fmt1[3],
        pad$4 = fmt1[2],
        iconv$2 = fmt1[1];
       return [7, iconv$2, pad$4, prec$2, concat_fmt(rest$6, fmt2)];
      case 8:
       var
        rest$7 = fmt1[4],
        prec$3 = fmt1[3],
        pad$5 = fmt1[2],
        fconv = fmt1[1];
       return [8, fconv, pad$5, prec$3, concat_fmt(rest$7, fmt2)];
      case 9:
       var rest$8 = fmt1[2], pad$6 = fmt1[1];
       return [9, pad$6, concat_fmt(rest$8, fmt2)];
      case 10:
       var rest$9 = fmt1[1]; return [10, concat_fmt(rest$9, fmt2)];
      case 11:
       var rest$10 = fmt1[2], str = fmt1[1];
       return [11, str, concat_fmt(rest$10, fmt2)];
      case 12:
       var rest$11 = fmt1[2], chr = fmt1[1];
       return [12, chr, concat_fmt(rest$11, fmt2)];
      case 13:
       var rest$12 = fmt1[3], fmtty = fmt1[2], pad$7 = fmt1[1];
       return [13, pad$7, fmtty, concat_fmt(rest$12, fmt2)];
      case 14:
       var rest$13 = fmt1[3], fmtty$0 = fmt1[2], pad$8 = fmt1[1];
       return [14, pad$8, fmtty$0, concat_fmt(rest$13, fmt2)];
      case 15:
       var rest$14 = fmt1[1]; return [15, concat_fmt(rest$14, fmt2)];
      case 16:
       var rest$15 = fmt1[1]; return [16, concat_fmt(rest$15, fmt2)];
      case 17:
       var rest$16 = fmt1[2], fmting_lit = fmt1[1];
       return [17, fmting_lit, concat_fmt(rest$16, fmt2)];
      case 18:
       var rest$17 = fmt1[2], fmting_gen = fmt1[1];
       return [18, fmting_gen, concat_fmt(rest$17, fmt2)];
      case 19:
       var rest$18 = fmt1[1]; return [19, concat_fmt(rest$18, fmt2)];
      case 20:
       var rest$19 = fmt1[3], char_set = fmt1[2], width_opt = fmt1[1];
       return [20, width_opt, char_set, concat_fmt(rest$19, fmt2)];
      case 21:
       var rest$20 = fmt1[2], counter = fmt1[1];
       return [21, counter, concat_fmt(rest$20, fmt2)];
      case 22:
       var rest$21 = fmt1[1]; return [22, concat_fmt(rest$21, fmt2)];
      case 23:
       var rest$22 = fmt1[2], ign = fmt1[1];
       return [23, ign, concat_fmt(rest$22, fmt2)];
      default:
       var rest$23 = fmt1[3], f = fmt1[2], arity = fmt1[1];
       return [24, arity, f, concat_fmt(rest$23, fmt2)];
    }
   }
   var CamlinternalFormatBasics = [0, concat_fmtty, erase_rel, concat_fmt];
   runtime.caml_register_global
    (0, CamlinternalFormatBasics, "CamlinternalFormatBasics");
   return;
  }
  (globalThis));

//# unitInfo: Provides: CamlinternalAtomic
//# shape: CamlinternalAtomic:[F(1)*,F(1)*,F(2),F(2),F(3),F(2),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function make(v){return [0, v];}
   function get(r){return r[1];}
   function set(r, v){r[1] = v; return 0;}
   function exchange(r, v){var cur = r[1]; r[1] = v; return cur;}
   function compare_and_set(r, seen, v){
    var cur = r[1];
    return cur === seen ? (r[1] = v, 1) : 0;
   }
   function fetch_and_add(r, n){
    var cur = r[1];
    r[1] = cur + n | 0;
    return cur;
   }
   function incr(r){fetch_and_add(r, 1); return 0;}
   function decr(r){fetch_and_add(r, -1); return 0;}
   var
    CamlinternalAtomic =
      [0,
       make,
       get,
       set,
       exchange,
       compare_and_set,
       fetch_and_add,
       incr,
       decr];
   runtime.caml_register_global(0, CamlinternalAtomic, "CamlinternalAtomic");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib
//# unitInfo: Requires: Assert_failure, CamlinternalAtomic, CamlinternalFormatBasics, Division_by_zero, End_of_file, Failure, Invalid_argument, Match_failure, Not_found, Out_of_memory, Stack_overflow, Sys_blocked_io, Sys_error, Undefined_recursive_module
//# shape: Stdlib:[F(1),F(1),N,N,N,N,N,N,N,N,N,N,N,N,N,F(2)*,F(2)*,F(1)*,N,N,F(1)*,N,N,N,N,N,N,F(2)*,F(1),F(1)*,F(1)*,F(1),F(1)*,F(1),F(1),F(1),F(2),N,N,N,F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(3),F(1),F(1),F(2),F(2),F(2),F(4),F(4),F(2),F(2),F(2),F(2),F(1),F(1),F(1),F(1),F(2),F(1),F(1),F(3),F(1),F(1),F(4),F(4),F(2),F(1),F(1),F(1),F(2),F(1),F(1),F(1),F(1),F(2),N,F(1)*,F(2),F(1),F(1),F(1),F(4),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_false$0 = "false",
    cst_true$0 = "true",
    caml_create_bytes = runtime.caml_create_bytes,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_channel_size = runtime.caml_ml_channel_size,
    caml_ml_channel_size_64 = runtime.caml_ml_channel_size_64,
    caml_ml_close_channel = runtime.caml_ml_close_channel,
    caml_ml_flush = runtime.caml_ml_flush,
    caml_ml_input = runtime.caml_ml_input,
    caml_ml_input_char = runtime.caml_ml_input_char,
    caml_ml_open_descriptor_in = runtime.caml_ml_open_descriptor_in,
    caml_ml_open_descriptor_out = runtime.caml_ml_open_descriptor_out,
    caml_ml_output = runtime.caml_ml_output,
    caml_ml_output_bytes = runtime.caml_ml_output_bytes,
    caml_ml_output_char = runtime.caml_ml_output_char,
    caml_ml_set_binary_mode = runtime.caml_ml_set_binary_mode,
    caml_ml_set_channel_name = runtime.caml_ml_set_channel_name,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_concat = runtime.caml_string_concat,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_sys_open = runtime.caml_sys_open,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalAtomic = global_data.CamlinternalAtomic,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Invalid_argument = global_data.Invalid_argument,
    Failure = global_data.Failure,
    Match_failure = global_data.Match_failure,
    Assert_failure = global_data.Assert_failure,
    Not_found = global_data.Not_found,
    Out_of_memory = global_data.Out_of_memory,
    Stack_overflow = global_data.Stack_overflow,
    Sys_error = global_data.Sys_error,
    End_of_file = global_data.End_of_file,
    Division_by_zero = global_data.Division_by_zero,
    Sys_blocked_io = global_data.Sys_blocked_io,
    Undefined_recursive_module = global_data.Undefined_recursive_module;
   function failwith(s){
    throw caml_maybe_attach_backtrace([0, Failure, s], 1);
   }
   function invalid_arg(s){
    throw caml_maybe_attach_backtrace([0, Invalid_argument, s], 1);
   }
   var Exit = [248, "Stdlib.Exit", runtime.caml_fresh_oo_id(0)];
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return runtime.caml_greaterequal(x, y) ? x : y;}
   function abs(x){return 0 <= x ? x : - x | 0;}
   function lnot(x){return x ^ -1;}
   var
    symbol_concat = caml_string_concat,
    cst_char_of_int = "char_of_int",
    cst_true = cst_true$0,
    cst_false = cst_false$0,
    cst_bool_of_string = "bool_of_string",
    a = [0, 1],
    b = [0, 0];
   function char_of_int(n){
    if(0 <= n && 255 >= n) return n;
    return invalid_arg(cst_char_of_int);
   }
   function string_of_bool(b){return b ? cst_true : cst_false;}
   function bool_of_string(param){
    return param !== cst_false$0
            ? param !== cst_true$0 ? invalid_arg(cst_bool_of_string) : 1
            : 0;
   }
   function bool_of_string_opt(param){
    return param !== cst_false$0 ? param !== cst_true$0 ? 0 : a : b;
   }
   function string_of_int(n){return "" + n;}
   function int_of_string_opt(s){
    try{var a = [0, caml_int_of_string(s)]; return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag === Failure) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function valid_float_lexem(s1){
    var l = caml_ml_string_length(s1), i = 0;
    for(;;){
     if(l <= i) return s1 + ".";
     var match = runtime.caml_string_get(s1, i);
     a:
     {
      if(48 <= match){if(58 <= match) break a;} else if(45 !== match) break a;
      var i$0 = i + 1 | 0;
      i = i$0;
      continue;
     }
     return s1;
    }
   }
   function string_of_float(f){
    return valid_float_lexem(runtime.caml_format_float("%.12g", f));
   }
   function float_of_string_opt(s){
    try{var a = [0, caml_float_of_string(s)]; return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag === Failure) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function symbol(l1, l2){
    if(! l1) return l2;
    var tl = l1[2], hd = l1[1];
    return [0, hd, symbol(tl, l2)];
   }
   var
    stdin = caml_ml_open_descriptor_in(0),
    stdout = caml_ml_open_descriptor_out(1),
    stderr = caml_ml_open_descriptor_out(2),
    c = [0, 1, [0, 3, [0, 4, [0, 7, 0]]]],
    d = [0, 1, [0, 3, [0, 4, [0, 6, 0]]]],
    cst_output = "output",
    cst_output_substring = "output_substring",
    e = [0, 0, [0, 7, 0]],
    f = [0, 0, [0, 6, 0]],
    cst_input = "input",
    cst_really_input = "really_input";
   function open_out_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_out(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_out(name){return open_out_gen(c, 438, name);}
   function open_out_bin(name){return open_out_gen(d, 438, name);}
   function flush_all(param){
    var param$0 = runtime.caml_ml_out_channels_list(0);
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     try{caml_ml_flush(a); param$0 = l;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0), tag = exn[1];
      if(tag !== Sys_error) throw caml_maybe_attach_backtrace(exn, 0);
      param$0 = l;
     }
    }
   }
   function output_bytes(oc, s){
    return caml_ml_output_bytes(oc, s, 0, caml_ml_bytes_length(s));
   }
   function output_string(oc, s){
    return caml_ml_output(oc, s, 0, caml_ml_string_length(s));
   }
   function output(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_output_bytes(oc, s, ofs, len);
    return invalid_arg(cst_output);
   }
   function output_substring(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(s) - len | 0) >= ofs)
     return caml_ml_output(oc, s, ofs, len);
    return invalid_arg(cst_output_substring);
   }
   function output_value(chan, v){
    return runtime.caml_output_value(chan, v, 0);
   }
   function close_out(oc){
    caml_ml_flush(oc);
    return caml_ml_close_channel(oc);
   }
   function close_out_noerr(oc){
    try{caml_ml_flush(oc);}catch(exn){}
    try{var a = caml_ml_close_channel(oc); return a;}catch(exn){return 0;}
   }
   function open_in_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_in(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_in(name){return open_in_gen(e, 0, name);}
   function open_in_bin(name){return open_in_gen(f, 0, name);}
   function input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_input(ic, s, ofs, len);
    return invalid_arg(cst_input);
   }
   function unsafe_really_input(ic, s, ofs$1, len$1){
    var ofs = ofs$1, len = len$1;
    for(;;){
     if(0 >= len) return 0;
     var r = caml_ml_input(ic, s, ofs, len);
     if(0 === r) throw caml_maybe_attach_backtrace(End_of_file, 1);
     var len$0 = len - r | 0, ofs$0 = ofs + r | 0;
     ofs = ofs$0;
     len = len$0;
    }
   }
   function really_input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return unsafe_really_input(ic, s, ofs, len);
    return invalid_arg(cst_really_input);
   }
   function really_input_string(ic, len){
    var s = caml_create_bytes(len);
    really_input(ic, s, 0, len);
    return caml_string_of_bytes(s);
   }
   function input_line(chan){
    function build_result(buf, pos$1, param$0){
     var pos = pos$1, param = param$0;
     for(;;){
      if(! param) return buf;
      var tl = param[2], hd = param[1], len = caml_ml_bytes_length(hd);
      runtime.caml_blit_bytes(hd, 0, buf, pos - len | 0, len);
      var pos$0 = pos - len | 0;
      pos = pos$0;
      param = tl;
     }
    }
    var accu = 0, len = 0;
    for(;;){
     var n = runtime.caml_ml_input_scan_line(chan);
     if(0 === n){
      if(! accu) throw caml_maybe_attach_backtrace(End_of_file, 1);
      var a = build_result(caml_create_bytes(len), len, accu);
     }
     else{
      if(0 >= n){
       var beg = caml_create_bytes(- n | 0);
       caml_ml_input(chan, beg, 0, - n | 0);
       var len$1 = len - n | 0, accu$0 = [0, beg, accu];
       accu = accu$0;
       len = len$1;
       continue;
      }
      var res = caml_create_bytes(n - 1 | 0);
      caml_ml_input(chan, res, 0, n - 1 | 0);
      caml_ml_input_char(chan);
      if(accu)
       var
        len$0 = (len + n | 0) - 1 | 0,
        a = build_result(caml_create_bytes(len$0), len$0, [0, res, accu]);
      else
       var a = res;
     }
     return caml_string_of_bytes(a);
    }
   }
   function close_in_noerr(ic){
    try{var a = caml_ml_close_channel(ic); return a;}catch(exn){return 0;}
   }
   function print_char(c){return caml_ml_output_char(stdout, c);}
   function print_string(s){return output_string(stdout, s);}
   function print_bytes(s){return output_bytes(stdout, s);}
   function print_int(i){return output_string(stdout, "" + i);}
   function print_float(f){return output_string(stdout, string_of_float(f));}
   function print_endline(s){
    output_string(stdout, s);
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function print_newline(param){
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function prerr_char(c){return caml_ml_output_char(stderr, c);}
   function prerr_string(s){return output_string(stderr, s);}
   function prerr_bytes(s){return output_bytes(stderr, s);}
   function prerr_int(i){return output_string(stderr, "" + i);}
   function prerr_float(f){return output_string(stderr, string_of_float(f));}
   function prerr_endline(s){
    output_string(stderr, s);
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function prerr_newline(param){
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function read_line(param){caml_ml_flush(stdout); return input_line(stdin);}
   function read_int(param){return caml_int_of_string(read_line(0));}
   function read_int_opt(param){return int_of_string_opt(read_line(0));}
   function read_float(param){return caml_float_of_string(read_line(0));}
   function read_float_opt(param){return float_of_string_opt(read_line(0));}
   function string_of_format(param){var str = param[2]; return str;}
   function symbol$0(param, a){
    var
     str2 = a[2],
     fmt2 = a[1],
     str1 = param[2],
     fmt1 = param[1],
     s2 = "%," + str2;
    return [0, CamlinternalFormatBasics[3].call(null, fmt1, fmt2), str1 + s2];
   }
   var exit_function = CamlinternalAtomic[1].call(null, flush_all);
   function at_exit(f){
    for(;;){
     var
      f_yet_to_run = CamlinternalAtomic[1].call(null, 1),
      old_exit = CamlinternalAtomic[2].call(null, exit_function);
     let f_yet_to_run$0 = f_yet_to_run, old_exit$0 = old_exit;
     var
      new_exit =
        function(param){
         if(CamlinternalAtomic[5].call(null, f_yet_to_run$0, 1, 0))
          caml_call1(f, 0);
         return caml_call1(old_exit$0, 0);
        },
      success =
        CamlinternalAtomic[5].call(null, exit_function, old_exit, new_exit),
      a = 1 - success;
     if(! a) return a;
    }
   }
   function do_at_exit(param){
    return caml_call1(CamlinternalAtomic[2].call(null, exit_function), 0);
   }
   function exit(retcode){
    do_at_exit(0);
    return runtime.caml_sys_exit(retcode);
   }
   runtime.caml_register_named_value("Pervasives.do_at_exit", do_at_exit);
   var
    Stdlib =
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       2147483647,
       -2147483648,
       lnot,
       Infinity,
       -Infinity,
       NaN,
       1.7976931348623157e+308,
       2.2250738585072014e-308,
       2.220446049250313e-16,
       symbol_concat,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       symbol,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       runtime.caml_ml_output_int,
       output_value,
       runtime.caml_ml_seek_out,
       runtime.caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       runtime.caml_ml_input_int,
       runtime.caml_input_value,
       runtime.caml_ml_seek_in,
       runtime.caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
   runtime.caml_register_global(46, Stdlib, "Stdlib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Pervasives
//# unitInfo: Requires: Stdlib
//# shape: Stdlib__Pervasives:[F(1),F(1),N,F(2)*,F(2)*,F(1)*,N,N,F(1)*,N,N,N,N,N,N,F(2)*,F(1),F(1)*,F(1),F(1)*,F(1)*,F(1),F(1),F(1),F(2),N,N,N,F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(3),F(1),F(1),F(2),F(2),F(2),F(4),F(4),F(2),F(2),F(2),F(2),F(1),F(1),F(1),F(1),F(2),F(1),F(1),F(3),F(1),F(1),F(4),F(4),F(2),F(1),F(1),F(1),F(2),F(1),F(1),F(1),F(1),F(2),F(1)*,F(2),F(1),F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    invalid_arg = Stdlib[1],
    failwith = Stdlib[2],
    Exit = [248, "Stdlib.Pervasives.Exit", runtime.caml_fresh_oo_id(0)],
    min = Stdlib[16],
    max = Stdlib[17],
    abs = Stdlib[18],
    max_int = Stdlib[19],
    min_int = Stdlib[20],
    lnot = Stdlib[21],
    infinity = Stdlib[22],
    neg_infinity = Stdlib[23],
    nan = Stdlib[24],
    max_float = Stdlib[25],
    min_float = Stdlib[26],
    epsilon_float = Stdlib[27],
    symbol_concat = Stdlib[28],
    char_of_int = Stdlib[29],
    string_of_bool = Stdlib[30],
    bool_of_string = Stdlib[32],
    bool_of_string_opt = Stdlib[31],
    string_of_int = Stdlib[33],
    int_of_string_opt = Stdlib[34],
    string_of_float = Stdlib[35],
    float_of_string_opt = Stdlib[36],
    symbol = Stdlib[37],
    stdin = Stdlib[38],
    stdout = Stdlib[39],
    stderr = Stdlib[40],
    print_char = Stdlib[41],
    print_string = Stdlib[42],
    print_bytes = Stdlib[43],
    print_int = Stdlib[44],
    print_float = Stdlib[45],
    print_endline = Stdlib[46],
    print_newline = Stdlib[47],
    prerr_char = Stdlib[48],
    prerr_string = Stdlib[49],
    prerr_bytes = Stdlib[50],
    prerr_int = Stdlib[51],
    prerr_float = Stdlib[52],
    prerr_endline = Stdlib[53],
    prerr_newline = Stdlib[54],
    read_line = Stdlib[55],
    read_int = Stdlib[57],
    read_int_opt = Stdlib[56],
    read_float = Stdlib[59],
    read_float_opt = Stdlib[58],
    open_out = Stdlib[60],
    open_out_bin = Stdlib[61],
    open_out_gen = Stdlib[62],
    flush = Stdlib[63],
    flush_all = Stdlib[64],
    output_char = Stdlib[65],
    output_string = Stdlib[66],
    output_bytes = Stdlib[67],
    output = Stdlib[68],
    output_substring = Stdlib[69],
    output_byte = Stdlib[70],
    output_binary_int = Stdlib[71],
    output_value = Stdlib[72],
    seek_out = Stdlib[73],
    pos_out = Stdlib[74],
    out_channel_length = Stdlib[75],
    close_out = Stdlib[76],
    close_out_noerr = Stdlib[77],
    set_binary_mode_out = Stdlib[78],
    open_in = Stdlib[79],
    open_in_bin = Stdlib[80],
    open_in_gen = Stdlib[81],
    input_char = Stdlib[82],
    input_line = Stdlib[83],
    input = Stdlib[84],
    really_input = Stdlib[85],
    really_input_string = Stdlib[86],
    input_byte = Stdlib[87],
    input_binary_int = Stdlib[88],
    input_value = Stdlib[89],
    seek_in = Stdlib[90],
    pos_in = Stdlib[91],
    in_channel_length = Stdlib[92],
    close_in = Stdlib[93],
    close_in_noerr = Stdlib[94],
    set_binary_mode_in = Stdlib[95],
    string_of_format = Stdlib[97],
    symbol$0 = Stdlib[98],
    exit = Stdlib[99],
    at_exit = Stdlib[100],
    valid_float_lexem = Stdlib[101],
    do_at_exit = Stdlib[103],
    Stdlib_Pervasives =
      [0,
       invalid_arg,
       failwith,
       Exit,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       symbol_concat,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       symbol,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       do_at_exit];
   runtime.caml_register_global(2, Stdlib_Pervasives, "Stdlib__Pervasives");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Either
//# shape: Stdlib__Either:[F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(2),F(2),F(3),F(3),F(3),F(3),F(4),F(4)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function left(v){return [0, v];}
   function right(v){return [1, v];}
   function is_left(param){return 0 === param[0] ? 1 : 0;}
   function is_right(param){return 0 === param[0] ? 0 : 1;}
   function find_left(param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return [0, v];
   }
   function find_right(param){
    if(0 === param[0]) return 0;
    var v = param[1];
    return [0, v];
   }
   function map_left(f, e){
    if(0 !== e[0]) return e;
    var v = e[1];
    return [0, caml_call1(f, v)];
   }
   function map_right(f, e){
    if(0 === e[0]) return e;
    var v = e[1];
    return [1, caml_call1(f, v)];
   }
   function map(left, right, param){
    if(0 === param[0]){var v = param[1]; return [0, caml_call1(left, v)];}
    var v$0 = param[1];
    return [1, caml_call1(right, v$0)];
   }
   function fold(left, right, param){
    if(0 === param[0]){var v = param[1]; return caml_call1(left, v);}
    var v$0 = param[1];
    return caml_call1(right, v$0);
   }
   function equal(left, right, e1, e2){
    if(0 === e1[0]){
     var v1 = e1[1];
     if(0 === e2[0]){var v2 = e2[1]; return caml_call2(left, v1, v2);}
    }
    else{
     var v1$0 = e1[1];
     if(0 !== e2[0]){var v2$0 = e2[1]; return caml_call2(right, v1$0, v2$0);}
    }
    return 0;
   }
   function compare(left, right, e1, e2){
    if(0 === e1[0]){
     var v1 = e1[1];
     if(0 !== e2[0]) return -1;
     var v2 = e2[1];
     return caml_call2(left, v1, v2);
    }
    var v1$0 = e1[1];
    if(0 === e2[0]) return 1;
    var v2$0 = e2[1];
    return caml_call2(right, v1$0, v2$0);
   }
   var
    Stdlib_Either =
      [0,
       left,
       right,
       is_left,
       is_right,
       find_left,
       find_right,
       map_left,
       map_right,
       map,
       fold,
       fold,
       fold,
       equal,
       compare];
   runtime.caml_register_global(0, Stdlib_Either, "Stdlib__Either");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Sys
//# unitInfo: Requires: Stdlib
//# shape: Stdlib__Sys:[N,F(1),N,N,[N],N,N,N,N,N,N,N,N,N,F(2)*,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,F(1)*,N,N,N,F(1),F(1),[F(2)*]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    ocaml_version = "4.14.2",
    ocaml_release = [0, 4, 14, 2, 0],
    Stdlib = global_data.Stdlib,
    executable_name = runtime.caml_sys_executable_name(0),
    os_type = runtime.caml_sys_get_config(0)[1],
    backend_type = [0, "js_of_ocaml"],
    unix = runtime.caml_sys_const_ostype_unix(0),
    win32 = runtime.caml_sys_const_ostype_win32(0),
    cygwin = runtime.caml_sys_const_ostype_cygwin(0),
    max_array_length = runtime.caml_sys_const_max_wosize(0),
    max_floatarray_length = max_array_length / 2 | 0,
    max_string_length = (4 * max_array_length | 0) - 1 | 0;
   function getenv_opt(s){
    try{var a = [0, runtime.caml_sys_getenv(s)]; return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var interactive = [0, 0];
   function set_signal(sig_num, sig_beh){return 0;}
   var Break = [248, "Stdlib.Sys.Break", runtime.caml_fresh_oo_id(0)];
   function catch_break(on){return on ? 0 : 0;}
   function Make(Immediate, Non_immediate){return [0, 1];}
   var
    Immediate64 = [0, Make],
    Stdlib_Sys =
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       backend_type,
       unix,
       win32,
       cygwin,
       32,
       32,
       0,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       -1,
       -2,
       -3,
       -4,
       -5,
       -6,
       -7,
       -8,
       -9,
       -10,
       -11,
       -12,
       -13,
       -14,
       -15,
       -16,
       -17,
       -18,
       -19,
       -20,
       -21,
       -22,
       -23,
       -24,
       -25,
       -26,
       -27,
       -28,
       Break,
       catch_break,
       ocaml_version,
       0,
       ocaml_release,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
   runtime.caml_register_global(4, Stdlib_Sys, "Stdlib__Sys");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Obj
//# unitInfo: Requires: Assert_failure, Stdlib, Stdlib__Sys
//# shape: Stdlib__Obj:[F(1)*,F(2),F(3),N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,[F(1),F(1)*,F(1)*],F(1),F(1)*,F(1)*,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Obj_extension_constructor$1 = "Obj.extension_constructor",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys;
   function is_block(a){return 1 - (typeof a === "number" ? 1 : 0);}
   function double_field(x, i){return caml_check_bound(x, i)[i + 1];}
   function set_double_field(x, i, v){
    caml_check_bound(x, i)[i + 1] = v;
    return 0;
   }
   var
    custom_tag = 255,
    a = [0, "obj.ml", 95, 4],
    cst_Obj_extension_constructor = cst_Obj_extension_constructor$1,
    cst_Obj_extension_constructor$0 = cst_Obj_extension_constructor$1;
   function info(obj){
    if(caml_obj_tag(obj) !== 247)
     throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
    var
     info = runtime.caml_obj_raw_field(obj, 1),
     arity = 64 === Stdlib_Sys[9] ? info >> 56 : info >> 24,
     start_env = info << 8 >>> 9 | 0;
    return [0, arity, start_env];
   }
   function extension_constructor(x){
    var
     slot =
       is_block(x)
        ? caml_obj_tag(x) !== 248 ? 1 <= x.length - 1 ? x[1] : x : x
        : x;
    a:
    {
     if(is_block(slot) && caml_obj_tag(slot) === 248){var name = slot[1]; break a;}
     var name = Stdlib[1].call(null, cst_Obj_extension_constructor$0);
    }
    return caml_obj_tag(name) === 252
            ? slot
            : Stdlib[1].call(null, cst_Obj_extension_constructor);
   }
   function extension_name(slot){return slot[1];}
   function extension_id(slot){return slot[2];}
   var
    Extension_constructor =
      [0, extension_constructor, extension_name, extension_id],
    max_ephe_length = Stdlib_Sys[13] - 2 | 0,
    cst_Obj_Ephemeron_create = "Obj.Ephemeron.create",
    cst_Obj_Ephemeron_get_key = "Obj.Ephemeron.get_key",
    cst_Obj_Ephemeron_get_key_copy = "Obj.Ephemeron.get_key_copy",
    cst_Obj_Ephemeron_set_key = "Obj.Ephemeron.set_key",
    cst_Obj_Ephemeron_unset_key = "Obj.Ephemeron.unset_key",
    cst_Obj_Ephemeron_check_key = "Obj.Ephemeron.check_key",
    cst_Obj_Ephemeron_blit_key = "Obj.Ephemeron.blit_key";
   function create(l){
    var a = 0 <= l ? 1 : 0, b = a ? l <= max_ephe_length ? 1 : 0 : a;
    if(1 - b) Stdlib[1].call(null, cst_Obj_Ephemeron_create);
    return runtime.caml_ephe_create(l);
   }
   function length(x){return x.length - 3 | 0;}
   function raise_if_invalid_offset(e, o, msg){
    var a = 0 <= o ? 1 : 0, c = a ? o < length(e) ? 1 : 0 : a, b = 1 - c;
    return b ? Stdlib[1].call(null, msg) : b;
   }
   function get_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key);
    return runtime.caml_ephe_get_key(e, o);
   }
   function get_key_copy(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key_copy);
    return runtime.caml_ephe_get_key_copy(e, o);
   }
   function set_key(e, o, x){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_set_key);
    return runtime.caml_ephe_set_key(e, o, x);
   }
   function unset_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_unset_key);
    return runtime.caml_ephe_unset_key(e, o);
   }
   function check_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_check_key);
    return runtime.caml_ephe_check_key(e, o);
   }
   function blit_key(e1, o1, e2, o2, l){
    if
     (0 <= l
      &&
       0 <= o1
       && (length(e1) - l | 0) >= o1 && 0 <= o2 && (length(e2) - l | 0) >= o2){
     var
      a = 0 !== l ? 1 : 0,
      b = a ? runtime.caml_ephe_blit_key(e1, o1, e2, o2, l) : a;
     return b;
    }
    return Stdlib[1].call(null, cst_Obj_Ephemeron_blit_key);
   }
   var
    Stdlib_Obj =
      [0,
       is_block,
       double_field,
       set_double_field,
       0,
       245,
       246,
       247,
       248,
       249,
       250,
       251,
       251,
       252,
       253,
       254,
       custom_tag,
       custom_tag,
       1000,
       1001,
       1002,
       [0, info],
       Extension_constructor,
       extension_constructor,
       extension_name,
       extension_id,
       [0,
        create,
        length,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        runtime.caml_ephe_get_data,
        runtime.caml_ephe_get_data_copy,
        runtime.caml_ephe_set_data,
        runtime.caml_ephe_unset_data,
        runtime.caml_ephe_check_data,
        runtime.caml_ephe_blit_data,
        max_ephe_length]];
   runtime.caml_register_global(13, Stdlib_Obj, "Stdlib__Obj");
   return;
  }
  (globalThis));

//# unitInfo: Provides: CamlinternalLazy
//# unitInfo: Requires: Stdlib, Stdlib__Obj
//# shape: CamlinternalLazy:[N,F(1),F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_make_forward = runtime.caml_obj_make_forward,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined =
      [248, "CamlinternalLazy.Undefined", runtime.caml_fresh_oo_id(0)];
   function raise_undefined(param){
    throw caml_maybe_attach_backtrace(Undefined, 1);
   }
   function force_lazy_block(blk){
    var closure = blk[1];
    blk[1] = raise_undefined;
    try{
     var result = caml_call1(closure, 0);
     caml_obj_make_forward(blk, result);
     return result;
    }
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     blk[1] = function(param){throw caml_maybe_attach_backtrace(e, 0);};
     throw caml_maybe_attach_backtrace(e, 0);
    }
   }
   function force_val_lazy_block(blk){
    var closure = blk[1];
    blk[1] = raise_undefined;
    var result = caml_call1(closure, 0);
    caml_obj_make_forward(blk, result);
    return result;
   }
   function force(lzv){
    var t = caml_obj_tag(lzv);
    return t === Stdlib_Obj[10]
            ? lzv[1]
            : t !== Stdlib_Obj[6] ? lzv : force_lazy_block(lzv);
   }
   function force_val(lzv){
    var t = caml_obj_tag(lzv);
    return t === Stdlib_Obj[10]
            ? lzv[1]
            : t !== Stdlib_Obj[6] ? lzv : force_val_lazy_block(lzv);
   }
   var
    CamlinternalLazy =
      [0, Undefined, force_lazy_block, force_val_lazy_block, force, force_val];
   runtime.caml_register_global(2, CamlinternalLazy, "CamlinternalLazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Lazy
//# unitInfo: Requires: CamlinternalLazy, Stdlib, Stdlib__Obj
//# shape: Stdlib__Lazy:[N,F(2)*,F(1),F(1),F(2),F(1),F(1),F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined = CamlinternalLazy[1],
    force_val = CamlinternalLazy[5];
   function from_fun(f){
    var x = runtime.caml_obj_block(Stdlib_Obj[6], 1);
    x[1] = f;
    return x;
   }
   function from_val(v){
    var t = caml_obj_tag(v);
    if(t !== Stdlib_Obj[10] && t !== Stdlib_Obj[6] && t !== Stdlib_Obj[14])
     return v;
    return runtime.caml_lazy_make_forward(v);
   }
   function is_val(l){
    var a = Stdlib_Obj[6];
    return caml_obj_tag(l) !== a ? 1 : 0;
   }
   function map(f, x){
    return [246,
            function(param){
             var
              a = caml_obj_tag(x),
              b =
                250 === a
                 ? x[1]
                 : 246 === a ? CamlinternalLazy[2].call(null, x) : x;
             return caml_call1(f, b);
            }];
   }
   function map_val(f, x){
    if(! is_val(x))
     return [246,
             function(param){
              var
               a = caml_obj_tag(x),
               b =
                 250 === a
                  ? x[1]
                  : 246 === a ? CamlinternalLazy[2].call(null, x) : x;
              return caml_call1(f, b);
             }];
    var
     a = caml_obj_tag(x),
     b = 250 === a ? x[1] : 246 === a ? CamlinternalLazy[2].call(null, x) : x;
    return from_val(caml_call1(f, b));
   }
   var
    Stdlib_Lazy =
      [0,
       Undefined,
       map,
       is_val,
       from_val,
       map_val,
       from_fun,
       force_val,
       from_fun,
       from_val,
       is_val];
   runtime.caml_register_global(2, Stdlib_Lazy, "Stdlib__Lazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Seq
//# unitInfo: Requires: Assert_failure, CamlinternalAtomic, CamlinternalLazy, Stdlib, Stdlib__Lazy
//# shape: Stdlib__Seq:[F(1),F(1),F(1),F(2),F(3),F(2),F(3),F(2),F(2),F(2),F(2),F(3),F(4),F(3),F(3),F(3),F(3),F(1)*,F(2)*,F(3)*,F(2),F(3),F(2)*,F(2),F(2),F(2)*->F(1)*,F(3),F(2)*->F(1),F(3),F(3),F(3)*->F(1)*,F(2),F(2),F(3),F(3),F(3),F(1)->F(1),N,F(1)*->F(1),F(2),F(3),F(2),F(3),F(3),F(3),F(4),F(3),F(4),F(2)*,F(3)*->F(1),F(1)*,F(1)*,F(2)*,F(2)*,F(1)*->F(1),F(1)*->F(1),F(2)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    CamlinternalAtomic = global_data.CamlinternalAtomic,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib = global_data.Stdlib,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    cst_Seq_init = "Seq.init",
    cst_Seq_take = "Seq.take",
    cst_Seq_drop = "Seq.drop";
   function empty(param){return 0;}
   function return$(x, param){return [0, x, empty];}
   function cons(x, next, param){return [0, x, next];}
   function append(seq1, seq2, param){
    var match = caml_call1(seq1, 0);
    if(! match) return caml_call1(seq2, 0);
    var next = match[2], x = match[1];
    return [0, x, function(a){return append(next, seq2, a);}];
   }
   function map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return [0, caml_call1(f, x), function(a){return map(f, next, a);}];
   }
   function filter_map(f, seq$0, param){
    var seq = seq$0;
    for(;;){
     var match = caml_call1(seq, 0);
     if(! match) return 0;
     var next = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(match$0) break;
     seq = next;
    }
    var y = match$0[1];
    return [0, y, function(a){return filter_map(f, next, a);}];
   }
   function filter(f, seq$0, param){
    var seq = seq$0;
    for(;;){
     var match = caml_call1(seq, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     if(caml_call1(f, x)) break;
     seq = next;
    }
    return [0, x, function(a){return filter(f, next, a);}];
   }
   function concat(seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return append(x, function(a){return concat(next, a);}, 0);
   }
   function flat_map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return append
            (caml_call1(f, x), function(a){return flat_map(f, next, a);}, 0);
   }
   function fold_left(f, acc$1, seq$0){
    var acc = acc$1, seq = seq$0;
    for(;;){
     var match = caml_call1(seq, 0);
     if(! match) return acc;
     var next = match[2], x = match[1], acc$0 = caml_call2(f, acc, x);
     acc = acc$0;
     seq = next;
    }
   }
   function iter(f, seq$0){
    var seq = seq$0;
    for(;;){
     var match = caml_call1(seq, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     caml_call1(f, x);
     seq = next;
    }
   }
   function unfold(f, u, param){
    var match = caml_call1(f, u);
    if(! match) return 0;
    var match$0 = match[1], u$0 = match$0[2], x = match$0[1];
    return [0, x, function(a){return unfold(f, u$0, a);}];
   }
   function is_empty(xs){return caml_call1(xs, 0) ? 0 : 1;}
   function uncons(xs){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return [0, [0, x, xs$0]];
   }
   function length(xs$1){
    var accu = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var xs$0 = match[2], accu$0 = accu + 1 | 0;
     accu = accu$0;
     xs = xs$0;
    }
   }
   function iteri(f, xs$1){
    var i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     caml_call2(f, i, x);
     var i$0 = i + 1 | 0;
     i = i$0;
     xs = xs$0;
    }
   }
   function fold_lefti(f, accu$1, xs$1){
    var accu = accu$1, i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var
      xs$0 = match[2],
      x = match[1],
      accu$0 = caml_call3(f, accu, i, x),
      i$0 = i + 1 | 0;
     accu = accu$0;
     i = i$0;
     xs = xs$0;
    }
   }
   function for_all(p, xs$1){
    var xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 1;
     var xs$0 = match[2], x = match[1], a = caml_call1(p, x);
     if(! a) return a;
     xs = xs$0;
    }
   }
   function exists(p, xs$1){
    var xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1], a = caml_call1(p, x);
     if(a) return a;
     xs = xs$0;
    }
   }
   function find(p, xs$1){
    var xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     if(caml_call1(p, x)) return [0, x];
     xs = xs$0;
    }
   }
   function find_map(f, xs$1){
    var xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1], result = caml_call1(f, x);
     if(result) return result;
     xs = xs$0;
    }
   }
   function iter2(f, xs$1, ys$1){
    var xs = xs$1, ys = ys$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
     if(! match$0) return 0;
     var ys$0 = match$0[2], y = match$0[1];
     caml_call2(f, x, y);
     xs = xs$0;
     ys = ys$0;
    }
   }
   function fold_left2(f, accu$1, xs$1, ys$1){
    var accu = accu$1, xs = xs$1, ys = ys$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
     if(! match$0) return accu;
     var
      ys$0 = match$0[2],
      y = match$0[1],
      accu$0 = caml_call3(f, accu, x, y);
     accu = accu$0;
     xs = xs$0;
     ys = ys$0;
    }
   }
   function for_all2(f, xs$1, ys$1){
    var xs = xs$1, ys = ys$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 1;
     var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
     if(! match$0) return 1;
     var ys$0 = match$0[2], y = match$0[1], a = caml_call2(f, x, y);
     if(! a) return a;
     xs = xs$0;
     ys = ys$0;
    }
   }
   function exists2(f, xs$1, ys$1){
    var xs = xs$1, ys = ys$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
     if(! match$0) return 0;
     var ys$0 = match$0[2], y = match$0[1], a = caml_call2(f, x, y);
     if(a) return a;
     xs = xs$0;
     ys = ys$0;
    }
   }
   function equal(eq, xs$1, ys$1){
    var xs = xs$1, ys = ys$1;
    for(;;){
     var match = caml_call1(xs, 0), match$0 = caml_call1(ys, 0);
     if(match){
      if(match$0){
       var
        ys$0 = match$0[2],
        y = match$0[1],
        xs$0 = match[2],
        x = match[1],
        a = caml_call2(eq, x, y);
       if(! a) return a;
       xs = xs$0;
       ys = ys$0;
       continue;
      }
     }
     else if(! match$0) return 1;
     return 0;
    }
   }
   function compare(cmp, xs$1, ys$1){
    var xs = xs$1, ys = ys$1;
    for(;;){
     var match = caml_call1(xs, 0), match$0 = caml_call1(ys, 0);
     if(! match) return match$0 ? -1 : 0;
     var xs$0 = match[2], x = match[1];
     if(! match$0) return 1;
     var ys$0 = match$0[2], y = match$0[1], c = caml_call2(cmp, x, y);
     if(0 !== c) return c;
     xs = xs$0;
     ys = ys$0;
    }
   }
   function init_aux(f, i, j, param){
    if(i >= j) return 0;
    var a = i + 1 | 0;
    return [0, caml_call1(f, i), function(b){return init_aux(f, a, j, b);}];
   }
   function init(n, f){
    if(0 > n) return Stdlib[1].call(null, cst_Seq_init);
    var a = 0;
    return function(b){return init_aux(f, a, n, b);};
   }
   function repeat(x, param){
    return [0, x, function(a){return repeat(x, a);}];
   }
   function forever(f, param){
    return [0, caml_call1(f, 0), function(a){return forever(f, a);}];
   }
   function cycle_nonempty(xs, param){
    return append(xs, function(a){return cycle_nonempty(xs, a);}, 0);
   }
   function cycle(xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    function a(a){return cycle_nonempty(xs, a);}
    return [0, x, function(b){return append(xs$0, a, b);}];
   }
   function iterate1(f, x, param){
    var y = caml_call1(f, x);
    return [0, y, function(a){return iterate1(f, y, a);}];
   }
   function iterate(f, x){
    function next(a){return iterate1(f, x, a);}
    return function(param){return [0, x, next];};
   }
   function mapi_aux(f, i, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], a = i + 1 | 0;
    return [0,
            caml_call2(f, i, x),
            function(b){return mapi_aux(f, a, xs$0, b);}];
   }
   function mapi(f, xs){
    var a = 0;
    return function(b){return mapi_aux(f, a, xs, b);};
   }
   function tail_scan(f, s, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], s$0 = caml_call2(f, s, x);
    return [0, s$0, function(a){return tail_scan(f, s$0, xs$0, a);}];
   }
   function scan(f, s, xs){
    function next(a){return tail_scan(f, s, xs, a);}
    return function(param){return [0, s, next];};
   }
   function take_aux(n, xs){
    return 0 === n
            ? empty
            : function
             (param){
              var match = caml_call1(xs, 0);
              if(! match) return 0;
              var xs$0 = match[2], x = match[1];
              return [0, x, take_aux(n - 1 | 0, xs$0)];
             };
   }
   function take(n, xs){
    if(n < 0) Stdlib[1].call(null, cst_Seq_take);
    return take_aux(n, xs);
   }
   function drop(n, xs){
    return 0 <= n
            ? 0
              === n
              ? xs
              : function
               (param){
                var n$0 = n, xs$0 = xs;
                for(;;){
                 var match = caml_call1(xs$0, 0);
                 if(! match) return 0;
                 var xs$1 = match[2], n$1 = n$0 - 1 | 0;
                 if(0 === n$1) return caml_call1(xs$1, 0);
                 n$0 = n$1;
                 xs$0 = xs$1;
                }
               }
            : Stdlib[1].call(null, cst_Seq_drop);
   }
   function take_while(p, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return caml_call1(p, x)
            ? [0, x, function(a){return take_while(p, xs$0, a);}]
            : 0;
   }
   function drop_while(p, xs$1, param){
    var xs = xs$1;
    for(;;){
     var node = caml_call1(xs, 0);
     if(! node) return 0;
     var xs$0 = node[2], x = node[1];
     if(! caml_call1(p, x)) return node;
     xs = xs$0;
    }
   }
   function group(eq, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], a = caml_call1(eq, x);
    function b(b){return drop_while(a, xs$0, b);}
    var c = caml_call1(eq, x);
    function next(a){return take_while(c, xs$0, a);}
    return [0,
            function(param){return [0, x, next];},
            function(a){return group(eq, b, a);}];
   }
   var
    Forced_twice =
      [248, "Stdlib.Seq.Forced_twice", runtime.caml_fresh_oo_id(0)],
    to_lazy = Stdlib_Lazy[6],
    b = [0, "seq.ml", 596, 4];
   function failure(param){
    throw caml_maybe_attach_backtrace(Forced_twice, 1);
   }
   function memoize(xs){
    function s$0(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, memoize(xs$0)];
    }
    var s = to_lazy(s$0);
    return function(param){
     var a = runtime.caml_obj_tag(s);
     return 250 === a
             ? s[1]
             : 246 === a ? CamlinternalLazy[2].call(null, s) : s;};
   }
   function once(xs){
    function f(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, once(xs$0)];
    }
    var action = CamlinternalAtomic[1].call(null, f);
    return function(param){
     var f = CamlinternalAtomic[4].call(null, action, failure);
     return caml_call1(f, 0);};
   }
   function zip(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0, [0, x, y], function(a){return zip(xs$0, ys$0, a);}];
   }
   function map2(f, xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0,
            caml_call2(f, x, y),
            function(a){return map2(f, xs$0, ys$0, a);}];
   }
   function interleave(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return caml_call1(ys, 0);
    var xs$0 = match[2], x = match[1];
    return [0, x, function(a){return interleave(ys, xs$0, a);}];
   }
   function sorted_merge1(cmp, x, xs, y, ys){
    return 0 < caml_call2(cmp, x, y)
            ? [0,
              y,
              function(param){
               var match = caml_call1(ys, 0);
               if(! match) return [0, x, xs];
               var ys$0 = match[2], y = match[1];
               return sorted_merge1(cmp, x, xs, y, ys$0);
              }]
            : [0,
              x,
              function(param){
               var match = caml_call1(xs, 0);
               if(! match) return [0, y, ys];
               var xs$0 = match[2], x = match[1];
               return sorted_merge1(cmp, x, xs$0, y, ys);
              }];
   }
   function sorted_merge(cmp, xs, ys, param){
    var match = caml_call1(xs, 0), match$0 = caml_call1(ys, 0);
    if(match){
     if(match$0){
      var ys$0 = match$0[2], y = match$0[1], xs$0 = match[2], x = match[1];
      return sorted_merge1(cmp, x, xs$0, y, ys$0);
     }
     var c = match;
    }
    else{if(! match$0) return 0; var c = match$0;}
    return c;
   }
   function map_fst(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], x = match[1][1];
    return [0, x, function(a){return map_fst(xys$0, a);}];
   }
   function map_snd(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], y = match[1][2];
    return [0, y, function(a){return map_snd(xys$0, a);}];
   }
   function unzip(xys){
    return [0,
            function(a){return map_fst(xys, a);},
            function(a){return map_snd(xys, a);}];
   }
   function filter_map_find_left_map(f, xs$1, param){
    var xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 === match$0[0]) break;
     xs = xs$0;
    }
    var y = match$0[1];
    return [0, y, function(a){return filter_map_find_left_map(f, xs$0, a);}];
   }
   function filter_map_find_right_map(f, xs$1, param){
    var xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 !== match$0[0]) break;
     xs = xs$0;
    }
    var z = match$0[1];
    return [0, z, function(a){return filter_map_find_right_map(f, xs$0, a);}];
   }
   function partition_map(f, xs){
    return [0,
            function(a){return filter_map_find_left_map(f, xs, a);},
            function(a){return filter_map_find_right_map(f, xs, a);}];
   }
   function partition(p, xs){
    function a(x){return 1 - caml_call1(p, x);}
    return [0,
            function(a){return filter(p, xs, a);},
            function(b){return filter(a, xs, b);}];
   }
   function peel(xss){
    return unzip(function(a){return filter_map(uncons, xss, a);});
   }
   function transpose(xss, param){
    var match = peel(xss), tails = match[2], heads = match[1];
    if(! is_empty(heads))
     return [0, heads, function(a){return transpose(tails, a);}];
    if(is_empty(tails)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
   }
   function a(remainders, xss, param){
    var match = caml_call1(xss, 0);
    if(! match) return transpose(remainders, 0);
    var xss$0 = match[2], xs = match[1], match$0 = caml_call1(xs, 0);
    if(match$0){
     var
      xs$0 = match$0[2],
      x = match$0[1],
      match$1 = peel(remainders),
      tails = match$1[2],
      heads = match$1[1],
      b = function(param){return [0, xs$0, tails];};
     return [0,
             function(param){return [0, x, heads];},
             function(c){return a(b, xss$0, c);}];
    }
    var
     match$2 = peel(remainders),
     tails$0 = match$2[2],
     heads$0 = match$2[1];
    return [0, heads$0, function(b){return a(tails$0, xss$0, b);}];
   }
   function map_product(f, xs, ys){
    function c(x){
     function a(y){return caml_call2(f, x, y);}
     return function(b){return map(a, ys, b);};
    }
    function xss(a){return map(c, xs, a);}
    function b(b){return a(empty, xss, b);}
    return function(a){return concat(b, a);};
   }
   function product(xs, ys){
    return map_product(function(x, y){return [0, x, y];}, xs, ys);
   }
   function of_dispenser(it){
    function c(param){
     var match = caml_call1(it, 0);
     if(! match) return 0;
     var x = match[1];
     return [0, x, c];
    }
    return c;
   }
   function to_dispenser(xs){
    var s = [0, xs];
    return function(param){
     var match = caml_call1(s[1], 0);
     if(! match) return 0;
     var xs = match[2], x = match[1];
     s[1] = xs;
     return [0, x];};
   }
   function ints(i, param){
    var a = i + 1 | 0;
    return [0, i, function(b){return ints(a, b);}];
   }
   var
    Stdlib_Seq =
      [0,
       is_empty,
       uncons,
       length,
       iter,
       fold_left,
       iteri,
       fold_lefti,
       for_all,
       exists,
       find,
       find_map,
       iter2,
       fold_left2,
       for_all2,
       exists2,
       equal,
       compare,
       empty,
       return$,
       cons,
       init,
       unfold,
       repeat,
       forever,
       cycle,
       iterate,
       map,
       mapi,
       filter,
       filter_map,
       scan,
       take,
       drop,
       take_while,
       drop_while,
       group,
       memoize,
       Forced_twice,
       once,
       transpose,
       append,
       concat,
       flat_map,
       flat_map,
       zip,
       map2,
       interleave,
       sorted_merge,
       product,
       map_product,
       unzip,
       unzip,
       partition_map,
       partition,
       of_dispenser,
       to_dispenser,
       ints];
   runtime.caml_register_global(10, Stdlib_Seq, "Stdlib__Seq");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Option
//# unitInfo: Requires: Stdlib, Stdlib__Seq
//# shape: Stdlib__Option:[N,F(1)*,F(2)*,F(1),F(2),F(1)*,F(2),F(3),F(2),F(1)*,F(1)*,F(3),F(3),F(2)*,F(1)*,F(1)*->F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    cst_option_is_None = "option is None";
   function some(v){return [0, v];}
   function value(o, default$){
    if(! o) return default$;
    var v = o[1];
    return v;
   }
   function get(param){
    if(! param) return Stdlib[1].call(null, cst_option_is_None);
    var v = param[1];
    return v;
   }
   function bind(o, f){
    if(! o) return 0;
    var v = o[1];
    return caml_call1(f, v);
   }
   function join(param){if(! param) return 0; var o = param[1]; return o;}
   function map(f, o){
    if(! o) return 0;
    var v = o[1];
    return [0, caml_call1(f, v)];
   }
   function fold(none, some, param){
    if(! param) return none;
    var v = param[1];
    return caml_call1(some, v);
   }
   function iter(f, param){
    if(! param) return 0;
    var v = param[1];
    return caml_call1(f, v);
   }
   function is_none(param){return param ? 0 : 1;}
   function is_some(param){return param ? 1 : 0;}
   function equal(eq, o0, o1){
    if(o0){
     if(o1){var v1 = o1[1], v0 = o0[1]; return caml_call2(eq, v0, v1);}
    }
    else if(! o1) return 1;
    return 0;
   }
   function compare(cmp, o0, o1){
    if(! o0) return o1 ? -1 : 0;
    var v0 = o0[1];
    if(! o1) return 1;
    var v1 = o1[1];
    return caml_call2(cmp, v0, v1);
   }
   function to_result(none, param){
    if(! param) return [1, none];
    var v = param[1];
    return [0, v];
   }
   function to_list(param){
    if(! param) return 0;
    var v = param[1];
    return [0, v, 0];
   }
   function to_seq(param){
    if(! param) return Stdlib_Seq[18];
    var v = param[1], a = Stdlib_Seq[19];
    return function(b){return a(v, b);};
   }
   var
    Stdlib_Option =
      [0,
       0,
       some,
       value,
       get,
       bind,
       join,
       map,
       fold,
       iter,
       is_none,
       is_some,
       equal,
       compare,
       to_result,
       to_list,
       to_seq];
   runtime.caml_register_global(3, Stdlib_Option, "Stdlib__Option");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Result
//# unitInfo: Requires: Stdlib, Stdlib__Seq
//# shape: Stdlib__Result:[F(1)*,F(1)*,F(2)*,F(1),F(1),F(2),F(1)*,F(2),F(2),F(3),F(2),F(2),F(1)*,F(1)*,F(4),F(4),F(1)*,F(1)*,F(1)*->F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    cst_result_is_Error = "result is Error _",
    cst_result_is_Ok = "result is Ok _";
   function ok(v){return [0, v];}
   function error(e){return [1, e];}
   function value(r, default$){
    if(0 !== r[0]) return default$;
    var v = r[1];
    return v;
   }
   function get_ok(param){
    if(0 !== param[0]) return Stdlib[1].call(null, cst_result_is_Error);
    var v = param[1];
    return v;
   }
   function get_error(param){
    if(0 === param[0]) return Stdlib[1].call(null, cst_result_is_Ok);
    var e = param[1];
    return e;
   }
   function bind(r, f){
    if(0 !== r[0]) return r;
    var v = r[1];
    return caml_call1(f, v);
   }
   function join(e){if(0 !== e[0]) return e; var r = e[1]; return r;}
   function map(f, e){
    if(0 !== e[0]) return e;
    var v = e[1];
    return [0, caml_call1(f, v)];
   }
   function map_error(f, v){
    if(0 === v[0]) return v;
    var e = v[1];
    return [1, caml_call1(f, e)];
   }
   function fold(ok, error, param){
    if(0 === param[0]){var v = param[1]; return caml_call1(ok, v);}
    var e = param[1];
    return caml_call1(error, e);
   }
   function iter(f, param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return caml_call1(f, v);
   }
   function iter_error(f, param){
    if(0 === param[0]) return 0;
    var e = param[1];
    return caml_call1(f, e);
   }
   function is_ok(param){return 0 === param[0] ? 1 : 0;}
   function is_error(param){return 0 === param[0] ? 0 : 1;}
   function equal(ok, error, r0, r1){
    if(0 === r0[0]){
     var v0 = r0[1];
     if(0 === r1[0]){var v1 = r1[1]; return caml_call2(ok, v0, v1);}
    }
    else{
     var e0 = r0[1];
     if(0 !== r1[0]){var e1 = r1[1]; return caml_call2(error, e0, e1);}
    }
    return 0;
   }
   function compare(ok, error, r0, r1){
    if(0 === r0[0]){
     var v0 = r0[1];
     if(0 !== r1[0]) return -1;
     var v1 = r1[1];
     return caml_call2(ok, v0, v1);
    }
    var e0 = r0[1];
    if(0 === r1[0]) return 1;
    var e1 = r1[1];
    return caml_call2(error, e0, e1);
   }
   function to_option(param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return [0, v];
   }
   function to_list(param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return [0, v, 0];
   }
   function to_seq(param){
    if(0 !== param[0]) return Stdlib_Seq[18];
    var v = param[1], a = Stdlib_Seq[19];
    return function(b){return a(v, b);};
   }
   var
    Stdlib_Result =
      [0,
       ok,
       error,
       value,
       get_ok,
       get_error,
       bind,
       join,
       map,
       map_error,
       fold,
       iter,
       iter_error,
       is_ok,
       is_error,
       equal,
       compare,
       to_option,
       to_list,
       to_seq];
   runtime.caml_register_global(4, Stdlib_Result, "Stdlib__Result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Bool
//# shape: Stdlib__Bool:[F(1)*,F(2)*,F(2)*,F(1)*,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function equal(b, a){return b === a ? 1 : 0;}
   var
    compare = runtime.caml_int_compare,
    cst_true = "true",
    cst_false = "false";
   function to_float(param){return param ? 1. : 0.;}
   function to_string(param){return param ? cst_true : cst_false;}
   var
    Stdlib_Bool =
      [0,
       function(a){return 1 - a;},
       equal,
       compare,
       function(a){return a;},
       to_float,
       to_string];
   runtime.caml_register_global(4, Stdlib_Bool, "Stdlib__Bool");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Char
//# unitInfo: Requires: Stdlib
//# shape: Stdlib__Char:[F(1),F(1),F(1)*,F(1)*,F(1)*,F(1)*,F(2)*,F(2)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    global_data = runtime.caml_get_global_data(),
    cst = "\\\\",
    cst$0 = "\\'",
    Stdlib = global_data.Stdlib,
    cst_Char_chr = "Char.chr",
    cst_b = "\\b",
    cst_t = "\\t",
    cst_n = "\\n",
    cst_r = "\\r";
   function chr(n){
    if(0 <= n && 255 >= n) return n;
    return Stdlib[1].call(null, cst_Char_chr);
   }
   function escaped(c){
    a:
    {
     if(40 <= c){
      if(92 === c) return cst;
      if(127 <= c) break a;
     }
     else{
      if(32 > c){
       if(14 <= c) break a;
       switch(c){
         case 8:
          return cst_b;
         case 9:
          return cst_t;
         case 10:
          return cst_n;
         case 13:
          return cst_r;
         default: break a;
       }
      }
      if(39 <= c) return cst$0;
     }
     var s$0 = caml_create_bytes(1);
     caml_bytes_unsafe_set(s$0, 0, c);
     return caml_string_of_bytes(s$0);
    }
    var s = caml_create_bytes(4);
    caml_bytes_unsafe_set(s, 0, 92);
    caml_bytes_unsafe_set(s, 1, 48 + (c / 100 | 0) | 0);
    caml_bytes_unsafe_set(s, 2, 48 + ((c / 10 | 0) % 10 | 0) | 0);
    caml_bytes_unsafe_set(s, 3, 48 + (c % 10 | 0) | 0);
    return caml_string_of_bytes(s);
   }
   function lowercase(c){
    var a = c - 192 | 0;
    a:
    {
     if(30 < a >>> 0){
      if(25 < a + 127 >>> 0) break a;
     }
     else if(23 === a) break a;
     return c + 32 | 0;
    }
    return c;
   }
   function uppercase(c){
    var a = c - 224 | 0;
    a:
    {
     if(30 < a >>> 0){
      if(25 < a + 127 >>> 0) break a;
     }
     else if(23 === a) break a;
     return c - 32 | 0;
    }
    return c;
   }
   function lowercase_ascii(c){return 25 < c - 65 >>> 0 ? c : c + 32 | 0;}
   function uppercase_ascii(c){return 25 < c - 97 >>> 0 ? c : c - 32 | 0;}
   function compare(c1, c2){return c1 - c2 | 0;}
   function equal(c1, c2){return 0 === (c1 - c2 | 0) ? 1 : 0;}
   var
    Stdlib_Char =
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare,
       equal];
   runtime.caml_register_global(8, Stdlib_Char, "Stdlib__Char");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Uchar
//# unitInfo: Requires: Assert_failure, Stdlib
//# shape: Stdlib__Uchar:[N,N,N,N,F(1),F(1),F(1)*,F(1),F(1)*,F(1)*,F(1)*,F(1)*,F(1),F(1)*,F(2)*,F(2)*,F(1)*,F(1)*,F(1)*,F(1)*,F(2)*,F(1)*,F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_uchar_ml = "uchar.ml",
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    err_no_pred = "U+0000 has no predecessor",
    err_no_succ = "U+10FFFF has no successor",
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    cst_is_not_an_Unicode_scalar_v = " is not an Unicode scalar value",
    cst_is_not_a_latin1_character = " is not a latin1 character",
    cst_U = "U+",
    lo_bound = 55295,
    hi_bound = 57344;
   function succ(u){
    return u === 55295
            ? hi_bound
            : u === 1114111 ? Stdlib[1].call(null, err_no_succ) : u + 1 | 0;
   }
   function pred(u){
    return u === 57344
            ? lo_bound
            : u === 0 ? Stdlib[1].call(null, err_no_pred) : u - 1 | 0;
   }
   function is_valid(i){
    var a = 0 <= i ? 1 : 0, b = a ? i <= 55295 ? 1 : 0 : a;
    if(b)
     var c = b;
    else
     var d = 57344 <= i ? 1 : 0, c = d ? i <= 1114111 ? 1 : 0 : d;
    return c;
   }
   function of_int(i){
    if(is_valid(i)) return i;
    var
     a =
       Stdlib[28].call
        (null, caml_format_int("%X", i), cst_is_not_an_Unicode_scalar_v);
    return Stdlib[1].call(null, a);
   }
   function is_char(u){return u < 256 ? 1 : 0;}
   function of_char(c){return c;}
   function to_char(u){
    if(255 >= u) return u;
    var
     a =
       Stdlib[28].call
        (null, caml_format_int("%04X", u), cst_is_not_a_latin1_character),
     b = Stdlib[28].call(null, cst_U, a);
    return Stdlib[1].call(null, b);
   }
   function unsafe_to_char(a){return a;}
   function equal(b, a){return b === a ? 1 : 0;}
   var
    compare = runtime.caml_int_compare,
    a = [0, cst_uchar_ml, 85, 7],
    b = [0, cst_uchar_ml, 80, 18],
    c = [0, cst_uchar_ml, 91, 7],
    d = [0, cst_uchar_ml, 88, 18];
   function hash(a){return a;}
   function utf_decode_is_valid(d){return 1 === (d >>> 27 | 0) ? 1 : 0;}
   function utf_decode_length(d){return (d >>> 24 | 0) & 7;}
   function utf_decode_uchar(d){return d & 16777215;}
   function utf_decode(n, u){return (8 | n) << 24 | u;}
   function utf_decode_invalid(n){return n << 24 | 65533;}
   function utf_8_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
    if(127 >= u) return 1;
    if(2047 >= u) return 2;
    if(65535 >= u) return 3;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
    return 4;
   }
   function utf_16_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
    if(65535 >= u) return 2;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
    return 4;
   }
   var
    Stdlib_Uchar =
      [0,
       0,
       1114111,
       65279,
       65533,
       succ,
       pred,
       is_valid,
       of_int,
       function(a){return a;},
       function(a){return a;},
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal,
       compare,
       hash,
       utf_decode_is_valid,
       utf_decode_uchar,
       utf_decode_length,
       utf_decode,
       utf_decode_invalid,
       utf_8_byte_length,
       utf_16_byte_length];
   runtime.caml_register_global(13, Stdlib_Uchar, "Stdlib__Uchar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__List
//# unitInfo: Requires: Stdlib, Stdlib__Seq, Stdlib__Sys
//# shape: Stdlib__List:[F(1),F(2),F(2),F(2)*,F(1),F(1),F(2),F(2),F(1),F(2),F(2),F(2),F(1),F(1),F(3),F(3),F(2),F(2),F(2),F(2),F(2),F(1)*->F(1),F(2),F(3),F(3),F(3),F(3),F(3),F(3),F(4),F(4),F(2),F(2),F(3),F(3),F(2),F(2),F(2),F(2),F(2),F(1)*->F(1),F(1)*->F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(1),F(2),F(2),F(2),F(2),F(2),F(3),F(1)*->F(1)*,F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_List_nth$1 = "List.nth",
    caml_compare = runtime.caml_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Sys = global_data.Stdlib__Sys,
    cst_hd = "hd",
    cst_tl = "tl",
    cst_nth = "nth",
    cst_List_nth = cst_List_nth$1,
    cst_List_nth$0 = cst_List_nth$1;
   function length(l$0){
    var len = 0, param = l$0;
    for(;;){
     if(! param) return len;
     var l = param[2], len$0 = len + 1 | 0;
     len = len$0;
     param = l;
    }
   }
   function cons(a, l){return [0, a, l];}
   function hd(param){
    if(! param) return Stdlib[2].call(null, cst_hd);
    var a = param[1];
    return a;
   }
   function tl(param){
    if(! param) return Stdlib[2].call(null, cst_tl);
    var l = param[2];
    return l;
   }
   function nth(l, n){
    if(0 > n) return Stdlib[1].call(null, cst_List_nth);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return Stdlib[2].call(null, cst_nth);
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return a;
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   function nth_opt(l, n){
    if(0 > n) return Stdlib[1].call(null, cst_List_nth$0);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0;
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   var append = Stdlib[37];
   function rev_append(l1$1, l2$1){
    var l1 = l1$1, l2 = l2$1;
    for(;;){
     if(! l1) return l2;
     var l1$0 = l1[2], a = l1[1], l2$0 = [0, a, l2];
     l1 = l1$0;
     l2 = l2$0;
    }
   }
   function rev(l){return rev_append(l, 0);}
   function init_aux(i, n, f){
    if(n <= i) return 0;
    var r = caml_call1(f, i);
    return [0, r, init_aux(i + 1 | 0, n, f)];
   }
   var
    cst_List_map2 = "List.map2",
    cst_List_iter2 = "List.iter2",
    cst_List_fold_left2 = "List.fold_left2",
    cst_List_fold_right2 = "List.fold_right2",
    cst_List_for_all2 = "List.for_all2",
    cst_List_exists2 = "List.exists2",
    b = [0, 0, 0],
    cst_List_combine = "List.combine",
    cst_List_rev_map2 = "List.rev_map2",
    cst_List_init = "List.init",
    rev_init_threshold = typeof Stdlib_Sys[5] === "number" ? 10000 : 50;
   function init(len, f){
    if(0 > len) return Stdlib[1].call(null, cst_List_init);
    if(rev_init_threshold >= len) return init_aux(0, len, f);
    var acc = 0, i = 0;
    for(;;){
     if(len <= i) return rev(acc);
     var i$0 = i + 1 | 0, acc$0 = [0, caml_call1(f, i), acc];
     acc = acc$0;
     i = i$0;
    }
   }
   function flatten(param){
    if(! param) return 0;
    var r = param[2], l = param[1], a = flatten(r);
    return Stdlib[37].call(null, l, a);
   }
   function map(f, param){
    if(! param) return 0;
    var l = param[2], a = param[1], r = caml_call1(f, a);
    return [0, r, map(f, l)];
   }
   function a(i, f, param){
    if(! param) return 0;
    var l = param[2], a$0 = param[1], r = caml_call2(f, i, a$0);
    return [0, r, a(i + 1 | 0, f, l)];
   }
   function mapi(f, l){return a(0, f, l);}
   function rev_map(f, l){
    var accu = 0, param = l;
    for(;;){
     if(! param) return accu;
     var l$0 = param[2], a = param[1], accu$0 = [0, caml_call1(f, a), accu];
     accu = accu$0;
     param = l$0;
    }
   }
   function iter(f, param$0){
    var param = param$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], a = param[1];
     caml_call1(f, a);
     param = l;
    }
   }
   function iteri(f, l$0){
    var i = 0, param = l$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], a = param[1];
     caml_call2(f, i, a);
     var i$0 = i + 1 | 0;
     i = i$0;
     param = l;
    }
   }
   function fold_left(f, accu$1, l$1){
    var accu = accu$1, l = l$1;
    for(;;){
     if(! l) return accu;
     var l$0 = l[2], a = l[1], accu$0 = caml_call2(f, accu, a);
     accu = accu$0;
     l = l$0;
    }
   }
   function fold_right(f, l, accu){
    if(! l) return accu;
    var l$0 = l[2], a = l[1];
    return caml_call2(f, a, fold_right(f, l$0, accu));
   }
   function map2(f, l1, l2){
    if(l1){
     if(l2){
      var
       l2$0 = l2[2],
       a2 = l2[1],
       l1$0 = l1[2],
       a1 = l1[1],
       r = caml_call2(f, a1, a2);
      return [0, r, map2(f, l1$0, l2$0)];
     }
    }
    else if(! l2) return 0;
    return Stdlib[1].call(null, cst_List_map2);
   }
   function rev_map2(f, l1, l2){
    var accu = 0, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$0 = [0, caml_call2(f, a1, a2), accu];
       accu = accu$0;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu;
     return Stdlib[1].call(null, cst_List_rev_map2);
    }
   }
   function iter2(f, l1$1, l2$1){
    var l1 = l1$1, l2 = l2$1;
    for(;;){
     if(l1){
      if(l2){
       var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
       caml_call2(f, a1, a2);
       l1 = l1$0;
       l2 = l2$0;
       continue;
      }
     }
     else if(! l2) return 0;
     return Stdlib[1].call(null, cst_List_iter2);
    }
   }
   function fold_left2(f, accu$1, l1$1, l2$1){
    var accu = accu$1, l1 = l1$1, l2 = l2$1;
    for(;;){
     if(l1){
      if(l2){
       var
        l2$0 = l2[2],
        a2 = l2[1],
        l1$0 = l1[2],
        a1 = l1[1],
        accu$0 = caml_call3(f, accu, a1, a2);
       accu = accu$0;
       l1 = l1$0;
       l2 = l2$0;
       continue;
      }
     }
     else if(! l2) return accu;
     return Stdlib[1].call(null, cst_List_fold_left2);
    }
   }
   function fold_right2(f, l1, l2, accu){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return caml_call3(f, a1, a2, fold_right2(f, l1$0, l2$0, accu));
     }
    }
    else if(! l2) return accu;
    return Stdlib[1].call(null, cst_List_fold_right2);
   }
   function for_all(p, param$0){
    var param = param$0;
    for(;;){
     if(! param) return 1;
     var l = param[2], a = param[1], b = caml_call1(p, a);
     if(! b) return b;
     param = l;
    }
   }
   function exists(p, param$0){
    var param = param$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], a = param[1], b = caml_call1(p, a);
     if(b) return b;
     param = l;
    }
   }
   function for_all2(p, l1$1, l2$1){
    var l1 = l1$1, l2 = l2$1;
    for(;;){
     if(l1){
      if(l2){
       var
        l2$0 = l2[2],
        a2 = l2[1],
        l1$0 = l1[2],
        a1 = l1[1],
        a = caml_call2(p, a1, a2);
       if(! a) return a;
       l1 = l1$0;
       l2 = l2$0;
       continue;
      }
     }
     else if(! l2) return 1;
     return Stdlib[1].call(null, cst_List_for_all2);
    }
   }
   function exists2(p, l1$1, l2$1){
    var l1 = l1$1, l2 = l2$1;
    for(;;){
     if(l1){
      if(l2){
       var
        l2$0 = l2[2],
        a2 = l2[1],
        l1$0 = l1[2],
        a1 = l1[1],
        a = caml_call2(p, a1, a2);
       if(a) return a;
       l1 = l1$0;
       l2 = l2$0;
       continue;
      }
     }
     else if(! l2) return 0;
     return Stdlib[1].call(null, cst_List_exists2);
    }
   }
   function mem(x, param$0){
    var param = param$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], a = param[1], b = 0 === caml_compare(a, x) ? 1 : 0;
     if(b) return b;
     param = l;
    }
   }
   function memq(x, param$0){
    var param = param$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], a = param[1], b = a === x ? 1 : 0;
     if(b) return b;
     param = l;
    }
   }
   function assoc(x, param$0){
    var param = param$0;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param[2], match = param[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return b;
     param = l;
    }
   }
   function assoc_opt(x, param$0){
    var param = param$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], match = param[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return [0, b];
     param = l;
    }
   }
   function assq(x, param$0){
    var param = param$0;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param[2], match = param[1], b = match[2], a = match[1];
     if(a === x) return b;
     param = l;
    }
   }
   function assq_opt(x, param$0){
    var param = param$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], match = param[1], b = match[2], a = match[1];
     if(a === x) return [0, b];
     param = l;
    }
   }
   function mem_assoc(x, param$0){
    var param = param$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], a = param[1][1], b = 0 === caml_compare(a, x) ? 1 : 0;
     if(b) return b;
     param = l;
    }
   }
   function mem_assq(x, param$0){
    var param = param$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], a = param[1][1], b = a === x ? 1 : 0;
     if(b) return b;
     param = l;
    }
   }
   function remove_assoc(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return 0 === caml_compare(a, x) ? l : [0, pair, remove_assoc(x, l)];
   }
   function remove_assq(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return a === x ? l : [0, pair, remove_assq(x, l)];
   }
   function find(p, param$0){
    var param = param$0;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param[2], x = param[1];
     if(caml_call1(p, x)) return x;
     param = l;
    }
   }
   function find_opt(p, param$0){
    var param = param$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1];
     if(caml_call1(p, x)) return [0, x];
     param = l;
    }
   }
   function find_map(f, param$0){
    var param = param$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1], result = caml_call1(f, x);
     if(result) return result;
     param = l;
    }
   }
   function find_all(p){
    var accu = 0;
    return function(param$0){
     var accu$0 = accu, param = param$0;
     for(;;){
      if(! param) return rev(accu$0);
      var l = param[2], x = param[1];
      if(caml_call1(p, x)){
       var accu$1 = [0, x, accu$0];
       accu$0 = accu$1;
       param = l;
      }
      else
       param = l;
     }};
   }
   function filteri(p, l){
    var i = 0, acc = 0, param = l;
    for(;;){
     if(! param) return rev(acc);
     var
      l$0 = param[2],
      x = param[1],
      acc$0 = caml_call2(p, i, x) ? [0, x, acc] : acc,
      i$0 = i + 1 | 0;
     i = i$0;
     acc = acc$0;
     param = l$0;
    }
   }
   function filter_map(f){
    var accu = 0;
    return function(param$0){
     var accu$0 = accu, param = param$0;
     for(;;){
      if(! param) return rev(accu$0);
      var l = param[2], x = param[1], match = caml_call1(f, x);
      if(match){
       var v = match[1], accu$1 = [0, v, accu$0];
       accu$0 = accu$1;
       param = l;
      }
      else
       param = l;
     }};
   }
   function concat_map(f, l){
    var acc = 0, param = l;
    for(;;){
     if(! param) return rev(acc);
     var
      l$0 = param[2],
      x = param[1],
      xs = caml_call1(f, x),
      acc$0 = rev_append(xs, acc);
     acc = acc$0;
     param = l$0;
    }
   }
   function fold_left_map(f, accu, l){
    var accu$0 = accu, l_accu = 0, param = l;
    for(;;){
     if(! param) return [0, accu$0, rev(l_accu)];
     var
      l$0 = param[2],
      x = param[1],
      match = caml_call2(f, accu$0, x),
      x$0 = match[2],
      accu$1 = match[1],
      l_accu$0 = [0, x$0, l_accu];
     accu$0 = accu$1;
     l_accu = l_accu$0;
     param = l$0;
    }
   }
   function partition(p, l){
    var yes = 0, no = 0, param = l;
    for(;;){
     if(! param){var a = rev(no); return [0, rev(yes), a];}
     var l$0 = param[2], x = param[1];
     if(caml_call1(p, x)){
      var yes$0 = [0, x, yes];
      yes = yes$0;
      param = l$0;
     }
     else{var no$0 = [0, x, no]; no = no$0; param = l$0;}
    }
   }
   function partition_map(p, l){
    var left = 0, right = 0, param = l;
    for(;;){
     if(! param){var a = rev(right); return [0, rev(left), a];}
     var l$0 = param[2], x = param[1], match = caml_call1(p, x);
     if(0 === match[0]){
      var v = match[1], left$0 = [0, v, left];
      left = left$0;
      param = l$0;
     }
     else{
      var v$0 = match[1], right$0 = [0, v$0, right];
      right = right$0;
      param = l$0;
     }
    }
   }
   function split(param){
    if(! param) return b;
    var
     l = param[2],
     match = param[1],
     y = match[2],
     x = match[1],
     match$0 = split(l),
     ry = match$0[2],
     rx = match$0[1];
    return [0, [0, x, rx], [0, y, ry]];
   }
   function combine(l1, l2){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return [0, [0, a1, a2], combine(l1$0, l2$0)];
     }
    }
    else if(! l2) return 0;
    return Stdlib[1].call(null, cst_List_combine);
   }
   function merge(cmp, l1, l2){
    if(! l1) return l2;
    if(! l2) return l1;
    var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
    return 0 < caml_call2(cmp, h1, h2)
            ? [0, h2, merge(cmp, l1, t2)]
            : [0, h1, merge(cmp, t1, l2)];
   }
   function stable_sort(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x2, [0, x1, 0]]
            : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var a = l[2];
      if(a){
       var match$2 = a[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = a[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x1$0, x3)
              ? 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]]
              : [0, x2$0, [0, x1$0, [0, x3, 0]]]
            : 0
              < caml_call2(cmp, x2$0, x3)
              ? 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]]
              : [0, x1$0, [0, x2$0, [0, x3, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         accu = accu$0;
         continue;
        }
        var accu$1 = [0, h2, accu];
        l2 = t2;
        accu = accu$1;
        continue;
       }
       var b = rev_append(l1, accu);
      }
      else
       var b = rev_append(l2, accu);
      return [0, b, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x1, [0, x2, 0]]
            : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var a = l[2];
      if(a){
       var match$2 = a[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = a[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x2$0, x3)
              ? [0, x1$0, [0, x2$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]]
            : 0
              < caml_call2(cmp, x1$0, x3)
              ? [0, x2$0, [0, x1$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h2, accu];
         l2 = t2;
         accu = accu$0;
         continue;
        }
        var accu$1 = [0, h1, accu];
        l1 = t1;
        accu = accu$1;
        continue;
       }
       var b = rev_append(l1, accu);
      }
      else
       var b = rev_append(l2, accu);
      return [0, b, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function sort_uniq(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 <= c$0 ? [0, x2, [0, x1, 0]] : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var a = l[2];
      if(a){
       var match$2 = a[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = a[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          s$0 =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 <= c$2 ? [0, x3, [0, x2$0, 0]] : [0, x2$0, [0, x3, 0]];
        else if(0 <= c$1){
         var c$3 = caml_call2(cmp, x1$0, x3);
         if(0 === c$3)
          var s$0 = [0, x2$0, [0, x1$0, 0]];
         else if(0 <= c$3)
          var
           c$4 = caml_call2(cmp, x2$0, x3),
           s$0 =
             0 === c$4
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                <= c$4
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]];
         else
          var s$0 = [0, x2$0, [0, x1$0, [0, x3, 0]]];
        }
        else{
         var c$5 = caml_call2(cmp, x2$0, x3);
         if(0 === c$5)
          var s$0 = [0, x1$0, [0, x2$0, 0]];
         else if(0 <= c$5)
          var
           c$6 = caml_call2(cmp, x1$0, x3),
           s$0 =
             0 === c$6
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                <= c$6
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]];
         else
          var s$0 = [0, x1$0, [0, x2$0, [0, x3, 0]]];
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         l2 = t2;
         accu = accu$0;
         continue;
        }
        if(0 < c){
         var accu$1 = [0, h1, accu];
         l1 = t1;
         accu = accu$1;
         continue;
        }
        var accu$2 = [0, h2, accu];
        l2 = t2;
        accu = accu$2;
        continue;
       }
       var b = rev_append(l1, accu);
      }
      else
       var b = rev_append(l2, accu);
      return [0, b, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 < c$0 ? [0, x1, [0, x2, 0]] : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var a = l[2];
      if(a){
       var match$2 = a[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = a[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          s$0 =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 < c$2 ? [0, x2$0, [0, x3, 0]] : [0, x3, [0, x2$0, 0]];
        else if(0 < c$1){
         var c$3 = caml_call2(cmp, x2$0, x3);
         if(0 === c$3)
          var s$0 = [0, x1$0, [0, x2$0, 0]];
         else if(0 < c$3)
          var s$0 = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         else
          var
           c$4 = caml_call2(cmp, x1$0, x3),
           s$0 =
             0 === c$4
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                < c$4
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]];
        }
        else{
         var c$5 = caml_call2(cmp, x1$0, x3);
         if(0 === c$5)
          var s$0 = [0, x2$0, [0, x1$0, 0]];
         else if(0 < c$5)
          var s$0 = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         else
          var
           c$6 = caml_call2(cmp, x2$0, x3),
           s$0 =
             0 === c$6
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                < c$6
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]];
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         l2 = t2;
         accu = accu$0;
         continue;
        }
        if(0 <= c){
         var accu$1 = [0, h2, accu];
         l2 = t2;
         accu = accu$1;
         continue;
        }
        var accu$2 = [0, h1, accu];
        l1 = t1;
        accu = accu$2;
        continue;
       }
       var b = rev_append(l1, accu);
      }
      else
       var b = rev_append(l2, accu);
      return [0, b, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function compare_lengths(l1$1, l2$1){
    var l1 = l1$1, l2 = l2$1;
    for(;;){
     if(! l1) return l2 ? -1 : 0;
     if(! l2) return 1;
     var l2$0 = l2[2], l1$0 = l1[2];
     l1 = l1$0;
     l2 = l2$0;
    }
   }
   function compare_length_with(l$1, n$1){
    var l = l$1, n = n$1;
    for(;;){
     if(! l) return 0 === n ? 0 : 0 < n ? -1 : 1;
     var l$0 = l[2];
     if(0 >= n) return 1;
     var n$0 = n - 1 | 0;
     l = l$0;
     n = n$0;
    }
   }
   function equal(eq, l1$1, l2$1){
    var l1 = l1$1, l2 = l2$1;
    for(;;){
     if(l1){
      if(l2){
       var
        l2$0 = l2[2],
        a2 = l2[1],
        l1$0 = l1[2],
        a1 = l1[1],
        a = caml_call2(eq, a1, a2);
       if(! a) return a;
       l1 = l1$0;
       l2 = l2$0;
       continue;
      }
     }
     else if(! l2) return 1;
     return 0;
    }
   }
   function compare(cmp, l1$1, l2$1){
    var l1 = l1$1, l2 = l2$1;
    for(;;){
     if(! l1) return l2 ? -1 : 0;
     var l1$0 = l1[2], a1 = l1[1];
     if(! l2) return 1;
     var l2$0 = l2[2], a2 = l2[1], c = caml_call2(cmp, a1, a2);
     if(0 !== c) return c;
     l1 = l1$0;
     l2 = l2$0;
    }
   }
   function to_seq(l){
    function aux(l, param){
     if(! l) return 0;
     var tail = l[2], x = l[1];
     return [0, x, function(a){return aux(tail, a);}];
    }
    return function(a){return aux(l, a);};
   }
   function of_seq(seq){
    function direct(depth, seq){
     if(0 === depth)
      return rev
              (Stdlib_Seq[5].call
                (null, function(acc, x){return [0, x, acc];}, 0, seq));
     var match = caml_call1(seq, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     return [0, x, direct(depth - 1 | 0, next)];
    }
    return direct(500, seq);
   }
   var
    Stdlib_List =
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal,
       compare,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       filter_map,
       concat_map,
       fold_left_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       stable_sort,
       stable_sort,
       stable_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
   runtime.caml_register_global(18, Stdlib_List, "Stdlib__List");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Int
//# shape: Stdlib__Int:[N,N,N,F(1)*,N,N,F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function abs(x){return 0 <= x ? x : - x | 0;}
   function lognot(x){return x ^ -1;}
   function equal(b, a){return b === a ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function min(x, y){return x <= y ? x : y;}
   function max(x, y){return y <= x ? x : y;}
   function to_string(x){return "" + x;}
   var
    Stdlib_Int =
      [0,
       0,
       1,
       -1,
       abs,
       2147483647,
       -2147483648,
       lognot,
       equal,
       compare,
       min,
       max,
       to_string];
   runtime.caml_register_global(1, Stdlib_Int, "Stdlib__Int");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Bytes
//# unitInfo: Requires: Assert_failure, Stdlib, Stdlib__Char, Stdlib__Int, Stdlib__Seq, Stdlib__Sys, Stdlib__Uchar
//# shape: Stdlib__Bytes:[F(2),F(2),N,F(1),F(1),F(1),F(3),F(3),F(3),F(4),F(5),F(5),F(2),F(2),F(2),F(2),F(2),F(2),F(3),F(3),F(2),F(2),F(1),F(1),F(2),F(2),F(2),F(2),F(3),F(3),F(3),F(3),F(2),F(3),F(3),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(2)*,F(2)*,F(2),F(2),F(1),F(1)*,F(2),F(1)*->F(1),F(1)*->F(1),F(1),F(2),F(3),F(1),F(2),F(3),F(1),F(2),F(3),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_bytes_ml = "bytes.ml",
    cst_index_out_of_bounds$3 = "index out of bounds",
    caml_blit_bytes = runtime.caml_blit_bytes,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_get16 = runtime.caml_bytes_get16,
    caml_bytes_get32 = runtime.caml_bytes_get32,
    caml_bytes_get64 = runtime.caml_bytes_get64,
    caml_bytes_of_string = runtime.caml_bytes_of_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_bytes_set32 = runtime.caml_bytes_set32,
    caml_bytes_set64 = runtime.caml_bytes_set64,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fill_bytes = runtime.caml_fill_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Char = global_data.Stdlib__Char;
   function make(n, c){
    var s = caml_create_bytes(n);
    caml_fill_bytes(s, 0, n, c);
    return s;
   }
   function init(n, f){
    var s = caml_create_bytes(n), a = n - 1 | 0, b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_bytes_unsafe_set(s, i, caml_call1(f, i));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return s;
   }
   var
    empty = caml_create_bytes(0),
    cst_String_sub_Bytes_sub = "String.sub / Bytes.sub",
    cst_Bytes_extend = "Bytes.extend",
    cst_String_fill_Bytes_fill = "String.fill / Bytes.fill",
    cst_Bytes_blit = "Bytes.blit",
    cst_String_blit_Bytes_blit_str = "String.blit / Bytes.blit_string",
    cst_Bytes_concat = "Bytes.concat",
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from";
   function copy(s){
    var len = caml_ml_bytes_length(s), r = caml_create_bytes(len);
    caml_blit_bytes(s, 0, r, 0, len);
    return r;
   }
   function to_string(b){return caml_string_of_bytes(copy(b));}
   function of_string(s){return copy(caml_bytes_of_string(s));}
   function sub(s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs){
     var r = caml_create_bytes(len);
     caml_blit_bytes(s, ofs, r, 0, len);
     return r;
    }
    return Stdlib[1].call(null, cst_String_sub_Bytes_sub);
   }
   function sub_string(b, ofs, len){
    return caml_string_of_bytes(sub(b, ofs, len));
   }
   function symbol(a, b){
    var c = a + b | 0, d = b < 0 ? 1 : 0, match = c < 0 ? 1 : 0;
    a:
    {
     if(a < 0){if(! d || match) break a;} else if(d || ! match) break a;
     return Stdlib[1].call(null, cst_Bytes_extend);
    }
    return c;
   }
   function extend(s, left, right){
    var
     len = symbol(symbol(caml_ml_bytes_length(s), left), right),
     r = caml_create_bytes(len);
    if(0 <= left)
     var dstoff = left, srcoff = 0;
    else
     var dstoff = 0, srcoff = - left | 0;
    var
     cpylen =
       Stdlib_Int[10].call
        (null, caml_ml_bytes_length(s) - srcoff | 0, len - dstoff | 0);
    if(0 < cpylen) caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
    return r;
   }
   function fill(s, ofs, len, c){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_fill_bytes(s, ofs, len, c);
    return Stdlib[1].call(null, cst_String_fill_Bytes_fill);
   }
   function blit(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (caml_ml_bytes_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return caml_blit_bytes(s1, ofs1, s2, ofs2, len);
    return Stdlib[1].call(null, cst_Bytes_blit);
   }
   function blit_string(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (runtime.caml_ml_string_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return runtime.caml_blit_string(s1, ofs1, s2, ofs2, len);
    return Stdlib[1].call(null, cst_String_blit_Bytes_blit_str);
   }
   function iter(f, a){
    var b = caml_ml_bytes_length(a) - 1 | 0, c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      caml_call1(f, caml_bytes_unsafe_get(a, i));
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return 0;
   }
   function iteri(f, a){
    var b = caml_ml_bytes_length(a) - 1 | 0, c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      caml_call2(f, i, caml_bytes_unsafe_get(a, i));
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return 0;
   }
   function concat(sep, l){
    if(! l) return empty;
    var seplen = caml_ml_bytes_length(sep);
    a:
    {
     var acc = 0, param = l, pos$1 = 0;
     for(;;){
      if(! param){var a = acc; break a;}
      var hd = param[1];
      if(! param[2]) break;
      var
       tl = param[2],
       x = (caml_ml_bytes_length(hd) + seplen | 0) + acc | 0;
      if(acc <= x){
       acc = x;
       param = tl;
      }
      else{acc = Stdlib[1].call(null, cst_Bytes_concat); param = tl;}
     }
     var a = caml_ml_bytes_length(hd) + acc | 0;
    }
    var dst = caml_create_bytes(a), pos = pos$1, param$0 = l;
    for(;;){
     if(! param$0) return dst;
     var hd$0 = param$0[1];
     if(! param$0[2]){
      caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
      return dst;
     }
     var tl$0 = param$0[2];
     caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
     caml_blit_bytes
      (sep, 0, dst, pos + caml_ml_bytes_length(hd$0) | 0, seplen);
     var pos$0 = (pos + caml_ml_bytes_length(hd$0) | 0) + seplen | 0;
     pos = pos$0;
     param$0 = tl$0;
    }
   }
   function cat(s1, s2){
    var
     l1 = caml_ml_bytes_length(s1),
     l2 = caml_ml_bytes_length(s2),
     r = caml_create_bytes(l1 + l2 | 0);
    caml_blit_bytes(s1, 0, r, 0, l1);
    caml_blit_bytes(s2, 0, r, l1, l2);
    return r;
   }
   function is_space(param){
    var a = param - 9 | 0;
    a:
    {
     if(4 < a >>> 0){if(23 !== a) break a;} else if(2 === a) break a;
     return 1;
    }
    return 0;
   }
   function trim(s){
    var len = caml_ml_bytes_length(s), i = [0, 0];
    for(;;){
     if(i[1] >= len) break;
     if(! is_space(caml_bytes_unsafe_get(s, i[1]))) break;
     i[1]++;
    }
    var j = [0, len - 1 | 0];
    for(;;){
     if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s, j[1]))){j[1]--; continue;}
     return i[1] <= j[1] ? sub(s, i[1], (j[1] - i[1] | 0) + 1 | 0) : empty;
    }
   }
   function escaped(s){
    var n = [0, 0], d = caml_ml_bytes_length(s) - 1 | 0, f = 0;
    if(d >= 0){
     var i$0 = f;
     for(;;){
      var match = caml_bytes_unsafe_get(s, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var a = match - 34 | 0;
          if(58 < a >>> 0){
           if(93 <= a) break c;
          }
          else if(56 < a - 1 >>> 0) break b;
          var b = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var b = 4;
        break a;
       }
       var b = 2;
      }
      n[1] = n[1] + b | 0;
      var j = i$0 + 1 | 0;
      if(d === i$0) break;
      i$0 = j;
     }
    }
    if(n[1] === caml_ml_bytes_length(s)) return copy(s);
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var e = caml_ml_bytes_length(s) - 1 | 0, g = 0;
    if(e >= 0){
     var i = g;
     for(;;){
      var c = caml_bytes_unsafe_get(s, i);
      a:
      {
       b:
       {
        c:
        {
         if(35 <= c){
          if(92 !== c){if(127 <= c) break b; break c;}
         }
         else{
          if(32 > c){
           if(14 <= c) break b;
           switch(c){
             case 8:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 98);
              break a;
             case 9:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 116);
              break a;
             case 10:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 110);
              break a;
             case 13:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 114);
              break a;
             default: break b;
           }
          }
          if(34 > c) break c;
         }
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break a;
        }
        caml_bytes_unsafe_set(s$0, n[1], c);
        break a;
       }
       caml_bytes_unsafe_set(s$0, n[1], 92);
       n[1]++;
       caml_bytes_unsafe_set(s$0, n[1], 48 + (c / 100 | 0) | 0);
       n[1]++;
       caml_bytes_unsafe_set(s$0, n[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
       n[1]++;
       caml_bytes_unsafe_set(s$0, n[1], 48 + (c % 10 | 0) | 0);
      }
      n[1]++;
      var h = i + 1 | 0;
      if(e === i) break;
      i = h;
     }
    }
    return s$0;
   }
   function map(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), a = l - 1 | 0, b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_bytes_unsafe_set(r, i, caml_call1(f, caml_bytes_unsafe_get(s, i)));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return r;
   }
   function mapi(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), a = l - 1 | 0, b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_bytes_unsafe_set
       (r, i, caml_call2(f, i, caml_bytes_unsafe_get(s, i)));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return r;
   }
   function fold_left(f, x, a){
    var r = [0, x], b = caml_ml_bytes_length(a) - 1 | 0, c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      r[1] = caml_call2(f, r[1], caml_bytes_unsafe_get(a, i));
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return r[1];
   }
   function fold_right(f, a, x){
    var r = [0, x], b = caml_ml_bytes_length(a) - 1 | 0;
    if(b >= 0){
     var i = b;
     for(;;){
      r[1] = caml_call2(f, caml_bytes_unsafe_get(a, i), r[1]);
      var c = i - 1 | 0;
      if(0 === i) break;
      i = c;
     }
    }
    return r[1];
   }
   function exists(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, caml_bytes_unsafe_get(s, i))) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, caml_bytes_unsafe_get(s, i))) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function uppercase_ascii(s){return map(Stdlib_Char[6], s);}
   function lowercase_ascii(s){return map(Stdlib_Char[5], s);}
   function apply1(f, s){
    if(0 === caml_ml_bytes_length(s)) return s;
    var r = copy(s);
    caml_bytes_unsafe_set(r, 0, caml_call1(f, caml_bytes_unsafe_get(s, 0)));
    return r;
   }
   function capitalize_ascii(s){return apply1(Stdlib_Char[6], s);}
   function uncapitalize_ascii(s){return apply1(Stdlib_Char[5], s);}
   function starts_with(prefix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_pre = caml_ml_bytes_length(prefix),
     a = len_pre <= len_s ? 1 : 0;
    if(! a) return a;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_bytes_unsafe_get(s, i) !== caml_bytes_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_suf = caml_ml_bytes_length(suffix),
     diff = len_s - len_suf | 0,
     a = 0 <= diff ? 1 : 0;
    if(! a) return a;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_bytes_unsafe_get(s, diff + i | 0)
       !== caml_bytes_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function index_rec(s, lim, i$1, c){
    var i = i$1;
    for(;;){
     if(lim <= i) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i) === c) return i;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_bytes_length(s), 0, c);}
   function index_rec_opt(s, lim, i$1, c){
    var i = i$1;
    for(;;){
     if(lim <= i) return 0;
     if(caml_bytes_unsafe_get(s, i) === c) return [0, i];
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_bytes_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return Stdlib[1].call(null, cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return Stdlib[1].call(null, cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i$1, c){
    var i = i$1;
    for(;;){
     if(0 > i) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i) === c) return i;
     var i$0 = i - 1 | 0;
     i = i$0;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec(s, i, c);
    return Stdlib[1].call(null, cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i$1, c){
    var i = i$1;
    for(;;){
     if(0 > i) return 0;
     if(caml_bytes_unsafe_get(s, i) === c) return [0, i];
     var i$0 = i - 1 | 0;
     i = i$0;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec_opt(s, i, c);
    return Stdlib[1].call(null, cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var a = 1; return a;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(exn, 0);
     }
    return Stdlib[1].call(null, cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_bytes_length(s) > i)
     try{rindex_rec(s, i, c); var a = 1; return a;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(exn, 0);
     }
    return Stdlib[1].call(null, cst_String_rcontains_from_Byte);
   }
   var
    compare = runtime.caml_bytes_compare,
    cst_Bytes_of_seq_cannot_grow_b = "Bytes.of_seq: cannot grow bytes";
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_bytes_length(s)],
     a = caml_ml_bytes_length(s) - 1 | 0;
    if(a >= 0){
     var i = a;
     for(;;){
      if(caml_bytes_unsafe_get(s, i) === sep){
       var c = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), c];
       j[1] = i;
      }
      var d = i - 1 | 0;
      if(0 === i) break;
      i = d;
     }
    }
    var b = r[1];
    return [0, sub(s, 0, j[1]), b];
   }
   function uppercase(s){return map(Stdlib_Char[4], s);}
   function lowercase(s){return map(Stdlib_Char[3], s);}
   function capitalize(s){return apply1(Stdlib_Char[4], s);}
   function uncapitalize(s){return apply1(Stdlib_Char[3], s);}
   function to_seq(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), a = i + 1 | 0;
     return [0, x, function(b){return aux(a, b);}];
    }
    var a = 0;
    return function(b){return aux(a, b);};
   }
   function to_seqi(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), a = i + 1 | 0;
     return [0, [0, i, x], function(b){return aux(a, b);}];
    }
    var a = 0;
    return function(b){return aux(a, b);};
   }
   function of_seq(i){
    var n = [0, 0], buf = [0, make(256, 0)];
    Stdlib_Seq[4].call
     (null,
      function(c){
       if(n[1] === caml_ml_bytes_length(buf[1])){
        var
         new_len =
           Stdlib_Int[10].call
            (null, 2 * caml_ml_bytes_length(buf[1]) | 0, Stdlib_Sys[12]);
        if(caml_ml_bytes_length(buf[1]) === new_len)
         Stdlib[2].call(null, cst_Bytes_of_seq_cannot_grow_b);
        var new_buf = make(new_len, 0);
        blit(buf[1], 0, new_buf, 0, n[1]);
        buf[1] = new_buf;
       }
       caml_bytes_set(buf[1], n[1], c);
       n[1]++;
       return 0;
      },
      i);
    return sub(buf[1], 0, n[1]);
   }
   function unsafe_get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function unsafe_get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int8(b, i){
    var a = Stdlib_Sys[10] - 8 | 0, c = Stdlib_Sys[10] - 8 | 0;
    return caml_bytes_get(b, i) << c >> a;
   }
   function get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int16_ne(b, i){
    var a = Stdlib_Sys[10] - 16 | 0, c = Stdlib_Sys[10] - 16 | 0;
    return caml_bytes_get16(b, i) << c >> a;
   }
   function get_int16_le(b, i){
    var a = Stdlib_Sys[10] - 16 | 0, c = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_le(b, i) << c >> a;
   }
   function get_int16_be(b, i){
    var a = Stdlib_Sys[10] - 16 | 0, c = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_be(b, i) << c >> a;
   }
   function get_int32_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int32_bswap(caml_bytes_get32(b, i))
            : caml_bytes_get32(b, i);
   }
   function get_int32_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get32(b, i)
            : caml_int32_bswap(caml_bytes_get32(b, i));
   }
   function get_int64_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int64_bswap(caml_bytes_get64(b, i))
            : caml_bytes_get64(b, i);
   }
   function get_int64_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get64(b, i)
            : caml_int64_bswap(caml_bytes_get64(b, i));
   }
   function unsafe_set_uint16_le(b, i, x){
    if(Stdlib_Sys[11]){caml_bytes_set16(b, i, caml_bswap16(x)); return;}
    caml_bytes_set16(b, i, x);
   }
   function unsafe_set_uint16_be(b, i, x){
    if(Stdlib_Sys[11]){caml_bytes_set16(b, i, x); return;}
    caml_bytes_set16(b, i, caml_bswap16(x));
   }
   function set_int16_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, caml_bswap16(x))
            : caml_bytes_set16(b, i, x);
   }
   function set_int16_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, x)
            : caml_bytes_set16(b, i, caml_bswap16(x));
   }
   function set_int32_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, caml_int32_bswap(x))
            : caml_bytes_set32(b, i, x);
   }
   function set_int32_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, x)
            : caml_bytes_set32(b, i, caml_int32_bswap(x));
   }
   function set_int64_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, caml_int64_bswap(x))
            : caml_bytes_set64(b, i, x);
   }
   function set_int64_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, x)
            : caml_bytes_set64(b, i, caml_int64_bswap(x));
   }
   var
    set_uint8 = caml_bytes_set,
    set_uint16_ne = caml_bytes_set16,
    dec_invalid = Stdlib_Uchar[22],
    a = [0, cst_bytes_ml, 667, 9],
    b = [0, cst_bytes_ml, 642, 20],
    cst_index_out_of_bounds = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$0 = cst_index_out_of_bounds$3,
    c = [0, cst_bytes_ml, 765, 9],
    d = [0, cst_bytes_ml, 754, 20],
    cst_index_out_of_bounds$1 = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$2 = cst_index_out_of_bounds$3,
    e = [0, cst_bytes_ml, 819, 9],
    f = [0, cst_bytes_ml, 808, 20];
   function dec_ret(n, u){
    var a = Stdlib_Uchar[9].call(null, u);
    return Stdlib_Uchar[21].call(null, n, a);
   }
   function not_in_x80_to_xBF(b){return 2 !== (b >>> 6 | 0) ? 1 : 0;}
   function not_in_xA0_to_xBF(b){return 5 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x80_to_x9F(b){return 4 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x90_to_xBF(b){
    var a = b < 144 ? 1 : 0, c = a || (191 < b ? 1 : 0);
    return c;
   }
   function not_in_x80_to_x8F(b){return 8 !== (b >>> 4 | 0) ? 1 : 0;}
   function utf_8_uchar_3(b0, b1, b2){
    return (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
   }
   function utf_8_uchar_4(b0, b1, b2, b3){
    return (b0 & 7) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
   }
   function get_utf_8_uchar(b, i){
    var b0 = caml_bytes_get(b, i), max = caml_ml_bytes_length(b) - 1 | 0;
    a:
    {
     if(224 <= b0){
      if(237 <= b0){
       if(245 <= b0) break a;
       switch(b0 - 237 | 0){
         case 0:
          var i$0 = i + 1 | 0;
          if(max < i$0) return dec_invalid(1);
          var b1$4 = caml_bytes_unsafe_get(b, i$0);
          if(not_in_x80_to_x9F(b1$4)) return dec_invalid(1);
          var i$1 = i$0 + 1 | 0;
          if(max < i$1) return dec_invalid(2);
          var b2$3 = caml_bytes_unsafe_get(b, i$1);
          return not_in_x80_to_xBF(b2$3)
                  ? dec_invalid(2)
                  : dec_ret(3, utf_8_uchar_3(b0, b1$4, b2$3));
         case 3:
          var i$4 = i + 1 | 0;
          if(max < i$4) return dec_invalid(1);
          var b1$2 = caml_bytes_unsafe_get(b, i$4);
          if(not_in_x90_to_xBF(b1$2)) return dec_invalid(1);
          var i$5 = i$4 + 1 | 0;
          if(max < i$5) return dec_invalid(2);
          var b2$1 = caml_bytes_unsafe_get(b, i$5);
          if(not_in_x80_to_xBF(b2$1)) return dec_invalid(2);
          var i$6 = i$5 + 1 | 0;
          if(max < i$6) return dec_invalid(3);
          var b3$1 = caml_bytes_unsafe_get(b, i$6);
          return not_in_x80_to_xBF(b3$1)
                  ? dec_invalid(3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$2, b2$1, b3$1));
         case 7:
          var i$10 = i + 1 | 0;
          if(max < i$10) return dec_invalid(1);
          var b1$0 = caml_bytes_unsafe_get(b, i$10);
          if(not_in_x80_to_x8F(b1$0)) return dec_invalid(1);
          var i$11 = i$10 + 1 | 0;
          if(max < i$11) return dec_invalid(2);
          var b2 = caml_bytes_unsafe_get(b, i$11);
          if(not_in_x80_to_xBF(b2)) return dec_invalid(2);
          var i$12 = i$11 + 1 | 0;
          if(max < i$12) return dec_invalid(3);
          var b3 = caml_bytes_unsafe_get(b, i$12);
          return not_in_x80_to_xBF(b3)
                  ? dec_invalid(3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$0, b2, b3));
         case 1:
         case 2: break;
         default:
          var i$7 = i + 1 | 0;
          if(max < i$7) return dec_invalid(1);
          var b1$1 = caml_bytes_unsafe_get(b, i$7);
          if(not_in_x80_to_xBF(b1$1)) return dec_invalid(1);
          var i$8 = i$7 + 1 | 0;
          if(max < i$8) return dec_invalid(2);
          var b2$0 = caml_bytes_unsafe_get(b, i$8);
          if(not_in_x80_to_xBF(b2$0)) return dec_invalid(2);
          var i$9 = i$8 + 1 | 0;
          if(max < i$9) return dec_invalid(3);
          var b3$0 = caml_bytes_unsafe_get(b, i$9);
          return not_in_x80_to_xBF(b3$0)
                  ? dec_invalid(3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$1, b2$0, b3$0));
       }
      }
      else if(225 > b0){
       var i$13 = i + 1 | 0;
       if(max < i$13) return dec_invalid(1);
       var b1$5 = caml_bytes_unsafe_get(b, i$13);
       if(not_in_xA0_to_xBF(b1$5)) return dec_invalid(1);
       var i$14 = i$13 + 1 | 0;
       if(max < i$14) return dec_invalid(2);
       var b2$4 = caml_bytes_unsafe_get(b, i$14);
       return not_in_x80_to_xBF(b2$4)
               ? dec_invalid(2)
               : dec_ret(3, utf_8_uchar_3(b0, b1$5, b2$4));
      }
      var i$2 = i + 1 | 0;
      if(max < i$2) return dec_invalid(1);
      var b1$3 = caml_bytes_unsafe_get(b, i$2);
      if(not_in_x80_to_xBF(b1$3)) return dec_invalid(1);
      var i$3 = i$2 + 1 | 0;
      if(max < i$3) return dec_invalid(2);
      var b2$2 = caml_bytes_unsafe_get(b, i$3);
      return not_in_x80_to_xBF(b2$2)
              ? dec_invalid(2)
              : dec_ret(3, utf_8_uchar_3(b0, b1$3, b2$2));
     }
     if(128 > b0) return dec_ret(1, b0);
     if(194 <= b0){
      var i$15 = i + 1 | 0;
      if(max < i$15) return dec_invalid(1);
      var b1 = caml_bytes_unsafe_get(b, i$15);
      return not_in_x80_to_xBF(b1)
              ? dec_invalid(1)
              : dec_ret(2, (b0 & 31) << 6 | b1 & 63);
     }
    }
    return dec_invalid(1);
   }
   function set_utf_8_uchar(b$0, i, u){
    function set(c, b, a){caml_bytes_unsafe_set(c, b, a);}
    var
     max = caml_ml_bytes_length(b$0) - 1 | 0,
     u$0 = Stdlib_Uchar[10].call(null, u);
    if(0 > u$0) throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
    if(127 >= u$0){caml_bytes_set(b$0, i, u$0); return 1;}
    if(2047 >= u$0){
     var last$1 = i + 1 | 0;
     return max < last$1
             ? 0
             : (caml_bytes_set
                (b$0, i, 192 | u$0 >>> 6 | 0),
               set(b$0, last$1, 128 | u$0 & 63),
               2);
    }
    if(65535 >= u$0){
     var last$0 = i + 2 | 0;
     return max < last$0
             ? 0
             : (caml_bytes_set
                (b$0, i, 224 | u$0 >>> 12 | 0),
               set(b$0, i + 1 | 0, 128 | (u$0 >>> 6 | 0) & 63),
               set(b$0, last$0, 128 | u$0 & 63),
               3);
    }
    if(1114111 < u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
    var last = i + 3 | 0;
    return max < last
            ? 0
            : (caml_bytes_set
               (b$0, i, 240 | u$0 >>> 18 | 0),
              set(b$0, i + 1 | 0, 128 | (u$0 >>> 12 | 0) & 63),
              set(b$0, i + 2 | 0, 128 | (u$0 >>> 6 | 0) & 63),
              set(b$0, last, 128 | u$0 & 63),
              4);
   }
   function is_valid_utf_8(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     var match = caml_bytes_unsafe_get(b, i);
     a:
     {
      if(224 <= match){
       if(237 <= match){
        if(245 <= match) break a;
        switch(match - 237 | 0){
          case 0:
           var last = i + 2 | 0;
           if
            (max >= last
             &&
              !
              not_in_x80_to_x9F(caml_bytes_unsafe_get(b, i + 1 | 0))
              && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last))){var i$0 = last + 1 | 0; i = i$0; continue;}
           return 0;
          case 3:
           var last$1 = i + 3 | 0;
           if
            (max >= last$1
             &&
              !
              not_in_x90_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$1))){var i$2 = last$1 + 1 | 0; i = i$2; continue;}
           return 0;
          case 7:
           var last$3 = i + 3 | 0;
           if
            (max >= last$3
             &&
              !
              not_in_x80_to_x8F(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$3))){var i$4 = last$3 + 1 | 0; i = i$4; continue;}
           return 0;
          case 1:
          case 2: break;
          default:
           var last$2 = i + 3 | 0;
           if
            (max >= last$2
             &&
              !
              not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$2))){var i$3 = last$2 + 1 | 0; i = i$3; continue;}
           return 0;
        }
       }
       else if(225 > match){
        var last$4 = i + 2 | 0;
        if
         (max >= last$4
          &&
           !
           not_in_xA0_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
           && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$4))){var i$5 = last$4 + 1 | 0; i = i$5; continue;}
        return 0;
       }
       var last$0 = i + 2 | 0;
       if
        (max >= last$0
         &&
          !
          not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
          && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$0))){var i$1 = last$0 + 1 | 0; i = i$1; continue;}
       return 0;
      }
      if(128 > match){var i$7 = i + 1 | 0; i = i$7; continue;}
      if(194 <= match){
       var last$5 = i + 1 | 0;
       if
        (max >= last$5
         && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$5))){var i$6 = last$5 + 1 | 0; i = i$6; continue;}
       return 0;
      }
     }
     return 0;
    }
   }
   function get_utf_16be_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return dec_invalid(1);
     var hi = unsafe_get_uint16_be(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return dec_invalid(2);
      var last = i + 3 | 0;
      if(max < last) return dec_invalid((max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return dec_invalid(2);
     }
     return dec_ret(2, hi);
    }
    return Stdlib[1].call(null, cst_index_out_of_bounds);
   }
   function set_utf_16be_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = Stdlib_Uchar[10].call(null, u);
     if(0 > u$0) throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_be(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_be(b, i, hi);
     unsafe_set_uint16_be(b, i + 2 | 0, lo);
     return 4;
    }
    return Stdlib[1].call(null, cst_index_out_of_bounds$0);
   }
   function is_valid_utf_16be(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_be(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0;
       i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0;
     i = i$0;
    }
   }
   function get_utf_16le_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return dec_invalid(1);
     var hi = unsafe_get_uint16_le(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return dec_invalid(2);
      var last = i + 3 | 0;
      if(max < last) return dec_invalid((max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return dec_invalid(2);
     }
     return dec_ret(2, hi);
    }
    return Stdlib[1].call(null, cst_index_out_of_bounds$1);
   }
   function set_utf_16le_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = Stdlib_Uchar[10].call(null, u);
     if(0 > u$0) throw caml_maybe_attach_backtrace([0, Assert_failure, f], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_le(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, e], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_le(b, i, hi);
     unsafe_set_uint16_le(b, i + 2 | 0, lo);
     return 4;
    }
    return Stdlib[1].call(null, cst_index_out_of_bounds$2);
   }
   function is_valid_utf_16le(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_le(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0;
       i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0;
     i = i$0;
    }
   }
   var
    Stdlib_Bytes =
      [0,
       make,
       init,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit_string,
       concat,
       cat,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare,
       runtime.caml_bytes_equal,
       starts_with,
       ends_with,
       caml_string_of_bytes,
       caml_bytes_of_string,
       split_on_char,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       set_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       set_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       set_utf_16le_uchar,
       is_valid_utf_16le,
       caml_bytes_get,
       get_int8,
       caml_bytes_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       caml_bytes_get32,
       get_int32_be,
       get_int32_le,
       caml_bytes_get64,
       get_int64_be,
       get_int64_le,
       set_uint8,
       caml_bytes_set,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       caml_bytes_set16,
       set_int16_be,
       set_int16_le,
       caml_bytes_set32,
       set_int32_be,
       set_int32_le,
       caml_bytes_set64,
       set_int64_be,
       set_int64_le];
   runtime.caml_register_global(30, Stdlib_Bytes, "Stdlib__Bytes");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__String
//# unitInfo: Requires: Stdlib, Stdlib__Bytes
//# shape: Stdlib__String:[F(2),F(2),N,F(1),F(1),F(2),F(2)*,F(2)*,F(2)*,F(2),F(2),F(3),F(3),F(2),F(3),F(2),F(2),F(2),F(3),F(3),F(2),F(2),F(1),F(1),F(1),F(1),F(1),F(1),F(2),F(2),F(3),F(3),F(3),F(3),F(2),F(2),F(2),F(2),F(1)*,F(1)*,F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(5),F(1),F(4),F(1),F(1),F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    caml_blit_string = runtime.caml_blit_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    empty = cst$0,
    Stdlib = global_data.Stdlib,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    bts = Stdlib_Bytes[48],
    bos = Stdlib_Bytes[49];
   function make(n, c){return bts(Stdlib_Bytes[1].call(null, n, c));}
   function init(n, f){return bts(Stdlib_Bytes[2].call(null, n, f));}
   function copy(s){
    var a = bos(s);
    return bts(Stdlib_Bytes[4].call(null, a));
   }
   var of_bytes = Stdlib_Bytes[6], to_bytes = Stdlib_Bytes[5];
   function sub(s, ofs, len){
    var a = bos(s);
    return bts(Stdlib_Bytes[7].call(null, a, ofs, len));
   }
   var
    fill = Stdlib_Bytes[10],
    blit = Stdlib_Bytes[12],
    cst_String_concat = "String.concat";
   function concat(sep, l){
    if(! l) return cst;
    var seplen = caml_ml_string_length(sep);
    a:
    {
     var acc = 0, param = l, pos$1 = 0;
     for(;;){
      if(! param){var a = acc; break a;}
      var hd = param[1];
      if(! param[2]) break;
      var
       tl = param[2],
       x = (caml_ml_string_length(hd) + seplen | 0) + acc | 0;
      if(acc <= x){
       acc = x;
       param = tl;
      }
      else{acc = Stdlib[1].call(null, cst_String_concat); param = tl;}
     }
     var a = caml_ml_string_length(hd) + acc | 0;
    }
    var dst = runtime.caml_create_bytes(a), pos = pos$1, param$0 = l;
    for(;;){
     if(param$0){
      var hd$0 = param$0[1];
      if(param$0[2]){
       var tl$0 = param$0[2];
       caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
       caml_blit_string
        (sep, 0, dst, pos + caml_ml_string_length(hd$0) | 0, seplen);
       var pos$0 = (pos + caml_ml_string_length(hd$0) | 0) + seplen | 0;
       pos = pos$0;
       param$0 = tl$0;
       continue;
      }
      caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
     }
     return bts(dst);
    }
   }
   var
    cat = Stdlib[28],
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from";
   function iter(f, s){
    var a = caml_ml_string_length(s) - 1 | 0, b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_call1(f, caml_string_unsafe_get(s, i));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return 0;
   }
   function iteri(f, s){
    var a = caml_ml_string_length(s) - 1 | 0, b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(s, i));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return 0;
   }
   function map(f, s){
    var a = bos(s);
    return bts(Stdlib_Bytes[17].call(null, f, a));
   }
   function mapi(f, s){
    var a = bos(s);
    return bts(Stdlib_Bytes[18].call(null, f, a));
   }
   function fold_right(f, x, a){
    var b = bos(x);
    return Stdlib_Bytes[20].call(null, f, b, a);
   }
   function fold_left(f, a, x){
    var b = bos(x);
    return Stdlib_Bytes[19].call(null, f, a, b);
   }
   function exists(f, s){
    var a = bos(s);
    return Stdlib_Bytes[22].call(null, f, a);
   }
   function for_all(f, s){
    var a = bos(s);
    return Stdlib_Bytes[21].call(null, f, a);
   }
   function is_space(param){
    var a = param - 9 | 0;
    a:
    {
     if(4 < a >>> 0){if(23 !== a) break a;} else if(2 === a) break a;
     return 1;
    }
    return 0;
   }
   function trim(s){
    if(s === cst$0) return s;
    if
     (!
      is_space(caml_string_unsafe_get(s, 0))
      &&
       !
       is_space(caml_string_unsafe_get(s, caml_ml_string_length(s) - 1 | 0)))
     return s;
    var a = bos(s);
    return bts(Stdlib_Bytes[23].call(null, a));
   }
   function escaped(s){
    var n = caml_ml_string_length(s), i = 0;
    for(;;){
     if(n <= i) return s;
     var a = caml_string_unsafe_get(s, i) - 32 | 0;
     a:
     {
      if(59 < a >>> 0){
       if(33 >= a - 61 >>> 0) break a;
      }
      else if(2 !== a) break a;
      var b = bos(s);
      return bts(Stdlib_Bytes[24].call(null, b));
     }
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function index_rec(s, lim, i$1, c){
    var i = i$1;
    for(;;){
     if(lim <= i) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i) === c) return i;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_string_length(s), 0, c);}
   function index_rec_opt(s, lim, i$1, c){
    var i = i$1;
    for(;;){
     if(lim <= i) return 0;
     if(caml_string_unsafe_get(s, i) === c) return [0, i];
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_string_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return Stdlib[1].call(null, cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return Stdlib[1].call(null, cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i$1, c){
    var i = i$1;
    for(;;){
     if(0 > i) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i) === c) return i;
     var i$0 = i - 1 | 0;
     i = i$0;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i) return rindex_rec(s, i, c);
    return Stdlib[1].call(null, cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i$1, c){
    var i = i$1;
    for(;;){
     if(0 > i) return 0;
     if(caml_string_unsafe_get(s, i) === c) return [0, i];
     var i$0 = i - 1 | 0;
     i = i$0;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i)
     return rindex_rec_opt(s, i, c);
    return Stdlib[1].call(null, cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var a = 1; return a;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(exn, 0);
     }
    return Stdlib[1].call(null, cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_string_length(s) > i)
     try{rindex_rec(s, i, c); var a = 1; return a;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(exn, 0);
     }
    return Stdlib[1].call(null, cst_String_rcontains_from_Byte);
   }
   function uppercase_ascii(s){
    var a = bos(s);
    return bts(Stdlib_Bytes[40].call(null, a));
   }
   function lowercase_ascii(s){
    var a = bos(s);
    return bts(Stdlib_Bytes[41].call(null, a));
   }
   function capitalize_ascii(s){
    var a = bos(s);
    return bts(Stdlib_Bytes[42].call(null, a));
   }
   function uncapitalize_ascii(s){
    var a = bos(s);
    return bts(Stdlib_Bytes[43].call(null, a));
   }
   function starts_with(prefix, s){
    var
     len_s = caml_ml_string_length(s),
     len_pre = caml_ml_string_length(prefix),
     a = len_pre <= len_s ? 1 : 0;
    if(! a) return a;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_string_unsafe_get(s, i) !== caml_string_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_string_length(s),
     len_suf = caml_ml_string_length(suffix),
     diff = len_s - len_suf | 0,
     a = 0 <= diff ? 1 : 0;
    if(! a) return a;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_string_unsafe_get(s, diff + i | 0)
       !== caml_string_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_string_length(s)],
     a = caml_ml_string_length(s) - 1 | 0;
    if(a >= 0){
     var i = a;
     for(;;){
      if(caml_string_unsafe_get(s, i) === sep){
       var c = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), c];
       j[1] = i;
      }
      var d = i - 1 | 0;
      if(0 === i) break;
      i = d;
     }
    }
    var b = r[1];
    return [0, sub(s, 0, j[1]), b];
   }
   function uppercase(s){
    var a = bos(s);
    return bts(Stdlib_Bytes[36].call(null, a));
   }
   function lowercase(s){
    var a = bos(s);
    return bts(Stdlib_Bytes[37].call(null, a));
   }
   function capitalize(s){
    var a = bos(s);
    return bts(Stdlib_Bytes[38].call(null, a));
   }
   function uncapitalize(s){
    var a = bos(s);
    return bts(Stdlib_Bytes[39].call(null, a));
   }
   var compare = runtime.caml_string_compare;
   function to_seq(s){var a = bos(s); return Stdlib_Bytes[51].call(null, a);}
   function to_seqi(s){var a = bos(s); return Stdlib_Bytes[52].call(null, a);}
   function of_seq(g){return bts(Stdlib_Bytes[53].call(null, g));}
   function get_utf_8_uchar(s, i){
    var a = bos(s);
    return Stdlib_Bytes[54].call(null, a, i);
   }
   function is_valid_utf_8(s){
    var a = bos(s);
    return Stdlib_Bytes[56].call(null, a);
   }
   function get_utf_16be_uchar(s, i){
    var a = bos(s);
    return Stdlib_Bytes[57].call(null, a, i);
   }
   function is_valid_utf_16be(s){
    var a = bos(s);
    return Stdlib_Bytes[59].call(null, a);
   }
   function get_utf_16le_uchar(s, i){
    var a = bos(s);
    return Stdlib_Bytes[60].call(null, a, i);
   }
   function is_valid_utf_16le(s){
    var a = bos(s);
    return Stdlib_Bytes[62].call(null, a);
   }
   function get_int8(s, i){
    var a = bos(s);
    return Stdlib_Bytes[64].call(null, a, i);
   }
   function get_uint16_le(s, i){
    var a = bos(s);
    return Stdlib_Bytes[67].call(null, a, i);
   }
   function get_uint16_be(s, i){
    var a = bos(s);
    return Stdlib_Bytes[66].call(null, a, i);
   }
   function get_int16_ne(s, i){
    var a = bos(s);
    return Stdlib_Bytes[68].call(null, a, i);
   }
   function get_int16_le(s, i){
    var a = bos(s);
    return Stdlib_Bytes[70].call(null, a, i);
   }
   function get_int16_be(s, i){
    var a = bos(s);
    return Stdlib_Bytes[69].call(null, a, i);
   }
   function get_int32_le(s, i){
    var a = bos(s);
    return Stdlib_Bytes[73].call(null, a, i);
   }
   function get_int32_be(s, i){
    var a = bos(s);
    return Stdlib_Bytes[72].call(null, a, i);
   }
   function get_int64_le(s, i){
    var a = bos(s);
    return Stdlib_Bytes[76].call(null, a, i);
   }
   function get_int64_be(s, i){
    var a = bos(s);
    return Stdlib_Bytes[75].call(null, a, i);
   }
   var
    Stdlib_String =
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       concat,
       cat,
       caml_string_equal,
       compare,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       blit,
       copy,
       fill,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       runtime.caml_string_get,
       get_int8,
       runtime.caml_string_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       runtime.caml_string_get32,
       get_int32_be,
       get_int32_le,
       runtime.caml_string_get64,
       get_int64_be,
       get_int64_le];
   runtime.caml_register_global(12, Stdlib_String, "Stdlib__String");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Unit
//# shape: Stdlib__Unit:[F(2)*,F(2)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = "()";
   function equal(param, a){return 1;}
   function compare(param, a){return 0;}
   function to_string(param){return cst;}
   var Stdlib_Unit = [0, equal, compare, to_string];
   runtime.caml_register_global(1, Stdlib_Unit, "Stdlib__Unit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Marshal
//# unitInfo: Requires: Stdlib, Stdlib__Bytes
//# shape: Stdlib__Marshal:[F(3),F(5),F(1),F(2),F(2),N,F(2),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Marshal_from_bytes$1 = "Marshal.from_bytes",
    caml_marshal_data_size = runtime.caml_marshal_data_size,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    cst_Marshal_to_buffer_substrin =
      "Marshal.to_buffer: substring out of bounds";
   function to_buffer(buff, ofs, len, v, flags){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buff) - len | 0) >= ofs)
     return runtime.caml_output_value_to_buffer(buff, ofs, len, v, flags);
    return Stdlib[1].call(null, cst_Marshal_to_buffer_substrin);
   }
   var
    cst_Marshal_data_size = "Marshal.data_size",
    cst_Marshal_from_bytes = cst_Marshal_from_bytes$1,
    cst_Marshal_from_bytes$0 = cst_Marshal_from_bytes$1;
   function data_size(buff, ofs){
    if(0 <= ofs && (caml_ml_bytes_length(buff) - 20 | 0) >= ofs)
     return caml_marshal_data_size(buff, ofs);
    return Stdlib[1].call(null, cst_Marshal_data_size);
   }
   function total_size(buff, ofs){return 20 + data_size(buff, ofs) | 0;}
   function from_bytes(buff, ofs){
    if(0 <= ofs && (caml_ml_bytes_length(buff) - 20 | 0) >= ofs){
     var len = caml_marshal_data_size(buff, ofs);
     return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
             ? Stdlib[1].call(null, cst_Marshal_from_bytes$0)
             : runtime.caml_input_value_from_bytes(buff, ofs);
    }
    return Stdlib[1].call(null, cst_Marshal_from_bytes);
   }
   function from_string(buff, ofs){
    return from_bytes(Stdlib_Bytes[49].call(null, buff), ofs);
   }
   var
    Stdlib_Marshal =
      [0,
       runtime.caml_output_value,
       to_buffer,
       runtime.caml_input_value,
       from_bytes,
       from_string,
       20,
       data_size,
       total_size];
   runtime.caml_register_global(6, Stdlib_Marshal, "Stdlib__Marshal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Array
//# unitInfo: Requires: Assert_failure, Stdlib, Stdlib__Seq
//# shape: Stdlib__Array:[F(1)*,F(2),F(3),F(3),F(2)*,F(1)*,F(3),F(1)*,F(4),F(5),F(1),F(1),F(2),F(2),F(2),F(2),F(3),F(3),F(3),F(3),F(3),F(2),F(2),F(3),F(3),F(2),F(2),F(2),F(2),F(1),F(2),F(2),F(2),F(2),F(1)*->F(1)*,F(1)*->F(1)*,F(1),[]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_array_sub = runtime.caml_array_sub,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    make_float = runtime.caml_make_float_vect,
    Floatarray = [0],
    cst_Array_init = "Array.init",
    cst_Array_sub = "Array.sub",
    cst_Array_fill = "Array.fill",
    cst_Array_blit = "Array.blit",
    cst_Array_iter2_arrays_must_ha =
      "Array.iter2: arrays must have the same length",
    cst_Array_map2_arrays_must_hav =
      "Array.map2: arrays must have the same length",
    cst_Array_for_all2 = "Array.for_all2",
    cst_Array_exists2 = "Array.exists2",
    cst_Array_combine = "Array.combine";
   function init(l, f){
    if(0 === l) return [0];
    if(0 > l) return Stdlib[1].call(null, cst_Array_init);
    var res = caml_make_vect(l, caml_call1(f, 0)), a = l - 1 | 0, b = 1;
    if(a >= 1){
     var i = b;
     for(;;){
      res[i + 1] = caml_call1(f, i);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return res;
   }
   function make_matrix(sx, sy, init){
    var res = caml_make_vect(sx, [0]), a = sx - 1 | 0, b = 0;
    if(a >= 0){
     var x = b;
     for(;;){
      res[x + 1] = caml_make_vect(sy, init);
      var c = x + 1 | 0;
      if(a === x) break;
      x = c;
     }
    }
    return res;
   }
   function copy(a){
    var l = a.length - 1;
    return 0 === l ? [0] : caml_array_sub(a, 0, l);
   }
   function append(a1, a2){
    var l1 = a1.length - 1;
    return 0 === l1
            ? copy(a2)
            : 0
              === a2.length - 1
              ? caml_array_sub(a1, 0, l1)
              : runtime.caml_array_append(a1, a2);
   }
   function sub(a, ofs, len){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return caml_array_sub(a, ofs, len);
    return Stdlib[1].call(null, cst_Array_sub);
   }
   function fill(a, ofs, len, v){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return runtime.caml_array_fill(a, ofs, len, v);
    return Stdlib[1].call(null, cst_Array_fill);
   }
   function blit(a1, ofs1, a2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (a1.length - 1 - len | 0) >= ofs1
        && 0 <= ofs2 && (a2.length - 1 - len | 0) >= ofs2)
     return runtime.caml_array_blit(a1, ofs1, a2, ofs2, len);
    return Stdlib[1].call(null, cst_Array_blit);
   }
   function iter(f, a){
    var b = a.length - 2 | 0, c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      caml_call1(f, a[i + 1]);
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return 0;
   }
   function iter2(f, a, b){
    if(a.length - 1 !== b.length - 1)
     return Stdlib[1].call(null, cst_Array_iter2_arrays_must_ha);
    var c = a.length - 2 | 0, d = 0;
    if(c >= 0){
     var i = d;
     for(;;){
      caml_call2(f, a[i + 1], b[i + 1]);
      var e = i + 1 | 0;
      if(c === i) break;
      i = e;
     }
    }
    return 0;
   }
   function map(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var r = caml_make_vect(l, caml_call1(f, a[1])), b = l - 1 | 0, c = 1;
    if(b >= 1){
     var i = c;
     for(;;){
      r[i + 1] = caml_call1(f, a[i + 1]);
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return r;
   }
   function map2(f, a, b){
    var la = a.length - 1, lb = b.length - 1;
    if(la !== lb) return Stdlib[1].call(null, cst_Array_map2_arrays_must_hav);
    if(0 === la) return [0];
    var
     r = caml_make_vect(la, caml_call2(f, a[1], b[1])),
     c = la - 1 | 0,
     d = 1;
    if(c >= 1){
     var i = d;
     for(;;){
      r[i + 1] = caml_call2(f, a[i + 1], b[i + 1]);
      var e = i + 1 | 0;
      if(c === i) break;
      i = e;
     }
    }
    return r;
   }
   function iteri(f, a){
    var b = a.length - 2 | 0, c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      caml_call2(f, i, a[i + 1]);
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return 0;
   }
   function mapi(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var r = caml_make_vect(l, caml_call2(f, 0, a[1])), b = l - 1 | 0, c = 1;
    if(b >= 1){
     var i = c;
     for(;;){
      r[i + 1] = caml_call2(f, i, a[i + 1]);
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return r;
   }
   function to_list(a){
    var i$1 = a.length - 2 | 0, i = i$1, res = 0;
    for(;;){
     if(0 > i) return res;
     var res$0 = [0, a[i + 1], res], i$0 = i - 1 | 0;
     i = i$0;
     res = res$0;
    }
   }
   function list_length(accu$1, param$0){
    var accu = accu$1, param = param$0;
    for(;;){
     if(! param) return accu;
     var t = param[2], accu$0 = accu + 1 | 0;
     accu = accu$0;
     param = t;
    }
   }
   function of_list(l){
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     a = caml_make_vect(list_length(0, l), hd),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[i + 1] = hd$0;
     var i$0 = i + 1 | 0;
     i = i$0;
     param = tl$0;
    }
   }
   function fold_left(f, x, a){
    var r = [0, x], b = a.length - 2 | 0, c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      r[1] = caml_call2(f, r[1], a[i + 1]);
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return r[1];
   }
   function fold_left_map(f, acc, input_array){
    var len = input_array.length - 1;
    if(0 === len) return [0, acc, [0]];
    var
     match = caml_call2(f, acc, input_array[1]),
     elt = match[2],
     acc$0 = match[1],
     output_array = caml_make_vect(len, elt),
     acc$1 = [0, acc$0],
     a = len - 1 | 0,
     b = 1;
    if(a >= 1){
     var i = b;
     for(;;){
      var
       match$0 = caml_call2(f, acc$1[1], input_array[i + 1]),
       elt$0 = match$0[2],
       acc$2 = match$0[1];
      acc$1[1] = acc$2;
      output_array[i + 1] = elt$0;
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return [0, acc$1[1], output_array];
   }
   function fold_right(f, a, x){
    var r = [0, x], b = a.length - 2 | 0;
    if(b >= 0){
     var i = b;
     for(;;){
      r[1] = caml_call2(f, a[i + 1], r[1]);
      var c = i - 1 | 0;
      if(0 === i) break;
      i = c;
     }
    }
    return r[1];
   }
   function exists(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[i + 1])) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, a[i + 1])) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return Stdlib[1].call(null, cst_Array_for_all2);
    var i = 0;
    for(;;){
     if(i === n1) return 1;
     if(! caml_call2(p, l1[i + 1], l2[i + 1])) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function exists2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return Stdlib[1].call(null, cst_Array_exists2);
    var i = 0;
    for(;;){
     if(i === n1) return 0;
     if(caml_call2(p, l1[i + 1], l2[i + 1])) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function mem(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(0 === runtime.caml_compare(a[i + 1], x)) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function memq(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(x === a[i + 1]) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_opt(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var x = a[i + 1];
     if(caml_call1(p, x)) return [0, x];
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_map(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call1(f, a[i + 1]);
     if(r) return r;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function split(x){
    if(runtime.caml_equal(x, [0])) return [0, [0], [0]];
    var
     match = x[1],
     b0 = match[2],
     a0 = match[1],
     n = x.length - 1,
     a = caml_make_vect(n, a0),
     b = caml_make_vect(n, b0),
     c = n - 1 | 0,
     d = 1;
    if(c >= 1){
     var i = d;
     for(;;){
      var match$0 = x[i + 1], bi = match$0[2], ai = match$0[1];
      a[i + 1] = ai;
      b[i + 1] = bi;
      var e = i + 1 | 0;
      if(c === i) break;
      i = e;
     }
    }
    return [0, a, b];
   }
   function combine(a, b){
    var na = a.length - 1, nb = b.length - 1;
    if(na !== nb) Stdlib[1].call(null, cst_Array_combine);
    if(0 === na) return [0];
    var x = caml_make_vect(na, [0, a[1], b[1]]), c = na - 1 | 0, d = 1;
    if(c >= 1){
     var i = d;
     for(;;){
      x[i + 1] = [0, a[i + 1], b[i + 1]];
      var e = i + 1 | 0;
      if(c === i) break;
      i = e;
     }
    }
    return x;
   }
   var
    Bottom = [248, "Stdlib.Array.Bottom", runtime.caml_fresh_oo_id(0)],
    a = [0, "array.ml", 322, 4];
   function sort(cmp, a$0){
    function maxson(l, i){
     var i31 = ((i + i | 0) + i | 0) + 1 | 0, x = [0, i31];
     if((i31 + 2 | 0) < l){
      var a = i31 + 1 | 0, e = caml_check_bound(a$0, a)[a + 1];
      if(caml_call2(cmp, caml_check_bound(a$0, i31)[i31 + 1], e) < 0)
       x[1] = i31 + 1 | 0;
      var b = i31 + 2 | 0, f = caml_check_bound(a$0, b)[b + 1], c = x[1];
      if(caml_call2(cmp, caml_check_bound(a$0, c)[c + 1], f) < 0)
       x[1] = i31 + 2 | 0;
      return x[1];
     }
     if((i31 + 1 | 0) < l){
      var d = i31 + 1 | 0, g = caml_check_bound(a$0, d)[d + 1];
      if(0 > caml_call2(cmp, caml_check_bound(a$0, i31)[i31 + 1], g))
       return i31 + 1 | 0;
     }
     if(i31 < l) return i31;
     throw caml_maybe_attach_backtrace([0, Bottom, i], 1);
    }
    var l = a$0.length - 1, b = ((l + 1 | 0) / 3 | 0) - 1 | 0;
    if(b >= 0){
     var i$6 = b;
     for(;;){
      var e$1 = caml_check_bound(a$0, i$6)[i$6 + 1];
      try{
       var i = i$6;
       for(;;){
        var j = maxson(l, i);
        if(0 >= caml_call2(cmp, caml_check_bound(a$0, j)[j + 1], e$1)){caml_check_bound(a$0, i)[i + 1] = e$1; break;}
        var g = caml_check_bound(a$0, j)[j + 1];
        caml_check_bound(a$0, i)[i + 1] = g;
        i = j;
       }
      }
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0), tag = exn[1];
       if(tag !== Bottom) throw caml_maybe_attach_backtrace(exn, 0);
       var i$0 = exn[2];
       caml_check_bound(a$0, i$0)[i$0 + 1] = e$1;
      }
      var n = i$6 - 1 | 0;
      if(0 === i$6) break;
      i$6 = n;
     }
    }
    var c = l - 1 | 0;
    if(c >= 2){
     var i$4 = c;
     a:
     for(;;){
      var e$0 = caml_check_bound(a$0, i$4)[i$4 + 1];
      a$0[i$4 + 1] = caml_check_bound(a$0, 0)[1];
      var i$5 = 0;
      try{
       var i$1 = i$5;
       for(;;){
        var j$0 = maxson(i$4, i$1), h = caml_check_bound(a$0, j$0)[j$0 + 1];
        caml_check_bound(a$0, i$1)[i$1 + 1] = h;
        i$1 = j$0;
       }
      }
      catch(exn){
       var exn$0 = caml_wrap_exception(exn), tag$0 = exn$0[1];
       if(tag$0 !== Bottom) throw caml_maybe_attach_backtrace(exn$0, 0);
       var i$2 = exn$0[2], i$3 = i$2;
       for(;;){
        var father = (i$3 - 1 | 0) / 3 | 0;
        if(i$3 === father)
         throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
        if
         (0 <= caml_call2(cmp, caml_check_bound(a$0, father)[father + 1], e$0))
         caml_check_bound(a$0, i$3)[i$3 + 1] = e$0;
        else{
         var k = caml_check_bound(a$0, father)[father + 1];
         caml_check_bound(a$0, i$3)[i$3 + 1] = k;
         if(0 < father){i$3 = father; continue;}
         caml_check_bound(a$0, 0)[1] = e$0;
        }
        var m = i$4 - 1 | 0;
        if(2 === i$4) break a;
        i$4 = m;
        break;
       }
      }
     }
    }
    var d = 1 < l ? 1 : 0;
    if(d){
     var e = caml_check_bound(a$0, 1)[2];
     a$0[2] = caml_check_bound(a$0, 0)[1];
     a$0[1] = e;
     var f = 0;
    }
    else
     var f = d;
    return f;
   }
   function stable_sort(cmp, a){
    function merge(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs){
     var
      src1r = src1ofs + src1len | 0,
      src2r = src2ofs + src2len | 0,
      s2$1 = caml_check_bound(src2, src2ofs)[src2ofs + 1],
      s1$1 = caml_check_bound(a, src1ofs)[src1ofs + 1],
      i1 = src1ofs,
      s1 = s1$1,
      i2 = src2ofs,
      s2 = s2$1,
      d = dstofs;
     for(;;)
      if(0 < caml_call2(cmp, s1, s2)){
       caml_check_bound(dst, d)[d + 1] = s2;
       var i2$0 = i2 + 1 | 0;
       if(i2$0 >= src2r) return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
       var d$0 = d + 1 | 0, s2$0 = caml_check_bound(src2, i2$0)[i2$0 + 1];
       i2 = i2$0;
       s2 = s2$0;
       d = d$0;
      }
      else{
       caml_check_bound(dst, d)[d + 1] = s1;
       var i1$0 = i1 + 1 | 0;
       if(i1$0 >= src1r)
        return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
       var d$1 = d + 1 | 0, s1$0 = caml_check_bound(a, i1$0)[i1$0 + 1];
       i1 = i1$0;
       s1 = s1$0;
       d = d$1;
      }
    }
    function isortto(srcofs, dst, dstofs, len){
     var b = len - 1 | 0, k = 0;
     if(b >= 0){
      var i = k;
      a:
      for(;;){
       var
        c = srcofs + i | 0,
        e = caml_check_bound(a, c)[c + 1],
        j = [0, (dstofs + i | 0) - 1 | 0];
       for(;;){
        if(dstofs <= j[1]){
         var d = j[1];
         if(0 < caml_call2(cmp, caml_check_bound(dst, d)[d + 1], e)){
          var f = j[1], l = caml_check_bound(dst, f)[f + 1], g = j[1] + 1 | 0;
          caml_check_bound(dst, g)[g + 1] = l;
          j[1]--;
          continue;
         }
        }
        var h = j[1] + 1 | 0;
        caml_check_bound(dst, h)[h + 1] = e;
        var m = i + 1 | 0;
        if(b === i) break a;
        i = m;
        break;
       }
      }
     }
     return 0;
    }
    function sortto(srcofs, dst, dstofs, len){
     if(len <= 5) return isortto(srcofs, dst, dstofs, len);
     var l1 = len / 2 | 0, l2 = len - l1 | 0;
     sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
     sortto(srcofs, a, srcofs + l2 | 0, l1);
     return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
    }
    var l = a.length - 1;
    if(l <= 5) return isortto(0, a, 0, l);
    var
     l1 = l / 2 | 0,
     l2 = l - l1 | 0,
     t = caml_make_vect(l2, caml_check_bound(a, 0)[1]);
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0);
   }
   function to_seq(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[i + 1], b = i + 1 | 0;
     return [0, x, function(a){return aux(b, a);}];
    }
    var b = 0;
    return function(a){return aux(b, a);};
   }
   function to_seqi(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[i + 1], b = i + 1 | 0;
     return [0, [0, i, x], function(a){return aux(b, a);}];
    }
    var b = 0;
    return function(a){return aux(b, a);};
   }
   function of_seq(i$2){
    var
     l =
       Stdlib_Seq[5].call(null, function(acc, x){return [0, x, acc];}, 0, i$2);
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     len = list_length(0, l),
     a = caml_make_vect(len, hd),
     i$1 = len - 2 | 0,
     i = i$1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[i + 1] = hd$0;
     var i$0 = i - 1 | 0;
     i = i$0;
     param = tl$0;
    }
   }
   var
    Stdlib_Array =
      [0,
       make_float,
       init,
       make_matrix,
       make_matrix,
       append,
       runtime.caml_array_concat,
       sub,
       copy,
       fill,
       blit,
       to_list,
       of_list,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_left_map,
       fold_right,
       iter2,
       map2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find_opt,
       find_map,
       split,
       combine,
       sort,
       stable_sort,
       stable_sort,
       to_seq,
       to_seqi,
       of_seq,
       Floatarray];
   runtime.caml_register_global(14, Stdlib_Array, "Stdlib__Array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Float
//# unitInfo: Requires: Assert_failure, Stdlib, Stdlib__Array, Stdlib__List, Stdlib__Seq
//# shape: Stdlib__Float:[N,N,N,F(1)*,F(1)*,N,N,N,N,N,N,N,F(1)*,F(1)*,F(1)*,F(1)*,F(1),F(1),F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Float_array_blit$1 = "Float.array.blit",
    cst_float_ml = "float.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_float_compare = runtime.caml_float_compare,
    caml_floatarray_blit = runtime.caml_floatarray_blit,
    caml_floatarray_create = runtime.caml_floatarray_create,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_nextafter_float = runtime.caml_nextafter_float,
    caml_signbit_float = runtime.caml_signbit_float,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    infinity = Stdlib[22],
    neg_infinity = Stdlib[23],
    nan = Stdlib[24];
   function is_finite(x){return x - x === 0. ? 1 : 0;}
   function is_infinite(x){return 1. / x === 0. ? 1 : 0;}
   function is_nan(x){return x !== x ? 1 : 0;}
   var
    max_float = Stdlib[25],
    min_float = Stdlib[26],
    epsilon = Stdlib[27],
    of_string_opt = Stdlib[36],
    to_string = Stdlib[35],
    cst_Float_Array_init = "Float.Array.init",
    cst_Float_Array_concat = "Float.Array.concat",
    a = [0, cst_float_ml, 222, 14],
    cst_Float_Array_sub = "Float.Array.sub",
    cst_Float_Array_fill = "Float.Array.fill",
    cst_Float_array_blit = cst_Float_array_blit$1,
    cst_Float_array_blit$0 = cst_Float_array_blit$1,
    cst_Float_Array_iter2_arrays_m =
      "Float.Array.iter2: arrays must have the same length",
    cst_Float_Array_map2_arrays_mu =
      "Float.Array.map2: arrays must have the same length";
   function is_integer(x){
    var a = x === runtime.caml_trunc_float(x) ? 1 : 0;
    return a ? is_finite(x) : a;
   }
   function succ(x){return caml_nextafter_float(x, infinity);}
   function pred(x){return caml_nextafter_float(x, neg_infinity);}
   function equal(x, y){return 0 === caml_float_compare(x, y) ? 1 : 0;}
   function min(x, y){
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return x !== x ? x : y;
    }
    return y !== y ? y : x;
   }
   function max(x, y){
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return y !== y ? y : x;
    }
    return x !== x ? x : y;
   }
   function min_max(x, y){
    if(x === x && y === y){
     a:
     if(! (x < y)){
      if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
      return [0, y, x];
     }
     return [0, x, y];
    }
    return [0, nan, nan];
   }
   function min_num(x, y){
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return y !== y ? x : y;
    }
    return x !== x ? y : x;
   }
   function max_num(x, y){
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return x !== x ? y : x;
    }
    return y !== y ? x : y;
   }
   function min_max_num(x, y){
    if(x !== x) return [0, y, y];
    if(y !== y) return [0, x, x];
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return [0, y, x];
    }
    return [0, x, y];
   }
   function hash(x){return runtime.caml_hash(10, 100, 0, x);}
   function unsafe_fill(a, ofs, len, v){
    var b = (ofs + len | 0) - 1 | 0;
    if(b >= ofs){
     var i = ofs;
     for(;;){a[i + 1] = v; var c = i + 1 | 0; if(b === i) break; i = c;}
    }
    return 0;
   }
   function check(a, ofs, len, msg){
    var c = ofs < 0 ? 1 : 0;
    if(c)
     var b = c;
    else{
     var d = len < 0 ? 1 : 0;
     if(d)
      var b = d;
     else
      var
       e = (ofs + len | 0) < 0 ? 1 : 0,
       b = e || (a.length - 1 < (ofs + len | 0) ? 1 : 0);
    }
    return b ? Stdlib[1].call(null, msg) : b;
   }
   function make(n, v){
    var result = caml_floatarray_create(n);
    unsafe_fill(result, 0, n, v);
    return result;
   }
   function init(l, f){
    if(0 > l) return Stdlib[1].call(null, cst_Float_Array_init);
    var res = caml_floatarray_create(l), a = l - 1 | 0, b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      res[i + 1] = caml_call1(f, i);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return res;
   }
   function append(a1, a2){
    var
     l1 = a1.length - 1,
     l2 = a2.length - 1,
     result = caml_floatarray_create(l1 + l2 | 0);
    caml_floatarray_blit(a1, 0, result, 0, l1);
    caml_floatarray_blit(a2, 0, result, l1, l2);
    return result;
   }
   function concat(l){
    var acc = 0, param = l;
    for(;;){
     if(! param) break;
     var tl = param[2], hd = param[1], x = hd.length - 1 + acc | 0;
     if(acc <= x){
      acc = x;
      param = tl;
     }
     else{acc = Stdlib[1].call(null, cst_Float_Array_concat); param = tl;}
    }
    var result = caml_floatarray_create(acc), l$0 = l, i = 0;
    for(;;){
     if(! l$0){
      if(i === acc) return result;
      throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
     }
     var tl$0 = l$0[2], hd$0 = l$0[1], hlen = hd$0.length - 1;
     caml_floatarray_blit(hd$0, 0, result, i, hlen);
     var i$0 = i + hlen | 0;
     l$0 = tl$0;
     i = i$0;
    }
   }
   function sub(a, ofs, len){
    check(a, ofs, len, cst_Float_Array_sub);
    var result = caml_floatarray_create(len);
    caml_floatarray_blit(a, ofs, result, 0, len);
    return result;
   }
   function copy(a){
    var l = a.length - 1, result = caml_floatarray_create(l);
    caml_floatarray_blit(a, 0, result, 0, l);
    return result;
   }
   function fill(a, ofs, len, v){
    check(a, ofs, len, cst_Float_Array_fill);
    return unsafe_fill(a, ofs, len, v);
   }
   function blit(src, sofs, dst, dofs, len){
    check(src, sofs, len, cst_Float_array_blit);
    check(dst, dofs, len, cst_Float_array_blit$0);
    return caml_floatarray_blit(src, sofs, dst, dofs, len);
   }
   function to_list(a){
    return Stdlib_List[10].call
            (null, a.length - 1, function(b){return a[b + 1];});
   }
   function of_list(l){
    var
     result = caml_floatarray_create(Stdlib_List[1].call(null, l)),
     i = 0,
     l$0 = l;
    for(;;){
     if(! l$0) return result;
     var t = l$0[2], h = l$0[1];
     result[i + 1] = h;
     var i$0 = i + 1 | 0;
     i = i$0;
     l$0 = t;
    }
   }
   function iter(f, a){
    var b = a.length - 2 | 0, c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      caml_call1(f, a[i + 1]);
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return 0;
   }
   function iter2(f, a, b){
    if(a.length - 1 !== b.length - 1)
     return Stdlib[1].call(null, cst_Float_Array_iter2_arrays_m);
    var c = a.length - 2 | 0, d = 0;
    if(c >= 0){
     var i = d;
     for(;;){
      caml_call2(f, a[i + 1], b[i + 1]);
      var e = i + 1 | 0;
      if(c === i) break;
      i = e;
     }
    }
    return 0;
   }
   function map(f, a){
    var l = a.length - 1, r = caml_floatarray_create(l), b = l - 1 | 0, c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      r[i + 1] = caml_call1(f, a[i + 1]);
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return r;
   }
   function map2(f, a, b){
    var la = a.length - 1, lb = b.length - 1;
    if(la !== lb) return Stdlib[1].call(null, cst_Float_Array_map2_arrays_mu);
    var r = caml_floatarray_create(la), c = la - 1 | 0, d = 0;
    if(c >= 0){
     var i = d;
     for(;;){
      r[i + 1] = caml_call2(f, a[i + 1], b[i + 1]);
      var e = i + 1 | 0;
      if(c === i) break;
      i = e;
     }
    }
    return r;
   }
   function iteri(f, a){
    var b = a.length - 2 | 0, c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      caml_call2(f, i, a[i + 1]);
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return 0;
   }
   function mapi(f, a){
    var l = a.length - 1, r = caml_floatarray_create(l), b = l - 1 | 0, c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      r[i + 1] = caml_call2(f, i, a[i + 1]);
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return r;
   }
   function fold_left(f, x, a){
    var r = [0, x], b = a.length - 2 | 0, c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      r[1] = caml_call2(f, r[1], a[i + 1]);
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return r[1];
   }
   function fold_right(f, a, x){
    var r = [0, x], b = a.length - 2 | 0;
    if(b >= 0){
     var i = b;
     for(;;){
      r[1] = caml_call2(f, a[i + 1], r[1]);
      var c = i - 1 | 0;
      if(0 === i) break;
      i = c;
     }
    }
    return r[1];
   }
   function exists(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[i + 1])) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, a[i + 1])) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function mem(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(0 === caml_float_compare(a[i + 1], x)) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function mem_ieee(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(x === a[i + 1]) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   var
    Bottom = [248, "Stdlib.Float.Array.Bottom", runtime.caml_fresh_oo_id(0)],
    b = [0, cst_float_ml, 395, 6];
   function sort(cmp, a){
    function maxson(l, i){
     var i31 = ((i + i | 0) + i | 0) + 1 | 0, x = [0, i31];
     if((i31 + 2 | 0) < l){
      var b = i31 + 1 | 0, f = caml_check_bound(a, b)[b + 1];
      if(caml_call2(cmp, caml_check_bound(a, i31)[i31 + 1], f) < 0)
       x[1] = i31 + 1 | 0;
      var c = i31 + 2 | 0, g = caml_check_bound(a, c)[c + 1], d = x[1];
      if(caml_call2(cmp, caml_check_bound(a, d)[d + 1], g) < 0)
       x[1] = i31 + 2 | 0;
      return x[1];
     }
     if((i31 + 1 | 0) < l){
      var e = i31 + 1 | 0, h = caml_check_bound(a, e)[e + 1];
      if(0 > caml_call2(cmp, caml_check_bound(a, i31)[i31 + 1], h))
       return i31 + 1 | 0;
     }
     if(i31 < l) return i31;
     throw caml_maybe_attach_backtrace([0, Bottom, i], 1);
    }
    var l = a.length - 1, c = ((l + 1 | 0) / 3 | 0) - 1 | 0;
    if(c >= 0){
     var i$6 = c;
     for(;;){
      var e$1 = caml_check_bound(a, i$6)[i$6 + 1];
      try{
       var i = i$6;
       for(;;){
        var j = maxson(l, i);
        if(0 >= caml_call2(cmp, caml_check_bound(a, j)[j + 1], e$1)){caml_check_bound(a, i)[i + 1] = e$1; break;}
        var h = caml_check_bound(a, j)[j + 1];
        caml_check_bound(a, i)[i + 1] = h;
        i = j;
       }
      }
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0), tag = exn[1];
       if(tag !== Bottom) throw caml_maybe_attach_backtrace(exn, 0);
       var i$0 = exn[2];
       caml_check_bound(a, i$0)[i$0 + 1] = e$1;
      }
      var o = i$6 - 1 | 0;
      if(0 === i$6) break;
      i$6 = o;
     }
    }
    var d = l - 1 | 0;
    if(d >= 2){
     var i$4 = d;
     a:
     for(;;){
      var e$0 = caml_check_bound(a, i$4)[i$4 + 1];
      a[i$4 + 1] = caml_check_bound(a, 0)[1];
      var i$5 = 0;
      try{
       var i$1 = i$5;
       for(;;){
        var j$0 = maxson(i$4, i$1), k = caml_check_bound(a, j$0)[j$0 + 1];
        caml_check_bound(a, i$1)[i$1 + 1] = k;
        i$1 = j$0;
       }
      }
      catch(exn){
       var exn$0 = caml_wrap_exception(exn), tag$0 = exn$0[1];
       if(tag$0 !== Bottom) throw caml_maybe_attach_backtrace(exn$0, 0);
       var i$2 = exn$0[2], i$3 = i$2;
       for(;;){
        var father = (i$3 - 1 | 0) / 3 | 0;
        if(i$3 === father)
         throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
        if(0 <= caml_call2(cmp, caml_check_bound(a, father)[father + 1], e$0))
         caml_check_bound(a, i$3)[i$3 + 1] = e$0;
        else{
         var m = caml_check_bound(a, father)[father + 1];
         caml_check_bound(a, i$3)[i$3 + 1] = m;
         if(0 < father){i$3 = father; continue;}
         caml_check_bound(a, 0)[1] = e$0;
        }
        var n = i$4 - 1 | 0;
        if(2 === i$4) break a;
        i$4 = n;
        break;
       }
      }
     }
    }
    var f = 1 < l ? 1 : 0;
    if(f){
     var e = caml_check_bound(a, 1)[2];
     a[2] = caml_check_bound(a, 0)[1];
     a[1] = e;
     var g = 0;
    }
    else
     var g = f;
    return g;
   }
   function stable_sort(cmp, a){
    function merge(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs){
     var
      src1r = src1ofs + src1len | 0,
      src2r = src2ofs + src2len | 0,
      s2$1 = caml_check_bound(src2, src2ofs)[src2ofs + 1],
      s1$1 = caml_check_bound(a, src1ofs)[src1ofs + 1],
      i1 = src1ofs,
      s1 = s1$1,
      i2 = src2ofs,
      s2 = s2$1,
      d = dstofs;
     for(;;)
      if(0 < caml_call2(cmp, s1, s2)){
       caml_check_bound(dst, d)[d + 1] = s2;
       var i2$0 = i2 + 1 | 0;
       if(i2$0 >= src2r) return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
       var d$0 = d + 1 | 0, s2$0 = caml_check_bound(src2, i2$0)[i2$0 + 1];
       i2 = i2$0;
       s2 = s2$0;
       d = d$0;
      }
      else{
       caml_check_bound(dst, d)[d + 1] = s1;
       var i1$0 = i1 + 1 | 0;
       if(i1$0 >= src1r)
        return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
       var d$1 = d + 1 | 0, s1$0 = caml_check_bound(a, i1$0)[i1$0 + 1];
       i1 = i1$0;
       s1 = s1$0;
       d = d$1;
      }
    }
    function isortto(srcofs, dst, dstofs, len){
     var b = len - 1 | 0, k = 0;
     if(b >= 0){
      var i = k;
      a:
      for(;;){
       var
        c = srcofs + i | 0,
        e = caml_check_bound(a, c)[c + 1],
        j = [0, (dstofs + i | 0) - 1 | 0];
       for(;;){
        if(dstofs <= j[1]){
         var d = j[1];
         if(0 < caml_call2(cmp, caml_check_bound(dst, d)[d + 1], e)){
          var f = j[1], l = caml_check_bound(dst, f)[f + 1], g = j[1] + 1 | 0;
          caml_check_bound(dst, g)[g + 1] = l;
          j[1]--;
          continue;
         }
        }
        var h = j[1] + 1 | 0;
        caml_check_bound(dst, h)[h + 1] = e;
        var m = i + 1 | 0;
        if(b === i) break a;
        i = m;
        break;
       }
      }
     }
     return 0;
    }
    function sortto(srcofs, dst, dstofs, len){
     if(len <= 5) return isortto(srcofs, dst, dstofs, len);
     var l1 = len / 2 | 0, l2 = len - l1 | 0;
     sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
     sortto(srcofs, a, srcofs + l2 | 0, l1);
     return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
    }
    var l = a.length - 1;
    if(l <= 5) return isortto(0, a, 0, l);
    var l1 = l / 2 | 0, l2 = l - l1 | 0, t = caml_floatarray_create(l2);
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0);
   }
   function to_seq(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[i + 1], b = i + 1 | 0;
     return [0, x, function(a){return aux(b, a);}];
    }
    var b = 0;
    return function(a){return aux(b, a);};
   }
   function to_seqi(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[i + 1], b = i + 1 | 0;
     return [0, [0, i, x], function(a){return aux(b, a);}];
    }
    var b = 0;
    return function(a){return aux(b, a);};
   }
   function of_seq(i$2){
    var
     l =
       Stdlib_Seq[5].call(null, function(acc, x){return [0, x, acc];}, 0, i$2),
     len = Stdlib_List[1].call(null, l),
     a = caml_floatarray_create(len),
     i$1 = len - 1 | 0,
     i = i$1,
     param = l;
    for(;;){
     if(! param) return a;
     var tl = param[2], hd = param[1];
     a[i + 1] = hd;
     var i$0 = i - 1 | 0;
     i = i$0;
     param = tl;
    }
   }
   function map_to_array(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = runtime.caml_make_vect(l, caml_call1(f, a[1])),
     b = l - 1 | 0,
     c = 1;
    if(b >= 1){
     var i = c;
     for(;;){
      r[i + 1] = caml_call1(f, a[i + 1]);
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return r;
   }
   function map_from_array(f, a){
    var l = a.length - 1, r = caml_floatarray_create(l), b = l - 1 | 0, c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      r[i + 1] = caml_call1(f, a[i + 1]);
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return r;
   }
   var
    Stdlib_Float =
      [0,
       0.,
       1.,
       -1.,
       succ,
       pred,
       infinity,
       neg_infinity,
       nan,
       3.141592653589793,
       max_float,
       min_float,
       epsilon,
       is_finite,
       is_infinite,
       is_nan,
       is_integer,
       of_string_opt,
       to_string,
       caml_float_compare,
       equal,
       min,
       max,
       min_max,
       min_num,
       max_num,
       min_max_num,
       hash,
       [0,
        function(a){return a.length - 1;},
        function(b, a){return caml_check_bound(b, a)[a + 1];},
        function(c, a, b){caml_check_bound(c, a)[a + 1] = b; return 0;},
        make,
        caml_floatarray_create,
        init,
        append,
        concat,
        sub,
        copy,
        fill,
        blit,
        to_list,
        of_list,
        iter,
        iteri,
        map,
        mapi,
        fold_left,
        fold_right,
        iter2,
        map2,
        for_all,
        exists,
        mem,
        mem_ieee,
        sort,
        stable_sort,
        stable_sort,
        to_seq,
        to_seqi,
        of_seq,
        map_to_array,
        map_from_array],
       [0,
        function(a){return a.length - 1;},
        function(b, a){return caml_check_bound(b, a)[a + 1];},
        function(c, a, b){caml_check_bound(c, a)[a + 1] = b; return 0;},
        make,
        caml_floatarray_create,
        init,
        append,
        concat,
        sub,
        copy,
        fill,
        blit,
        to_list,
        of_list,
        iter,
        iteri,
        map,
        mapi,
        fold_left,
        fold_right,
        iter2,
        map2,
        for_all,
        exists,
        mem,
        mem_ieee,
        sort,
        stable_sort,
        stable_sort,
        to_seq,
        to_seqi,
        of_seq,
        map_to_array,
        map_from_array]];
   runtime.caml_register_global(22, Stdlib_Float, "Stdlib__Float");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Int32
//# unitInfo: Requires: Assert_failure, Stdlib, Stdlib__Sys
//# shape: Stdlib__Int32:[N,N,N,F(2),F(2),F(1)*,F(1)*,F(1)*,N,N,F(1)*,F(1)*,F(1),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Assert_failure = global_data.Assert_failure,
    zero = 0,
    one = 1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   function lognot(n){return n ^ -1;}
   var
    match = Stdlib_Sys[9],
    a = [0, "int32.ml", 69, 6],
    minus_one = -1,
    min_int = -2147483648,
    max_int = 2147483647;
   if(32 === match)
    var
     max_int$0 = Stdlib[19],
     unsigned_to_int =
       function(n){
        if(0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, max_int$0))
         return [0, n];
        return 0;
       };
   else{
    if(64 !== match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
    var unsigned_to_int = function(n){return [0, n & -1];};
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var a = [0, runtime.caml_int_of_string(s)]; return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = m + 2147483648 | 0, x = n + 2147483648 | 0;
    return caml_int_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, 0))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   var
    Stdlib_Int32 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(14, Stdlib_Int32, "Stdlib__Int32");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Int64
//# unitInfo: Requires: Stdlib
//# shape: Stdlib__Int64:[N,N,N,F(2),F(2),F(1)*,F(1)*,F(1)*,N,N,F(1)*,F(1)*,F(1),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_create_lo_mi_hi = runtime.caml_int64_create_lo_mi_hi,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    a = caml_int64_create_lo_mi_hi(1, 0, 0),
    zero = caml_int64_create_lo_mi_hi(0, 0, 0),
    one = caml_int64_create_lo_mi_hi(1, 0, 0),
    minus_one = caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    min_int = caml_int64_create_lo_mi_hi(0, 0, 32768),
    max_int = caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Stdlib = global_data.Stdlib,
    b = caml_int64_create_lo_mi_hi(1, 0, 0),
    c = caml_int64_create_lo_mi_hi(0, 0, 0),
    d = caml_int64_create_lo_mi_hi(16777215, 16777215, 65535);
   function succ(n){return caml_int64_add(n, a);}
   function pred(n){return caml_int64_sub(n, b);}
   function abs(n){
    return caml_greaterequal(n, c) ? n : runtime.caml_int64_neg(n);
   }
   function lognot(n){return runtime.caml_int64_xor(n, d);}
   var max_int$0 = runtime.caml_int64_of_int32(Stdlib[19]);
   function unsigned_to_int(n){
    if
     (0 >= caml_int64_compare(zero, n)
      && 0 >= caml_int64_compare(n, max_int$0))
     return [0, runtime.caml_int64_to_int32(n)];
    return 0;
   }
   function to_string(n){return runtime.caml_int64_format("%d", n);}
   function of_string_opt(s){
    try{var a = [0, runtime.caml_int64_of_string(s)]; return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function compare(x, y){return caml_int64_compare(x, y);}
   function equal(x, y){return 0 === caml_int64_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = caml_int64_sub(m, min_int), x = caml_int64_sub(n, min_int);
    return caml_int64_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, zero))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var
     q =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_div
          (runtime.caml_int64_shift_right_unsigned(n, 1), d),
         1),
     r = caml_int64_sub(n, caml_int64_mul(q, d));
    return 0 <= unsigned_compare(r, d) ? caml_int64_add(q, a) : q;
   }
   function unsigned_rem(n, d){
    return caml_int64_sub(n, caml_int64_mul(unsigned_div(n, d), d));
   }
   var
    Stdlib_Int64 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(11, Stdlib_Int64, "Stdlib__Int64");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Nativeint
//# unitInfo: Requires: Stdlib, Stdlib__Sys
//# shape: Stdlib__Nativeint:[N,N,N,F(2),F(2),F(1)*,F(1)*,F(1)*,N,N,N,F(1)*,F(1)*,F(1),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    zero = 0,
    one = 1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   var
    size = Stdlib_Sys[9],
    min_int = 1 << (size - 1 | 0),
    max_int = min_int - 1 | 0;
   function lognot(n){return n ^ -1;}
   var max_int$0 = Stdlib[19];
   function unsigned_to_int(n){
    if(0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, max_int$0))
     return [0, n];
    return 0;
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var a = [0, runtime.caml_int_of_string(s)]; return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = m - min_int | 0, x = n - min_int | 0;
    return caml_int_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, 0))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   var
    Stdlib_Nativeint =
      [0,
       zero,
       one,
       -1,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       size,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(12, Stdlib_Nativeint, "Stdlib__Nativeint");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Lexing
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Int, Stdlib__Sys
//# shape: Stdlib__Lexing:[N,F(2)*,F(2),F(2)*,F(2),F(2),F(1)*,F(1),F(2),F(1)*,F(1)*,F(1)*,F(1)*,F(1),F(1),F(3),F(3),F(2),F(2),F(3),F(3)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    caml_bytes_get = runtime.caml_bytes_get,
    caml_check_bound = runtime.caml_check_bound,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    dummy_pos = [0, cst, 0, 0, -1],
    zero_pos = [0, cst, 1, 0, 0],
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    cst_Lexing_lex_refill_cannot_g = "Lexing.lex_refill: cannot grow buffer";
   function engine(tbl, state, buf){
    var
     result = runtime.caml_lex_engine(tbl, state, buf),
     b = 0 <= result ? 1 : 0,
     c = b ? buf[12] !== dummy_pos ? 1 : 0 : b;
    if(c){
     buf[11] = buf[12];
     var a = buf[12];
     buf[12] = [0, a[1], a[2], a[3], buf[4] + buf[6] | 0];
    }
    return result;
   }
   function new_engine(tbl, state, buf){
    var
     result = runtime.caml_new_lex_engine(tbl, state, buf),
     b = 0 <= result ? 1 : 0,
     c = b ? buf[12] !== dummy_pos ? 1 : 0 : b;
    if(c){
     buf[11] = buf[12];
     var a = buf[12];
     buf[12] = [0, a[1], a[2], a[3], buf[4] + buf[6] | 0];
    }
    return result;
   }
   function from_function(opt, read_fun){
    if(opt)
     var sth = opt[1], with_positions = sth;
    else
     var with_positions = 1;
    var
     a = with_positions ? zero_pos : dummy_pos,
     b = with_positions ? zero_pos : dummy_pos,
     aux_buffer = caml_create_bytes(512);
    return [0,
            function(lexbuf){
             var
              read =
                caml_call2
                 (read_fun, aux_buffer, caml_ml_bytes_length(aux_buffer)),
              n = 0 < read ? read : (lexbuf[9] = 1, 0);
             if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0)){
              if
               (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                <= caml_ml_bytes_length(lexbuf[2]))
               Stdlib_Bytes[11].call
                (null,
                 lexbuf[2],
                 lexbuf[5],
                 lexbuf[2],
                 0,
                 lexbuf[3] - lexbuf[5] | 0);
              else{
               var
                newlen =
                  Stdlib_Int[10].call
                   (null,
                    2 * caml_ml_bytes_length(lexbuf[2]) | 0,
                    Stdlib_Sys[12]);
               if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                Stdlib[2].call(null, cst_Lexing_lex_refill_cannot_g);
               var newbuf = caml_create_bytes(newlen);
               Stdlib_Bytes[11].call
                (null,
                 lexbuf[2],
                 lexbuf[5],
                 newbuf,
                 0,
                 lexbuf[3] - lexbuf[5] | 0);
               lexbuf[2] = newbuf;
              }
              var s = lexbuf[5];
              lexbuf[4] = lexbuf[4] + s | 0;
              lexbuf[6] = lexbuf[6] - s | 0;
              lexbuf[5] = 0;
              lexbuf[7] = lexbuf[7] - s | 0;
              lexbuf[3] = lexbuf[3] - s | 0;
              var t = lexbuf[10], a = t.length - 2 | 0, b = 0;
              if(a >= 0){
               var i = b;
               for(;;){
                var v = caml_check_bound(t, i)[i + 1];
                if(0 <= v) caml_check_bound(t, i)[i + 1] = v - s | 0;
                var c = i + 1 | 0;
                if(a === i) break;
                i = c;
               }
              }
             }
             Stdlib_Bytes[11].call
              (null, aux_buffer, 0, lexbuf[2], lexbuf[3], n);
             lexbuf[3] = lexbuf[3] + n | 0;
             return 0;
            },
            caml_create_bytes(1024),
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            [0],
            b,
            a];
   }
   function from_channel(with_positions, ic){
    return from_function
            (with_positions,
             function(buf, n){return Stdlib[84].call(null, ic, buf, 0, n);});
   }
   function from_string(opt, s){
    if(opt)
     var sth = opt[1], with_positions = sth;
    else
     var with_positions = 1;
    var
     a = with_positions ? zero_pos : dummy_pos,
     b = with_positions ? zero_pos : dummy_pos;
    return [0,
            function(lexbuf){lexbuf[9] = 1; return 0;},
            Stdlib_Bytes[5].call(null, s),
            runtime.caml_ml_string_length(s),
            0,
            0,
            0,
            0,
            0,
            1,
            [0],
            b,
            a];
   }
   function set_position(lexbuf, position){
    lexbuf[12] = [0, lexbuf[12][1], position[2], position[3], position[4]];
    lexbuf[4] = position[4];
    return 0;
   }
   function set_filename(lexbuf, fname){
    var a = lexbuf[12];
    lexbuf[12] = [0, fname, a[2], a[3], a[4]];
    return 0;
   }
   function with_positions(lexbuf){return lexbuf[12] !== dummy_pos ? 1 : 0;}
   function lexeme(lexbuf){
    var len = lexbuf[6] - lexbuf[5] | 0;
    return Stdlib_Bytes[8].call(null, lexbuf[2], lexbuf[5], len);
   }
   function sub_lexeme(lexbuf, i1, i2){
    var len = i2 - i1 | 0;
    return Stdlib_Bytes[8].call(null, lexbuf[2], i1, len);
   }
   function sub_lexeme_opt(lexbuf, i1, i2){
    if(0 > i1) return 0;
    var len = i2 - i1 | 0;
    return [0, Stdlib_Bytes[8].call(null, lexbuf[2], i1, len)];
   }
   function sub_lexeme_char(lexbuf, i){return caml_bytes_get(lexbuf[2], i);}
   function sub_lexeme_char_opt(lexbuf, i){
    return 0 <= i ? [0, caml_bytes_get(lexbuf[2], i)] : 0;
   }
   function lexeme_char(lexbuf, i){
    return caml_bytes_get(lexbuf[2], lexbuf[5] + i | 0);
   }
   function lexeme_start(lexbuf){return lexbuf[11][4];}
   function lexeme_end(lexbuf){return lexbuf[12][4];}
   function lexeme_start_p(lexbuf){return lexbuf[11];}
   function lexeme_end_p(lexbuf){return lexbuf[12];}
   function new_line(lexbuf){
    var
     lcp = lexbuf[12],
     a = lcp !== dummy_pos ? 1 : 0,
     b = a ? (lexbuf[12] = [0, lcp[1], lcp[2] + 1 | 0, lcp[4], lcp[4]], 0) : a;
    return b;
   }
   function flush_input(lb){
    lb[6] = 0;
    lb[4] = 0;
    var lcp = lb[12];
    if(lcp !== dummy_pos)
     lb[12] = [0, lcp[1], zero_pos[2], zero_pos[3], zero_pos[4]];
    lb[3] = 0;
    return 0;
   }
   var
    Stdlib_Lexing =
      [0,
       dummy_pos,
       from_channel,
       from_string,
       from_function,
       set_position,
       set_filename,
       with_positions,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
   runtime.caml_register_global(7, Stdlib_Lexing, "Stdlib__Lexing");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Parsing
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Lexing, Stdlib__Obj
//# shape: Stdlib__Parsing:[F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),N,F(1),N,F(4),F(2),F(1),F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    YYexit = [248, "Stdlib.Parsing.YYexit", caml_fresh_oo_id(0)],
    Parse_error = [248, "Stdlib.Parsing.Parse_error", caml_fresh_oo_id(0)],
    env =
      [0,
       caml_make_vect(100, 0),
       caml_make_vect(100, 0),
       caml_make_vect(100, Stdlib_Lexing[1]),
       caml_make_vect(100, Stdlib_Lexing[1]),
       100,
       0,
       0,
       0,
       Stdlib_Lexing[1],
       Stdlib_Lexing[1],
       0,
       0,
       0,
       0,
       0,
       0],
    dummy = 0;
   function grow_stacks(param){
    var
     oldsize = env[5],
     newsize = oldsize * 2 | 0,
     new_s = caml_make_vect(newsize, 0),
     new_v = caml_make_vect(newsize, 0),
     new_start = caml_make_vect(newsize, Stdlib_Lexing[1]),
     new_end = caml_make_vect(newsize, Stdlib_Lexing[1]);
    Stdlib_Array[10].call(null, env[1], 0, new_s, 0, oldsize);
    env[1] = new_s;
    Stdlib_Array[10].call(null, env[2], 0, new_v, 0, oldsize);
    env[2] = new_v;
    Stdlib_Array[10].call(null, env[3], 0, new_start, 0, oldsize);
    env[3] = new_start;
    Stdlib_Array[10].call(null, env[4], 0, new_end, 0, oldsize);
    env[4] = new_end;
    env[5] = newsize;
   }
   function clear_parser(param){
    Stdlib_Array[9].call(null, env[2], 0, env[5], 0);
    env[8] = 0;
    return 0;
   }
   var
    current_lookahead_fun = [0, function(param){return 0;}],
    cst_syntax_error = "syntax error";
   function yyparse(tables, start, lexer, lexbuf){
    var
     init_asp = env[11],
     init_sp = env[14],
     init_stackbase = env[6],
     init_state = env[15],
     init_curr_char = env[7],
     init_lval = env[8],
     init_errflag = env[16];
    env[6] = env[14] + 1 | 0;
    env[7] = start;
    env[10] = lexbuf[12];
    try{
     var cmd = 0, arg = 0;
     for(;;)
      switch(runtime.caml_parse_engine(tables, env, cmd, arg)){
        case 0:
         var arg$0 = caml_call1(lexer, lexbuf);
         env[9] = lexbuf[11];
         env[10] = lexbuf[12];
         cmd = 1;
         arg = arg$0;
         break;
        case 1:
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        case 2:
         grow_stacks(0); cmd = 2; arg = 0; break;
        case 3:
         grow_stacks(0); cmd = 3; arg = 0; break;
        case 4:
         try{
          var
           a = env[13],
           b = caml_call1(caml_check_bound(tables[1], a)[a + 1], env),
           c = 4;
          cmd = c;
          arg = b;
         }
         catch(exn$0){
          var exn = caml_wrap_exception(exn$0);
          if(exn !== Parse_error) throw caml_maybe_attach_backtrace(exn, 0);
          cmd = 5;
          arg = 0;
         }
         break;
        default: caml_call1(tables[14], cst_syntax_error); cmd = 5; arg = 0;
      }
    }
    catch(exn){
     var exn$0 = caml_wrap_exception(exn), curr_char = env[7];
     env[11] = init_asp;
     env[14] = init_sp;
     env[6] = init_stackbase;
     env[15] = init_state;
     env[7] = init_curr_char;
     env[8] = init_lval;
     env[16] = init_errflag;
     var tag = exn$0[1];
     if(tag === YYexit){var v = exn$0[2]; return v;}
     current_lookahead_fun[1] =
      function(tok){
       if(! Stdlib_Obj[1].call(null, tok))
        return caml_check_bound(tables[2], tok)[tok + 1] === curr_char ? 1 : 0;
       var a = runtime.caml_obj_tag(tok);
       return caml_check_bound(tables[3], a)[a + 1] === curr_char ? 1 : 0;
      };
     throw caml_maybe_attach_backtrace(exn$0, 0);
    }
   }
   function peek_val(env, n){
    var a = env[11] - n | 0;
    return caml_check_bound(env[2], a)[a + 1];
   }
   function symbol_start_pos(param){
    var i$1 = env[12], i = i$1;
    for(;;){
     if(0 >= i){var c = env[11]; return caml_check_bound(env[4], c)[c + 1];}
     var
      a = (env[11] - i | 0) + 1 | 0,
      st = caml_check_bound(env[3], a)[a + 1],
      b = (env[11] - i | 0) + 1 | 0,
      en = caml_check_bound(env[4], b)[b + 1];
     if(runtime.caml_notequal(st, en)) return st;
     var i$0 = i - 1 | 0;
     i = i$0;
    }
   }
   function symbol_end_pos(param){
    var a = env[11];
    return caml_check_bound(env[4], a)[a + 1];
   }
   function rhs_start_pos(n){
    var a = env[11] - (env[12] - n | 0) | 0;
    return caml_check_bound(env[3], a)[a + 1];
   }
   function rhs_end_pos(n){
    var a = env[11] - (env[12] - n | 0) | 0;
    return caml_check_bound(env[4], a)[a + 1];
   }
   function symbol_start(param){return symbol_start_pos(0)[4];}
   function symbol_end(param){return symbol_end_pos(0)[4];}
   function rhs_start(n){return rhs_start_pos(n)[4];}
   function rhs_end(n){return rhs_end_pos(n)[4];}
   function is_current_lookahead(tok){
    return caml_call1(current_lookahead_fun[1], tok);
   }
   function parse_error(param){return 0;}
   var
    Stdlib_Parsing =
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       runtime.caml_set_parser_trace,
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
   runtime.caml_register_global(7, Stdlib_Parsing, "Stdlib__Parsing");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Set
//# unitInfo: Requires: Assert_failure, Stdlib, Stdlib__List, Stdlib__Seq
//# shape: Stdlib__Set:[F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Set_bal$3 = "Set.bal",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    cst_Set_bal = cst_Set_bal$3,
    cst_Set_bal$0 = cst_Set_bal$3,
    cst_Set_bal$1 = cst_Set_bal$3,
    cst_Set_bal$2 = cst_Set_bal$3,
    cst_Set_remove_min_elt = "Set.remove_min_elt",
    a = [0, 0, 0, 0],
    b = [0, 0, 0],
    c = [0, "set.ml", 570, 18],
    Stdlib_Set =
      [0,
       function(Ord){
        function height(param){
         if(! param) return 0;
         var h = param[4];
         return h;
        }
        function create(l, v, r){
         if(l) var h = l[4], hl = h; else var hl = 0;
         if(r) var h$0 = r[4], hr = h$0; else var hr = 0;
         var a = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
         return [0, l, v, r, a];
        }
        function bal(l, v, r){
         if(l) var h = l[4], hl = h; else var hl = 0;
         if(r) var h$0 = r[4], hr = h$0; else var hr = 0;
         if((hr + 2 | 0) < hl){
          if(! l) return Stdlib[1].call(null, cst_Set_bal$0);
          var lr = l[3], lv = l[2], ll = l[1], a = height(lr);
          if(a <= height(ll)) return create(ll, lv, create(lr, v, r));
          if(! lr) return Stdlib[1].call(null, cst_Set_bal);
          var lrr = lr[3], lrv = lr[2], lrl = lr[1], b = create(lrr, v, r);
          return create(create(ll, lv, lrl), lrv, b);
         }
         if((hl + 2 | 0) >= hr){
          var e = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
          return [0, l, v, r, e];
         }
         if(! r) return Stdlib[1].call(null, cst_Set_bal$2);
         var rr = r[3], rv = r[2], rl = r[1], c = height(rl);
         if(c <= height(rr)) return create(create(l, v, rl), rv, rr);
         if(! rl) return Stdlib[1].call(null, cst_Set_bal$1);
         var rlr = rl[3], rlv = rl[2], rll = rl[1], d = create(rlr, rv, rr);
         return create(create(l, v, rll), rlv, d);
        }
        function add(x, t){
         if(! t) return [0, 0, x, 0, 1];
         var r = t[3], v = t[2], l = t[1], c = caml_call2(Ord[1], x, v);
         if(0 === c) return t;
         if(0 <= c){var rr = add(x, r); return r === rr ? t : bal(l, v, rr);}
         var ll = add(x, l);
         return l === ll ? t : bal(ll, v, r);
        }
        function singleton(x){return [0, 0, x, 0, 1];}
        function add_min_element(x, param){
         if(! param) return singleton(x);
         var r = param[3], v = param[2], l = param[1];
         return bal(add_min_element(x, l), v, r);
        }
        function add_max_element(x, param){
         if(! param) return singleton(x);
         var r = param[3], v = param[2], l = param[1];
         return bal(l, v, add_max_element(x, r));
        }
        function join(l, v, r){
         if(! l) return add_min_element(v, r);
         if(! r) return add_max_element(v, l);
         var
          rh = r[4],
          rr = r[3],
          rv = r[2],
          rl = r[1],
          lh = l[4],
          lr = l[3],
          lv = l[2],
          ll = l[1];
         return (rh + 2 | 0) < lh
                 ? bal(ll, lv, join(lr, v, r))
                 : (lh
                   + 2
                   | 0)
                   < rh
                   ? bal(join(l, v, rl), rv, rr)
                   : create(l, v, r);
        }
        function min_elt(param$0){
         var param = param$0;
         for(;;){
          if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var l = param[1];
          if(! l){var v = param[2]; return v;}
          param = l;
         }
        }
        function min_elt_opt(param$0){
         var param = param$0;
         for(;;){
          if(! param) return 0;
          var l = param[1];
          if(! l){var v = param[2]; return [0, v];}
          param = l;
         }
        }
        function max_elt(param$0){
         var param = param$0;
         for(;;){
          if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          if(! param[3]){var v = param[2]; return v;}
          var r = param[3];
          param = r;
         }
        }
        function max_elt_opt(param$0){
         var param = param$0;
         for(;;){
          if(! param) return 0;
          if(! param[3]){var v = param[2]; return [0, v];}
          var r = param[3];
          param = r;
         }
        }
        function remove_min_elt(param){
         if(! param) return Stdlib[1].call(null, cst_Set_remove_min_elt);
         var l = param[1];
         if(l){
          var r = param[3], v = param[2];
          return bal(remove_min_elt(l), v, r);
         }
         var r$0 = param[3];
         return r$0;
        }
        function concat(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var a = remove_min_elt(t2);
         return join(t1, min_elt(t2), a);
        }
        function split(x, param){
         if(! param) return a;
         var
          r = param[3],
          v = param[2],
          l = param[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return [0, l, 1, r];
         if(0 <= c){
          var
           match = split(x, r),
           rr = match[3],
           pres = match[2],
           lr = match[1];
          return [0, join(l, v, lr), pres, rr];
         }
         var
          match$0 = split(x, l),
          rl = match$0[3],
          pres$0 = match$0[2],
          ll = match$0[1];
         return [0, ll, pres$0, join(rl, v, r)];
        }
        var empty = 0;
        function is_empty(param){return param ? 0 : 1;}
        function mem(x, param$0){
         var param = param$0;
         for(;;){
          if(! param) return 0;
          var
           r = param[3],
           v = param[2],
           l = param[1],
           c = caml_call2(Ord[1], x, v),
           a = 0 === c ? 1 : 0;
          if(a) return a;
          param = 0 <= c ? r : l;
         }
        }
        function remove(x, t){
         if(! t) return 0;
         var t2 = t[3], v = t[2], t1 = t[1], c = caml_call2(Ord[1], x, v);
         if(0 === c){
          if(! t1) return t2;
          if(! t2) return t1;
          var a = remove_min_elt(t2);
          return bal(t1, min_elt(t2), a);
         }
         if(0 <= c){
          var rr = remove(x, t2);
          return t2 === rr ? t : bal(t1, v, rr);
         }
         var ll = remove(x, t1);
         return t1 === ll ? t : bal(ll, v, t2);
        }
        function union(s1, s2){
         if(! s1) return s2;
         if(! s2) return s1;
         var
          h2 = s2[4],
          r2 = s2[3],
          v2 = s2[2],
          l2 = s2[1],
          h1 = s1[4],
          r1 = s1[3],
          v1 = s1[2],
          l1 = s1[1];
         if(h2 <= h1){
          if(1 === h2) return add(v2, s1);
          var
           match = split(v1, s2),
           r2$0 = match[3],
           l2$0 = match[1],
           a = union(r1, r2$0);
          return join(union(l1, l2$0), v1, a);
         }
         if(1 === h1) return add(v1, s2);
         var
          match$0 = split(v2, s1),
          r1$0 = match$0[3],
          l1$0 = match$0[1],
          b = union(r1$0, r2);
         return join(union(l1$0, l2), v2, b);
        }
        function inter(s1, s2){
         if(! s1) return 0;
         if(! s2) return 0;
         var r1 = s1[3], v1 = s1[2], l1 = s1[1], a = split(v1, s2), l2 = a[1];
         if(a[2]){
          var r2 = a[3], b = inter(r1, r2);
          return join(inter(l1, l2), v1, b);
         }
         var r2$0 = a[3], c = inter(r1, r2$0);
         return concat(inter(l1, l2), c);
        }
        function split_bis(x, param){
         if(! param) return [0, 0, function(param){return 0;}];
         var
          r = param[3],
          v = param[2],
          l = param[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return 0;
         if(0 <= c){
          var match = split_bis(x, r);
          if(! match) return 0;
          var rr = match[2], lr = match[1];
          return [0, join(l, v, lr), rr];
         }
         var match$0 = split_bis(x, l);
         if(! match$0) return 0;
         var rl = match$0[2], ll = match$0[1];
         return [0, ll, function(param){return join(rl(0), v, r);}];
        }
        function disjoint(s1$0, s2$1){
         var s1 = s1$0, s2 = s2$1;
         for(;;){
          if(s1 && s2){
           var r1 = s1[3], v1 = s1[2], l1 = s1[1];
           if(s1 === s2) return 0;
           var match = split_bis(v1, s2);
           if(! match) return 0;
           var r2 = match[2], l2 = match[1], a = disjoint(l1, l2);
           if(! a) return a;
           var s2$0 = r2(0);
           s1 = r1;
           s2 = s2$0;
           continue;
          }
          return 1;
         }
        }
        function diff(s1, s2){
         if(! s1) return 0;
         if(! s2) return s1;
         var r1 = s1[3], v1 = s1[2], l1 = s1[1], a = split(v1, s2), l2 = a[1];
         if(a[2]){
          var r2 = a[3], b = diff(r1, r2);
          return concat(diff(l1, l2), b);
         }
         var r2$0 = a[3], c = diff(r1, r2$0);
         return join(diff(l1, l2), v1, c);
        }
        function cons_enum(s$0, e$1){
         var s = s$0, e = e$1;
         for(;;){
          if(! s) return e;
          var r = s[3], v = s[2], l = s[1], e$0 = [0, v, r, e];
          s = l;
          e = e$0;
         }
        }
        function compare(s1, s2){
         var
          e2$2 = cons_enum(s2, 0),
          e1$2 = cons_enum(s1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? -1 : 0;
          if(! e2) return 1;
          var
           e2$0 = e2[3],
           r2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[3],
           r1 = e1[2],
           v1 = e1[1],
           c = caml_call2(Ord[1], v1, v2);
          if(0 !== c) return c;
          var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0);
          e1 = e1$1;
          e2 = e2$1;
         }
        }
        function equal(s1, s2){return 0 === compare(s1, s2) ? 1 : 0;}
        function subset(s1$0, s2$0){
         var s1 = s1$0, s2 = s2$0;
         for(;;){
          if(! s1) return 1;
          if(! s2) return 0;
          var
           r2 = s2[3],
           v2 = s2[2],
           l2 = s2[1],
           r1 = s1[3],
           v1 = s1[2],
           l1 = s1[1],
           c = caml_call2(Ord[1], v1, v2);
          if(0 === c){
           var a = subset(l1, l2);
           if(! a) return a;
           s1 = r1;
           s2 = r2;
          }
          else if(0 <= c){
           var b = subset([0, 0, v1, r1, 0], r2);
           if(! b) return b;
           s1 = l1;
          }
          else{
           var d = subset([0, l1, v1, 0, 0], l2);
           if(! d) return d;
           s1 = r1;
          }
         }
        }
        function iter(f, param$0){
         var param = param$0;
         for(;;){
          if(! param) return 0;
          var r = param[3], v = param[2], l = param[1];
          iter(f, l);
          caml_call1(f, v);
          param = r;
         }
        }
        function fold(f, s$0, accu$1){
         var s = s$0, accu = accu$1;
         for(;;){
          if(! s) return accu;
          var
           r = s[3],
           v = s[2],
           l = s[1],
           accu$0 = caml_call2(f, v, fold(f, l, accu));
          s = r;
          accu = accu$0;
         }
        }
        function for_all(p, param$0){
         var param = param$0;
         for(;;){
          if(! param) return 1;
          var r = param[3], v = param[2], l = param[1], a = caml_call1(p, v);
          if(a){
           var b = for_all(p, l);
           if(b){param = r; continue;}
           var c = b;
          }
          else
           var c = a;
          return c;
         }
        }
        function exists(p, param$0){
         var param = param$0;
         for(;;){
          if(! param) return 0;
          var r = param[3], v = param[2], l = param[1], a = caml_call1(p, v);
          if(a)
           var b = a;
          else{var c = exists(p, l); if(! c){param = r; continue;} var b = c;}
          return b;
         }
        }
        function filter(p, t){
         if(! t) return 0;
         var
          r = t[3],
          v = t[2],
          l = t[1],
          l$0 = filter(p, l),
          pv = caml_call1(p, v),
          r$0 = filter(p, r);
         if(! pv) return concat(l$0, r$0);
         if(l === l$0 && r === r$0) return t;
         return join(l$0, v, r$0);
        }
        function partition(p, param){
         if(! param) return b;
         var
          r = param[3],
          v = param[2],
          l = param[1],
          match = partition(p, l),
          lf = match[2],
          lt = match[1],
          pv = caml_call1(p, v),
          match$0 = partition(p, r),
          rf = match$0[2],
          rt = match$0[1];
         if(pv){var a = concat(lf, rf); return [0, join(lt, v, rt), a];}
         var c = join(lf, v, rf);
         return [0, concat(lt, rt), c];
        }
        function cardinal(param){
         if(! param) return 0;
         var r = param[3], l = param[1], a = cardinal(r);
         return (cardinal(l) + 1 | 0) + a | 0;
        }
        function elements_aux(accu$1, param$0){
         var accu = accu$1, param = param$0;
         for(;;){
          if(! param) return accu;
          var
           r = param[3],
           v = param[2],
           l = param[1],
           accu$0 = [0, v, elements_aux(accu, r)];
          accu = accu$0;
          param = l;
         }
        }
        function elements(s){return elements_aux(0, s);}
        function find(x, param$0){
         var param = param$0;
         for(;;){
          if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r = param[3],
           v = param[2],
           l = param[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return v;
          param = 0 <= c ? r : l;
         }
        }
        function find_first(f, param$1){
         var param$0 = param$1;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var r$0 = param$0[3], v0$1 = param$0[2], l$0 = param$0[1];
          if(caml_call1(f, v0$1)){var v0 = v0$1, param = l$0; break;}
          param$0 = r$0;
         }
         for(;;){
          if(! param) return v0;
          var r = param[3], v0$0 = param[2], l = param[1];
          if(caml_call1(f, v0$0)){v0 = v0$0; param = l;} else param = r;
         }
        }
        function find_first_opt(f, param$1){
         var param$0 = param$1;
         for(;;){
          if(! param$0) return 0;
          var r$0 = param$0[3], v0$1 = param$0[2], l$0 = param$0[1];
          if(caml_call1(f, v0$1)){var v0 = v0$1, param = l$0; break;}
          param$0 = r$0;
         }
         for(;;){
          if(! param) return [0, v0];
          var r = param[3], v0$0 = param[2], l = param[1];
          if(caml_call1(f, v0$0)){v0 = v0$0; param = l;} else param = r;
         }
        }
        function find_last(f, param$1){
         var param$0 = param$1;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var r$0 = param$0[3], v0$1 = param$0[2], l$0 = param$0[1];
          if(caml_call1(f, v0$1)){var v0 = v0$1, param = r$0; break;}
          param$0 = l$0;
         }
         for(;;){
          if(! param) return v0;
          var r = param[3], v0$0 = param[2], l = param[1];
          if(caml_call1(f, v0$0)){v0 = v0$0; param = r;} else param = l;
         }
        }
        function find_last_opt(f, param$1){
         var param$0 = param$1;
         for(;;){
          if(! param$0) return 0;
          var r$0 = param$0[3], v0$1 = param$0[2], l$0 = param$0[1];
          if(caml_call1(f, v0$1)){var v0 = v0$1, param = r$0; break;}
          param$0 = l$0;
         }
         for(;;){
          if(! param) return [0, v0];
          var r = param[3], v0$0 = param[2], l = param[1];
          if(caml_call1(f, v0$0)){v0 = v0$0; param = r;} else param = l;
         }
        }
        function find_opt(x, param$0){
         var param = param$0;
         for(;;){
          if(! param) return 0;
          var
           r = param[3],
           v = param[2],
           l = param[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return [0, v];
          param = 0 <= c ? r : l;
         }
        }
        function try_join(l, v, r){
         a:
         {
          if(0 !== l){
           var b = max_elt(l);
           if(0 <= caml_call2(Ord[1], b, v)) break a;
          }
          if(0 !== r){
           var a = min_elt(r);
           if(0 <= caml_call2(Ord[1], v, a)) break a;
          }
          return join(l, v, r);
         }
         return union(l, add(v, r));
        }
        function map(f, t){
         if(! t) return 0;
         var
          r = t[3],
          v = t[2],
          l = t[1],
          l$0 = map(f, l),
          v$0 = caml_call1(f, v),
          r$0 = map(f, r);
         if(l === l$0 && v === v$0 && r === r$0) return t;
         return try_join(l$0, v$0, r$0);
        }
        function filter_map(f, t){
         if(! t) return 0;
         var
          r = t[3],
          v = t[2],
          l = t[1],
          t1 = filter_map(f, l),
          v$0 = caml_call1(f, v),
          t2 = filter_map(f, r);
         if(v$0){
          var v$1 = v$0[1];
          if(l === t1 && v === v$1 && r === t2) return t;
          return try_join(t1, v$1, t2);
         }
         if(! t1) return t2;
         if(! t2) return t1;
         var a = remove_min_elt(t2);
         return try_join(t1, min_elt(t2), a);
        }
        function of_list(l){
         if(! l) return empty;
         var match = l[2], x0 = l[1];
         if(! match) return singleton(x0);
         var match$0 = match[2], x1 = match[1];
         if(! match$0) return add(x1, singleton(x0));
         var match$1 = match$0[2], x2 = match$0[1];
         if(! match$1) return add(x2, add(x1, singleton(x0)));
         var match$2 = match$1[2], x3 = match$1[1];
         if(! match$2) return add(x3, add(x2, add(x1, singleton(x0))));
         if(match$2[2]){
          var
           l$0 = Stdlib_List[59].call(null, Ord[1], l),
           sub =
             function(n, l){
              if(3 >= n >>> 0)
               switch(n){
                 case 0:
                  return [0, 0, l];
                 case 1:
                  if(l){
                   var l$3 = l[2], x0 = l[1];
                   return [0, [0, 0, x0, 0, 1], l$3];
                  }
                  break;
                 case 2:
                  if(l){
                   var match$1 = l[2];
                   if(match$1){
                    var l$4 = match$1[2], x1 = match$1[1], x0$0 = l[1];
                    return [0, [0, [0, 0, x0$0, 0, 1], x1, 0, 2], l$4];
                   }
                  }
                  break;
                 default:
                  if(l){
                   var a = l[2];
                   if(a){
                    var match$2 = a[2];
                    if(match$2){
                     var
                      l$5 = match$2[2],
                      x2 = match$2[1],
                      x1$0 = a[1],
                      x0$1 = l[1];
                     return [0,
                             [0, [0, 0, x0$1, 0, 1], x1$0, [0, 0, x2, 0, 1], 2],
                             l$5];
                    }
                   }
                  }
               }
              var
               nl = n / 2 | 0,
               match = sub(nl, l),
               l$0 = match[2],
               left = match[1];
              if(! l$0)
               throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
              var
               l$1 = l$0[2],
               mid = l$0[1],
               match$0 = sub((n - nl | 0) - 1 | 0, l$1),
               l$2 = match$0[2],
               right = match$0[1];
              return [0, create(left, mid, right), l$2];
             };
          return sub(Stdlib_List[1].call(null, l$0), l$0)[1];
         }
         var x4 = match$2[1];
         return add(x4, add(x3, add(x2, add(x1, singleton(x0)))));
        }
        function add_seq(i, m){
         return Stdlib_Seq[5].call
                 (null, function(s, x){return add(x, s);}, m, i);
        }
        function of_seq(i){return add_seq(i, empty);}
        function seq_of_enum(c, param){
         if(! c) return 0;
         var rest = c[3], t = c[2], x = c[1], a = cons_enum(t, rest);
         return [0, x, function(b){return seq_of_enum(a, b);}];
        }
        function to_seq(c){
         var a = cons_enum(c, 0);
         return function(b){return seq_of_enum(a, b);};
        }
        function snoc_enum(s$0, e$1){
         var s = s$0, e = e$1;
         for(;;){
          if(! s) return e;
          var r = s[3], v = s[2], l = s[1], e$0 = [0, v, l, e];
          s = r;
          e = e$0;
         }
        }
        function rev_seq_of_enum(c, param){
         if(! c) return 0;
         var rest = c[3], t = c[2], x = c[1], a = snoc_enum(t, rest);
         return [0, x, function(b){return rev_seq_of_enum(a, b);}];
        }
        function to_rev_seq(c){
         var a = snoc_enum(c, 0);
         return function(b){return rev_seq_of_enum(a, b);};
        }
        function to_seq_from(low, s){
         a:
         {
          var s$0 = s, c = 0;
          for(;;){
           if(! s$0){var a = c; break a;}
           var
            r = s$0[3],
            v = s$0[2],
            l = s$0[1],
            n = caml_call2(Ord[1], v, low);
           if(0 === n) break;
           if(0 <= n){var c$0 = [0, v, r, c]; s$0 = l; c = c$0;} else s$0 = r;
          }
          var a = [0, v, r, c];
         }
         return function(b){return seq_of_enum(a, b);};
        }
        return [0,
                empty,
                is_empty,
                mem,
                add,
                singleton,
                remove,
                union,
                inter,
                disjoint,
                diff,
                compare,
                equal,
                subset,
                iter,
                map,
                fold,
                for_all,
                exists,
                filter,
                filter_map,
                partition,
                cardinal,
                elements,
                min_elt,
                min_elt_opt,
                max_elt,
                max_elt_opt,
                min_elt,
                min_elt_opt,
                split,
                find,
                find_opt,
                find_first,
                find_first_opt,
                find_last,
                find_last_opt,
                of_list,
                to_seq_from,
                to_seq,
                to_rev_seq,
                add_seq,
                of_seq];
       }];
   runtime.caml_register_global(12, Stdlib_Set, "Stdlib__Set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Map
//# unitInfo: Requires: Assert_failure, Stdlib, Stdlib__Seq
//# shape: Stdlib__Map:[F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Seq = global_data.Stdlib__Seq,
    cst_Map_bal = cst_Map_bal$3,
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    cst_Map_bal$2 = cst_Map_bal$3,
    cst_Map_remove_min_elt = "Map.remove_min_elt",
    a = [0, 0, 0, 0],
    b = [0, "map.ml", 400, 10],
    c = [0, 0, 0],
    Stdlib_Map =
      [0,
       function(Ord){
        function height(param){
         if(! param) return 0;
         var h = param[5];
         return h;
        }
        function create(l, x, d, r){
         var
          hl = height(l),
          hr = height(r),
          a = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
         return [0, l, x, d, r, a];
        }
        function singleton(x, d){return [0, 0, x, d, 0, 1];}
        function bal(l, x, d, r){
         if(l) var h = l[5], hl = h; else var hl = 0;
         if(r) var h$0 = r[5], hr = h$0; else var hr = 0;
         if((hr + 2 | 0) < hl){
          if(! l) return Stdlib[1].call(null, cst_Map_bal$0);
          var lr = l[4], ld = l[3], lv = l[2], ll = l[1], a = height(lr);
          if(a <= height(ll)) return create(ll, lv, ld, create(lr, x, d, r));
          if(! lr) return Stdlib[1].call(null, cst_Map_bal);
          var
           lrr = lr[4],
           lrd = lr[3],
           lrv = lr[2],
           lrl = lr[1],
           b = create(lrr, x, d, r);
          return create(create(ll, lv, ld, lrl), lrv, lrd, b);
         }
         if((hl + 2 | 0) >= hr){
          var f = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
          return [0, l, x, d, r, f];
         }
         if(! r) return Stdlib[1].call(null, cst_Map_bal$2);
         var rr = r[4], rd = r[3], rv = r[2], rl = r[1], c = height(rl);
         if(c <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
         if(! rl) return Stdlib[1].call(null, cst_Map_bal$1);
         var
          rlr = rl[4],
          rld = rl[3],
          rlv = rl[2],
          rll = rl[1],
          e = create(rlr, rv, rd, rr);
         return create(create(l, x, d, rll), rlv, rld, e);
        }
        var empty = 0;
        function is_empty(param){return param ? 0 : 1;}
        function add(x, data, m){
         if(! m) return [0, 0, x, data, 0, 1];
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return d === data ? m : [0, l, x, data, r, h];
         if(0 <= c){
          var rr = add(x, data, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = add(x, data, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function find(x, param$0){
         var param = param$0;
         for(;;){
          if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r = param[4],
           d = param[3],
           v = param[2],
           l = param[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return d;
          param = 0 <= c ? r : l;
         }
        }
        function find_first(f, param$1){
         var param$0 = param$1;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$0[4],
           d0$1 = param$0[3],
           v0$1 = param$0[2],
           l$0 = param$0[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = l$0;
           break;
          }
          param$0 = r$0;
         }
         for(;;){
          if(! param) return [0, v0, d0];
          var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
          if(caml_call1(f, v0$0)){
           v0 = v0$0;
           d0 = d0$0;
           param = l;
          }
          else
           param = r;
         }
        }
        function find_first_opt(f, param$1){
         var param$0 = param$1;
         for(;;){
          if(! param$0) return 0;
          var
           r$0 = param$0[4],
           d0$1 = param$0[3],
           v0$1 = param$0[2],
           l$0 = param$0[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = l$0;
           break;
          }
          param$0 = r$0;
         }
         for(;;){
          if(! param) return [0, [0, v0, d0]];
          var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
          if(caml_call1(f, v0$0)){
           v0 = v0$0;
           d0 = d0$0;
           param = l;
          }
          else
           param = r;
         }
        }
        function find_last(f, param$1){
         var param$0 = param$1;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$0[4],
           d0$1 = param$0[3],
           v0$1 = param$0[2],
           l$0 = param$0[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = r$0;
           break;
          }
          param$0 = l$0;
         }
         for(;;){
          if(! param) return [0, v0, d0];
          var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
          if(caml_call1(f, v0$0)){
           v0 = v0$0;
           d0 = d0$0;
           param = r;
          }
          else
           param = l;
         }
        }
        function find_last_opt(f, param$1){
         var param$0 = param$1;
         for(;;){
          if(! param$0) return 0;
          var
           r$0 = param$0[4],
           d0$1 = param$0[3],
           v0$1 = param$0[2],
           l$0 = param$0[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = r$0;
           break;
          }
          param$0 = l$0;
         }
         for(;;){
          if(! param) return [0, [0, v0, d0]];
          var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
          if(caml_call1(f, v0$0)){
           v0 = v0$0;
           d0 = d0$0;
           param = r;
          }
          else
           param = l;
         }
        }
        function find_opt(x, param$0){
         var param = param$0;
         for(;;){
          if(! param) return 0;
          var
           r = param[4],
           d = param[3],
           v = param[2],
           l = param[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return [0, d];
          param = 0 <= c ? r : l;
         }
        }
        function mem(x, param$0){
         var param = param$0;
         for(;;){
          if(! param) return 0;
          var
           r = param[4],
           v = param[2],
           l = param[1],
           c = caml_call2(Ord[1], x, v),
           a = 0 === c ? 1 : 0;
          if(a) return a;
          param = 0 <= c ? r : l;
         }
        }
        function min_binding(param$0){
         var param = param$0;
         for(;;){
          if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var l = param[1];
          if(! l){var d = param[3], v = param[2]; return [0, v, d];}
          param = l;
         }
        }
        function min_binding_opt(param$0){
         var param = param$0;
         for(;;){
          if(! param) return 0;
          var l = param[1];
          if(! l){var d = param[3], v = param[2]; return [0, [0, v, d]];}
          param = l;
         }
        }
        function max_binding(param$0){
         var param = param$0;
         for(;;){
          if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          if(! param[4]){var d = param[3], v = param[2]; return [0, v, d];}
          var r = param[4];
          param = r;
         }
        }
        function max_binding_opt(param$0){
         var param = param$0;
         for(;;){
          if(! param) return 0;
          if(! param[4]){
           var d = param[3], v = param[2];
           return [0, [0, v, d]];
          }
          var r = param[4];
          param = r;
         }
        }
        function remove_min_binding(param){
         if(! param) return Stdlib[1].call(null, cst_Map_remove_min_elt);
         var l = param[1];
         if(l){
          var r = param[4], d = param[3], v = param[2];
          return bal(remove_min_binding(l), v, d, r);
         }
         var r$0 = param[4];
         return r$0;
        }
        function d(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return bal(t1, x, d, remove_min_binding(t2));
        }
        function remove(x, m){
         if(! m) return 0;
         var
          r = m[4],
          d$0 = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return d(l, r);
         if(0 <= c){
          var rr = remove(x, r);
          return r === rr ? m : bal(l, v, d$0, rr);
         }
         var ll = remove(x, l);
         return l === ll ? m : bal(ll, v, d$0, r);
        }
        function update(x, f, m){
         if(! m){
          var match$0 = caml_call1(f, 0);
          if(! match$0) return 0;
          var data$0 = match$0[1];
          return [0, 0, x, data$0, 0, 1];
         }
         var
          h = m[5],
          r = m[4],
          d$0 = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c){
          var match = caml_call1(f, [0, d$0]);
          if(! match) return d(l, r);
          var data = match[1];
          return d$0 === data ? m : [0, l, x, data, r, h];
         }
         if(0 <= c){
          var rr = update(x, f, r);
          return r === rr ? m : bal(l, v, d$0, rr);
         }
         var ll = update(x, f, l);
         return l === ll ? m : bal(ll, v, d$0, r);
        }
        function iter(f, param$0){
         var param = param$0;
         for(;;){
          if(! param) return 0;
          var r = param[4], d = param[3], v = param[2], l = param[1];
          iter(f, l);
          caml_call2(f, v, d);
          param = r;
         }
        }
        function map(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = map(f, l),
          d$0 = caml_call1(f, d),
          r$0 = map(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function mapi(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = mapi(f, l),
          d$0 = caml_call2(f, v, d),
          r$0 = mapi(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function fold(f, m$0, accu$1){
         var m = m$0, accu = accu$1;
         for(;;){
          if(! m) return accu;
          var
           r = m[4],
           d = m[3],
           v = m[2],
           l = m[1],
           accu$0 = caml_call3(f, v, d, fold(f, l, accu));
          m = r;
          accu = accu$0;
         }
        }
        function for_all(p, param$0){
         var param = param$0;
         for(;;){
          if(! param) return 1;
          var
           r = param[4],
           d = param[3],
           v = param[2],
           l = param[1],
           a = caml_call2(p, v, d);
          if(a){
           var b = for_all(p, l);
           if(b){param = r; continue;}
           var c = b;
          }
          else
           var c = a;
          return c;
         }
        }
        function exists(p, param$0){
         var param = param$0;
         for(;;){
          if(! param) return 0;
          var
           r = param[4],
           d = param[3],
           v = param[2],
           l = param[1],
           a = caml_call2(p, v, d);
          if(a)
           var b = a;
          else{var c = exists(p, l); if(! c){param = r; continue;} var b = c;}
          return b;
         }
        }
        function add_min_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(add_min_binding(k, x, l), v, d, r);
        }
        function add_max_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(l, v, d, add_max_binding(k, x, r));
        }
        function join(l, v, d, r){
         if(! l) return add_min_binding(v, d, r);
         if(! r) return add_max_binding(v, d, l);
         var
          rh = r[5],
          rr = r[4],
          rd = r[3],
          rv = r[2],
          rl = r[1],
          lh = l[5],
          lr = l[4],
          ld = l[3],
          lv = l[2],
          ll = l[1];
         return (rh + 2 | 0) < lh
                 ? bal(ll, lv, ld, join(lr, v, d, r))
                 : (lh
                   + 2
                   | 0)
                   < rh
                   ? bal(join(l, v, d, rl), rv, rd, rr)
                   : create(l, v, d, r);
        }
        function concat(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return join(t1, x, d, remove_min_binding(t2));
        }
        function concat_or_join(t1, v, d, t2){
         if(! d) return concat(t1, t2);
         var d$0 = d[1];
         return join(t1, v, d$0, t2);
        }
        function split(x, param){
         if(! param) return a;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return [0, l, [0, d], r];
         if(0 <= c){
          var
           match = split(x, r),
           rr = match[3],
           pres = match[2],
           lr = match[1];
          return [0, join(l, v, d, lr), pres, rr];
         }
         var
          match$0 = split(x, l),
          rl = match$0[3],
          pres$0 = match$0[2],
          ll = match$0[1];
         return [0, ll, pres$0, join(rl, v, d, r)];
        }
        function merge(f, s1, s2){
         if(s1){
          var h1 = s1[5], r1 = s1[4], d1 = s1[3], v1 = s1[2], l1 = s1[1];
          if(height(s2) <= h1){
           var
            match = split(v1, s2),
            r2 = match[3],
            d2 = match[2],
            l2 = match[1],
            a = merge(f, r1, r2),
            c = caml_call3(f, v1, [0, d1], d2);
           return concat_or_join(merge(f, l1, l2), v1, c, a);
          }
         }
         else if(! s2) return 0;
         if(! s2)
          throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
         var
          r2$0 = s2[4],
          d2$0 = s2[3],
          v2 = s2[2],
          l2$0 = s2[1],
          match$0 = split(v2, s1),
          r1$0 = match$0[3],
          d1$0 = match$0[2],
          l1$0 = match$0[1],
          d = merge(f, r1$0, r2$0),
          e = caml_call3(f, v2, d1$0, [0, d2$0]);
         return concat_or_join(merge(f, l1$0, l2$0), v2, e, d);
        }
        function union(f, s1, s2){
         if(s1){
          if(s2){
           var
            h2 = s2[5],
            r2 = s2[4],
            d2 = s2[3],
            v2 = s2[2],
            l2 = s2[1],
            h1 = s1[5],
            r1 = s1[4],
            d1 = s1[3],
            v1 = s1[2],
            l1 = s1[1];
           if(h2 <= h1){
            var
             match = split(v1, s2),
             r2$0 = match[3],
             d2$0 = match[2],
             l2$0 = match[1],
             l = union(f, l1, l2$0),
             r = union(f, r1, r2$0);
            if(! d2$0) return join(l, v1, d1, r);
            var d2$1 = d2$0[1];
            return concat_or_join(l, v1, caml_call3(f, v1, d1, d2$1), r);
           }
           var
            match$0 = split(v2, s1),
            r1$0 = match$0[3],
            d1$0 = match$0[2],
            l1$0 = match$0[1],
            l$0 = union(f, l1$0, l2),
            r$0 = union(f, r1$0, r2);
           if(! d1$0) return join(l$0, v2, d2, r$0);
           var d1$1 = d1$0[1];
           return concat_or_join(l$0, v2, caml_call3(f, v2, d1$1, d2), r$0);
          }
          var s = s1;
         }
         else
          var s = s2;
         return s;
        }
        function filter(p, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          l$0 = filter(p, l),
          pvd = caml_call2(p, v, d),
          r$0 = filter(p, r);
         if(! pvd) return concat(l$0, r$0);
         if(l === l$0 && r === r$0) return m;
         return join(l$0, v, d, r$0);
        }
        function filter_map(f, param){
         if(! param) return 0;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = filter_map(f, l),
          fvd = caml_call2(f, v, d),
          r$0 = filter_map(f, r);
         if(! fvd) return concat(l$0, r$0);
         var d$0 = fvd[1];
         return join(l$0, v, d$0, r$0);
        }
        function partition(p, param){
         if(! param) return c;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          match = partition(p, l),
          lf = match[2],
          lt = match[1],
          pvd = caml_call2(p, v, d),
          match$0 = partition(p, r),
          rf = match$0[2],
          rt = match$0[1];
         if(pvd){var a = concat(lf, rf); return [0, join(lt, v, d, rt), a];}
         var b = join(lf, v, d, rf);
         return [0, concat(lt, rt), b];
        }
        function cons_enum(m$0, e$1){
         var m = m$0, e = e$1;
         for(;;){
          if(! m) return e;
          var r = m[4], d = m[3], v = m[2], l = m[1], e$0 = [0, v, d, r, e];
          m = l;
          e = e$0;
         }
        }
        function compare(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? -1 : 0;
          if(! e2) return 1;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           c = caml_call2(Ord[1], v1, v2);
          if(0 !== c) return c;
          var c$0 = caml_call2(cmp, d1, d2);
          if(0 !== c$0) return c$0;
          var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0);
          e1 = e1$1;
          e2 = e2$1;
         }
        }
        function equal(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? 0 : 1;
          if(! e2) return 0;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           a = 0 === caml_call2(Ord[1], v1, v2) ? 1 : 0;
          if(a){
           var b = caml_call2(cmp, d1, d2);
           if(b){
            var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0);
            e1 = e1$1;
            e2 = e2$1;
            continue;
           }
           var c = b;
          }
          else
           var c = a;
          return c;
         }
        }
        function cardinal(param){
         if(! param) return 0;
         var r = param[4], l = param[1], a = cardinal(r);
         return (cardinal(l) + 1 | 0) + a | 0;
        }
        function bindings_aux(accu$1, param$0){
         var accu = accu$1, param = param$0;
         for(;;){
          if(! param) return accu;
          var
           r = param[4],
           d = param[3],
           v = param[2],
           l = param[1],
           accu$0 = [0, [0, v, d], bindings_aux(accu, r)];
          accu = accu$0;
          param = l;
         }
        }
        function bindings(s){return bindings_aux(0, s);}
        function add_seq(i, m){
         return Stdlib_Seq[5].call
                 (null,
                  function(m, param){
                   var v = param[2], k = param[1];
                   return add(k, v, m);
                  },
                  m,
                  i);
        }
        function of_seq(i){return add_seq(i, empty);}
        function seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          a = cons_enum(t, rest);
         return [0, [0, k, v], function(b){return seq_of_enum(a, b);}];
        }
        function to_seq(m){
         var a = cons_enum(m, 0);
         return function(b){return seq_of_enum(a, b);};
        }
        function snoc_enum(s$0, e$1){
         var s = s$0, e = e$1;
         for(;;){
          if(! s) return e;
          var r = s[4], d = s[3], v = s[2], l = s[1], e$0 = [0, v, d, l, e];
          s = r;
          e = e$0;
         }
        }
        function rev_seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          a = snoc_enum(t, rest);
         return [0, [0, k, v], function(b){return rev_seq_of_enum(a, b);}];
        }
        function to_rev_seq(c){
         var a = snoc_enum(c, 0);
         return function(b){return rev_seq_of_enum(a, b);};
        }
        function to_seq_from(low, m){
         a:
         {
          var m$0 = m, c = 0;
          for(;;){
           if(! m$0){var a = c; break a;}
           var
            r = m$0[4],
            d = m$0[3],
            v = m$0[2],
            l = m$0[1],
            n = caml_call2(Ord[1], v, low);
           if(0 === n) break;
           if(0 <= n){
            var c$0 = [0, v, d, r, c];
            m$0 = l;
            c = c$0;
           }
           else
            m$0 = r;
          }
          var a = [0, v, d, r, c];
         }
         return function(b){return seq_of_enum(a, b);};
        }
        return [0,
                empty,
                is_empty,
                mem,
                add,
                update,
                singleton,
                remove,
                merge,
                union,
                compare,
                equal,
                iter,
                fold,
                for_all,
                exists,
                filter,
                filter_map,
                partition,
                cardinal,
                bindings,
                min_binding,
                min_binding_opt,
                max_binding,
                max_binding_opt,
                min_binding,
                min_binding_opt,
                split,
                find,
                find_opt,
                find_first,
                find_first_opt,
                find_last,
                find_last_opt,
                map,
                mapi,
                to_seq,
                to_rev_seq,
                to_seq_from,
                add_seq,
                of_seq];
       }];
   runtime.caml_register_global(11, Stdlib_Map, "Stdlib__Map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Stack
//# unitInfo: Requires: Stdlib__List, Stdlib__Seq
//# shape: Stdlib__Stack:[N,F(1)*,F(2),F(1),F(1),F(1),F(1)*,F(1),F(1)*,F(1)*,F(1)*,F(2),F(3),F(1)*,F(2),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    Empty = [248, "Stdlib.Stack.Empty", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, 0, 0];}
   function clear(s){s[1] = 0; s[2] = 0; return 0;}
   function copy(s){return [0, s[1], s[2]];}
   function push(x, s){s[1] = [0, x, s[1]]; s[2] = s[2] + 1 | 0; return 0;}
   function pop(s){
    var match = s[1];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var tl = match[2], hd = match[1];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return hd;
   }
   function pop_opt(s){
    var match = s[1];
    if(! match) return 0;
    var tl = match[2], hd = match[1];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return [0, hd];
   }
   function top(s){
    var match = s[1];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var hd = match[1];
    return hd;
   }
   function top_opt(s){
    var match = s[1];
    if(! match) return 0;
    var hd = match[1];
    return [0, hd];
   }
   function is_empty(s){return 0 === s[1] ? 1 : 0;}
   function length(s){return s[2];}
   function iter(f, s){return Stdlib_List[17].call(null, f, s[1]);}
   function fold(f, acc, s){return Stdlib_List[25].call(null, f, acc, s[1]);}
   function to_seq(s){return Stdlib_List[61].call(null, s[1]);}
   function add_seq(q, i){
    return Stdlib_Seq[4].call(null, function(x){return push(x, q);}, i);
   }
   function of_seq(g){var s = create(0); add_seq(s, g); return s;}
   var
    Stdlib_Stack =
      [0,
       Empty,
       create,
       push,
       pop,
       pop_opt,
       top,
       top_opt,
       clear,
       copy,
       is_empty,
       length,
       iter,
       fold,
       to_seq,
       add_seq,
       of_seq];
   runtime.caml_register_global(3, Stdlib_Stack, "Stdlib__Stack");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Queue
//# unitInfo: Requires: Stdlib__Seq
//# shape: Stdlib__Queue:[N,F(1)*,F(2),F(2),F(1),F(1),F(1),F(1),F(1)*,F(1),F(1),F(1),F(1)*,F(1)*,F(2),F(3),F(2),F(1)*->F(1)*,F(2),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Empty = [248, "Stdlib.Queue.Empty", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, 0, 0, 0];}
   function clear(q){q[1] = 0; q[2] = 0; q[3] = 0; return 0;}
   function add(x, q){
    var cell = [0, x, 0], match = q[3];
    return match
            ? (q[1] = q[1] + 1 | 0, match[2] = cell, q[3] = cell, 0)
            : (q[1] = 1, q[2] = cell, q[3] = cell, 0);
   }
   function peek(q){
    var match = q[2];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var content = match[1];
    return content;
   }
   function peek_opt(q){
    var match = q[2];
    if(! match) return 0;
    var content = match[1];
    return [0, content];
   }
   function take(q){
    var match = q[2];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var content = match[1];
    if(match[2]){
     var next = match[2];
     q[1] = q[1] - 1 | 0;
     q[2] = next;
     return content;
    }
    clear(q);
    return content;
   }
   function take_opt(q){
    var match = q[2];
    if(! match) return 0;
    var content = match[1];
    if(match[2]){
     var next = match[2];
     q[1] = q[1] - 1 | 0;
     q[2] = next;
     return [0, content];
    }
    clear(q);
    return [0, content];
   }
   function copy(q){
    var cell$0 = q[2], q_res = [0, q[1], 0, 0], prev = 0, cell = cell$0;
    for(;;){
     if(! cell){q_res[3] = prev; return q_res;}
     var content = cell[1], next = cell[2], prev$0 = [0, content, 0];
     if(prev){
      prev[2] = prev$0;
      prev = prev$0;
      cell = next;
     }
     else{q_res[2] = prev$0; prev = prev$0; cell = next;}
    }
   }
   function is_empty(q){return 0 === q[1] ? 1 : 0;}
   function length(q){return q[1];}
   function iter(f, q){
    var cell$0 = q[2], cell = cell$0;
    for(;;){
     if(! cell) return 0;
     var content = cell[1], next = cell[2];
     caml_call1(f, content);
     cell = next;
    }
   }
   function fold(f, accu$1, q){
    var cell$0 = q[2], accu = accu$1, cell = cell$0;
    for(;;){
     if(! cell) return accu;
     var
      content = cell[1],
      next = cell[2],
      accu$0 = caml_call2(f, accu, content);
     accu = accu$0;
     cell = next;
    }
   }
   function transfer(q1, q2){
    var a = 0 < q1[1] ? 1 : 0;
    if(! a) return a;
    var match = q2[3];
    return match
            ? (q2
               [1]
              = q2[1] + q1[1] | 0,
              match[2] = q1[2],
              q2[3] = q1[3],
              clear(q1))
            : (q2[1] = q1[1], q2[2] = q1[2], q2[3] = q1[3], clear(q1));
   }
   function to_seq(q){
    function aux(c, param){
     if(! c) return 0;
     var x = c[1], next = c[2];
     return [0, x, function(a){return aux(next, a);}];
    }
    var a = q[2];
    return function(b){return aux(a, b);};
   }
   function add_seq(q, i){
    return Stdlib_Seq[4].call(null, function(x){return add(x, q);}, i);
   }
   function of_seq(g){var q = create(0); add_seq(q, g); return q;}
   var
    Stdlib_Queue =
      [0,
       Empty,
       create,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear,
       copy,
       is_empty,
       length,
       iter,
       fold,
       transfer,
       to_seq,
       add_seq,
       of_seq];
   runtime.caml_register_global(2, Stdlib_Queue, "Stdlib__Queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Stream
//# unitInfo: Requires: Assert_failure, CamlinternalLazy, Stdlib, Stdlib__Bytes, Stdlib__List
//# shape: Stdlib__Stream:[N,N,F(1)*,F(1),F(1)*,F(1)*,F(1)*,F(2),F(1),F(1),F(1),F(1),F(1)*,F(2),F(2)*,F(2)*,F(1)*,F(2)*,F(2)*,F(1)*,N,F(1)*,F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = ")",
    cst$4 = ", ",
    cst_stream_ml = "stream.ml",
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "}",
    cst$0 = cst$4,
    cst$1 = cst$5,
    cst$2 = cst$4,
    cst$3 = cst$5,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Failure = [248, "Stdlib.Stream.Failure", caml_fresh_oo_id(0)],
    Error = [248, "Stdlib.Stream.Error", caml_fresh_oo_id(0)],
    a = [0, cst_stream_ml, 53, 12],
    b = [0, 0],
    c = [0, cst_stream_ml, 82, 12],
    dummy = 0;
   function count(param){
    if(! param) return 0;
    var count = param[1][1];
    return count;
   }
   function data(param){
    if(! param) return 0;
    var data = param[1][2];
    return data;
   }
   function fill_buff(b){
    b[3] = Stdlib[84].call(null, b[1], b[2], 0, caml_ml_bytes_length(b[2]));
    b[4] = 0;
   }
   function get_data(count, d$0){
    var d = d$0;
    a:
    for(;;){
     if(typeof d !== "number")
      switch(d[0]){
        case 1:
         var d2 = d[2], d1 = d[1], match = get_data(count, d1);
         if(typeof match === "number"){d = d2; continue;}
         if(0 !== match[0])
          throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
         var d11 = match[2], a$0 = match[1];
         return [0, a$0, [1, d11, d2]];
        case 2:
         var f = d[1], c = caml_obj_tag(f);
         if(250 === c){d = f[1]; continue;}
         if(246 === c){d = CamlinternalLazy[2].call(null, f); continue;}
         d = f;
         continue;
        case 3:
         var g = d[1], match$0 = g[1];
         if(match$0){
          var match$1 = match$0[1];
          if(! match$1) return 0;
          var a$1 = match$1[1];
          g[1] = 0;
          return [0, a$1, d];
         }
         var match$2 = caml_call1(g[2], count);
         if(match$2){var a$2 = match$2[1]; return [0, a$2, d];}
         g[1] = b;
         return 0;
        case 4:
         break a;
      }
     return d;
    }
    var b$0 = d[1];
    if(b$0[3] <= b$0[4]) fill_buff(b$0);
    if(0 === b$0[3]) return 0;
    var r = caml_bytes_unsafe_get(b$0[2], b$0[4]);
    b$0[4] = b$0[4] + 1 | 0;
    return [0, r, d];
   }
   function peek_data(s){
    a:
    for(;;){
     var match = s[2];
     if(typeof match === "number") return 0;
     switch(match[0]){
       case 0:
        var a = match[1]; return [0, a];
       case 1:
        var d = get_data(s[1], s[2]);
        if(typeof d === "number") return 0;
        if(0 !== d[0])
         throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
        var a$0 = d[1];
        s[2] = d;
        return [0, a$0];
       case 2:
        var
         f = match[1],
         e = caml_obj_tag(f),
         h =
           250 === e
            ? f[1]
            : 246 === e ? CamlinternalLazy[2].call(null, f) : f;
        s[2] = h;
        break;
       case 3:
        var g = match[1], match$0 = g[1];
        if(match$0){var a$1 = match$0[1]; return a$1;}
        var x = caml_call1(g[2], s[1]);
        g[1] = [0, x];
        return x;
       default: break a;
     }
    }
    var b = match[1];
    if(b[3] <= b[4]) fill_buff(b);
    return 0 === b[3] ? (s[2] = 0, 0) : [0, caml_bytes_unsafe_get(b[2], b[4])];
   }
   function peek(param){
    if(! param) return 0;
    var s = param[1];
    return peek_data(s);
   }
   function junk_data(s){
    a:
    for(;;){
     var match = s[2];
     if(typeof match !== "number")
      switch(match[0]){
        case 0:
         var d = match[2]; s[1] = s[1] + 1 | 0; s[2] = d; return 0;
        case 3:
         var g = match[1];
         if(g[1]){s[1] = s[1] + 1 | 0; g[1] = 0; return 0;}
         break;
        case 4:
         break a;
      }
     if(! peek_data(s)) return 0;
    }
    var b = match[1];
    if(b[3] <= b[4]) fill_buff(b);
    return 0 === b[3]
            ? (s[2] = 0, 0)
            : (s[1] = s[1] + 1 | 0, b[4] = b[4] + 1 | 0, 0);
   }
   function junk(param){
    if(! param) return 0;
    var data = param[1];
    return junk_data(data);
   }
   function nget_data(n, s){
    if(0 >= n) return [0, 0, s[2], 0];
    var match = peek_data(s);
    if(! match) return [0, 0, s[2], 0];
    var a = match[1];
    junk_data(s);
    var
     match$0 = nget_data(n - 1 | 0, s),
     k = match$0[3],
     d = match$0[2],
     al = match$0[1];
    return [0, [0, a, al], [0, a, d], k + 1 | 0];
   }
   function npeek(n, param){
    if(! param) return 0;
    var
     d$0 = param[1],
     match = nget_data(n, d$0),
     len = match[3],
     d = match[2],
     al = match[1];
    d$0[1] = d$0[1] - len | 0;
    d$0[2] = d;
    return al;
   }
   function next(s){
    var match = peek(s);
    if(! match) throw caml_maybe_attach_backtrace(Failure, 1);
    var a = match[1];
    junk(s);
    return a;
   }
   function empty(s){
    if(peek(s)) throw caml_maybe_attach_backtrace(Failure, 1);
    return 0;
   }
   function iter(f, strm){
    for(;;){
     var match = peek(strm);
     if(! match) return 0;
     var a = match[1];
     junk(strm);
     caml_call1(f, a);
    }
   }
   function from(f){return [0, [0, 0, [3, [0, 0, f]]]];}
   function of_list(l){
    return [0,
            [0,
             0,
             Stdlib_List[26].call
              (null, function(x, l){return [0, x, l];}, l, 0)]];
   }
   function of_string(s){
    var count = [0, 0];
    return from
            (function(param){
              var c = count[1];
              return c < runtime.caml_ml_string_length(s)
                      ? (count[1]++, [0, runtime.caml_string_get(s, c)])
                      : 0;
             });
   }
   function of_bytes(s){
    var count = [0, 0];
    return from
            (function(param){
              var c = count[1];
              return c < caml_ml_bytes_length(s)
                      ? (count[1]++, [0, runtime.caml_bytes_get(s, c)])
                      : 0;
             });
   }
   function of_channel(ic){
    return [0, [0, 0, [4, [0, ic, runtime.caml_create_bytes(4096), 0, 0]]]];
   }
   function iapp(i, s){var a = data(s); return [0, [0, 0, [1, data(i), a]]];}
   function icons(i, s){return [0, [0, 0, [0, i, data(s)]]];}
   function ising(i){return [0, [0, 0, [0, i, 0]]];}
   function lapp(f, s){
    return [0,
            [0,
             0,
             [2,
              [246,
               function(param){
                var a = data(s);
                return [1, data(caml_call1(f, 0)), a];
               }]]]];
   }
   function lcons(f, s){
    return [0,
            [0,
             0,
             [2,
              [246,
               function(param){
                var a = data(s);
                return [0, caml_call1(f, 0), a];
               }]]]];
   }
   function lsing(f){
    return [0,
            [0,
             0,
             [2, [246, function(param){return [0, caml_call1(f, 0), 0];}]]]];
   }
   var
    cst_count = "{count = ",
    cst_data = "; data = ",
    cst_Sempty = "Sempty",
    cst_Scons = "Scons (",
    cst_Sapp = "Sapp (",
    cst_Slazy = "Slazy",
    cst_Sgen = "Sgen",
    cst_Sbuffio = "Sbuffio";
   function slazy(f){
    return [0,
            [0,
             0,
             [2, [246, function(param){return data(caml_call1(f, 0));}]]]];
   }
   function dump(f, s){
    Stdlib[42].call(null, cst_count);
    var a = count(s);
    Stdlib[44].call(null, a);
    Stdlib[42].call(null, cst_data);
    dump_data(f, data(s));
    Stdlib[42].call(null, cst);
    return Stdlib[47].call(null, 0);
   }
   function dump_data(f, param){
    if(typeof param === "number") return Stdlib[42].call(null, cst_Sempty);
    switch(param[0]){
      case 0:
       var d = param[2], a = param[1];
       Stdlib[42].call(null, cst_Scons);
       caml_call1(f, a);
       Stdlib[42].call(null, cst$0);
       dump_data(f, d);
       return Stdlib[42].call(null, cst$1);
      case 1:
       var d2 = param[2], d1 = param[1];
       Stdlib[42].call(null, cst_Sapp);
       dump_data(f, d1);
       Stdlib[42].call(null, cst$2);
       dump_data(f, d2);
       return Stdlib[42].call(null, cst$3);
      case 2:
       return Stdlib[42].call(null, cst_Slazy);
      case 3:
       return Stdlib[42].call(null, cst_Sgen);
      default: return Stdlib[42].call(null, cst_Sbuffio);
    }
   }
   var
    Stdlib_Stream =
      [0,
       Failure,
       Error,
       from,
       of_list,
       of_string,
       of_bytes,
       of_channel,
       iter,
       next,
       empty,
       peek,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       0,
       slazy,
       dump];
   runtime.caml_register_global(22, Stdlib_Stream, "Stdlib__Stream");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Buffer
//# unitInfo: Requires: Assert_failure, Stdlib, Stdlib__Bytes, Stdlib__Seq, Stdlib__String, Stdlib__Sys
//# shape: Stdlib__Buffer:[F(1)*,F(1),F(1),F(3),F(5),F(2),F(1)*,F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(4),F(4),F(3),F(2),F(3),F(1)*->F(1)*,F(1)*->F(1)*,F(2),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_buffer_ml = "buffer.ml",
    caml_blit_string = runtime.caml_blit_string,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure,
    cst_Buffer_sub = "Buffer.sub",
    cst_Buffer_blit = "Buffer.blit",
    cst_Buffer_nth = "Buffer.nth",
    a = [0, cst_buffer_ml, 94, 2],
    b = [0, cst_buffer_ml, 93, 2],
    cst_Buffer_add_cannot_grow_buf = "Buffer.add: cannot grow buffer",
    dummy = 0;
   function create(n){
    var
     n$0 = 1 <= n ? n : 1,
     n$1 = Stdlib_Sys[12] < n$0 ? Stdlib_Sys[12] : n$0,
     s = caml_create_bytes(n$1);
    return [0, s, 0, n$1, s];
   }
   function contents(b){return Stdlib_Bytes[8].call(null, b[1], 0, b[2]);}
   function to_bytes(b){return Stdlib_Bytes[7].call(null, b[1], 0, b[2]);}
   function sub(b, ofs, len){
    if(0 <= ofs && 0 <= len && (b[2] - len | 0) >= ofs)
     return Stdlib_Bytes[8].call(null, b[1], ofs, len);
    return Stdlib[1].call(null, cst_Buffer_sub);
   }
   function blit(src, srcoff, dst, dstoff, len){
    if
     (0 <= len
      &&
       0 <= srcoff
       &&
        (src[2] - len | 0) >= srcoff
        && 0 <= dstoff && (caml_ml_bytes_length(dst) - len | 0) >= dstoff)
     return runtime.caml_blit_bytes(src[1], srcoff, dst, dstoff, len);
    return Stdlib[1].call(null, cst_Buffer_blit);
   }
   function nth(b, ofs){
    if(0 <= ofs && b[2] > ofs) return caml_bytes_unsafe_get(b[1], ofs);
    return Stdlib[1].call(null, cst_Buffer_nth);
   }
   function length(b){return b[2];}
   function clear(b){b[2] = 0; return 0;}
   function reset(b){
    b[2] = 0;
    b[1] = b[4];
    b[3] = caml_ml_bytes_length(b[1]);
    return 0;
   }
   function resize(b$0, more){
    var old_pos = b$0[2], old_len = b$0[3], new_len = [0, old_len];
    for(;;){
     if(new_len[1] >= (old_pos + more | 0)) break;
     new_len[1] = 2 * new_len[1] | 0;
    }
    if(Stdlib_Sys[12] < new_len[1])
     if((old_pos + more | 0) <= Stdlib_Sys[12])
      new_len[1] = Stdlib_Sys[12];
     else
      Stdlib[2].call(null, cst_Buffer_add_cannot_grow_buf);
    var new_buffer = caml_create_bytes(new_len[1]);
    Stdlib_Bytes[11].call(null, b$0[1], 0, new_buffer, 0, b$0[2]);
    b$0[1] = new_buffer;
    b$0[3] = new_len[1];
    if((b$0[2] + more | 0) > b$0[3])
     throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
    if((old_pos + more | 0) <= b$0[3]) return;
    throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
   }
   function add_char(b, c){
    var pos = b[2];
    if(b[3] <= pos) resize(b, 1);
    caml_bytes_unsafe_set(b[1], pos, c);
    b[2] = pos + 1 | 0;
    return 0;
   }
   var
    uchar_utf_8_byte_length_max = 4,
    uchar_utf_16_byte_length_max = 4,
    cst_Buffer_add_substring_add_s = "Buffer.add_substring/add_subbytes",
    c = [0, cst_buffer_ml, 212, 2],
    cst_Buffer_add_channel = "Buffer.add_channel",
    d = [0, cst_buffer_ml, 231, 9],
    cst_Buffer_truncate = "Buffer.truncate";
   function add_utf_8_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[3] <= pos) resize(b, uchar_utf_8_byte_length_max);
     var n = Stdlib_Bytes[55].call(null, b[1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_8_byte_length_max);
    }
   }
   function add_utf_16be_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[3] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = Stdlib_Bytes[58].call(null, b[1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_16_byte_length_max);
    }
   }
   function add_utf_16le_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[3] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = Stdlib_Bytes[61].call(null, b[1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_16_byte_length_max);
    }
   }
   function add_substring(b, s, offset, len){
    var a = offset < 0 ? 1 : 0;
    if(a)
     var c = a;
    else
     var
      d = len < 0 ? 1 : 0,
      c = d || ((caml_ml_string_length(s) - len | 0) < offset ? 1 : 0);
    if(c) Stdlib[1].call(null, cst_Buffer_add_substring_add_s);
    var new_position = b[2] + len | 0;
    if(b[3] < new_position) resize(b, len);
    caml_blit_string(s, offset, b[1], b[2], len);
    b[2] = new_position;
    return 0;
   }
   function add_subbytes(b, s, offset, len){
    return add_substring(b, Stdlib_Bytes[48].call(null, s), offset, len);
   }
   function add_string(b, s){
    var len = caml_ml_string_length(s), new_position = b[2] + len | 0;
    if(b[3] < new_position) resize(b, len);
    caml_blit_string(s, 0, b[1], b[2], len);
    b[2] = new_position;
    return 0;
   }
   function add_bytes(b, s){
    return add_string(b, Stdlib_Bytes[48].call(null, s));
   }
   function add_buffer(b, bs){return add_subbytes(b, bs[1], 0, bs[2]);}
   function add_channel(b, ic, to_read$1){
    var
     a = to_read$1 < 0 ? 1 : 0,
     d = a || (Stdlib_Sys[12] < to_read$1 ? 1 : 0);
    if(d) Stdlib[1].call(null, cst_Buffer_add_channel);
    if(b[3] < (b[2] + to_read$1 | 0)) resize(b, to_read$1);
    var
     ofs$1 = b[2],
     buf = b[1],
     already_read = 0,
     ofs = ofs$1,
     to_read = to_read$1;
    for(;;){
     if(0 !== to_read){
      var r = Stdlib[84].call(null, ic, buf, ofs, to_read);
      if(0 !== r){
       var
        already_read$0 = already_read + r | 0,
        ofs$0 = ofs + r | 0,
        to_read$0 = to_read - r | 0;
       already_read = already_read$0;
       ofs = ofs$0;
       to_read = to_read$0;
       continue;
      }
     }
     if((b[2] + already_read | 0) > b[3])
      throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
     b[2] = b[2] + already_read | 0;
     if(already_read < to_read$1)
      throw caml_maybe_attach_backtrace(Stdlib[12], 1);
     return 0;
    }
   }
   function output_buffer(oc, b){
    return Stdlib[68].call(null, oc, b[1], 0, b[2]);
   }
   function add_substitute(b, f, s){
    var lim$1 = caml_ml_string_length(s), previous = 32, i$4 = 0;
    for(;;){
     if(i$4 >= lim$1){
      var a = 92 === previous ? 1 : 0;
      return a ? add_char(b, previous) : a;
     }
     var previous$0 = caml_string_get(s, i$4);
     if(36 === previous$0)
      if(92 === previous){
       add_char(b, previous$0);
       var i$5 = i$4 + 1 | 0;
       previous = 32;
       i$4 = i$5;
      }
      else{
       var start$0 = i$4 + 1 | 0;
       if(lim$1 <= start$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
       var opening = caml_string_get(s, start$0);
       a:
       {
        if(40 !== opening && 123 !== opening){
         var
          start = start$0 + 1 | 0,
          lim$0 = caml_ml_string_length(s),
          i$2 = start;
         for(;;){
          b:
          {
           if(lim$0 > i$2){
            var match = caml_string_get(s, i$2);
            if(91 <= match){
             if(97 <= match){
              if(123 <= match){var stop$0 = i$2; break b;}
             }
             else if(95 !== match){var stop$0 = i$2; break b;}
            }
            else
             if(58 <= match){
              if(65 > match){var stop$0 = i$2; break b;}
             }
             else if(48 > match){var stop$0 = i$2; break b;}
            var i$3 = i$2 + 1 | 0;
            i$2 = i$3;
            continue;
           }
           var stop$0 = lim$0;
          }
          var
           match$0 =
             [0,
              Stdlib_String[15].call(null, s, start$0, stop$0 - start$0 | 0),
              stop$0];
          break a;
         }
        }
        var new_start = start$0 + 1 | 0, k$2 = 0;
        if(40 === opening)
         var closing = 41;
        else{
         if(123 !== opening)
          throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
         var closing = 125;
        }
        var lim = caml_ml_string_length(s), k = k$2, stop = new_start;
        for(;;){
         if(lim <= stop) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
         if(caml_string_get(s, stop) === opening){
          var i = stop + 1 | 0, k$0 = k + 1 | 0;
          k = k$0;
          stop = i;
         }
         else if(caml_string_get(s, stop) === closing){
          if(0 === k){
           var
            match$0 =
              [0,
               Stdlib_String[15].call
                (null, s, new_start, (stop - start$0 | 0) - 1 | 0),
               stop + 1 | 0];
           break;
          }
          var i$0 = stop + 1 | 0, k$1 = k - 1 | 0;
          k = k$1;
          stop = i$0;
         }
         else{var i$1 = stop + 1 | 0; stop = i$1;}
        }
       }
       var next_i = match$0[2], ident = match$0[1];
       add_string(b, caml_call1(f, ident));
       previous = 32;
       i$4 = next_i;
      }
     else if(92 === previous){
      add_char(b, 92);
      add_char(b, previous$0);
      var i$6 = i$4 + 1 | 0;
      previous = 32;
      i$4 = i$6;
     }
     else if(92 === previous$0){
      var i$7 = i$4 + 1 | 0;
      previous = previous$0;
      i$4 = i$7;
     }
     else{
      add_char(b, previous$0);
      var i$8 = i$4 + 1 | 0;
      previous = previous$0;
      i$4 = i$8;
     }
    }
   }
   function truncate(b, len){
    if(0 <= len && b[2] >= len){b[2] = len; return 0;}
    return Stdlib[1].call(null, cst_Buffer_truncate);
   }
   function to_seq(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_unsafe_get(b[1], i), a = i + 1 | 0;
     return [0, x, function(b){return aux(a, b);}];
    }
    var a = 0;
    return function(b){return aux(a, b);};
   }
   function to_seqi(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_unsafe_get(b[1], i), a = i + 1 | 0;
     return [0, [0, i, x], function(b){return aux(a, b);}];
    }
    var a = 0;
    return function(b){return aux(a, b);};
   }
   function add_seq(b, seq){
    return Stdlib_Seq[4].call(null, function(a){return add_char(b, a);}, seq);
   }
   function of_seq(i){var b = create(32); add_seq(b, i); return b;}
   function add_int8(b, x){
    var new_position = b[2] + 1 | 0;
    if(b[3] < new_position) resize(b, 1);
    caml_bytes_unsafe_set(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_ne(b, x){
    var new_position = b[2] + 2 | 0;
    if(b[3] < new_position) resize(b, 2);
    runtime.caml_bytes_set16(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int32_ne(b, x){
    var new_position = b[2] + 4 | 0;
    if(b[3] < new_position) resize(b, 4);
    runtime.caml_bytes_set32(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int64_ne(b, x){
    var new_position = b[2] + 8 | 0;
    if(b[3] < new_position) resize(b, 8);
    runtime.caml_bytes_set64(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_le(b, x){
    var a = Stdlib_Sys[11] ? caml_bswap16(x) : x;
    return add_int16_ne(b, a);
   }
   function add_int16_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_bswap16(x);
    return add_int16_ne(b, x$0);
   }
   function add_int32_le(b, x){
    var a = Stdlib_Sys[11] ? caml_int32_bswap(x) : x;
    return add_int32_ne(b, a);
   }
   function add_int32_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int32_bswap(x);
    return add_int32_ne(b, x$0);
   }
   function add_int64_le(b, x){
    var a = Stdlib_Sys[11] ? caml_int64_bswap(x) : x;
    return add_int64_ne(b, a);
   }
   function add_int64_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int64_bswap(x);
    return add_int64_ne(b, x$0);
   }
   var
    Stdlib_Buffer =
      [0,
       create,
       contents,
       to_bytes,
       sub,
       blit,
       nth,
       length,
       clear,
       reset,
       output_buffer,
       truncate,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       to_seq,
       to_seqi,
       add_seq,
       of_seq,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
   runtime.caml_register_global(17, Stdlib_Buffer, "Stdlib__Buffer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: CamlinternalFormat
//# unitInfo: Requires: Assert_failure, CamlinternalFormatBasics, Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Int, Stdlib__String, Stdlib__Sys
//# shape: CamlinternalFormat:[F(2),F(1),F(1),F(2),F(1),F(2)*,F(3),F(3),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(1)*,F(1),F(1),F(1),F(1),F(1),F(2),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$43 = "",
    cst_and = " and ",
    cst_Li$3 = "%Li",
    cst_i$3 = "%i",
    cst_li$3 = "%li",
    cst_ni$3 = "%ni",
    cst_u$0 = "%u",
    cst$42 = "' '",
    cst$41 = "'#'",
    cst$39 = "'*'",
    cst$40 = "'+'",
    cst$44 = ", ",
    cst_0$3 = "0",
    cst_at_character_number = ": at character number ",
    cst$38 = "@[",
    cst$37 = "@{",
    cst_bad_input_format_type_mism =
      "bad input: format type mismatch between ",
    cst_bad_input_format_type_mism$0 =
      "bad input: format type mismatch between %S and %S",
    cst_camlinternalFormat_ml = "camlinternalFormat.ml",
    cst_invalid_format = "invalid format ",
    cst_precision$3 = "precision",
    caml_blit_string = runtime.caml_blit_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_format_float = runtime.caml_format_float,
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    cst$9 = "%{",
    cst$10 = "%}",
    cst$11 = "%(",
    cst$12 = "%)",
    cst$13 = "%?",
    cst$18 = cst$37,
    cst$19 = cst$38,
    cst$20 = cst$37,
    cst$21 = cst$38,
    cst$22 = cst$37,
    cst$23 = cst$38,
    cst$26 = cst$39,
    cst$24 = "'-'",
    cst$25 = cst$39,
    cst$27 = cst$40,
    cst$28 = cst$41,
    cst$29 = cst$42,
    cst$30 = cst$40,
    cst$31 = "'_'",
    sub_format = [0, 0, cst$43],
    formatting_lit = [0, "@;", 1, 0],
    cst$35 = cst$41,
    cst$32 = cst$40,
    cst$33 = cst$40,
    cst$34 = cst$42,
    cst$36 = cst$40,
    cst_unexpected_end_of_format = "unexpected end of format",
    cst$17 = ".",
    cst_nd = "%nd",
    cst_ni$0 = cst_ni$3,
    cst_nu = "%nu",
    cst_ld = "%ld",
    cst_li$0 = cst_li$3,
    cst_lu = "%lu",
    cst_Ld = "%Ld",
    cst_Li$0 = cst_Li$3,
    cst_Lu = "%Lu",
    cst_d = "%d",
    cst_i$0 = cst_i$3,
    cst_u = cst_u$0,
    cst$14 = "%!",
    cst$15 = cst$37,
    cst$16 = cst$38,
    cst$8 = "%%",
    cst$0 = "@]",
    cst$1 = "@}",
    cst$2 = "@?",
    cst$3 = "@\n",
    cst$4 = "@.",
    cst$5 = "@@",
    cst$6 = "@%",
    cst$7 = "@",
    cst = ".*",
    Assert_failure = global_data.Assert_failure,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Int = global_data.Stdlib__Int,
    a = [0, 0, 0],
    cst_c = "%c",
    cst_s = "%s",
    cst_i = cst_i$3,
    cst_li = cst_li$3,
    cst_ni = cst_ni$3,
    cst_Li = cst_Li$3,
    cst_f = "%f",
    cst_B = "%B",
    cst_a = "%a",
    cst_t = "%t",
    cst_r = "%r",
    cst_r$0 = "%_r",
    cst_0c = "0c",
    b = [0, cst_camlinternalFormat_ml, 850, 23],
    c = [0, cst_camlinternalFormat_ml, 837, 26],
    d = [0, cst_camlinternalFormat_ml, 847, 28],
    e = [0, cst_camlinternalFormat_ml, 815, 21],
    f = [0, cst_camlinternalFormat_ml, 819, 21],
    g = [0, cst_camlinternalFormat_ml, 823, 19],
    h = [0, cst_camlinternalFormat_ml, 827, 22],
    i = [0, cst_camlinternalFormat_ml, 832, 30],
    j = [0, cst_camlinternalFormat_ml, 851, 23],
    k = [0, cst_camlinternalFormat_ml, 836, 26],
    l = [0, cst_camlinternalFormat_ml, 846, 28],
    m = [0, cst_camlinternalFormat_ml, 814, 21],
    n = [0, cst_camlinternalFormat_ml, 818, 21],
    o = [0, cst_camlinternalFormat_ml, 822, 19],
    p = [0, cst_camlinternalFormat_ml, 826, 22],
    q = [0, cst_camlinternalFormat_ml, 831, 30];
   function create_char_set(param){return Stdlib_Bytes[1].call(null, 32, 0);}
   function add_in_char_set(char_set, c){
    var
     str_ind = c >>> 3 | 0,
     mask = 1 << (c & 7),
     a = runtime.caml_bytes_get(char_set, str_ind) | mask;
    return caml_bytes_set(char_set, str_ind, Stdlib[29].call(null, a));
   }
   function freeze_char_set(char_set){
    return Stdlib_Bytes[6].call(null, char_set);
   }
   function rev_char_set(char_set){
    var char_set$0 = create_char_set(0), i = 0;
    for(;;){
     var a = caml_string_get(char_set, i) ^ 255;
     caml_bytes_set(char_set$0, i, Stdlib[29].call(null, a));
     var b = i + 1 | 0;
     if(31 === i) return Stdlib_Bytes[48].call(null, char_set$0);
     i = b;
    }
   }
   function is_in_char_set(char_set, c){
    var str_ind = c >>> 3 | 0, mask = 1 << (c & 7);
    return 0 !== (caml_string_get(char_set, str_ind) & mask) ? 1 : 0;
   }
   function pad_of_pad_opt(pad_opt){
    if(! pad_opt) return 0;
    var width = pad_opt[1];
    return [0, 1, width];
   }
   function param_format_of_ignored_format(ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        return [0, [0, fmt]];
       case 1:
        return [0, [1, fmt]];
       case 2:
        return [0, [19, fmt]];
       default: return [0, [22, fmt]];
     }
    switch(ign[0]){
      case 0:
       var pad_opt = ign[1]; return [0, [2, pad_of_pad_opt(pad_opt), fmt]];
      case 1:
       var pad_opt$0 = ign[1];
       return [0, [3, pad_of_pad_opt(pad_opt$0), fmt]];
      case 2:
       var pad_opt$1 = ign[2], iconv = ign[1];
       return [0, [4, iconv, pad_of_pad_opt(pad_opt$1), 0, fmt]];
      case 3:
       var pad_opt$2 = ign[2], iconv$0 = ign[1];
       return [0, [5, iconv$0, pad_of_pad_opt(pad_opt$2), 0, fmt]];
      case 4:
       var pad_opt$3 = ign[2], iconv$1 = ign[1];
       return [0, [6, iconv$1, pad_of_pad_opt(pad_opt$3), 0, fmt]];
      case 5:
       var pad_opt$4 = ign[2], iconv$2 = ign[1];
       return [0, [7, iconv$2, pad_of_pad_opt(pad_opt$4), 0, fmt]];
      case 6:
       var prec_opt = ign[2], pad_opt$5 = ign[1];
       if(prec_opt) var ndec = prec_opt[1], b = [0, ndec]; else var b = 0;
       return [0, [8, a, pad_of_pad_opt(pad_opt$5), b, fmt]];
      case 7:
       var pad_opt$6 = ign[1];
       return [0, [9, pad_of_pad_opt(pad_opt$6), fmt]];
      case 8:
       var fmtty = ign[2], pad_opt$7 = ign[1];
       return [0, [13, pad_opt$7, fmtty, fmt]];
      case 9:
       var fmtty$0 = ign[2], pad_opt$8 = ign[1];
       return [0, [14, pad_opt$8, fmtty$0, fmt]];
      case 10:
       var char_set = ign[2], width_opt = ign[1];
       return [0, [20, width_opt, char_set, fmt]];
      default: var counter = ign[1]; return [0, [21, counter, fmt]];
    }
   }
   function default_float_precision(fconv){return 5 === fconv[2] ? 12 : -6;}
   function buffer_create(init_size){
    return [0, 0, caml_create_bytes(init_size)];
   }
   function buffer_check_size(buf, overhead){
    var
     len = runtime.caml_ml_bytes_length(buf[2]),
     min_len = buf[1] + overhead | 0;
    if(len < min_len){
     var
      new_len = Stdlib_Int[11].call(null, len * 2 | 0, min_len),
      new_str = caml_create_bytes(new_len);
     Stdlib_Bytes[11].call(null, buf[2], 0, new_str, 0, len);
     buf[2] = new_str;
    }
   }
   function buffer_add_char(buf, c){
    buffer_check_size(buf, 1);
    caml_bytes_set(buf[2], buf[1], c);
    buf[1] = buf[1] + 1 | 0;
   }
   function buffer_add_string(buf, s){
    var str_len = caml_ml_string_length(s);
    buffer_check_size(buf, str_len);
    Stdlib_String[48].call(null, s, 0, buf[2], buf[1], str_len);
    buf[1] = buf[1] + str_len | 0;
   }
   function buffer_contents(buf){
    return Stdlib_Bytes[8].call(null, buf[2], 0, buf[1]);
   }
   function char_of_iconv(iconv){
    switch(iconv){
      case 6:
      case 7:
       return 120;
      case 8:
      case 9:
       return 88;
      case 10:
      case 11:
       return 111;
      case 12:
      case 15:
       return 117;
      case 0:
      case 1:
      case 2:
      case 13:
       return 100;
      default: return 105;
    }
   }
   function char_of_fconv(opt, fconv){
    if(opt) var sth = opt[1], cF = sth; else var cF = 70;
    switch(fconv[2]){
      case 0:
       return 102;
      case 1:
       return 101;
      case 2:
       return 69;
      case 3:
       return 103;
      case 4:
       return 71;
      case 5:
       return cF;
      case 6:
       return 104;
      case 7:
       return 72;
      default: return 70;
    }
   }
   function bprint_char_set(buf, char_set){
    function print_char(buf, i){
     var c = Stdlib[29].call(null, i);
     return 37 === c
             ? (buffer_add_char(buf, 37), buffer_add_char(buf, 37))
             : 64
               === c
               ? (buffer_add_char(buf, 37), buffer_add_char(buf, 64))
               : buffer_add_char(buf, c);
    }
    buffer_add_char(buf, 91);
    var
     set =
       is_in_char_set(char_set, 0)
        ? (buffer_add_char(buf, 94), rev_char_set(char_set))
        : char_set;
    function is_alone(c){
     var
      after = Stdlib_Char[1].call(null, c + 1 | 0),
      before = Stdlib_Char[1].call(null, c - 1 | 0),
      a = is_in_char_set(set, c);
     if(a)
      var
       b = is_in_char_set(set, before),
       e = b ? is_in_char_set(set, after) : b,
       d = 1 - e;
     else
      var d = a;
     return d;
    }
    if(is_alone(93)) buffer_add_char(buf, 93);
    var i = 1;
    a:
    for(;;){
     b:
     if(i < 256){
      if(! is_in_char_set(set, Stdlib[29].call(null, i))){var i$0 = i + 1 | 0; i = i$0; continue;}
      var switcher = Stdlib[29].call(null, i) - 45 | 0;
      if(48 < switcher >>> 0){
       if(210 <= switcher){print_char(buf, 255); break b;}
      }
      else if(46 < switcher - 1 >>> 0){
       var i$2 = i + 1 | 0;
       i = i$2;
       continue;
      }
      var i$1 = i + 1 | 0;
      if(! is_in_char_set(set, Stdlib[29].call(null, i$1))){
       print_char(buf, i$1 - 1 | 0);
       var i$6 = i$1 + 1 | 0;
       i = i$6;
       continue;
      }
      var switcher$0 = Stdlib[29].call(null, i$1) - 45 | 0;
      if(48 < switcher$0 >>> 0){
       if(210 <= switcher$0){
        print_char(buf, 254);
        print_char(buf, 255);
        break b;
       }
      }
      else if
       (46 < switcher$0 - 1 >>> 0
        && ! is_in_char_set(set, Stdlib[29].call(null, i$1 + 1 | 0))){
       print_char(buf, i$1 - 1 | 0);
       var i$5 = i$1 + 1 | 0;
       i = i$5;
       continue;
      }
      if(! is_in_char_set(set, Stdlib[29].call(null, i$1 + 1 | 0))){
       print_char(buf, i$1 - 1 | 0);
       print_char(buf, i$1);
       var i$4 = i$1 + 2 | 0;
       i = i$4;
       continue;
      }
      var j = i$1 + 2 | 0, i$3 = i$1 - 1 | 0, j$0 = j;
      for(;;){
       if(256 !== j$0 && is_in_char_set(set, Stdlib[29].call(null, j$0))){var j$1 = j$0 + 1 | 0; j$0 = j$1; continue;}
       print_char(buf, i$3);
       print_char(buf, 45);
       print_char(buf, j$0 - 1 | 0);
       if(j$0 >= 256) break;
       var i$7 = j$0 + 1 | 0;
       i = i$7;
       continue a;
      }
     }
     if(is_alone(45)) buffer_add_char(buf, 45);
     return buffer_add_char(buf, 93);
    }
   }
   function bprint_padty(buf, padty){
    switch(padty){
      case 0:
       return buffer_add_char(buf, 45);
      case 1:
       return;
      default: return buffer_add_char(buf, 48);
    }
   }
   function bprint_ignored_flag(buf, ign_flag){
    return ign_flag ? buffer_add_char(buf, 95) : ign_flag;
   }
   function bprint_pad_opt(buf, pad_opt){
    if(! pad_opt) return;
    var width = pad_opt[1];
    return buffer_add_string(buf, Stdlib_Int[12].call(null, width));
   }
   function bprint_padding(buf, pad){
    if(typeof pad === "number") return;
    if(0 === pad[0]){
     var n = pad[2], padty = pad[1];
     bprint_padty(buf, padty);
     return buffer_add_string(buf, Stdlib_Int[12].call(null, n));
    }
    var padty$0 = pad[1];
    bprint_padty(buf, padty$0);
    return buffer_add_char(buf, 42);
   }
   function bprint_precision(buf, prec){
    if(typeof prec !== "number"){
     var n = prec[1];
     buffer_add_char(buf, 46);
     return buffer_add_string(buf, Stdlib_Int[12].call(null, n));
    }
    if(prec) return buffer_add_string(buf, cst);
   }
   function bprint_iconv_flag(buf, iconv){
    switch(iconv){
      case 1:
      case 4:
       return buffer_add_char(buf, 43);
      case 2:
      case 5:
       return buffer_add_char(buf, 32);
      case 7:
      case 9:
      case 11:
      case 13:
      case 14:
      case 15:
       return buffer_add_char(buf, 35);
      default: return;
    }
   }
   function bprint_altint_fmt(buf, ign_flag, iconv, pad, prec, c){
    buffer_add_char(buf, 37);
    bprint_ignored_flag(buf, ign_flag);
    bprint_iconv_flag(buf, iconv);
    bprint_padding(buf, pad);
    bprint_precision(buf, prec);
    buffer_add_char(buf, c);
    return buffer_add_char(buf, char_of_iconv(iconv));
   }
   function bprint_fconv_flag(buf, fconv){
    switch(fconv[1]){
      case 1:
       buffer_add_char(buf, 43); break;
      case 2:
       buffer_add_char(buf, 32); break;
    }
    if(8 <= fconv[2]) return buffer_add_char(buf, 35);
   }
   function string_of_formatting_lit(formatting_lit){
    if(typeof formatting_lit === "number")
     switch(formatting_lit){
       case 0:
        return cst$0;
       case 1:
        return cst$1;
       case 2:
        return cst$2;
       case 3:
        return cst$3;
       case 4:
        return cst$4;
       case 5:
        return cst$5;
       default: return cst$6;
     }
    if(2 === formatting_lit[0]){
     var c = formatting_lit[1], a = Stdlib_String[1].call(null, 1, c);
     return Stdlib[28].call(null, cst$7, a);
    }
    var str = formatting_lit[1];
    return str;
   }
   function bprint_char_literal(buf, chr){
    return 37 === chr
            ? buffer_add_string(buf, cst$8)
            : buffer_add_char(buf, chr);
   }
   function bprint_string_literal(buf, str){
    var a = caml_ml_string_length(str) - 1 | 0, b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      bprint_char_literal(buf, caml_string_get(str, i));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
   }
   function bprint_fmtty(buf, fmtty$15){
    var fmtty = fmtty$15;
    for(;;){
     if(typeof fmtty === "number") return;
     switch(fmtty[0]){
       case 0:
        var fmtty$0 = fmtty[1];
        buffer_add_string(buf, cst_c);
        fmtty = fmtty$0;
        break;
       case 1:
        var fmtty$1 = fmtty[1];
        buffer_add_string(buf, cst_s);
        fmtty = fmtty$1;
        break;
       case 2:
        var fmtty$2 = fmtty[1];
        buffer_add_string(buf, cst_i);
        fmtty = fmtty$2;
        break;
       case 3:
        var fmtty$3 = fmtty[1];
        buffer_add_string(buf, cst_li);
        fmtty = fmtty$3;
        break;
       case 4:
        var fmtty$4 = fmtty[1];
        buffer_add_string(buf, cst_ni);
        fmtty = fmtty$4;
        break;
       case 5:
        var fmtty$5 = fmtty[1];
        buffer_add_string(buf, cst_Li);
        fmtty = fmtty$5;
        break;
       case 6:
        var fmtty$6 = fmtty[1];
        buffer_add_string(buf, cst_f);
        fmtty = fmtty$6;
        break;
       case 7:
        var fmtty$7 = fmtty[1];
        buffer_add_string(buf, cst_B);
        fmtty = fmtty$7;
        break;
       case 8:
        var fmtty$8 = fmtty[2], sub_fmtty = fmtty[1];
        buffer_add_string(buf, cst$9);
        bprint_fmtty(buf, sub_fmtty);
        buffer_add_string(buf, cst$10);
        fmtty = fmtty$8;
        break;
       case 9:
        var fmtty$9 = fmtty[3], sub_fmtty$0 = fmtty[1];
        buffer_add_string(buf, cst$11);
        bprint_fmtty(buf, sub_fmtty$0);
        buffer_add_string(buf, cst$12);
        fmtty = fmtty$9;
        break;
       case 10:
        var fmtty$10 = fmtty[1];
        buffer_add_string(buf, cst_a);
        fmtty = fmtty$10;
        break;
       case 11:
        var fmtty$11 = fmtty[1];
        buffer_add_string(buf, cst_t);
        fmtty = fmtty$11;
        break;
       case 12:
        var fmtty$12 = fmtty[1];
        buffer_add_string(buf, cst$13);
        fmtty = fmtty$12;
        break;
       case 13:
        var fmtty$13 = fmtty[1];
        buffer_add_string(buf, cst_r);
        fmtty = fmtty$13;
        break;
       default:
        var fmtty$14 = fmtty[1];
        buffer_add_string(buf, cst_r$0);
        fmtty = fmtty$14;
     }
    }
   }
   function int_of_custom_arity(param){
    if(! param) return 0;
    var x = param[1];
    return 1 + int_of_custom_arity(x) | 0;
   }
   function string_of_fmt(fmt){
    var buf = buffer_create(16);
    function fmtiter(fmt$1, ign_flag$0){
     var fmt = fmt$1, ign_flag = ign_flag$0;
     for(;;){
      if(typeof fmt === "number") return;
      switch(fmt[0]){
        case 0:
         var rest = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         buffer_add_char(buf, 99);
         fmt = rest;
         ign_flag = 0;
         break;
        case 1:
         var rest$0 = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         buffer_add_char(buf, 67);
         fmt = rest$0;
         ign_flag = 0;
         break;
        case 2:
         var rest$1 = fmt[2], pad = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         bprint_padding(buf, pad);
         buffer_add_char(buf, 115);
         fmt = rest$1;
         ign_flag = 0;
         break;
        case 3:
         var rest$2 = fmt[2], pad$0 = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         bprint_padding(buf, pad$0);
         buffer_add_char(buf, 83);
         fmt = rest$2;
         ign_flag = 0;
         break;
        case 4:
         var rest$3 = fmt[4], prec = fmt[3], pad$1 = fmt[2], iconv = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         bprint_iconv_flag(buf, iconv);
         bprint_padding(buf, pad$1);
         bprint_precision(buf, prec);
         buffer_add_char(buf, char_of_iconv(iconv));
         fmt = rest$3;
         ign_flag = 0;
         break;
        case 5:
         var
          rest$4 = fmt[4],
          prec$0 = fmt[3],
          pad$2 = fmt[2],
          iconv$0 = fmt[1];
         bprint_altint_fmt(buf, ign_flag, iconv$0, pad$2, prec$0, 108);
         fmt = rest$4;
         ign_flag = 0;
         break;
        case 6:
         var
          rest$5 = fmt[4],
          prec$1 = fmt[3],
          pad$3 = fmt[2],
          iconv$1 = fmt[1];
         bprint_altint_fmt(buf, ign_flag, iconv$1, pad$3, prec$1, 110);
         fmt = rest$5;
         ign_flag = 0;
         break;
        case 7:
         var
          rest$6 = fmt[4],
          prec$2 = fmt[3],
          pad$4 = fmt[2],
          iconv$2 = fmt[1];
         bprint_altint_fmt(buf, ign_flag, iconv$2, pad$4, prec$2, 76);
         fmt = rest$6;
         ign_flag = 0;
         break;
        case 8:
         var rest$7 = fmt[4], prec$3 = fmt[3], pad$5 = fmt[2], fconv = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         bprint_fconv_flag(buf, fconv);
         bprint_padding(buf, pad$5);
         bprint_precision(buf, prec$3);
         buffer_add_char(buf, char_of_fconv(0, fconv));
         fmt = rest$7;
         ign_flag = 0;
         break;
        case 9:
         var rest$8 = fmt[2], pad$6 = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         bprint_padding(buf, pad$6);
         buffer_add_char(buf, 66);
         fmt = rest$8;
         ign_flag = 0;
         break;
        case 10:
         var rest$9 = fmt[1];
         buffer_add_string(buf, cst$14);
         fmt = rest$9;
         break;
        case 11:
         var rest$10 = fmt[2], str = fmt[1];
         bprint_string_literal(buf, str);
         fmt = rest$10;
         break;
        case 12:
         var rest$11 = fmt[2], chr = fmt[1];
         bprint_char_literal(buf, chr);
         fmt = rest$11;
         break;
        case 13:
         var rest$12 = fmt[3], fmtty = fmt[2], pad_opt = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         bprint_pad_opt(buf, pad_opt);
         buffer_add_char(buf, 123);
         bprint_fmtty(buf, fmtty);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 125);
         fmt = rest$12;
         ign_flag = 0;
         break;
        case 14:
         var rest$13 = fmt[3], fmtty$0 = fmt[2], pad_opt$0 = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         bprint_pad_opt(buf, pad_opt$0);
         buffer_add_char(buf, 40);
         bprint_fmtty(buf, fmtty$0);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 41);
         fmt = rest$13;
         ign_flag = 0;
         break;
        case 15:
         var rest$14 = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         buffer_add_char(buf, 97);
         fmt = rest$14;
         ign_flag = 0;
         break;
        case 16:
         var rest$15 = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         buffer_add_char(buf, 116);
         fmt = rest$15;
         ign_flag = 0;
         break;
        case 17:
         var rest$16 = fmt[2], fmting_lit = fmt[1];
         bprint_string_literal(buf, string_of_formatting_lit(fmting_lit));
         fmt = rest$16;
         break;
        case 18:
         var rest$17 = fmt[2], fmting_gen = fmt[1];
         if(0 === fmting_gen[0]){
          var str$0 = fmting_gen[1][2];
          buffer_add_string(buf, cst$15);
          buffer_add_string(buf, str$0);
          fmt = rest$17;
         }
         else{
          var str$1 = fmting_gen[1][2];
          buffer_add_string(buf, cst$16);
          buffer_add_string(buf, str$1);
          fmt = rest$17;
         }
         break;
        case 19:
         var rest$18 = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         buffer_add_char(buf, 114);
         fmt = rest$18;
         ign_flag = 0;
         break;
        case 20:
         var rest$19 = fmt[3], char_set = fmt[2], width_opt = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         bprint_pad_opt(buf, width_opt);
         bprint_char_set(buf, char_set);
         fmt = rest$19;
         ign_flag = 0;
         break;
        case 21:
         var rest$20 = fmt[2], counter = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         switch(counter){
           case 0:
            var a = 108; break;
           case 1:
            var a = 110; break;
           default: var a = 78;
         }
         buffer_add_char(buf, a);
         fmt = rest$20;
         ign_flag = 0;
         break;
        case 22:
         var rest$21 = fmt[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag);
         bprint_string_literal(buf, cst_0c);
         fmt = rest$21;
         ign_flag = 0;
         break;
        case 23:
         var
          rest$22 = fmt[2],
          ign = fmt[1],
          fmt$0 = param_format_of_ignored_format(ign, rest$22)[1];
         fmt = fmt$0;
         ign_flag = 1;
         break;
        default:
         var
          rest$23 = fmt[3],
          arity = fmt[1],
          b = int_of_custom_arity(arity),
          c = 1;
         if(b >= 1){
          var i = c;
          for(;;){
           buffer_add_char(buf, 37);
           bprint_ignored_flag(buf, ign_flag);
           buffer_add_char(buf, 63);
           var d = i + 1 | 0;
           if(b === i) break;
           i = d;
          }
         }
         fmt = rest$23;
         ign_flag = 0;
      }
     }
    }
    fmtiter(fmt, 0);
    return buffer_contents(buf);
   }
   function symm(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, symm(rest)];
      case 1:
       var rest$0 = param[1]; return [1, symm(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, symm(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, symm(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, symm(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, symm(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, symm(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, symm(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1]; return [8, ty, symm(rest$7)];
      case 9:
       var rest$8 = param[3], ty2 = param[2], ty1 = param[1];
       return [9, ty2, ty1, symm(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, symm(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, symm(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, symm(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, symm(rest$12)];
      default: var rest$13 = param[1]; return [14, symm(rest$13)];
    }
   }
   function fmtty_rel_det(param){
    if(typeof param === "number")
     return [0, , function(param){}, , function(param){}];
    switch(param[0]){
      case 0:
       var
        rest = param[1],
        match = fmtty_rel_det(rest),
        de = match[4],
        af = match[2];
       return [0, , function(param){af(0);}, , de];
      case 1:
       var
        rest$0 = param[1],
        match$0 = fmtty_rel_det(rest$0),
        de$0 = match$0[4],
        af$0 = match$0[2];
       return [0, , function(param){af$0(0);}, , de$0];
      case 2:
       var
        rest$1 = param[1],
        match$1 = fmtty_rel_det(rest$1),
        de$1 = match$1[4],
        af$1 = match$1[2];
       return [0, , function(param){af$1(0);}, , de$1];
      case 3:
       var
        rest$2 = param[1],
        match$2 = fmtty_rel_det(rest$2),
        de$2 = match$2[4],
        af$2 = match$2[2];
       return [0, , function(param){af$2(0);}, , de$2];
      case 4:
       var
        rest$3 = param[1],
        match$3 = fmtty_rel_det(rest$3),
        de$3 = match$3[4],
        af$3 = match$3[2];
       return [0, , function(param){af$3(0);}, , de$3];
      case 5:
       var
        rest$4 = param[1],
        match$4 = fmtty_rel_det(rest$4),
        de$4 = match$4[4],
        af$4 = match$4[2];
       return [0, , function(param){af$4(0);}, , de$4];
      case 6:
       var
        rest$5 = param[1],
        match$5 = fmtty_rel_det(rest$5),
        de$5 = match$5[4],
        af$5 = match$5[2];
       return [0, , function(param){af$5(0);}, , de$5];
      case 7:
       var
        rest$6 = param[1],
        match$6 = fmtty_rel_det(rest$6),
        de$6 = match$6[4],
        af$6 = match$6[2];
       return [0, , function(param){af$6(0);}, , de$6];
      case 8:
       var
        rest$7 = param[2],
        match$7 = fmtty_rel_det(rest$7),
        de$7 = match$7[4],
        af$7 = match$7[2];
       return [0, , function(param){af$7(0);}, , de$7];
      case 9:
       var
        rest$8 = param[3],
        ty2 = param[2],
        ty1 = param[1],
        match$8 = fmtty_rel_det(rest$8),
        de$8 = match$8[4],
        af$8 = match$8[2],
        ty = trans(symm(ty1), ty2),
        match$9 = fmtty_rel_det(ty),
        jd = match$9[4],
        ga = match$9[2];
       return [0,
               ,
               function(param){ga(0); af$8(0);},
               ,
               function(param){jd(0); de$8(0);}];
      case 10:
       var
        rest$9 = param[1],
        match$10 = fmtty_rel_det(rest$9),
        de$9 = match$10[4],
        af$9 = match$10[2];
       return [0, , function(param){af$9(0);}, , de$9];
      case 11:
       var
        rest$10 = param[1],
        match$11 = fmtty_rel_det(rest$10),
        de$10 = match$11[4],
        af$10 = match$11[2];
       return [0, , function(param){af$10(0);}, , de$10];
      case 12:
       var
        rest$11 = param[1],
        match$12 = fmtty_rel_det(rest$11),
        de$11 = match$12[4],
        af$11 = match$12[2];
       return [0, , function(param){af$11(0);}, , de$11];
      case 13:
       var
        rest$12 = param[1],
        match$13 = fmtty_rel_det(rest$12),
        de$12 = match$13[4],
        af$12 = match$13[2];
       return [0, , function(param){af$12(0);}, , function(param){de$12(0);}];
      default:
       var
        rest$13 = param[1],
        match$14 = fmtty_rel_det(rest$13),
        de$13 = match$14[4],
        af$13 = match$14[2];
       return [0, , function(param){af$13(0);}, , function(param){de$13(0);}];
    }
   }
   function trans(ty1, ty2){
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           if(typeof ty1 !== "number"){
            switch(ty1[0]){
              case 0:
               var rest1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 0:
                   var rest2 = ty2[1]; return [0, trans(rest1, rest2)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                  case 8:
                   break f;
                  case 9:
                   break g;
                }
               break;
              case 1:
               var rest1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 1:
                   var rest2$0 = ty2[1]; return [1, trans(rest1$0, rest2$0)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                  case 8:
                   break f;
                  case 9:
                   break g;
                }
               break;
              case 2:
               var rest1$1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 2:
                   var rest2$1 = ty2[1]; return [2, trans(rest1$1, rest2$1)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                  case 8:
                   break f;
                  case 9:
                   break g;
                }
               break;
              case 3:
               var rest1$2 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 3:
                   var rest2$2 = ty2[1]; return [3, trans(rest1$2, rest2$2)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                  case 8:
                   break f;
                  case 9:
                   break g;
                }
               break;
              case 4:
               var rest1$3 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 4:
                   var rest2$3 = ty2[1]; return [4, trans(rest1$3, rest2$3)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                  case 8:
                   break f;
                  case 9:
                   break g;
                }
               break;
              case 5:
               var rest1$4 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 5:
                   var rest2$4 = ty2[1]; return [5, trans(rest1$4, rest2$4)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                  case 8:
                   break f;
                  case 9:
                   break g;
                }
               break;
              case 6:
               var rest1$5 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 6:
                   var rest2$5 = ty2[1]; return [6, trans(rest1$5, rest2$5)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                  case 8:
                   break f;
                  case 9:
                   break g;
                }
               break;
              case 7:
               var rest1$6 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 7:
                   var rest2$6 = ty2[1]; return [7, trans(rest1$6, rest2$6)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                  case 8:
                   break f;
                  case 9:
                   break g;
                }
               break;
              case 8:
               var rest1$7 = ty1[2], ty1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   var
                    rest2$7 = ty2[2],
                    ty2$0 = ty2[1],
                    a = trans(rest1$7, rest2$7);
                   return [8, trans(ty1$0, ty2$0), a];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, k], 1);
              case 9:
               var rest1$8 = ty1[3], ty12 = ty1[2], ty11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 9:
                   var
                    rest2$8 = ty2[3],
                    ty22 = ty2[2],
                    ty21 = ty2[1],
                    ty = trans(symm(ty12), ty21),
                    match = fmtty_rel_det(ty),
                    f4 = match[4],
                    f2 = match[2];
                   f2(0);
                   f4(0);
                   return [9, ty11, ty22, trans(rest1$8, rest2$8)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                  case 8:
                   break f;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, l], 1);
              case 10:
               var rest1$9 = ty1[1];
               if(typeof ty2 !== "number" && 10 === ty2[0]){
                var rest2$9 = ty2[1];
                return [10, trans(rest1$9, rest2$9)];
               }
               throw caml_maybe_attach_backtrace([0, Assert_failure, m], 1);
              case 11:
               var rest1$10 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 11:
                   var rest2$10 = ty2[1];
                   return [11, trans(rest1$10, rest2$10)];
                  case 10:
                   break a;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, n], 1);
              case 12:
               var rest1$11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 12:
                   var rest2$11 = ty2[1];
                   return [12, trans(rest1$11, rest2$11)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, o], 1);
              case 13:
               var rest1$12 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 13:
                   var rest2$12 = ty2[1];
                   return [13, trans(rest1$12, rest2$12)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, p], 1);
              default:
               var rest1$13 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 14:
                   var rest2$13 = ty2[1];
                   return [14, trans(rest1$13, rest2$13)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, q], 1);
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, j], 1);
           }
           if(typeof ty2 === "number") return 0;
           switch(ty2[0]){
             case 10:
              break a;
             case 11:
              break b;
             case 12:
              break c;
             case 13:
              break d;
             case 14:
              break e;
             case 8:
              break f;
             case 9: break;
             default:
              throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
           }
          }
          throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
        }
        throw caml_maybe_attach_backtrace([0, Assert_failure, i], 1);
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, h], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, g], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, f], 1);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, e], 1);
   }
   function fmtty_of_fmt(fmtty$4){
    var fmtty = fmtty$4;
    for(;;){
     if(typeof fmtty === "number") return 0;
     switch(fmtty[0]){
       case 4:
        var
         rest$1 = fmtty[4],
         prec = fmtty[3],
         pad$0 = fmtty[2],
         ty_rest = fmtty_of_fmt(rest$1),
         prec_ty = fmtty_of_precision_fmtty(prec, [2, ty_rest]);
        return fmtty_of_padding_fmtty(pad$0, prec_ty);
       case 5:
        var
         rest$2 = fmtty[4],
         prec$0 = fmtty[3],
         pad$1 = fmtty[2],
         ty_rest$0 = fmtty_of_fmt(rest$2),
         prec_ty$0 = fmtty_of_precision_fmtty(prec$0, [3, ty_rest$0]);
        return fmtty_of_padding_fmtty(pad$1, prec_ty$0);
       case 6:
        var
         rest$3 = fmtty[4],
         prec$1 = fmtty[3],
         pad$2 = fmtty[2],
         ty_rest$1 = fmtty_of_fmt(rest$3),
         prec_ty$1 = fmtty_of_precision_fmtty(prec$1, [4, ty_rest$1]);
        return fmtty_of_padding_fmtty(pad$2, prec_ty$1);
       case 7:
        var
         rest$4 = fmtty[4],
         prec$2 = fmtty[3],
         pad$3 = fmtty[2],
         ty_rest$2 = fmtty_of_fmt(rest$4),
         prec_ty$2 = fmtty_of_precision_fmtty(prec$2, [5, ty_rest$2]);
        return fmtty_of_padding_fmtty(pad$3, prec_ty$2);
       case 8:
        var
         rest$5 = fmtty[4],
         prec$3 = fmtty[3],
         pad$4 = fmtty[2],
         ty_rest$3 = fmtty_of_fmt(rest$5),
         prec_ty$3 = fmtty_of_precision_fmtty(prec$3, [6, ty_rest$3]);
        return fmtty_of_padding_fmtty(pad$4, prec_ty$3);
       case 9:
        var rest$6 = fmtty[2], pad$5 = fmtty[1];
        return fmtty_of_padding_fmtty(pad$5, [7, fmtty_of_fmt(rest$6)]);
       case 10:
        var fmtty$0 = fmtty[1]; fmtty = fmtty$0; break;
       case 13:
        var rest$7 = fmtty[3], ty = fmtty[2];
        return [8, ty, fmtty_of_fmt(rest$7)];
       case 14:
        var rest$8 = fmtty[3], ty$0 = fmtty[2];
        return [9, ty$0, ty$0, fmtty_of_fmt(rest$8)];
       case 15:
        var rest$9 = fmtty[1]; return [10, fmtty_of_fmt(rest$9)];
       case 16:
        var rest$10 = fmtty[1]; return [11, fmtty_of_fmt(rest$10)];
       case 18:
        var
         rest$11 = fmtty[2],
         formatting_gen = fmtty[1],
         b = fmtty_of_fmt(rest$11);
        if(0 === formatting_gen[0])
         var fmt = formatting_gen[1][1], a = fmtty_of_fmt(fmt);
        else
         var fmt$0 = formatting_gen[1][1], a = fmtty_of_fmt(fmt$0);
        return CamlinternalFormatBasics[1].call(null, a, b);
       case 19:
        var rest$12 = fmtty[1]; return [13, fmtty_of_fmt(rest$12)];
       case 20:
        var rest$13 = fmtty[3]; return [1, fmtty_of_fmt(rest$13)];
       case 21:
        var rest$14 = fmtty[2]; return [2, fmtty_of_fmt(rest$14)];
       case 23:
        var fmtty$2 = fmtty[2], ign = fmtty[1];
        if(typeof ign === "number"){
         if(2 === ign) return [14, fmtty_of_fmt(fmtty$2)];
         fmtty = fmtty$2;
        }
        else{
         if(9 === ign[0]){
          var fmtty$3 = ign[2], c = fmtty_of_fmt(fmtty$2);
          return CamlinternalFormatBasics[1].call(null, fmtty$3, c);
         }
         fmtty = fmtty$2;
        }
        break;
       case 24:
        var rest$15 = fmtty[3], arity = fmtty[1];
        return fmtty_of_custom(arity, fmtty_of_fmt(rest$15));
       case 2:
       case 3:
        var rest$0 = fmtty[2], pad = fmtty[1];
        return fmtty_of_padding_fmtty(pad, [1, fmtty_of_fmt(rest$0)]);
       case 0:
       case 1:
       case 22:
        var rest = fmtty[1]; return [0, fmtty_of_fmt(rest)];
       default: var fmtty$1 = fmtty[2]; fmtty = fmtty$1;
     }
    }
   }
   function fmtty_of_custom(arity, fmtty){
    if(! arity) return fmtty;
    var arity$0 = arity[1];
    return [12, fmtty_of_custom(arity$0, fmtty)];
   }
   function fmtty_of_padding_fmtty(pad, fmtty){
    return typeof pad === "number" ? fmtty : 0 === pad[0] ? fmtty : [2, fmtty];
   }
   function fmtty_of_precision_fmtty(prec, fmtty){
    return typeof prec === "number" ? prec ? [2, fmtty] : fmtty : fmtty;
   }
   var
    Type_mismatch =
      [248, "CamlinternalFormat.Type_mismatch", runtime.caml_fresh_oo_id(0)],
    cst_d$0 = "%+d",
    cst_d$1 = "% d",
    cst_i$1 = "%+i",
    cst_i$2 = "% i",
    cst_x = "%x",
    cst_x$0 = "%#x",
    cst_X = "%X",
    cst_X$0 = "%#X",
    cst_o = "%o",
    cst_o$0 = "%#o",
    cst_Ld$0 = "%+Ld",
    cst_Ld$1 = "% Ld",
    cst_Li$1 = "%+Li",
    cst_Li$2 = "% Li",
    cst_Lx = "%Lx",
    cst_Lx$0 = "%#Lx",
    cst_LX = "%LX",
    cst_LX$0 = "%#LX",
    cst_Lo = "%Lo",
    cst_Lo$0 = "%#Lo",
    cst_ld$0 = "%+ld",
    cst_ld$1 = "% ld",
    cst_li$1 = "%+li",
    cst_li$2 = "% li",
    cst_lx = "%lx",
    cst_lx$0 = "%#lx",
    cst_lX = "%lX",
    cst_lX$0 = "%#lX",
    cst_lo = "%lo",
    cst_lo$0 = "%#lo",
    cst_nd$0 = "%+nd",
    cst_nd$1 = "% nd",
    cst_ni$1 = "%+ni",
    cst_ni$2 = "% ni",
    cst_nx = "%nx",
    cst_nx$0 = "%#nx",
    cst_nX = "%nX",
    cst_nX$0 = "%#nX",
    cst_no = "%no",
    cst_no$0 = "%#no",
    r = [0, 103],
    cst_neg_infinity = "neg_infinity",
    cst_infinity = "infinity",
    cst_nan = "nan",
    s = [0, cst_camlinternalFormat_ml, 1558, 4],
    cst_Printf_bad_conversion = "Printf: bad conversion %[",
    t = [0, cst_camlinternalFormat_ml, 1626, 39],
    u = [0, cst_camlinternalFormat_ml, 1649, 31],
    v = [0, cst_camlinternalFormat_ml, 1650, 31],
    cst_Printf_bad_conversion$0 = "Printf: bad conversion %_",
    w = [0, cst_camlinternalFormat_ml, 1830, 8],
    x = [0, 0, 4],
    y =
      [0,
       [11, "invalid box description ", [3, 0, 0]],
       "invalid box description %S"],
    z =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11, cst_at_character_number, [4, 0, 0, 0, [11, cst$44, [2, 0, 0]]]]]],
       "invalid format %S: at character number %d, %s"],
    cst_non_zero_widths_are_unsupp =
      "non-zero widths are unsupported for %c conversions",
    A =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", '", [0, [11, "' without ", [2, 0, 0]]]]]]]],
       "invalid format %S: at character number %d, '%c' without %s"],
    B =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, cst$44, [2, 0, [11, " expected, read ", [1, 0]]]]]]]],
       "invalid format %S: at character number %d, %s expected, read %C"],
    C =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", duplicate flag ", [1, 0]]]]]],
       "invalid format %S: at character number %d, duplicate flag %C"],
    cst_padding = "padding",
    D = [0, 1, 0],
    cst_0 = cst_0$3,
    E = [0, 0],
    cst_precision = cst_precision$3,
    F = [1, 0],
    G = [1, 1],
    cst_precision$0 = cst_precision$3,
    H = [1, 1],
    cst_precision$1 = cst_precision$3,
    cst_0$0 = cst_0$3,
    I = [1, 1],
    cst_0$1 = cst_0$3,
    cst_0$2 = "'0'",
    J =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11, ', invalid conversion "', [12, 37, [0, [12, 34, 0]]]]]]]],
       'invalid format %S: at character number %d, invalid conversion "%%%c"'],
    K = [0, 0],
    cst_padding$0 = "`padding'",
    L = [0, 0],
    cst_precision$2 = "`precision'",
    M =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            ", flag ",
            [1,
             [11,
              " is only allowed after the '",
              [12, 37, [11, "', before padding and precision", 0]]]]]]]]],
       "invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision"],
    N = [0, [12, 64, 0]],
    O = [0, "@ ", 1, 0],
    P = [0, "@,", 0, 0],
    Q = [2, 60],
    R =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": '",
          [12,
           37,
           [11,
            "' alone is not accepted in character sets, use ",
            [12,
             37,
             [12,
              37,
              [11, " instead at position ", [4, 0, 0, 0, [12, 46, 0]]]]]]]]]],
       "invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d."],
    S =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": integer ",
          [4, 0, 0, 0, [11, " is greater than the limit ", [4, 0, 0, 0, 0]]]]]],
       "invalid format %S: integer %d is greater than the limit %d"],
    T = [0, cst_camlinternalFormat_ml, 2837, 11],
    cst_digit = "digit",
    U =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ': unclosed sub-format, expected "',
          [12, 37, [0, [11, '" at character number ', [4, 0, 0, 0, 0]]]]]]],
       'invalid format %S: unclosed sub-format, expected "%%%c" at character number %d'],
    cst_character = "character ')'",
    cst_character$0 = "character '}'",
    V = [0, cst_camlinternalFormat_ml, 2899, 34],
    W = [0, cst_camlinternalFormat_ml, 2935, 28],
    X = [0, cst_camlinternalFormat_ml, 2957, 11],
    Y =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            cst$44,
            [2,
             0,
             [11,
              " is incompatible with '",
              [0, [11, "' in sub-format ", [3, 0, 0]]]]]]]]]],
       "invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S"],
    Z =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0],
    _ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0];
   function type_padding(pad, fmtty){
    if(typeof pad === "number") return [0, 0, fmtty];
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     return [0, [0, padty, w], fmtty];
    }
    if(typeof fmtty !== "number" && 2 === fmtty[0]){
     var rest = fmtty[1], padty$0 = pad[1];
     return [0, [1, padty$0], rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_padprec(pad, prec, fmtty){
    var match = type_padding(pad, fmtty);
    if(typeof prec !== "number"){
     var rest$1 = match[2], pad$2 = match[1], p = prec[1];
     return [0, pad$2, [0, p], rest$1];
    }
    if(! prec){
     var rest$0 = match[2], pad$1 = match[1];
     return [0, pad$1, 0, rest$0];
    }
    var match$0 = match[2];
    if(typeof match$0 !== "number" && 2 === match$0[0]){
     var rest = match$0[1], pad$0 = match[1];
     return [0, pad$0, 1, rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_format(fmt, fmtty){
    var a = type_format_gen(fmt, fmtty);
    if(typeof a[2] !== "number")
     throw caml_maybe_attach_backtrace(Type_mismatch, 1);
    var fmt$0 = a[1];
    return fmt$0;
   }
   function type_format_gen(fmt, fmtty0){
    if(typeof fmt === "number") return [0, 0, fmtty0];
    switch(fmt[0]){
      case 0:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest = fmtty0[1],
         fmt_rest = fmt[1],
         match = type_format_gen(fmt_rest, fmtty_rest),
         fmtty = match[2],
         fmt$0 = match[1];
        return [0, [0, fmt$0], fmtty];
       }
       break;
      case 1:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest$0 = fmtty0[1],
         fmt_rest$0 = fmt[1],
         match$0 = type_format_gen(fmt_rest$0, fmtty_rest$0),
         fmtty$0 = match$0[2],
         fmt$1 = match$0[1];
        return [0, [1, fmt$1], fmtty$0];
       }
       break;
      case 2:
       var
        fmt_rest$1 = fmt[2],
        pad = fmt[1],
        match$1 = type_padding(pad, fmtty0),
        pad$0 = match$1[1],
        match$2 = match$1[2];
       if(typeof match$2 !== "number" && 1 === match$2[0]){
        var
         fmtty_rest$1 = match$2[1],
         match$3 = type_format_gen(fmt_rest$1, fmtty_rest$1),
         fmtty$1 = match$3[2],
         fmt$2 = match$3[1];
        return [0, [2, pad$0, fmt$2], fmtty$1];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 3:
       var
        fmt_rest$2 = fmt[2],
        pad$1 = fmt[1],
        match$4 = type_padding(pad$1, fmtty0),
        pad$2 = match$4[1],
        match$5 = match$4[2];
       if(typeof match$5 !== "number" && 1 === match$5[0]){
        var
         fmtty_rest$2 = match$5[1],
         match$6 = type_format_gen(fmt_rest$2, fmtty_rest$2),
         fmtty$2 = match$6[2],
         fmt$3 = match$6[1];
        return [0, [3, pad$2, fmt$3], fmtty$2];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 4:
       var
        fmt_rest$3 = fmt[4],
        prec = fmt[3],
        pad$3 = fmt[2],
        iconv = fmt[1],
        match$7 = type_padprec(pad$3, prec, fmtty0),
        pad$4 = match$7[1],
        match$8 = match$7[3];
       if(typeof match$8 !== "number" && 2 === match$8[0]){
        var
         fmtty_rest$3 = match$8[1],
         prec$0 = match$7[2],
         match$9 = type_format_gen(fmt_rest$3, fmtty_rest$3),
         fmtty$3 = match$9[2],
         fmt$4 = match$9[1];
        return [0, [4, iconv, pad$4, prec$0, fmt$4], fmtty$3];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 5:
       var
        fmt_rest$4 = fmt[4],
        prec$1 = fmt[3],
        pad$5 = fmt[2],
        iconv$0 = fmt[1],
        match$10 = type_padprec(pad$5, prec$1, fmtty0),
        pad$6 = match$10[1],
        match$11 = match$10[3];
       if(typeof match$11 !== "number" && 3 === match$11[0]){
        var
         fmtty_rest$4 = match$11[1],
         prec$2 = match$10[2],
         match$12 = type_format_gen(fmt_rest$4, fmtty_rest$4),
         fmtty$4 = match$12[2],
         fmt$5 = match$12[1];
        return [0, [5, iconv$0, pad$6, prec$2, fmt$5], fmtty$4];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 6:
       var
        fmt_rest$5 = fmt[4],
        prec$3 = fmt[3],
        pad$7 = fmt[2],
        iconv$1 = fmt[1],
        match$13 = type_padprec(pad$7, prec$3, fmtty0),
        pad$8 = match$13[1],
        match$14 = match$13[3];
       if(typeof match$14 !== "number" && 4 === match$14[0]){
        var
         fmtty_rest$5 = match$14[1],
         prec$4 = match$13[2],
         match$15 = type_format_gen(fmt_rest$5, fmtty_rest$5),
         fmtty$5 = match$15[2],
         fmt$6 = match$15[1];
        return [0, [6, iconv$1, pad$8, prec$4, fmt$6], fmtty$5];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 7:
       var
        fmt_rest$6 = fmt[4],
        prec$5 = fmt[3],
        pad$9 = fmt[2],
        iconv$2 = fmt[1],
        match$16 = type_padprec(pad$9, prec$5, fmtty0),
        pad$10 = match$16[1],
        match$17 = match$16[3];
       if(typeof match$17 !== "number" && 5 === match$17[0]){
        var
         fmtty_rest$6 = match$17[1],
         prec$6 = match$16[2],
         match$18 = type_format_gen(fmt_rest$6, fmtty_rest$6),
         fmtty$6 = match$18[2],
         fmt$7 = match$18[1];
        return [0, [7, iconv$2, pad$10, prec$6, fmt$7], fmtty$6];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 8:
       var
        fmt_rest$7 = fmt[4],
        prec$7 = fmt[3],
        pad$11 = fmt[2],
        fconv = fmt[1],
        match$19 = type_padprec(pad$11, prec$7, fmtty0),
        pad$12 = match$19[1],
        match$20 = match$19[3];
       if(typeof match$20 !== "number" && 6 === match$20[0]){
        var
         fmtty_rest$7 = match$20[1],
         prec$8 = match$19[2],
         match$21 = type_format_gen(fmt_rest$7, fmtty_rest$7),
         fmtty$7 = match$21[2],
         fmt$8 = match$21[1];
        return [0, [8, fconv, pad$12, prec$8, fmt$8], fmtty$7];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 9:
       var
        fmt_rest$8 = fmt[2],
        pad$13 = fmt[1],
        match$22 = type_padding(pad$13, fmtty0),
        pad$14 = match$22[1],
        match$23 = match$22[2];
       if(typeof match$23 !== "number" && 7 === match$23[0]){
        var
         fmtty_rest$8 = match$23[1],
         match$24 = type_format_gen(fmt_rest$8, fmtty_rest$8),
         fmtty$8 = match$24[2],
         fmt$9 = match$24[1];
        return [0, [9, pad$14, fmt$9], fmtty$8];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 10:
       var
        fmt_rest$9 = fmt[1],
        match$25 = type_format_gen(fmt_rest$9, fmtty0),
        fmtty$9 = match$25[2],
        fmt$10 = match$25[1];
       return [0, [10, fmt$10], fmtty$9];
      case 11:
       var
        fmt_rest$10 = fmt[2],
        str = fmt[1],
        match$26 = type_format_gen(fmt_rest$10, fmtty0),
        fmtty$10 = match$26[2],
        fmt$11 = match$26[1];
       return [0, [11, str, fmt$11], fmtty$10];
      case 12:
       var
        fmt_rest$11 = fmt[2],
        chr = fmt[1],
        match$27 = type_format_gen(fmt_rest$11, fmtty0),
        fmtty$11 = match$27[2],
        fmt$12 = match$27[1];
       return [0, [12, chr, fmt$12], fmtty$11];
      case 13:
       if(typeof fmtty0 !== "number" && 8 === fmtty0[0]){
        var
         fmtty_rest$9 = fmtty0[2],
         sub_fmtty = fmtty0[1],
         fmt_rest$12 = fmt[3],
         sub_fmtty$0 = fmt[2],
         pad_opt = fmt[1];
        if(caml_notequal([0, sub_fmtty$0], [0, sub_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$28 = type_format_gen(fmt_rest$12, fmtty_rest$9),
         fmtty$12 = match$28[2],
         fmt$13 = match$28[1];
        return [0, [13, pad_opt, sub_fmtty, fmt$13], fmtty$12];
       }
       break;
      case 14:
       if(typeof fmtty0 !== "number" && 9 === fmtty0[0]){
        var
         fmtty_rest$10 = fmtty0[3],
         sub_fmtty1 = fmtty0[1],
         fmt_rest$13 = fmt[3],
         sub_fmtty$1 = fmt[2],
         pad_opt$0 = fmt[1],
         b = [0, CamlinternalFormatBasics[2].call(null, sub_fmtty1)];
        if
         (caml_notequal
           ([0, CamlinternalFormatBasics[2].call(null, sub_fmtty$1)], b))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$29 =
           type_format_gen
            (fmt_rest$13,
             CamlinternalFormatBasics[2].call(null, fmtty_rest$10)),
         fmtty$13 = match$29[2],
         fmt$14 = match$29[1];
        return [0, [14, pad_opt$0, sub_fmtty1, fmt$14], fmtty$13];
       }
       break;
      case 15:
       if(typeof fmtty0 !== "number" && 10 === fmtty0[0]){
        var
         fmtty_rest$11 = fmtty0[1],
         fmt_rest$14 = fmt[1],
         match$30 = type_format_gen(fmt_rest$14, fmtty_rest$11),
         fmtty$14 = match$30[2],
         fmt$15 = match$30[1];
        return [0, [15, fmt$15], fmtty$14];
       }
       break;
      case 16:
       if(typeof fmtty0 !== "number" && 11 === fmtty0[0]){
        var
         fmtty_rest$12 = fmtty0[1],
         fmt_rest$15 = fmt[1],
         match$31 = type_format_gen(fmt_rest$15, fmtty_rest$12),
         fmtty$15 = match$31[2],
         fmt$16 = match$31[1];
        return [0, [16, fmt$16], fmtty$15];
       }
       break;
      case 17:
       var
        fmt_rest$16 = fmt[2],
        formatting_lit = fmt[1],
        match$32 = type_format_gen(fmt_rest$16, fmtty0),
        fmtty$16 = match$32[2],
        fmt$17 = match$32[1];
       return [0, [17, formatting_lit, fmt$17], fmtty$16];
      case 18:
       var fmt_rest$17 = fmt[2], formatting_gen = fmt[1];
       if(0 === formatting_gen[0]){
        var
         match$36 = formatting_gen[1],
         str$0 = match$36[2],
         fmt1 = match$36[1],
         match$37 = type_format_gen(fmt1, fmtty0),
         fmtty2 = match$37[2],
         fmt2 = match$37[1],
         match$38 = type_format_gen(fmt_rest$17, fmtty2),
         fmtty3 = match$38[2],
         fmt3 = match$38[1];
        return [0, [18, [0, [0, fmt2, str$0]], fmt3], fmtty3];
       }
       var
        match$39 = formatting_gen[1],
        str$1 = match$39[2],
        fmt1$0 = match$39[1],
        match$40 = type_format_gen(fmt1$0, fmtty0),
        fmtty2$0 = match$40[2],
        fmt2$0 = match$40[1],
        match$41 = type_format_gen(fmt_rest$17, fmtty2$0),
        fmtty3$0 = match$41[2],
        fmt3$0 = match$41[1];
       return [0, [18, [1, [0, fmt2$0, str$1]], fmt3$0], fmtty3$0];
      case 19:
       if(typeof fmtty0 !== "number" && 13 === fmtty0[0]){
        var
         fmtty_rest$13 = fmtty0[1],
         fmt_rest$18 = fmt[1],
         match$33 = type_format_gen(fmt_rest$18, fmtty_rest$13),
         fmtty$17 = match$33[2],
         fmt$18 = match$33[1];
        return [0, [19, fmt$18], fmtty$17];
       }
       break;
      case 20:
       if(typeof fmtty0 !== "number" && 1 === fmtty0[0]){
        var
         fmtty_rest$14 = fmtty0[1],
         fmt_rest$19 = fmt[3],
         char_set = fmt[2],
         width_opt = fmt[1],
         match$34 = type_format_gen(fmt_rest$19, fmtty_rest$14),
         fmtty$18 = match$34[2],
         fmt$19 = match$34[1];
        return [0, [20, width_opt, char_set, fmt$19], fmtty$18];
       }
       break;
      case 21:
       if(typeof fmtty0 !== "number" && 2 === fmtty0[0]){
        var
         fmtty_rest$15 = fmtty0[1],
         fmt_rest$20 = fmt[2],
         counter = fmt[1],
         match$35 = type_format_gen(fmt_rest$20, fmtty_rest$15),
         fmtty$19 = match$35[2],
         fmt$20 = match$35[1];
        return [0, [21, counter, fmt$20], fmtty$19];
       }
       break;
      case 23:
       var rest = fmt[2], ign = fmt[1];
       if(typeof ign !== "number")
        switch(ign[0]){
          case 8:
           var sub_fmtty$2 = ign[2], pad_opt$1 = ign[1];
           return type_ignored_param_one
                   ([8, pad_opt$1, sub_fmtty$2], rest, fmtty0);
          case 9:
           var
            sub_fmtty$3 = ign[2],
            pad_opt$2 = ign[1],
            a = type_ignored_format_substituti(sub_fmtty$3, rest, fmtty0),
            match$43 = a[2],
            fmtty$21 = match$43[2],
            fmt$22 = match$43[1],
            sub_fmtty$4 = a[1];
           return [0, [23, [9, pad_opt$2, sub_fmtty$4], fmt$22], fmtty$21];
          default: return type_ignored_param_one(ign, rest, fmtty0);
        }
       if(2 !== ign) return type_ignored_param_one(ign, rest, fmtty0);
       if(typeof fmtty0 !== "number" && 14 === fmtty0[0]){
        var
         fmtty_rest$16 = fmtty0[1],
         match$42 = type_format_gen(rest, fmtty_rest$16),
         fmtty$20 = match$42[2],
         fmt$21 = match$42[1];
        return [0, [23, 2, fmt$21], fmtty$20];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_ignored_param_one(ign, fmt, fmtty){
    var
     match = type_format_gen(fmt, fmtty),
     fmtty$0 = match[2],
     fmt$0 = match[1];
    return [0, [23, ign, fmt$0], fmtty$0];
   }
   function type_ignored_format_substituti(sub_fmtty, fmt, fmtty){
    if(typeof sub_fmtty === "number")
     return [0, 0, type_format_gen(fmt, fmtty)];
    switch(sub_fmtty[0]){
      case 0:
       if(typeof fmtty !== "number" && 0 === fmtty[0]){
        var
         fmtty_rest = fmtty[1],
         sub_fmtty_rest = sub_fmtty[1],
         match =
           type_ignored_format_substituti(sub_fmtty_rest, fmt, fmtty_rest),
         fmt$0 = match[2],
         sub_fmtty_rest$0 = match[1];
        return [0, [0, sub_fmtty_rest$0], fmt$0];
       }
       break;
      case 1:
       if(typeof fmtty !== "number" && 1 === fmtty[0]){
        var
         fmtty_rest$0 = fmtty[1],
         sub_fmtty_rest$1 = sub_fmtty[1],
         match$0 =
           type_ignored_format_substituti(sub_fmtty_rest$1, fmt, fmtty_rest$0),
         fmt$1 = match$0[2],
         sub_fmtty_rest$2 = match$0[1];
        return [0, [1, sub_fmtty_rest$2], fmt$1];
       }
       break;
      case 2:
       if(typeof fmtty !== "number" && 2 === fmtty[0]){
        var
         fmtty_rest$1 = fmtty[1],
         sub_fmtty_rest$3 = sub_fmtty[1],
         match$1 =
           type_ignored_format_substituti(sub_fmtty_rest$3, fmt, fmtty_rest$1),
         fmt$2 = match$1[2],
         sub_fmtty_rest$4 = match$1[1];
        return [0, [2, sub_fmtty_rest$4], fmt$2];
       }
       break;
      case 3:
       if(typeof fmtty !== "number" && 3 === fmtty[0]){
        var
         fmtty_rest$2 = fmtty[1],
         sub_fmtty_rest$5 = sub_fmtty[1],
         match$2 =
           type_ignored_format_substituti(sub_fmtty_rest$5, fmt, fmtty_rest$2),
         fmt$3 = match$2[2],
         sub_fmtty_rest$6 = match$2[1];
        return [0, [3, sub_fmtty_rest$6], fmt$3];
       }
       break;
      case 4:
       if(typeof fmtty !== "number" && 4 === fmtty[0]){
        var
         fmtty_rest$3 = fmtty[1],
         sub_fmtty_rest$7 = sub_fmtty[1],
         match$3 =
           type_ignored_format_substituti(sub_fmtty_rest$7, fmt, fmtty_rest$3),
         fmt$4 = match$3[2],
         sub_fmtty_rest$8 = match$3[1];
        return [0, [4, sub_fmtty_rest$8], fmt$4];
       }
       break;
      case 5:
       if(typeof fmtty !== "number" && 5 === fmtty[0]){
        var
         fmtty_rest$4 = fmtty[1],
         sub_fmtty_rest$9 = sub_fmtty[1],
         match$4 =
           type_ignored_format_substituti(sub_fmtty_rest$9, fmt, fmtty_rest$4),
         fmt$5 = match$4[2],
         sub_fmtty_rest$10 = match$4[1];
        return [0, [5, sub_fmtty_rest$10], fmt$5];
       }
       break;
      case 6:
       if(typeof fmtty !== "number" && 6 === fmtty[0]){
        var
         fmtty_rest$5 = fmtty[1],
         sub_fmtty_rest$11 = sub_fmtty[1],
         match$5 =
           type_ignored_format_substituti
            (sub_fmtty_rest$11, fmt, fmtty_rest$5),
         fmt$6 = match$5[2],
         sub_fmtty_rest$12 = match$5[1];
        return [0, [6, sub_fmtty_rest$12], fmt$6];
       }
       break;
      case 7:
       if(typeof fmtty !== "number" && 7 === fmtty[0]){
        var
         fmtty_rest$6 = fmtty[1],
         sub_fmtty_rest$13 = sub_fmtty[1],
         match$6 =
           type_ignored_format_substituti
            (sub_fmtty_rest$13, fmt, fmtty_rest$6),
         fmt$7 = match$6[2],
         sub_fmtty_rest$14 = match$6[1];
        return [0, [7, sub_fmtty_rest$14], fmt$7];
       }
       break;
      case 8:
       if(typeof fmtty !== "number" && 8 === fmtty[0]){
        var
         fmtty_rest$7 = fmtty[2],
         sub2_fmtty = fmtty[1],
         sub_fmtty_rest$15 = sub_fmtty[2],
         sub2_fmtty$0 = sub_fmtty[1];
        if(caml_notequal([0, sub2_fmtty$0], [0, sub2_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$7 =
           type_ignored_format_substituti
            (sub_fmtty_rest$15, fmt, fmtty_rest$7),
         fmt$8 = match$7[2],
         sub_fmtty_rest$16 = match$7[1];
        return [0, [8, sub2_fmtty, sub_fmtty_rest$16], fmt$8];
       }
       break;
      case 9:
       if(typeof fmtty !== "number" && 9 === fmtty[0]){
        var
         fmtty_rest$8 = fmtty[3],
         sub2_fmtty$1 = fmtty[2],
         sub1_fmtty = fmtty[1],
         sub_fmtty_rest$17 = sub_fmtty[3],
         sub2_fmtty$2 = sub_fmtty[2],
         sub1_fmtty$0 = sub_fmtty[1],
         a = [0, CamlinternalFormatBasics[2].call(null, sub1_fmtty)];
        if
         (caml_notequal
           ([0, CamlinternalFormatBasics[2].call(null, sub1_fmtty$0)], a))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var b = [0, CamlinternalFormatBasics[2].call(null, sub2_fmtty$1)];
        if
         (caml_notequal
           ([0, CamlinternalFormatBasics[2].call(null, sub2_fmtty$2)], b))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         sub_fmtty$0 = trans(symm(sub1_fmtty), sub2_fmtty$1),
         match$8 = fmtty_rel_det(sub_fmtty$0),
         f4 = match$8[4],
         f2 = match$8[2];
        f2(0);
        f4(0);
        var
         match$9 =
           type_ignored_format_substituti
            (CamlinternalFormatBasics[2].call(null, sub_fmtty_rest$17),
             fmt,
             fmtty_rest$8),
         fmt$9 = match$9[2],
         sub_fmtty_rest$18 = match$9[1];
        return [0,
                [9, sub1_fmtty, sub2_fmtty$1, symm(sub_fmtty_rest$18)],
                fmt$9];
       }
       break;
      case 10:
       if(typeof fmtty !== "number" && 10 === fmtty[0]){
        var
         fmtty_rest$9 = fmtty[1],
         sub_fmtty_rest$19 = sub_fmtty[1],
         match$10 =
           type_ignored_format_substituti
            (sub_fmtty_rest$19, fmt, fmtty_rest$9),
         fmt$10 = match$10[2],
         sub_fmtty_rest$20 = match$10[1];
        return [0, [10, sub_fmtty_rest$20], fmt$10];
       }
       break;
      case 11:
       if(typeof fmtty !== "number" && 11 === fmtty[0]){
        var
         fmtty_rest$10 = fmtty[1],
         sub_fmtty_rest$21 = sub_fmtty[1],
         match$11 =
           type_ignored_format_substituti
            (sub_fmtty_rest$21, fmt, fmtty_rest$10),
         fmt$11 = match$11[2],
         sub_fmtty_rest$22 = match$11[1];
        return [0, [11, sub_fmtty_rest$22], fmt$11];
       }
       break;
      case 13:
       if(typeof fmtty !== "number" && 13 === fmtty[0]){
        var
         fmtty_rest$11 = fmtty[1],
         sub_fmtty_rest$23 = sub_fmtty[1],
         match$12 =
           type_ignored_format_substituti
            (sub_fmtty_rest$23, fmt, fmtty_rest$11),
         fmt$12 = match$12[2],
         sub_fmtty_rest$24 = match$12[1];
        return [0, [13, sub_fmtty_rest$24], fmt$12];
       }
       break;
      case 14:
       if(typeof fmtty !== "number" && 14 === fmtty[0]){
        var
         fmtty_rest$12 = fmtty[1],
         sub_fmtty_rest$25 = sub_fmtty[1],
         match$13 =
           type_ignored_format_substituti
            (sub_fmtty_rest$25, fmt, fmtty_rest$12),
         fmt$13 = match$13[2],
         sub_fmtty_rest$26 = match$13[1];
        return [0, [14, sub_fmtty_rest$26], fmt$13];
       }
       break;
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function recast(fmt, fmtty){
    var a = symm(fmtty);
    return type_format(fmt, CamlinternalFormatBasics[2].call(null, a));
   }
   function fix_padding(padty, width, str){
    var
     len = caml_ml_string_length(str),
     padty$0 = 0 <= width ? padty : 0,
     width$0 = Stdlib[18].call(null, width);
    if(width$0 <= len) return str;
    var
     a = 2 === padty$0 ? 48 : 32,
     res = Stdlib_Bytes[1].call(null, width$0, a);
    switch(padty$0){
      case 0:
       Stdlib_String[48].call(null, str, 0, res, 0, len); break;
      case 1:
       Stdlib_String[48].call(null, str, 0, res, width$0 - len | 0, len);
       break;
      default:
       a:
       if(0 < len){
        if
         (43 !== caml_string_get(str, 0)
          && 45 !== caml_string_get(str, 0) && 32 !== caml_string_get(str, 0))
         break a;
        caml_bytes_set(res, 0, caml_string_get(str, 0));
        Stdlib_String[48].call
         (null, str, 1, res, (width$0 - len | 0) + 1 | 0, len - 1 | 0);
        break;
       }
       a:
       if(1 < len && 48 === caml_string_get(str, 0)){
        if(120 !== caml_string_get(str, 1) && 88 !== caml_string_get(str, 1))
         break a;
        caml_bytes_set(res, 1, caml_string_get(str, 1));
        Stdlib_String[48].call
         (null, str, 2, res, (width$0 - len | 0) + 2 | 0, len - 2 | 0);
        break;
       }
       Stdlib_String[48].call(null, str, 0, res, width$0 - len | 0, len);
    }
    return Stdlib_Bytes[48].call(null, res);
   }
   function fix_int_precision(prec, str){
    var
     prec$0 = Stdlib[18].call(null, prec),
     len = caml_ml_string_length(str),
     c = caml_string_get(str, 0);
    a:
    {
     b:
     {
      if(58 > c){
       if(32 !== c){
        if(43 > c) break a;
        switch(c - 43 | 0){
          case 5:
           if(len >= (prec$0 + 2 | 0)) break b;
           if(1 >= len) break b;
           if
            (120 !== caml_string_get(str, 1) && 88 !== caml_string_get(str, 1))
            break b;
           var res$1 = Stdlib_Bytes[1].call(null, prec$0 + 2 | 0, 48);
           caml_bytes_set(res$1, 1, caml_string_get(str, 1));
           Stdlib_String[48].call
            (null, str, 2, res$1, (prec$0 - len | 0) + 4 | 0, len - 2 | 0);
           return Stdlib_Bytes[48].call(null, res$1);
          case 0:
          case 2: break;
          case 1:
          case 3:
          case 4:
           break a;
          default: break b;
        }
       }
       if(len >= (prec$0 + 1 | 0)) break a;
       var res$0 = Stdlib_Bytes[1].call(null, prec$0 + 1 | 0, 48);
       caml_bytes_set(res$0, 0, c);
       Stdlib_String[48].call
        (null, str, 1, res$0, (prec$0 - len | 0) + 2 | 0, len - 1 | 0);
       return Stdlib_Bytes[48].call(null, res$0);
      }
      if(71 <= c){if(5 < c - 97 >>> 0) break a;} else if(65 > c) break a;
     }
     if(len < prec$0){
      var res = Stdlib_Bytes[1].call(null, prec$0, 48);
      Stdlib_String[48].call(null, str, 0, res, prec$0 - len | 0, len);
      return Stdlib_Bytes[48].call(null, res);
     }
    }
    return str;
   }
   function string_to_caml_string(str){
    var
     str$0 = Stdlib_String[24].call(null, str),
     l = caml_ml_string_length(str$0),
     res = Stdlib_Bytes[1].call(null, l + 2 | 0, 34);
    caml_blit_string(str$0, 0, res, 1, l);
    return Stdlib_Bytes[48].call(null, res);
   }
   function format_of_fconv(fconv, prec){
    var
     prec$0 = Stdlib[18].call(null, prec),
     symb = char_of_fconv(r, fconv),
     buf = buffer_create(16);
    buffer_add_char(buf, 37);
    bprint_fconv_flag(buf, fconv);
    buffer_add_char(buf, 46);
    buffer_add_string(buf, Stdlib_Int[12].call(null, prec$0));
    buffer_add_char(buf, symb);
    return buffer_contents(buf);
   }
   function transform_int_alt(iconv, s){
    if(13 > iconv) return s;
    var n = [0, 0], a = caml_ml_string_length(s) - 1 | 0, d = 0;
    if(a >= 0){
     var i$0 = d;
     for(;;){
      if(9 >= caml_string_unsafe_get(s, i$0) - 48 >>> 0) n[1]++;
      var g = i$0 + 1 | 0;
      if(a === i$0) break;
      i$0 = g;
     }
    }
    var
     digits = n[1],
     buf =
       caml_create_bytes
        (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
     pos = [0, 0];
    function put(c){caml_bytes_set(buf, pos[1], c); pos[1]++;}
    var
     left = [0, ((digits - 1 | 0) % 3 | 0) + 1 | 0],
     b = caml_ml_string_length(s) - 1 | 0,
     e = 0;
    if(b >= 0){
     var i = e;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      if(9 < c - 48 >>> 0)
       put(c);
      else{if(0 === left[1]){put(95); left[1] = 3;} left[1]--; put(c);}
      var f = i + 1 | 0;
      if(b === i) break;
      i = f;
     }
    }
    return Stdlib_Bytes[48].call(null, buf);
   }
   function convert_int(iconv, n){
    switch(iconv){
      case 1:
       var a = cst_d$0; break;
      case 2:
       var a = cst_d$1; break;
      case 4:
       var a = cst_i$1; break;
      case 5:
       var a = cst_i$2; break;
      case 6:
       var a = cst_x; break;
      case 7:
       var a = cst_x$0; break;
      case 8:
       var a = cst_X; break;
      case 9:
       var a = cst_X$0; break;
      case 10:
       var a = cst_o; break;
      case 11:
       var a = cst_o$0; break;
      case 0:
      case 13:
       var a = cst_d; break;
      case 3:
      case 14:
       var a = cst_i$0; break;
      default: var a = cst_u;
    }
    return transform_int_alt(iconv, caml_format_int(a, n));
   }
   function convert_int32(iconv, n){
    switch(iconv){
      case 1:
       var a = cst_ld$0; break;
      case 2:
       var a = cst_ld$1; break;
      case 4:
       var a = cst_li$1; break;
      case 5:
       var a = cst_li$2; break;
      case 6:
       var a = cst_lx; break;
      case 7:
       var a = cst_lx$0; break;
      case 8:
       var a = cst_lX; break;
      case 9:
       var a = cst_lX$0; break;
      case 10:
       var a = cst_lo; break;
      case 11:
       var a = cst_lo$0; break;
      case 0:
      case 13:
       var a = cst_ld; break;
      case 3:
      case 14:
       var a = cst_li$0; break;
      default: var a = cst_lu;
    }
    return transform_int_alt(iconv, caml_format_int(a, n));
   }
   function convert_nativeint(iconv, n){
    switch(iconv){
      case 1:
       var a = cst_nd$0; break;
      case 2:
       var a = cst_nd$1; break;
      case 4:
       var a = cst_ni$1; break;
      case 5:
       var a = cst_ni$2; break;
      case 6:
       var a = cst_nx; break;
      case 7:
       var a = cst_nx$0; break;
      case 8:
       var a = cst_nX; break;
      case 9:
       var a = cst_nX$0; break;
      case 10:
       var a = cst_no; break;
      case 11:
       var a = cst_no$0; break;
      case 0:
      case 13:
       var a = cst_nd; break;
      case 3:
      case 14:
       var a = cst_ni$0; break;
      default: var a = cst_nu;
    }
    return transform_int_alt(iconv, caml_format_int(a, n));
   }
   function convert_int64(iconv, n){
    switch(iconv){
      case 1:
       var a = cst_Ld$0; break;
      case 2:
       var a = cst_Ld$1; break;
      case 4:
       var a = cst_Li$1; break;
      case 5:
       var a = cst_Li$2; break;
      case 6:
       var a = cst_Lx; break;
      case 7:
       var a = cst_Lx$0; break;
      case 8:
       var a = cst_LX; break;
      case 9:
       var a = cst_LX$0; break;
      case 10:
       var a = cst_Lo; break;
      case 11:
       var a = cst_Lo$0; break;
      case 0:
      case 13:
       var a = cst_Ld; break;
      case 3:
      case 14:
       var a = cst_Li$0; break;
      default: var a = cst_Lu;
    }
    return transform_int_alt(iconv, runtime.caml_int64_format(a, n));
   }
   function convert_float(fconv, prec, x){
    function hex(param){
     switch(fconv[1]){
       case 0:
        var sign = 45; break;
       case 1:
        var sign = 43; break;
       default: var sign = 32;
     }
     return runtime.caml_hexstring_of_float(x, prec, sign);
    }
    function caml_special_val(str){
     var match = runtime.caml_classify_float(x);
     return 3 === match
             ? x < 0. ? cst_neg_infinity : cst_infinity
             : 4 <= match ? cst_nan : str;
    }
    switch(fconv[2]){
      case 5:
       var
        str = caml_format_float(format_of_fconv(fconv, prec), x),
        len = caml_ml_string_length(str),
        i = 0;
       for(;;){
        a:
        {
         if(i !== len){
          var a = caml_string_get(str, i) - 46 | 0;
          b:
          {
           if(23 < a >>> 0){
            if(55 !== a) break b;
           }
           else if(21 >= a - 1 >>> 0) break b;
           var b = 1;
           break a;
          }
          var i$0 = i + 1 | 0;
          i = i$0;
          continue;
         }
         var b = 0;
        }
        var c = b ? str : Stdlib[28].call(null, str, cst$17);
        return caml_special_val(c);
       }
      case 6:
       return hex(0);
      case 7:
       var d = hex(0); return Stdlib_String[25].call(null, d);
      case 8:
       return caml_special_val(hex(0));
      default: return caml_format_float(format_of_fconv(fconv, prec), x);
    }
   }
   function string_of_fmtty(fmtty){
    var buf = buffer_create(16);
    bprint_fmtty(buf, fmtty);
    return buffer_contents(buf);
   }
   function make_printf$0(counter, k$2, acc$4, fmt$2){
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           h:
           {
            i:
            {
             j:
             {
              var k = k$2, acc = acc$4, fmt = fmt$2;
              k:
              for(;;){
               if(typeof fmt === "number") return caml_call1(k, acc);
               switch(fmt[0]){
                 case 0:
                  break a;
                 case 1:
                  break b;
                 case 2:
                  break c;
                 case 3:
                  var rest$2 = fmt[2], pad$0 = fmt[1];
                  return make_padding
                          (k, acc, rest$2, pad$0, string_to_caml_string);
                 case 4:
                  var
                   rest$3 = fmt[4],
                   prec = fmt[3],
                   pad$1 = fmt[2],
                   iconv = fmt[1];
                  return make_int_padding_precision
                          (k, acc, rest$3, pad$1, prec, convert_int, iconv);
                 case 5:
                  var
                   rest$4 = fmt[4],
                   prec$0 = fmt[3],
                   pad$2 = fmt[2],
                   iconv$0 = fmt[1];
                  return make_int_padding_precision
                          (k, acc, rest$4, pad$2, prec$0, convert_int32, iconv$0);
                 case 6:
                  var
                   rest$5 = fmt[4],
                   prec$1 = fmt[3],
                   pad$3 = fmt[2],
                   iconv$1 = fmt[1];
                  return make_int_padding_precision
                          (k, acc, rest$5, pad$3, prec$1, convert_nativeint, iconv$1);
                 case 7:
                  var
                   rest$6 = fmt[4],
                   prec$2 = fmt[3],
                   pad$4 = fmt[2],
                   iconv$2 = fmt[1];
                  return make_int_padding_precision
                          (k, acc, rest$6, pad$4, prec$2, convert_int64, iconv$2);
                 case 8:
                  break d;
                 case 9:
                  var rest$8 = fmt[2], pad$6 = fmt[1];
                  return make_padding(k, acc, rest$8, pad$6, Stdlib[30]);
                 case 10:
                  var rest$9 = fmt[1], acc$0 = [7, acc];
                  acc = acc$0;
                  fmt = rest$9;
                  break;
                 case 11:
                  var rest$10 = fmt[2], str = fmt[1], acc$1 = [2, acc, str];
                  acc = acc$1;
                  fmt = rest$10;
                  break;
                 case 12:
                  var rest$11 = fmt[2], chr = fmt[1], acc$2 = [3, acc, chr];
                  acc = acc$2;
                  fmt = rest$11;
                  break;
                 case 13:
                  break e;
                 case 14:
                  break f;
                 case 15:
                  break g;
                 case 16:
                  break h;
                 case 17:
                  var
                   rest$16 = fmt[2],
                   fmting_lit = fmt[1],
                   acc$3 = [0, acc, fmting_lit];
                  acc = acc$3;
                  fmt = rest$16;
                  break;
                 case 18:
                  var a = fmt[1];
                  if(0 === a[0]){
                   var rest$17 = fmt[2], fmt$0 = a[1][1];
                   let acc$0 = acc, k$1 = k, rest = rest$17;
                   var
                    k$0 =
                      function(kacc){
                       return make_printf(k$1, [1, acc$0, [0, kacc]], rest);
                      };
                   k = k$0;
                   acc = 0;
                   fmt = fmt$0;
                  }
                  else{
                   var rest$18 = fmt[2], fmt$1 = a[1][1];
                   let acc$0 = acc, k$0 = k, rest = rest$18;
                   var
                    k$1 =
                      function(kacc){
                       return make_printf(k$0, [1, acc$0, [1, kacc]], rest);
                      };
                   k = k$1;
                   acc = 0;
                   fmt = fmt$1;
                  }
                  break;
                 case 19:
                  throw caml_maybe_attach_backtrace([0, Assert_failure, s], 1);
                 case 20:
                  break i;
                 case 21:
                  break j;
                 case 22:
                  break k;
                 case 23:
                  var rest$22 = fmt[2], ign = fmt[1];
                  if(counter >= 50)
                   return caml_trampoline_return
                           (make_ignored_param$0, [0, k, acc, ign, rest$22]);
                  var counter$1 = counter + 1 | 0;
                  return make_ignored_param$0(counter$1, k, acc, ign, rest$22);
                 default:
                  var
                   rest$23 = fmt[3],
                   f = fmt[2],
                   arity = fmt[1],
                   b = caml_call1(f, 0);
                  if(counter >= 50)
                   return caml_trampoline_return
                           (make_custom$0, [0, k, acc, rest$23, arity, b]);
                  var counter$0 = counter + 1 | 0;
                  return make_custom$0(counter$0, k, acc, rest$23, arity, b);
               }
              }
              var rest$21 = fmt[1];
              return function(c){
               var new_acc = [5, acc, c];
               return make_printf(k, new_acc, rest$21);};
             }
             var rest$20 = fmt[2];
             return function(n){
              var new_acc = [4, acc, caml_format_int(cst_u$0, n)];
              return make_printf(k, new_acc, rest$20);};
            }
            var
             rest$19 = fmt[3],
             new_acc = [8, acc, cst_Printf_bad_conversion];
            return function(param){return make_printf(k, new_acc, rest$19);};
           }
           var rest$15 = fmt[1];
           return function(f){return make_printf(k, [6, acc, f], rest$15);};
          }
          var rest$14 = fmt[1];
          return function(f, x){
           return make_printf
                   (k,
                    [6, acc, function(o){return caml_call2(f, o, x);}],
                    rest$14);};
         }
         var rest$13 = fmt[3], fmtty = fmt[2];
         return function(param){
          var fmt = param[1], a = recast(fmt, fmtty);
          return make_printf
                  (k, acc, CamlinternalFormatBasics[3].call(null, a, rest$13));};
        }
        var
         rest$12 = fmt[3],
         sub_fmtty = fmt[2],
         ty = string_of_fmtty(sub_fmtty);
        return function(str){return make_printf(k, [4, acc, ty], rest$12);};
       }
       var rest$7 = fmt[4], prec$3 = fmt[3], pad$5 = fmt[2], fconv = fmt[1];
       if(typeof pad$5 === "number"){
        if(typeof prec$3 === "number")
         return prec$3
                 ? function
                  (p, x){
                   var str = convert_float(fconv, p, x);
                   return make_printf(k, [4, acc, str], rest$7);
                  }
                 : function
                  (x){
                   var
                    str =
                      convert_float(fconv, default_float_precision(fconv), x);
                   return make_printf(k, [4, acc, str], rest$7);
                  };
        var p = prec$3[1];
        return function(x){
         var str = convert_float(fconv, p, x);
         return make_printf(k, [4, acc, str], rest$7);};
       }
       if(0 === pad$5[0]){
        var w = pad$5[2], padty = pad$5[1];
        if(typeof prec$3 === "number")
         return prec$3
                 ? function
                  (p, x){
                   var str = fix_padding(padty, w, convert_float(fconv, p, x));
                   return make_printf(k, [4, acc, str], rest$7);
                  }
                 : function
                  (x){
                   var
                    str =
                      convert_float(fconv, default_float_precision(fconv), x),
                    str$0 = fix_padding(padty, w, str);
                   return make_printf(k, [4, acc, str$0], rest$7);
                  };
        var p$0 = prec$3[1];
        return function(x){
         var str = fix_padding(padty, w, convert_float(fconv, p$0, x));
         return make_printf(k, [4, acc, str], rest$7);};
       }
       var padty$0 = pad$5[1];
       if(typeof prec$3 === "number")
        return prec$3
                ? function
                 (w, p, x){
                  var
                   str = fix_padding(padty$0, w, convert_float(fconv, p, x));
                  return make_printf(k, [4, acc, str], rest$7);
                 }
                : function
                 (w, x){
                  var
                   str =
                     convert_float(fconv, default_float_precision(fconv), x),
                   str$0 = fix_padding(padty$0, w, str);
                  return make_printf(k, [4, acc, str$0], rest$7);
                 };
       var p$1 = prec$3[1];
       return function(w, x){
        var str = fix_padding(padty$0, w, convert_float(fconv, p$1, x));
        return make_printf(k, [4, acc, str], rest$7);};
      }
      var rest$1 = fmt[2], pad = fmt[1];
      return make_padding(k, acc, rest$1, pad, function(str){return str;});
     }
     var rest$0 = fmt[1];
     return function(c){
      var
       str = Stdlib_Char[2].call(null, c),
       l = caml_ml_string_length(str),
       res = Stdlib_Bytes[1].call(null, l + 2 | 0, 39);
      caml_blit_string(str, 0, res, 1, l);
      var new_acc = [4, acc, Stdlib_Bytes[48].call(null, res)];
      return make_printf(k, new_acc, rest$0);};
    }
    var rest = fmt[1];
    return function(c){
     var new_acc = [5, acc, c];
     return make_printf(k, new_acc, rest);};
   }
   function make_printf(k, acc, fmt){
    return caml_trampoline(make_printf$0(0, k, acc, fmt));
   }
   function make_ignored_param$0(counter, k, acc, ign, fmt){
    if(typeof ign === "number"){
     if(2 === ign)
      throw caml_maybe_attach_backtrace([0, Assert_failure, t], 1);
     if(counter >= 50)
      return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
     var counter$0 = counter + 1 | 0;
     return make_invalid_arg(counter$0, k, acc, fmt);
    }
    if(9 === ign[0]){
     var fmtty = ign[2];
     if(counter >= 50)
      return caml_trampoline_return
              (make_from_fmtty$0, [0, k, acc, fmtty, fmt]);
     var counter$2 = counter + 1 | 0;
     return make_from_fmtty$0(counter$2, k, acc, fmtty, fmt);
    }
    if(counter >= 50)
     return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
    var counter$1 = counter + 1 | 0;
    return make_invalid_arg(counter$1, k, acc, fmt);
   }
   function make_ignored_param(k, acc, ign, fmt){
    return caml_trampoline(make_ignored_param$0(0, k, acc, ign, fmt));
   }
   function make_from_fmtty$0(counter, k, acc, fmtty, fmt){
    if(typeof fmtty !== "number")
     switch(fmtty[0]){
       case 0:
        var rest = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest, fmt);};
       case 1:
        var rest$0 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$0, fmt);};
       case 2:
        var rest$1 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$1, fmt);};
       case 3:
        var rest$2 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$2, fmt);};
       case 4:
        var rest$3 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$3, fmt);};
       case 5:
        var rest$4 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$4, fmt);};
       case 6:
        var rest$5 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$5, fmt);};
       case 7:
        var rest$6 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$6, fmt);};
       case 8:
        var rest$7 = fmtty[2];
        return function(param){return make_from_fmtty(k, acc, rest$7, fmt);};
       case 9:
        var
         rest$8 = fmtty[3],
         ty2 = fmtty[2],
         ty1 = fmtty[1],
         ty = trans(symm(ty1), ty2);
        return function(param){
         return make_from_fmtty
                 (k,
                  acc,
                  CamlinternalFormatBasics[1].call(null, ty, rest$8),
                  fmt);};
       case 10:
        var rest$9 = fmtty[1];
        return function(param, a){
         return make_from_fmtty(k, acc, rest$9, fmt);};
       case 11:
        var rest$10 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$10, fmt);};
       case 12:
        var rest$11 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$11, fmt);};
       case 13:
        throw caml_maybe_attach_backtrace([0, Assert_failure, u], 1);
       default: throw caml_maybe_attach_backtrace([0, Assert_failure, v], 1);
     }
    if(counter >= 50)
     return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_invalid_arg(counter$0, k, acc, fmt);
   }
   function make_from_fmtty(k, acc, fmtty, fmt){
    return caml_trampoline(make_from_fmtty$0(0, k, acc, fmtty, fmt));
   }
   function make_invalid_arg(counter, k, acc, fmt){
    var a = [8, acc, cst_Printf_bad_conversion$0];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, a, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, a, fmt);
   }
   function make_padding(k, acc, fmt, pad, trans){
    if(typeof pad === "number")
     return function(x){
      var new_acc = [4, acc, caml_call1(trans, x)];
      return make_printf(k, new_acc, fmt);};
    if(0 === pad[0]){
     var width = pad[2], padty = pad[1];
     return function(x){
      var new_acc = [4, acc, fix_padding(padty, width, caml_call1(trans, x))];
      return make_printf(k, new_acc, fmt);};
    }
    var padty$0 = pad[1];
    return function(w, x){
     var new_acc = [4, acc, fix_padding(padty$0, w, caml_call1(trans, x))];
     return make_printf(k, new_acc, fmt);};
   }
   function make_int_padding_precision(k, acc, fmt, pad, prec, trans, iconv){
    if(typeof pad === "number"){
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var str = fix_int_precision(p, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = caml_call2(trans, iconv, x);
                return make_printf(k, [4, acc, str], fmt);
               };
     var p = prec[1];
     return function(x){
      var str = fix_int_precision(p, caml_call2(trans, iconv, x));
      return make_printf(k, [4, acc, str], fmt);};
    }
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var
                 str =
                   fix_padding
                    (padty,
                     w,
                     fix_int_precision(p, caml_call2(trans, iconv, x)));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = fix_padding(padty, w, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               };
     var p$0 = prec[1];
     return function(x){
      var
       str =
         fix_padding
          (padty, w, fix_int_precision(p$0, caml_call2(trans, iconv, x)));
      return make_printf(k, [4, acc, str], fmt);};
    }
    var padty$0 = pad[1];
    if(typeof prec === "number")
     return prec
             ? function
              (w, p, x){
               var
                str =
                  fix_padding
                   (padty$0,
                    w,
                    fix_int_precision(p, caml_call2(trans, iconv, x)));
               return make_printf(k, [4, acc, str], fmt);
              }
             : function
              (w, x){
               var str = fix_padding(padty$0, w, caml_call2(trans, iconv, x));
               return make_printf(k, [4, acc, str], fmt);
              };
    var p$1 = prec[1];
    return function(w, x){
     var
      str =
        fix_padding
         (padty$0, w, fix_int_precision(p$1, caml_call2(trans, iconv, x)));
     return make_printf(k, [4, acc, str], fmt);};
   }
   function make_custom$0(counter, k, acc, rest, arity, f){
    if(arity){
     var arity$0 = arity[1];
     return function(x){
      return make_custom(k, acc, rest, arity$0, caml_call1(f, x));};
    }
    var a = [4, acc, f];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, a, rest]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, a, rest);
   }
   function make_custom(k, acc, rest, arity, f){
    return caml_trampoline(make_custom$0(0, k, acc, rest, arity, f));
   }
   function make_iprintf$0(counter, k$2, o, fmt$2){
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           h:
           {
            i:
            {
             var k = k$2, fmt = fmt$2;
             j:
             for(;;){
              if(typeof fmt === "number") return caml_call1(k, o);
              switch(fmt[0]){
                case 2:
                 break b;
                case 3:
                 break c;
                case 9:
                 break e;
                case 10:
                 var rest$10 = fmt[1]; fmt = rest$10; break;
                case 14:
                 break g;
                case 15:
                 break h;
                case 18:
                 var a = fmt[1];
                 if(0 === a[0]){
                  var rest$15 = fmt[2], fmt$0 = a[1][1];
                  let k$1 = k, rest = rest$15;
                  var
                   k$0 = function(koc){return make_iprintf(k$1, koc, rest);};
                  k = k$0;
                  fmt = fmt$0;
                 }
                 else{
                  var rest$16 = fmt[2], fmt$1 = a[1][1];
                  let k$0 = k, rest = rest$16;
                  var
                   k$1 = function(koc){return make_iprintf(k$0, koc, rest);};
                  k = k$1;
                  fmt = fmt$1;
                 }
                 break;
                case 19:
                 throw caml_maybe_attach_backtrace([0, Assert_failure, w], 1);
                case 21:
                 break i;
                case 23:
                 break j;
                case 24:
                 var rest$19 = fmt[3], arity = fmt[1];
                 if(counter >= 50)
                  return caml_trampoline_return
                          (fn_of_custom_arity$0, [0, k, o, rest$19, arity]);
                 var counter$0 = counter + 1 | 0;
                 return fn_of_custom_arity$0(counter$0, k, o, rest$19, arity);
                case 13:
                case 20:
                 break f;
                case 11:
                case 12:
                case 17:
                 var rest$11 = fmt[2]; fmt = rest$11; break;
                case 0:
                case 1:
                case 16:
                case 22:
                 break a;
                default: break d;
              }
             }
             var rest$18 = fmt[2], ign = fmt[1];
             return make_ignored_param
                     (function(param){return caml_call1(k, o);}, 0, ign, rest$18);
            }
            var rest$17 = fmt[2], x$15 = make_iprintf(k, o, rest$17);
            return function(param){return x$15;};
           }
           var
            rest$14 = fmt[1],
            x$13 = make_iprintf(k, o, rest$14),
            x$14 = function(param){return x$13;};
           return function(param){return x$14;};
          }
          var rest$13 = fmt[3], fmtty = fmt[2];
          return function(param){
           var fmt = param[1], a = recast(fmt, fmtty);
           return make_iprintf
                   (k, o, CamlinternalFormatBasics[3].call(null, a, rest$13));};
         }
         var rest$12 = fmt[3], x$12 = make_iprintf(k, o, rest$12);
         return function(param){return x$12;};
        }
        var match$1 = fmt[1];
        if(typeof match$1 === "number"){
         var rest$7 = fmt[2], x$8 = make_iprintf(k, o, rest$7);
         return function(param){return x$8;};
        }
        if(0 === match$1[0]){
         var rest$8 = fmt[2], x$9 = make_iprintf(k, o, rest$8);
         return function(param){return x$9;};
        }
        var
         rest$9 = fmt[2],
         x$10 = make_iprintf(k, o, rest$9),
         x$11 = function(param){return x$10;};
        return function(param){return x$11;};
       }
       var rest$6 = fmt[4], prec = fmt[3], pad = fmt[2];
       if(typeof pad === "number"){
        if(typeof prec !== "number"){
         var x$19 = make_iprintf(k, o, rest$6);
         return function(param){return x$19;};
        }
        if(prec){
         var
          x$16 = make_iprintf(k, o, rest$6),
          x$17 = function(param){return x$16;};
         return function(param){return x$17;};
        }
        var x$18 = make_iprintf(k, o, rest$6);
        return function(param){return x$18;};
       }
       if(0 === pad[0]){
        if(typeof prec !== "number"){
         var x$23 = make_iprintf(k, o, rest$6);
         return function(param){return x$23;};
        }
        if(prec){
         var
          x$20 = make_iprintf(k, o, rest$6),
          x$21 = function(param){return x$20;};
         return function(param){return x$21;};
        }
        var x$22 = make_iprintf(k, o, rest$6);
        return function(param){return x$22;};
       }
       if(typeof prec !== "number"){
        var
         x$29 = make_iprintf(k, o, rest$6),
         x$30 = function(param){return x$29;};
        return function(param){return x$30;};
       }
       if(prec){
        var
         x$24 = make_iprintf(k, o, rest$6),
         x$25 = function(param){return x$24;},
         x$26 = function(param){return x$25;};
        return function(param){return x$26;};
       }
       var
        x$27 = make_iprintf(k, o, rest$6),
        x$28 = function(param){return x$27;};
       return function(param){return x$28;};
      }
      var match$0 = fmt[1];
      if(typeof match$0 === "number"){
       var rest$3 = fmt[2], x$4 = make_iprintf(k, o, rest$3);
       return function(param){return x$4;};
      }
      if(0 === match$0[0]){
       var rest$4 = fmt[2], x$5 = make_iprintf(k, o, rest$4);
       return function(param){return x$5;};
      }
      var
       rest$5 = fmt[2],
       x$6 = make_iprintf(k, o, rest$5),
       x$7 = function(param){return x$6;};
      return function(param){return x$7;};
     }
     var match = fmt[1];
     if(typeof match === "number"){
      var rest$0 = fmt[2], x$0 = make_iprintf(k, o, rest$0);
      return function(param){return x$0;};
     }
     if(0 === match[0]){
      var rest$1 = fmt[2], x$1 = make_iprintf(k, o, rest$1);
      return function(param){return x$1;};
     }
     var
      rest$2 = fmt[2],
      x$2 = make_iprintf(k, o, rest$2),
      x$3 = function(param){return x$2;};
     return function(param){return x$3;};
    }
    var rest = fmt[1], x = make_iprintf(k, o, rest);
    return function(param){return x;};
   }
   function make_iprintf(k, o, fmt){
    return caml_trampoline(make_iprintf$0(0, k, o, fmt));
   }
   function fn_of_custom_arity$0(counter, k, o, fmt, param){
    if(param){
     var arity = param[1], x = fn_of_custom_arity(k, o, fmt, arity);
     return function(param){return x;};
    }
    if(counter >= 50)
     return caml_trampoline_return(make_iprintf$0, [0, k, o, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_iprintf$0(counter$0, k, o, fmt);
   }
   function fn_of_custom_arity(k, o, fmt, param){
    return caml_trampoline(fn_of_custom_arity$0(0, k, o, fmt, param));
   }
   function output_acc(o, acc$2){
    var acc = acc$2;
    for(;;){
     if(typeof acc === "number") return 0;
     switch(acc[0]){
       case 0:
        var
         fmting_lit = acc[2],
         p = acc[1],
         s = string_of_formatting_lit(fmting_lit);
        output_acc(o, p);
        return Stdlib[66].call(null, o, s);
       case 1:
        var match = acc[2], p$0 = acc[1];
        if(0 === match[0]){
         var acc$0 = match[1];
         output_acc(o, p$0);
         Stdlib[66].call(null, o, cst$18);
         acc = acc$0;
        }
        else{
         var acc$1 = match[1];
         output_acc(o, p$0);
         Stdlib[66].call(null, o, cst$19);
         acc = acc$1;
        }
        break;
       case 6:
        var f = acc[2], p$3 = acc[1];
        output_acc(o, p$3);
        return caml_call1(f, o);
       case 7:
        var p$4 = acc[1]; output_acc(o, p$4); return Stdlib[63].call(null, o);
       case 8:
        var msg = acc[2], p$5 = acc[1];
        output_acc(o, p$5);
        return Stdlib[1].call(null, msg);
       case 2:
       case 4:
        var s$0 = acc[2], p$1 = acc[1];
        output_acc(o, p$1);
        return Stdlib[66].call(null, o, s$0);
       default:
        var c = acc[2], p$2 = acc[1];
        output_acc(o, p$2);
        return Stdlib[65].call(null, o, c);
     }
    }
   }
   function bufput_acc(b, acc$3){
    var acc = acc$3;
    for(;;){
     if(typeof acc === "number") return 0;
     switch(acc[0]){
       case 0:
        var
         fmting_lit = acc[2],
         p = acc[1],
         s = string_of_formatting_lit(fmting_lit);
        bufput_acc(b, p);
        return Stdlib_Buffer[16].call(null, b, s);
       case 1:
        var match = acc[2], p$0 = acc[1];
        if(0 === match[0]){
         var acc$0 = match[1];
         bufput_acc(b, p$0);
         Stdlib_Buffer[16].call(null, b, cst$20);
         acc = acc$0;
        }
        else{
         var acc$1 = match[1];
         bufput_acc(b, p$0);
         Stdlib_Buffer[16].call(null, b, cst$21);
         acc = acc$1;
        }
        break;
       case 6:
        var f = acc[2], p$3 = acc[1];
        bufput_acc(b, p$3);
        return caml_call1(f, b);
       case 7:
        var acc$2 = acc[1]; acc = acc$2; break;
       case 8:
        var msg = acc[2], p$4 = acc[1];
        bufput_acc(b, p$4);
        return Stdlib[1].call(null, msg);
       case 2:
       case 4:
        var s$0 = acc[2], p$1 = acc[1];
        bufput_acc(b, p$1);
        return Stdlib_Buffer[16].call(null, b, s$0);
       default:
        var c = acc[2], p$2 = acc[1];
        bufput_acc(b, p$2);
        return Stdlib_Buffer[12].call(null, b, c);
     }
    }
   }
   function strput_acc(b, acc$3){
    var acc = acc$3;
    for(;;){
     if(typeof acc === "number") return 0;
     switch(acc[0]){
       case 0:
        var
         fmting_lit = acc[2],
         p = acc[1],
         s = string_of_formatting_lit(fmting_lit);
        strput_acc(b, p);
        return Stdlib_Buffer[16].call(null, b, s);
       case 1:
        var match = acc[2], p$0 = acc[1];
        if(0 === match[0]){
         var acc$0 = match[1];
         strput_acc(b, p$0);
         Stdlib_Buffer[16].call(null, b, cst$22);
         acc = acc$0;
        }
        else{
         var acc$1 = match[1];
         strput_acc(b, p$0);
         Stdlib_Buffer[16].call(null, b, cst$23);
         acc = acc$1;
        }
        break;
       case 6:
        var f = acc[2], p$3 = acc[1];
        strput_acc(b, p$3);
        var a = caml_call1(f, 0);
        return Stdlib_Buffer[16].call(null, b, a);
       case 7:
        var acc$2 = acc[1]; acc = acc$2; break;
       case 8:
        var msg = acc[2], p$4 = acc[1];
        strput_acc(b, p$4);
        return Stdlib[1].call(null, msg);
       case 2:
       case 4:
        var s$0 = acc[2], p$1 = acc[1];
        strput_acc(b, p$1);
        return Stdlib_Buffer[16].call(null, b, s$0);
       default:
        var c = acc[2], p$2 = acc[1];
        strput_acc(b, p$2);
        return Stdlib_Buffer[12].call(null, b, c);
     }
    }
   }
   function failwith_message(param){
    var fmt = param[1], buf = Stdlib_Buffer[1].call(null, 256);
    function k(acc){
     strput_acc(buf, acc);
     var a = Stdlib_Buffer[2].call(null, buf);
     return Stdlib[2].call(null, a);
    }
    return make_printf(k, 0, fmt);
   }
   function open_box_of_string(str){
    if(str === cst$43) return x;
    var len = caml_ml_string_length(str);
    function invalid_box(param){return caml_call1(failwith_message(y), str);}
    function parse_spaces(i$1){
     var i = i$1;
     for(;;){
      if(i === len) return i;
      var match = caml_string_get(str, i);
      if(9 !== match && 32 !== match) return i;
      var i$0 = i + 1 | 0;
      i = i$0;
     }
    }
    var wstart = parse_spaces(0), wend = wstart;
    for(;;){
     if(wend === len) break;
     if(25 < caml_string_get(str, wend) - 97 >>> 0) break;
     var j = wend + 1 | 0;
     wend = j;
    }
    var
     box_name = Stdlib_String[15].call(null, str, wstart, wend - wstart | 0),
     nstart = parse_spaces(wend),
     nend = nstart;
    for(;;){
     if(nend === len) break;
     var match = caml_string_get(str, nend);
     if(48 <= match){if(58 <= match) break;} else if(45 !== match) break;
     var j$0 = nend + 1 | 0;
     nend = j$0;
    }
    if(nstart === nend)
     var indent = 0;
    else
     try{
      var
       a =
         runtime.caml_int_of_string
          (Stdlib_String[15].call(null, str, nstart, nend - nstart | 0)),
       indent = a;
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0), tag = exn[1];
      if(tag !== Stdlib[7]) throw caml_maybe_attach_backtrace(exn, 0);
      var indent = invalid_box(0);
     }
    var exp_end = parse_spaces(nend);
    if(exp_end !== len) invalid_box(0);
    a:
    {
     if(box_name !== cst$43 && box_name !== "b"){
      if(box_name === "h"){var box_type = 0; break a;}
      if(box_name === "hov"){var box_type = 3; break a;}
      if(box_name === "hv"){var box_type = 2; break a;}
      if(box_name !== "v"){var box_type = invalid_box(0); break a;}
      var box_type = 1;
      break a;
     }
     var box_type = 4;
    }
    return [0, indent, box_type];
   }
   function make_padding_fmt_ebb(pad, fmt){
    if(typeof pad === "number") return [0, 0, fmt];
    if(0 === pad[0]){var w = pad[2], s = pad[1]; return [0, [0, s, w], fmt];}
    var s$0 = pad[1];
    return [0, [1, s$0], fmt];
   }
   function make_padprec_fmt_ebb(pad, prec, fmt){
    if(typeof prec === "number")
     var match = prec ? [0, 1] : [0, 0];
    else
     var p = prec[1], match = [0, [0, p]];
    var prec$0 = match[1];
    if(typeof pad === "number") return [0, 0, prec$0, fmt];
    if(0 === pad[0]){
     var w = pad[2], s = pad[1];
     return [0, [0, s, w], prec$0, fmt];
    }
    var s$0 = pad[1];
    return [0, [1, s$0], prec$0, fmt];
   }
   function fmt_ebb_of_string(legacy_behavior, str){
    if(legacy_behavior)
     var flag = legacy_behavior[1], legacy_behavior$0 = flag;
    else
     var legacy_behavior$0 = 1;
    function invalid_format_message(str_ind, msg){
     return caml_call3(failwith_message(z), str, str_ind, msg);
    }
    function invalid_format_without(str_ind, c, s){
     return caml_call4(failwith_message(A), str, str_ind, c, s);
    }
    function expected_character(str_ind, expected, read){
     return caml_call4(failwith_message(B), str, str_ind, expected, read);
    }
    function parse(lit_start, end_ind){
     var str_ind = lit_start;
     for(;;){
      if(str_ind === end_ind) return add_literal(lit_start, str_ind, 0);
      var match = caml_string_get(str, str_ind);
      if(37 === match) break;
      if(64 === match){
       var fmt_rest$0 = parse_after_at(str_ind + 1 | 0, end_ind)[1];
       return add_literal(lit_start, str_ind, fmt_rest$0);
      }
      var str_ind$0 = str_ind + 1 | 0;
      str_ind = str_ind$0;
     }
     var str_ind$1 = str_ind + 1 | 0;
     if(str_ind$1 === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var
      match$0 =
        95 === caml_string_get(str, str_ind$1)
         ? parse_flags(str_ind, str_ind$1 + 1 | 0, end_ind, 1)
         : parse_flags(str_ind, str_ind$1, end_ind, 0),
      fmt_rest = match$0[1];
     return add_literal(lit_start, str_ind, fmt_rest);
    }
    function parse_flags(pct_ind, str_ind, end_ind, ign){
     var
      zero = [0, 0],
      minus = [0, 0],
      plus = [0, 0],
      space = [0, 0],
      hash = [0, 0];
     function set_flag(str_ind, flag){
      var a = flag[1], b = a ? 1 - legacy_behavior$0 : a;
      if(b){
       var c = caml_string_get(str, str_ind);
       caml_call3(failwith_message(C), str, str_ind, c);
      }
      flag[1] = 1;
     }
     var str_ind$0 = str_ind;
     a:
     for(;;){
      if(str_ind$0 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var switcher = caml_string_get(str, str_ind$0) - 32 | 0;
      if(16 < switcher >>> 0) break;
      switch(switcher){
        case 0:
         set_flag(str_ind$0, space);
         var str_ind$1 = str_ind$0 + 1 | 0;
         str_ind$0 = str_ind$1;
         break;
        case 3:
         set_flag(str_ind$0, hash);
         var str_ind$2 = str_ind$0 + 1 | 0;
         str_ind$0 = str_ind$2;
         break;
        case 11:
         set_flag(str_ind$0, plus);
         var str_ind$3 = str_ind$0 + 1 | 0;
         str_ind$0 = str_ind$3;
         break;
        case 13:
         set_flag(str_ind$0, minus);
         var str_ind$4 = str_ind$0 + 1 | 0;
         str_ind$0 = str_ind$4;
         break;
        case 16:
         set_flag(str_ind$0, zero);
         var str_ind$5 = str_ind$0 + 1 | 0;
         str_ind$0 = str_ind$5;
         break;
        default: break a;
      }
     }
     var
      space$0 = space[1],
      hash$0 = hash[1],
      plus$0 = plus[1],
      minus$0 = minus[1],
      zero$0 = zero[1];
     if(str_ind$0 === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var
      padty =
        zero$0
         ? minus$0
           ? legacy_behavior$0
             ? 0
             : incompatible_flag(pct_ind, str_ind$0, 45, cst_0)
           : 2
         : minus$0 ? 0 : 1,
      match = caml_string_get(str, str_ind$0);
     if(48 <= match){
      if(58 > match){
       var
        match$0 = parse_positive(str_ind$0, end_ind, 0),
        width = match$0[2],
        new_ind = match$0[1];
       return parse_after_padding
               (pct_ind,
                new_ind,
                end_ind,
                minus$0,
                plus$0,
                hash$0,
                space$0,
                ign,
                [0, padty, width]);
      }
     }
     else if(42 === match)
      return parse_after_padding
              (pct_ind,
               str_ind$0 + 1 | 0,
               end_ind,
               minus$0,
               plus$0,
               hash$0,
               space$0,
               ign,
               [1, padty]);
     switch(padty){
       case 0:
        if(1 - legacy_behavior$0)
         invalid_format_without(str_ind$0 - 1 | 0, 45, cst_padding);
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 0);
       case 1:
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 0);
       default:
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 D);
     }
    }
    function parse_after_padding
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var symb = caml_string_get(str, str_ind);
     if(46 !== symb)
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               0,
               pad,
               symb);
     var str_ind$0 = str_ind + 1 | 0;
     if(str_ind$0 === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     function parse_literal(minus, str_ind){
      var
       match = parse_positive(str_ind, end_ind, 0),
       prec = match[2],
       new_ind = match[1];
      return parse_after_precision
              (pct_ind,
               new_ind,
               end_ind,
               minus,
               plus,
               hash,
               space,
               ign,
               pad,
               [0, prec]);
     }
     var symb$0 = caml_string_get(str, str_ind$0);
     if(48 <= symb$0){
      if(58 > symb$0) return parse_literal(minus, str_ind$0);
     }
     else if(42 <= symb$0)
      switch(symb$0 - 42 | 0){
        case 0:
         return parse_after_precision
                 (pct_ind,
                  str_ind$0 + 1 | 0,
                  end_ind,
                  minus,
                  plus,
                  hash,
                  space,
                  ign,
                  pad,
                  1);
        case 1:
        case 3:
         if(legacy_behavior$0){
          var
           a = str_ind$0 + 1 | 0,
           minus$0 = minus || (45 === symb$0 ? 1 : 0);
          return parse_literal(minus$0, a);
         }
         break;
      }
     return legacy_behavior$0
             ? parse_after_precision
               (pct_ind,
                str_ind$0,
                end_ind,
                minus,
                plus,
                hash,
                space,
                ign,
                pad,
                E)
             : invalid_format_without(str_ind$0 - 1 | 0, 46, cst_precision);
    }
    function parse_after_precision
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad, prec){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     function parse_conv(padprec){
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               prec,
               padprec,
               caml_string_get(str, str_ind));
     }
     if(typeof pad !== "number") return parse_conv(pad);
     if(typeof prec === "number" && ! prec) return parse_conv(0);
     if(minus){
      if(typeof prec === "number") return parse_conv(F);
      var n = prec[1];
      return parse_conv([0, 0, n]);
     }
     if(typeof prec === "number") return parse_conv(G);
     var n$0 = prec[1];
     return parse_conv([0, 1, n$0]);
    }
    function parse_conversion
    (pct_ind,
     str_ind,
     end_ind,
     plus,
     hash,
     space,
     ign,
     pad,
     prec,
     padprec,
     symb){
     var
      plus_used = [0, 0],
      hash_used = [0, 0],
      space_used = [0, 0],
      ign_used = [0, 0],
      pad_used = [0, 0],
      prec_used = [0, 0];
     function get_plus(param){plus_used[1] = 1; return plus;}
     function get_hash(param){hash_used[1] = 1; return hash;}
     function get_space(param){space_used[1] = 1; return space;}
     function get_ign(param){ign_used[1] = 1; return ign;}
     function get_pad(param){pad_used[1] = 1; return pad;}
     function get_prec(param){prec_used[1] = 1; return prec;}
     function get_padprec(param){pad_used[1] = 1; return padprec;}
     function get_int_pad(param){
      var pad = get_pad(0), match = get_prec(0);
      if(typeof match === "number" && ! match) return pad;
      if(typeof pad === "number") return 0;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? H
                 : incompatible_flag(pct_ind, str_ind, 48, cst_precision$1)
               : pad;
      if(2 > pad[1]) return pad;
      var n = pad[2];
      return legacy_behavior$0
              ? [0, 1, n]
              : incompatible_flag(pct_ind, str_ind, 48, cst_precision$0);
     }
     function check_no_0(symb, pad){
      if(typeof pad === "number") return pad;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? I
                 : incompatible_flag(pct_ind, str_ind, symb, cst_0$1)
               : pad;
      if(2 > pad[1]) return pad;
      var width = pad[2];
      return legacy_behavior$0
              ? [0, 1, width]
              : incompatible_flag(pct_ind, str_ind, symb, cst_0$0);
     }
     function opt_of_pad(c, pad){
      if(typeof pad === "number") return 0;
      if(0 === pad[0])
       switch(pad[1]){
         case 0:
          var width = pad[2];
          return legacy_behavior$0
                  ? [0, width]
                  : incompatible_flag(pct_ind, str_ind, c, cst$24);
         case 1:
          var width$0 = pad[2]; return [0, width$0];
         default:
          var width$1 = pad[2];
          return legacy_behavior$0
                  ? [0, width$1]
                  : incompatible_flag(pct_ind, str_ind, c, cst_0$2);
       }
      return incompatible_flag(pct_ind, str_ind, c, cst$25);
     }
     function get_pad_opt(c){return opt_of_pad(c, get_pad(0));}
     function get_padprec_opt(c){return opt_of_pad(c, get_padprec(0));}
     a:
     {
      if(124 > symb)
       switch(symb){
         case 33:
          var
           fmt_rest$5 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [10, fmt_rest$5]];
          break a;
         case 40:
          var
           sub_end = search_subformat_end(str_ind, end_ind, 41),
           fmt_rest$7 = parse(sub_end + 2 | 0, end_ind)[1],
           sub_fmt = parse(str_ind, sub_end)[1],
           sub_fmtty = fmtty_of_fmt(sub_fmt);
          if(get_ign(0)){
           var
            ignored$2 = [9, get_pad_opt(95), sub_fmtty],
            fmt_result = [0, [23, ignored$2, fmt_rest$7]];
           break a;
          }
          var fmt_result = [0, [14, get_pad_opt(40), sub_fmtty, fmt_rest$7]];
          break a;
         case 44:
          var fmt_result = parse(str_ind, end_ind); break a;
         case 67:
          var fmt_rest$10 = parse(str_ind, end_ind)[1];
          if(get_ign(0)){var fmt_result = [0, [23, 1, fmt_rest$10]]; break a;}
          var fmt_result = [0, [1, fmt_rest$10]];
          break a;
         case 78:
          var fmt_rest$14 = parse(str_ind, end_ind)[1], counter$0 = 2;
          if(get_ign(0)){
           var
            ignored$6 = [11, counter$0],
            fmt_result = [0, [23, ignored$6, fmt_rest$14]];
           break a;
          }
          var fmt_result = [0, [21, counter$0, fmt_rest$14]];
          break a;
         case 83:
          var
           pad$6 = check_no_0(symb, get_padprec(0)),
           fmt_rest$15 = parse(str_ind, end_ind)[1];
          if(get_ign(0)){
           var
            ignored$7 = [1, get_padprec_opt(95)],
            fmt_result = [0, [23, ignored$7, fmt_rest$15]];
           break a;
          }
          var
           match$5 = make_padding_fmt_ebb(pad$6, fmt_rest$15),
           fmt_rest$16 = match$5[2],
           pad$7 = match$5[1],
           fmt_result = [0, [3, pad$7, fmt_rest$16]];
          break a;
         case 91:
          var
           match$7 = parse_char_set(str_ind, end_ind),
           char_set = match$7[2],
           next_ind = match$7[1],
           fmt_rest$19 = parse(next_ind, end_ind)[1];
          if(get_ign(0)){
           var
            ignored$9 = [10, get_pad_opt(95), char_set],
            fmt_result = [0, [23, ignored$9, fmt_rest$19]];
           break a;
          }
          var fmt_result = [0, [20, get_pad_opt(91), char_set, fmt_rest$19]];
          break a;
         case 97:
          var
           fmt_rest$20 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [15, fmt_rest$20]];
          break a;
         case 99:
          var
           char_format =
             function(fmt_rest){
              return get_ign(0) ? [0, [23, 0, fmt_rest]] : [0, [0, fmt_rest]];
             },
           fmt_rest$21 = parse(str_ind, end_ind)[1],
           match$8 = get_pad_opt(99);
          if(! match$8){var fmt_result = char_format(fmt_rest$21); break a;}
          var n = match$8[1];
          if(0 === n){
           if(get_ign(0)){
            var fmt_result = [0, [23, 3, fmt_rest$21]];
            break a;
           }
           var fmt_result = [0, [22, fmt_rest$21]];
           break a;
          }
          if(legacy_behavior$0){
           var fmt_result = char_format(fmt_rest$21);
           break a;
          }
          var
           fmt_result =
             invalid_format_message(str_ind, cst_non_zero_widths_are_unsupp);
          break a;
         case 114:
          var fmt_rest$22 = parse(str_ind, end_ind)[1];
          if(get_ign(0)){var fmt_result = [0, [23, 2, fmt_rest$22]]; break a;}
          var fmt_result = [0, [19, fmt_rest$22]];
          break a;
         case 115:
          var
           pad$9 = check_no_0(symb, get_padprec(0)),
           fmt_rest$23 = parse(str_ind, end_ind)[1];
          if(get_ign(0)){
           var
            ignored$10 = [0, get_padprec_opt(95)],
            fmt_result = [0, [23, ignored$10, fmt_rest$23]];
           break a;
          }
          var
           match$9 = make_padding_fmt_ebb(pad$9, fmt_rest$23),
           fmt_rest$24 = match$9[2],
           pad$10 = match$9[1],
           fmt_result = [0, [2, pad$10, fmt_rest$24]];
          break a;
         case 116:
          var
           fmt_rest$25 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [16, fmt_rest$25]];
          break a;
         case 123:
          var
           sub_end$0 = search_subformat_end(str_ind, end_ind, 125),
           sub_fmt$0 = parse(str_ind, sub_end$0)[1],
           fmt_rest$26 = parse(sub_end$0 + 2 | 0, end_ind)[1],
           sub_fmtty$0 = fmtty_of_fmt(sub_fmt$0);
          if(get_ign(0)){
           var
            ignored$11 = [8, get_pad_opt(95), sub_fmtty$0],
            fmt_result = [0, [23, ignored$11, fmt_rest$26]];
           break a;
          }
          var
           fmt_result = [0, [13, get_pad_opt(123), sub_fmtty$0, fmt_rest$26]];
          break a;
         case 66:
         case 98:
          var
           pad$3 = check_no_0(symb, get_padprec(0)),
           fmt_rest$8 = parse(str_ind, end_ind)[1];
          if(get_ign(0)){
           var
            ignored$3 = [7, get_padprec_opt(95)],
            fmt_result = [0, [23, ignored$3, fmt_rest$8]];
           break a;
          }
          var
           match$3 = make_padding_fmt_ebb(pad$3, fmt_rest$8),
           fmt_rest$9 = match$3[2],
           pad$4 = match$3[1],
           fmt_result = [0, [9, pad$4, fmt_rest$9]];
          break a;
         case 37:
         case 64:
          var
           fmt_rest$6 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [12, symb, fmt_rest$6]];
          break a;
         case 76:
         case 108:
         case 110:
          if(str_ind !== end_ind){
           var symb$0 = caml_string_get(str, str_ind), i = symb$0 - 88 | 0;
           b:
           {
            if(32 >= i >>> 0)
             switch(i){
               case 0:
               case 12:
               case 17:
               case 23:
               case 29:
               case 32:
                var h = 1; break b;
             }
            var h = 0;
           }
           if(h) break;
          }
          var fmt_rest$13 = parse(str_ind, end_ind)[1];
          b:
          {
           if(108 <= symb){
            if(111 > symb)
             switch(symb - 108 | 0){
               case 0:
                var counter = 0; break b;
               case 2:
                var counter = 1; break b;
             }
           }
           else if(76 === symb){var counter = 2; break b;}
           throw caml_maybe_attach_backtrace([0, Assert_failure, V], 1);
          }
          if(get_ign(0)){
           var
            ignored$5 = [11, counter],
            fmt_result = [0, [23, ignored$5, fmt_rest$13]];
           break a;
          }
          var fmt_result = [0, [21, counter, fmt_rest$13]];
          break a;
         case 32:
         case 35:
         case 43:
         case 45:
         case 95:
          var
           fmt_result = caml_call3(failwith_message(M), str, pct_ind, symb);
          break a;
         case 88:
         case 100:
         case 105:
         case 111:
         case 117:
         case 120:
          var
           A = get_space(0),
           B = get_hash(0),
           iconv$2 =
             compute_int_conv(pct_ind, str_ind, get_plus(0), B, A, symb),
           fmt_rest$17 = parse(str_ind, end_ind)[1];
          if(get_ign(0)){
           var
            ignored$8 = [2, iconv$2, get_pad_opt(95)],
            fmt_result = [0, [23, ignored$8, fmt_rest$17]];
           break a;
          }
          var
           C = get_prec(0),
           match$6 = make_padprec_fmt_ebb(get_int_pad(0), C, fmt_rest$17),
           fmt_rest$18 = match$6[3],
           prec$4 = match$6[2],
           pad$8 = match$6[1],
           fmt_result = [0, [4, iconv$2, pad$8, prec$4, fmt_rest$18]];
          break a;
         case 69:
         case 70:
         case 71:
         case 72:
         case 101:
         case 102:
         case 103:
         case 104:
          var
           space$1 = get_space(0),
           hash$1 = get_hash(0),
           plus$2 = get_plus(0),
           flag =
             plus$2
              ? space$1
                ? legacy_behavior$0
                  ? 1
                  : incompatible_flag(pct_ind, str_ind, 32, cst$36)
                : 1
              : space$1 ? 2 : 0;
          b:
          {
           if(73 <= symb){
            var switcher = symb - 101 | 0;
            if(3 >= switcher >>> 0)
             switch(switcher){
               case 0:
                var kind = 1; break b;
               case 1:
                var kind = 0; break b;
               case 2:
                var kind = 3; break b;
               default: var kind = 6; break b;
             }
           }
           else if(69 <= symb)
            switch(symb - 69 | 0){
              case 0:
               var kind = 2; break b;
              case 2:
               var kind = 4; break b;
              case 3:
               var kind = 7; break b;
            }
           if(hash$1){
            if(70 === symb){var kind = 8; break b;}
           }
           else if(70 === symb){var kind = 5; break b;}
           throw caml_maybe_attach_backtrace([0, Assert_failure, X], 1);
          }
          var
           fconv = [0, flag, kind],
           fmt_rest$11 = parse(str_ind, end_ind)[1];
          if(! get_ign(0)){
           var
            z = get_prec(0),
            match$4 = make_padprec_fmt_ebb(get_pad(0), z, fmt_rest$11),
            fmt_rest$12 = match$4[3],
            prec$3 = match$4[2],
            pad$5 = match$4[1],
            fmt_result = [0, [8, fconv, pad$5, prec$3, fmt_rest$12]];
           break a;
          }
          var match = get_prec(0);
          if(typeof match === "number")
           var
            g = match ? incompatible_flag(pct_ind, str_ind, 95, cst$26) : 0;
          else
           var ndec = match[1], g = [0, ndec];
          var
           ignored$4 = [6, get_pad_opt(95), g],
           fmt_result = [0, [23, ignored$4, fmt_rest$11]];
          break a;
       }
      if(108 <= symb){
       if(111 > symb)
        switch(symb - 108 | 0){
          case 0:
           var
            m = caml_string_get(str, str_ind),
            o = get_space(0),
            p = get_hash(0),
            iconv =
              compute_int_conv(pct_ind, str_ind + 1 | 0, get_plus(0), p, o, m),
            fmt_rest = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0)){
            var
             ignored = [3, iconv, get_pad_opt(95)],
             fmt_result = [0, [23, ignored, fmt_rest]];
            break a;
           }
           var
            q = get_prec(0),
            match$0 = make_padprec_fmt_ebb(get_int_pad(0), q, fmt_rest),
            fmt_rest$0 = match$0[3],
            prec$0 = match$0[2],
            pad$0 = match$0[1],
            fmt_result = [0, [5, iconv, pad$0, prec$0, fmt_rest$0]];
           break a;
          case 2:
           var
            r = caml_string_get(str, str_ind),
            s = get_space(0),
            t = get_hash(0),
            iconv$0 =
              compute_int_conv(pct_ind, str_ind + 1 | 0, get_plus(0), t, s, r),
            fmt_rest$1 = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0)){
            var
             ignored$0 = [4, iconv$0, get_pad_opt(95)],
             fmt_result = [0, [23, ignored$0, fmt_rest$1]];
            break a;
           }
           var
            u = get_prec(0),
            match$1 = make_padprec_fmt_ebb(get_int_pad(0), u, fmt_rest$1),
            fmt_rest$2 = match$1[3],
            prec$1 = match$1[2],
            pad$1 = match$1[1],
            fmt_result = [0, [6, iconv$0, pad$1, prec$1, fmt_rest$2]];
           break a;
        }
      }
      else if(76 === symb){
       var
        v = caml_string_get(str, str_ind),
        w = get_space(0),
        x = get_hash(0),
        iconv$1 =
          compute_int_conv(pct_ind, str_ind + 1 | 0, get_plus(0), x, w, v),
        fmt_rest$3 = parse(str_ind + 1 | 0, end_ind)[1];
       if(get_ign(0)){
        var
         ignored$1 = [5, iconv$1, get_pad_opt(95)],
         fmt_result = [0, [23, ignored$1, fmt_rest$3]];
        break a;
       }
       var
        y = get_prec(0),
        match$2 = make_padprec_fmt_ebb(get_int_pad(0), y, fmt_rest$3),
        fmt_rest$4 = match$2[3],
        prec$2 = match$2[2],
        pad$2 = match$2[1],
        fmt_result = [0, [7, iconv$1, pad$2, prec$2, fmt_rest$4]];
       break a;
      }
      var
       fmt_result =
         caml_call3(failwith_message(J), str, str_ind - 1 | 0, symb);
     }
     if(1 - legacy_behavior$0){
      var a = 1 - plus_used[1], plus$0 = a ? plus : a;
      if(plus$0) incompatible_flag(pct_ind, str_ind, symb, cst$27);
      var b = 1 - hash_used[1], hash$0 = b ? hash : b;
      if(hash$0) incompatible_flag(pct_ind, str_ind, symb, cst$28);
      var c = 1 - space_used[1], space$0 = c ? space : c;
      if(space$0) incompatible_flag(pct_ind, str_ind, symb, cst$29);
      var d = 1 - pad_used[1], j = d ? caml_notequal([0, pad], K) : d;
      if(j) incompatible_flag(pct_ind, str_ind, symb, cst_padding$0);
      var e = 1 - prec_used[1], k = e ? caml_notequal([0, prec], L) : e;
      if(k){
       var l = ign ? 95 : symb;
       incompatible_flag(pct_ind, str_ind, l, cst_precision$2);
      }
      var plus$1 = ign ? plus : ign;
      if(plus$1) incompatible_flag(pct_ind, str_ind, 95, cst$30);
     }
     var f = 1 - ign_used[1], ign$0 = f ? ign : f;
     a:
     if(ign$0){
      b:
      {
       if(38 <= symb){
        if(44 !== symb && 64 !== symb) break b;
       }
       else if(33 !== symb && 37 > symb) break b;
       if(legacy_behavior$0) break a;
      }
      incompatible_flag(pct_ind, str_ind, symb, cst$31);
     }
     return fmt_result;
    }
    function parse_after_at(str_ind, end_ind){
     if(str_ind === end_ind) return N;
     var c = caml_string_get(str, str_ind);
     if(65 <= c){
      if(94 <= c){
       var switcher = c - 123 | 0;
       if(2 >= switcher >>> 0)
        switch(switcher){
          case 0:
           return parse_tag(1, str_ind + 1 | 0, end_ind);
          case 2:
           var fmt_rest$0 = parse(str_ind + 1 | 0, end_ind)[1];
           return [0, [17, 1, fmt_rest$0]];
        }
      }
      else if(91 <= c)
       switch(c - 91 | 0){
         case 0:
          return parse_tag(0, str_ind + 1 | 0, end_ind);
         case 2:
          var fmt_rest$1 = parse(str_ind + 1 | 0, end_ind)[1];
          return [0, [17, 0, fmt_rest$1]];
       }
     }
     else{
      if(10 === c){
       var fmt_rest$2 = parse(str_ind + 1 | 0, end_ind)[1];
       return [0, [17, 3, fmt_rest$2]];
      }
      if(32 <= c)
       switch(c - 32 | 0){
         case 0:
          var fmt_rest$3 = parse(str_ind + 1 | 0, end_ind)[1];
          return [0, [17, O, fmt_rest$3]];
         case 5:
          if
           ((str_ind + 1 | 0) < end_ind
            && 37 === caml_string_get(str, str_ind + 1 | 0)){
           var fmt_rest$4 = parse(str_ind + 2 | 0, end_ind)[1];
           return [0, [17, 6, fmt_rest$4]];
          }
          var fmt_rest$5 = parse(str_ind, end_ind)[1];
          return [0, [12, 64, fmt_rest$5]];
         case 12:
          var fmt_rest$6 = parse(str_ind + 1 | 0, end_ind)[1];
          return [0, [17, P, fmt_rest$6]];
         case 14:
          var fmt_rest$7 = parse(str_ind + 1 | 0, end_ind)[1];
          return [0, [17, 4, fmt_rest$7]];
         case 27:
          var str_ind$0 = str_ind + 1 | 0;
          a:
          try{
           var
            b = str_ind$0 === end_ind ? 1 : 0,
            d = b || (60 !== caml_string_get(str, str_ind$0) ? 1 : 0);
           if(d) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
           var
            str_ind_1 = parse_spaces(str_ind$0 + 1 | 0, end_ind),
            match = caml_string_get(str, str_ind_1);
           b:
           {
            if(48 <= match){
             if(58 <= match) break b;
            }
            else if(45 !== match) break b;
            var
             match$0 = parse_integer(str_ind_1, end_ind),
             width = match$0[2],
             str_ind_2 = match$0[1],
             str_ind_3 = parse_spaces(str_ind_2, end_ind),
             switcher$0 = caml_string_get(str, str_ind_3) - 45 | 0;
            if(12 < switcher$0 >>> 0){
             if(17 === switcher$0){
              var
               s =
                 Stdlib_String[15].call
                  (null,
                   str,
                   str_ind$0 - 2 | 0,
                   (str_ind_3 - str_ind$0 | 0) + 3 | 0),
               e = [0, s, width, 0],
               f = str_ind_3 + 1 | 0,
               formatting_lit$0 = e,
               next_ind = f;
              break a;
             }
            }
            else if(1 < switcher$0 - 1 >>> 0){
             var
              match$1 = parse_integer(str_ind_3, end_ind),
              offset = match$1[2],
              str_ind_4 = match$1[1],
              str_ind_5 = parse_spaces(str_ind_4, end_ind);
             if(62 !== caml_string_get(str, str_ind_5))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$0 =
                Stdlib_String[15].call
                 (null,
                  str,
                  str_ind$0 - 2 | 0,
                  (str_ind_5 - str_ind$0 | 0) + 3 | 0),
              g = [0, s$0, width, offset],
              h = str_ind_5 + 1 | 0,
              formatting_lit$0 = g,
              next_ind = h;
             break a;
            }
            throw caml_maybe_attach_backtrace(Stdlib[8], 1);
           }
           throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          }
          catch(exn$0){
           var exn = caml_wrap_exception(exn$0);
           if(exn === Stdlib[8])
            var formatting_lit$0 = formatting_lit, next_ind = str_ind$0;
           else{
            if(exn[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(exn, 0);
            var formatting_lit$0 = formatting_lit, next_ind = str_ind$0;
           }
          }
          var fmt_rest$10 = parse(next_ind, end_ind)[1];
          return [0, [17, formatting_lit$0, fmt_rest$10]];
         case 28:
          var str_ind$1 = str_ind + 1 | 0;
          try{
           var
            str_ind_1$0 = parse_spaces(str_ind$1, end_ind),
            match$4 = caml_string_get(str, str_ind_1$0);
           a:
           {
            b:
            {
             if(48 <= match$4){
              if(58 <= match$4) break b;
             }
             else if(45 !== match$4) break b;
             var
              match$5 = parse_integer(str_ind_1$0, end_ind),
              size = match$5[2],
              str_ind_2$0 = match$5[1],
              str_ind_3$0 = parse_spaces(str_ind_2$0, end_ind);
             if(62 !== caml_string_get(str, str_ind_3$0))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$1 =
                Stdlib_String[15].call
                 (null,
                  str,
                  str_ind$1 - 2 | 0,
                  (str_ind_3$0 - str_ind$1 | 0) + 3 | 0),
              a = [0, [0, str_ind_3$0 + 1 | 0, [1, s$1, size]]];
             break a;
            }
            var a = 0;
           }
           var match$2 = a;
          }
          catch(exn){
           var exn$0 = caml_wrap_exception(exn);
           if(exn$0 !== Stdlib[8] && exn$0[1] !== Stdlib[7])
            throw caml_maybe_attach_backtrace(exn$0, 0);
           var match$2 = 0;
          }
          if(match$2){
           var
            match$3 = match$2[1],
            formatting_lit$1 = match$3[2],
            next_ind$0 = match$3[1],
            fmt_rest$11 = parse(next_ind$0, end_ind)[1];
           return [0, [17, formatting_lit$1, fmt_rest$11]];
          }
          var fmt_rest$12 = parse(str_ind$1, end_ind)[1];
          return [0, [17, Q, fmt_rest$12]];
         case 31:
          var fmt_rest$8 = parse(str_ind + 1 | 0, end_ind)[1];
          return [0, [17, 2, fmt_rest$8]];
         case 32:
          var fmt_rest$9 = parse(str_ind + 1 | 0, end_ind)[1];
          return [0, [17, 5, fmt_rest$9]];
       }
     }
     var fmt_rest = parse(str_ind + 1 | 0, end_ind)[1];
     return [0, [17, [2, c], fmt_rest]];
    }
    function parse_tag(is_open_tag, str_ind, end_ind){
     try{
      if(str_ind === end_ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      if(60 !== caml_string_get(str, str_ind))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var ind = Stdlib_String[31].call(null, str, str_ind + 1 | 0, 62);
      if(end_ind <= ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var
       sub_str =
         Stdlib_String[15].call
          (null, str, str_ind, (ind - str_ind | 0) + 1 | 0),
       fmt_rest$0 = parse(ind + 1 | 0, end_ind)[1],
       sub_fmt = parse(str_ind, ind + 1 | 0)[1],
       sub_format$0 = [0, sub_fmt, sub_str],
       formatting$0 = is_open_tag ? [0, sub_format$0] : [1, sub_format$0],
       a = [0, [18, formatting$0, fmt_rest$0]];
      return a;
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn, 0);
      var
       fmt_rest = parse(str_ind, end_ind)[1],
       formatting = is_open_tag ? [0, sub_format] : [1, sub_format];
      return [0, [18, formatting, fmt_rest]];
     }
    }
    function parse_char_set(str_ind, end_ind){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var char_set = create_char_set(0);
     function add_range(c$0, c){
      if(c >= c$0){
       var i = c$0;
       for(;;){
        add_in_char_set(char_set, Stdlib[29].call(null, i));
        var a = i + 1 | 0;
        if(c === i) break;
        i = a;
       }
      }
     }
     function fail_single_percent(str_ind){
      return caml_call2(failwith_message(R), str, str_ind);
     }
     function parse_char_set_content(counter, str_ind$1, end_ind){
      var str_ind = str_ind$1;
      for(;;){
       if(str_ind === end_ind)
        invalid_format_message(end_ind, cst_unexpected_end_of_format);
       var c = caml_string_get(str, str_ind);
       if(45 !== c){
        if(93 === c) return str_ind + 1 | 0;
        var a = str_ind + 1 | 0;
        if(counter >= 50)
         return caml_trampoline_return
                 (parse_char_set_after_char$0, [0, a, end_ind, c]);
        var counter$0 = counter + 1 | 0;
        return parse_char_set_after_char$0(counter$0, a, end_ind, c);
       }
       add_in_char_set(char_set, 45);
       var str_ind$0 = str_ind + 1 | 0;
       str_ind = str_ind$0;
      }
     }
     function parse_char_set_after_char$0(counter, str_ind$2, end_ind, c$3){
      var str_ind = str_ind$2, c = c$3;
      for(;;){
       if(str_ind === end_ind)
        invalid_format_message(end_ind, cst_unexpected_end_of_format);
       var c$0 = caml_string_get(str, str_ind);
       a:
       {
        if(46 <= c$0){
         if(64 !== c$0){
          if(93 !== c$0) break a;
          add_in_char_set(char_set, c);
          return str_ind + 1 | 0;
         }
        }
        else if(37 !== c$0){if(45 <= c$0) break; break a;}
        if(37 === c){
         add_in_char_set(char_set, c$0);
         var a = str_ind + 1 | 0;
         if(counter >= 50)
          return caml_trampoline_return
                  (parse_char_set_content, [0, a, end_ind]);
         var counter$0 = counter + 1 | 0;
         return parse_char_set_content(counter$0, a, end_ind);
        }
       }
       if(37 === c) fail_single_percent(str_ind);
       add_in_char_set(char_set, c);
       var str_ind$0 = str_ind + 1 | 0;
       str_ind = str_ind$0;
       c = c$0;
      }
      var str_ind$1 = str_ind + 1 | 0;
      if(str_ind$1 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var c$1 = caml_string_get(str, str_ind$1);
      if(37 === c$1){
       if((str_ind$1 + 1 | 0) === end_ind)
        invalid_format_message(end_ind, cst_unexpected_end_of_format);
       var c$2 = caml_string_get(str, str_ind$1 + 1 | 0);
       if(37 !== c$2 && 64 !== c$2) return fail_single_percent(str_ind$1);
       add_range(c, c$2);
       var b = str_ind$1 + 2 | 0;
       if(counter >= 50)
        return caml_trampoline_return(parse_char_set_content, [0, b, end_ind]);
       var counter$2 = counter + 1 | 0;
       return parse_char_set_content(counter$2, b, end_ind);
      }
      if(93 === c$1){
       add_in_char_set(char_set, c);
       add_in_char_set(char_set, 45);
       return str_ind$1 + 1 | 0;
      }
      add_range(c, c$1);
      var d = str_ind$1 + 1 | 0;
      if(counter >= 50)
       return caml_trampoline_return(parse_char_set_content, [0, d, end_ind]);
      var counter$1 = counter + 1 | 0;
      return parse_char_set_content(counter$1, d, end_ind);
     }
     function parse_char_set_after_char(str_ind, end_ind, c){
      return caml_trampoline
              (parse_char_set_after_char$0(0, str_ind, end_ind, c));
     }
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     if(94 === caml_string_get(str, str_ind))
      var str_ind$0 = str_ind + 1 | 0, reverse = 1, str_ind$1 = str_ind$0;
     else
      var reverse = 0, str_ind$1 = str_ind;
     if(str_ind$1 === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var
      c = caml_string_get(str, str_ind$1),
      next_ind = parse_char_set_after_char(str_ind$1 + 1 | 0, end_ind, c),
      char_set$0 = freeze_char_set(char_set),
      a = reverse ? rev_char_set(char_set$0) : char_set$0;
     return [0, next_ind, a];
    }
    function parse_spaces(str_ind$1, end_ind){
     var str_ind = str_ind$1;
     for(;;){
      if(str_ind === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      if(32 !== caml_string_get(str, str_ind)) return str_ind;
      var str_ind$0 = str_ind + 1 | 0;
      str_ind = str_ind$0;
     }
    }
    function parse_positive(str_ind$1, end_ind, acc$0){
     var str_ind = str_ind$1, acc = acc$0;
     for(;;){
      if(str_ind === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var c = caml_string_get(str, str_ind);
      if(9 < c - 48 >>> 0) return [0, str_ind, acc];
      var new_acc = (acc * 10 | 0) + (c - 48 | 0) | 0;
      if(Stdlib_Sys[12] < new_acc){
       var a = Stdlib_Sys[12];
       return caml_call3(failwith_message(S), str, new_acc, a);
      }
      var str_ind$0 = str_ind + 1 | 0;
      str_ind = str_ind$0;
      acc = new_acc;
     }
    }
    function parse_integer(str_ind, end_ind){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var match = caml_string_get(str, str_ind);
     if(48 <= match){
      if(58 > match) return parse_positive(str_ind, end_ind, 0);
     }
     else if(45 === match){
      if((str_ind + 1 | 0) === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var c = caml_string_get(str, str_ind + 1 | 0);
      if(9 < c - 48 >>> 0)
       return expected_character(str_ind + 1 | 0, cst_digit, c);
      var
       match$0 = parse_positive(str_ind + 1 | 0, end_ind, 0),
       n = match$0[2],
       next_ind = match$0[1];
      return [0, next_ind, - n | 0];
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, T], 1);
    }
    function add_literal(lit_start, str_ind, fmt){
     var size = str_ind - lit_start | 0;
     return 0 === size
             ? [0, fmt]
             : 1
               === size
               ? [0, [12, caml_string_get(str, lit_start), fmt]]
               : [0,
                 [11, Stdlib_String[15].call(null, str, lit_start, size), fmt]];
    }
    function search_subformat_end(str_ind$7, end_ind, c){
     var str_ind = str_ind$7;
     for(;;){
      if(str_ind === end_ind)
       caml_call3(failwith_message(U), str, c, end_ind);
      if(37 === caml_string_get(str, str_ind)){
       if((str_ind + 1 | 0) === end_ind)
        invalid_format_message(end_ind, cst_unexpected_end_of_format);
       if(caml_string_get(str, str_ind + 1 | 0) === c) return str_ind;
       var match = caml_string_get(str, str_ind + 1 | 0);
       if(95 <= match){
        if(123 <= match){
         if(126 > match)
          switch(match - 123 | 0){
            case 0:
             var
              sub_end = search_subformat_end(str_ind + 2 | 0, end_ind, 125),
              str_ind$1 = sub_end + 2 | 0;
             str_ind = str_ind$1;
             continue;
            case 2:
             return expected_character(str_ind + 1 | 0, cst_character, 125);
          }
        }
        else if(96 > match){
         if((str_ind + 2 | 0) === end_ind)
          invalid_format_message(end_ind, cst_unexpected_end_of_format);
         var match$0 = caml_string_get(str, str_ind + 2 | 0);
         if(40 === match$0){
          var
           sub_end$0 = search_subformat_end(str_ind + 3 | 0, end_ind, 41),
           str_ind$2 = sub_end$0 + 2 | 0;
          str_ind = str_ind$2;
          continue;
         }
         if(123 === match$0){
          var
           sub_end$1 = search_subformat_end(str_ind + 3 | 0, end_ind, 125),
           str_ind$3 = sub_end$1 + 2 | 0;
          str_ind = str_ind$3;
          continue;
         }
         var str_ind$4 = str_ind + 3 | 0;
         str_ind = str_ind$4;
         continue;
        }
       }
       else{
        if(40 === match){
         var
          sub_end$2 = search_subformat_end(str_ind + 2 | 0, end_ind, 41),
          str_ind$5 = sub_end$2 + 2 | 0;
         str_ind = str_ind$5;
         continue;
        }
        if(41 === match)
         return expected_character(str_ind + 1 | 0, cst_character$0, 41);
       }
       var str_ind$0 = str_ind + 2 | 0;
       str_ind = str_ind$0;
      }
      else{var str_ind$6 = str_ind + 1 | 0; str_ind = str_ind$6;}
     }
    }
    function compute_int_conv(pct_ind, str_ind, plus$0, hash$0, space$0, symb){
     var plus = plus$0, hash = hash$0, space = space$0;
     for(;;){
      a:
      {
       if(plus){
        if(! hash){
         if(space) break a;
         if(100 === symb) return 1;
         if(105 === symb) return 4;
         break a;
        }
       }
       else{
        if(! hash){
         if(space){
          if(100 === symb) return 2;
          if(105 === symb) return 5;
          break a;
         }
         var switcher$1 = symb - 88 | 0;
         if(32 < switcher$1 >>> 0) break a;
         switch(switcher$1){
           case 0:
            return 8;
           case 12:
            return 0;
           case 17:
            return 3;
           case 23:
            return 10;
           case 29:
            return 12;
           case 32:
            return 6;
           default: break a;
         }
        }
        if(! space){
         var switcher$0 = symb - 88 | 0;
         if(32 >= switcher$0 >>> 0)
          switch(switcher$0){
            case 0:
             return 9;
            case 12:
             return 13;
            case 17:
             return 14;
            case 23:
             return 11;
            case 29:
             return 15;
            case 32:
             return 7;
          }
        }
       }
       var switcher = symb - 88 | 0;
       if(32 >= switcher >>> 0)
        switch(switcher){
          case 0:
           if(legacy_behavior$0) return 9; break;
          case 23:
           if(legacy_behavior$0) return 11; break;
          case 32:
           if(legacy_behavior$0) return 7; break;
          case 12:
          case 17:
          case 29:
           if(! legacy_behavior$0)
            return incompatible_flag(pct_ind, str_ind, symb, cst$35);
           hash = 0;
           continue;
        }
      }
      if(plus)
       if(space){
        if(! legacy_behavior$0)
         return incompatible_flag(pct_ind, str_ind, 32, cst$32);
        space = 0;
       }
       else{
        if(! legacy_behavior$0)
         return incompatible_flag(pct_ind, str_ind, symb, cst$33);
        plus = 0;
       }
      else{
       if(! space)
        throw caml_maybe_attach_backtrace([0, Assert_failure, W], 1);
       if(! legacy_behavior$0)
        return incompatible_flag(pct_ind, str_ind, symb, cst$34);
       space = 0;
      }
     }
    }
    function incompatible_flag(pct_ind, str_ind, symb, option){
     var
      subfmt =
        Stdlib_String[15].call(null, str, pct_ind, str_ind - pct_ind | 0);
     return caml_call5
             (failwith_message(Y), str, pct_ind, option, symb, subfmt);
    }
    return parse(0, caml_ml_string_length(str));
   }
   function format_of_string_fmtty(str, fmtty){
    var fmt = fmt_ebb_of_string(0, str)[1];
    try{var b = [0, type_format(fmt, fmtty), str]; return b;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn !== Type_mismatch) throw caml_maybe_attach_backtrace(exn, 0);
     var a = string_of_fmtty(fmtty);
     return caml_call2(failwith_message(Z), str, a);
    }
   }
   function format_of_string_format(str, param){
    var
     str$0 = param[2],
     fmt = param[1],
     fmt$0 = fmt_ebb_of_string(0, str)[1];
    try{var a = [0, type_format(fmt$0, fmtty_of_fmt(fmt)), str]; return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Type_mismatch)
      return caml_call2(failwith_message(_), str, str$0);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var
    CamlinternalFormat =
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
   runtime.caml_register_global(197, CamlinternalFormat, "CamlinternalFormat");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Printf
//# unitInfo: Requires: CamlinternalFormat, Stdlib, Stdlib__Buffer
//# shape: Stdlib__Printf:[F(2),F(1),F(1),F(1),F(2),F(2),F(2),F(3),F(3),F(2),F(3),F(3),F(2)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    CamlinternalFormat = global_data.CamlinternalFormat,
    Stdlib = global_data.Stdlib;
   function kfprintf(k, o, param){
    var fmt = param[1];
    return CamlinternalFormat[7].call
            (null,
             function(acc){
              CamlinternalFormat[9].call(null, o, acc);
              return caml_call1(k, o);
             },
             0,
             fmt);
   }
   function kbprintf(k, b, param){
    var fmt = param[1];
    return CamlinternalFormat[7].call
            (null,
             function(acc){
              CamlinternalFormat[10].call(null, b, acc);
              return caml_call1(k, b);
             },
             0,
             fmt);
   }
   function ikfprintf(k, oc, param){
    var fmt = param[1];
    return CamlinternalFormat[8].call(null, k, oc, fmt);
   }
   function fprintf(oc, fmt){
    return kfprintf(function(a){return 0;}, oc, fmt);
   }
   function bprintf(b, fmt){return kbprintf(function(a){return 0;}, b, fmt);}
   function ifprintf(oc, fmt){
    return ikfprintf(function(a){return 0;}, oc, fmt);
   }
   function ibprintf(b, fmt){
    return ikfprintf(function(a){return 0;}, b, fmt);
   }
   function printf(fmt){return fprintf(Stdlib[39], fmt);}
   function eprintf(fmt){return fprintf(Stdlib[40], fmt);}
   function ksprintf(k, param){
    var fmt = param[1];
    function k$0(acc){
     var buf = Stdlib_Buffer[1].call(null, 64);
     CamlinternalFormat[11].call(null, buf, acc);
     return caml_call1(k, Stdlib_Buffer[2].call(null, buf));
    }
    return CamlinternalFormat[7].call(null, k$0, 0, fmt);
   }
   function sprintf(fmt){return ksprintf(function(s){return s;}, fmt);}
   var
    Stdlib_Printf =
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       ibprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ikfprintf,
       ksprintf];
   runtime.caml_register_global(3, Stdlib_Printf, "Stdlib__Printf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Arg
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Int, Stdlib__List, Stdlib__Printf, Stdlib__String, Stdlib__Sys
//# shape: Stdlib__Arg:[F(3),F(3),F(5),F(5),F(5),F(3),N,N,F(2),F(2),F(2),N,F(1),F(1),F(2),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$7 = "",
    cst$9 = "  ",
    cst_Display_this_list_of_optio$1 = " Display this list of options",
    cst_s = "%s",
    cst_help$4 = "--help",
    cst_help$3 = "-help",
    cst$8 = ".\n",
    cst_a_float$1 = "a float",
    cst_an_integer$1 = "an integer",
    caml_check_bound = runtime.caml_check_bound,
    caml_equal = runtime.caml_equal,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$6 = "\n",
    cst$3 = cst$7,
    cst$4 = " ",
    cst$5 = cst$7,
    cst$2 = "(?)",
    cst = "}",
    cst$0 = "|",
    cst$1 = "{",
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Int = global_data.Stdlib__Int,
    Bad = [248, "Stdlib.Arg.Bad", caml_fresh_oo_id(0)],
    Help = [248, "Stdlib.Arg.Help", caml_fresh_oo_id(0)],
    Stop = [248, "Stdlib.Arg.Stop", caml_fresh_oo_id(0)],
    cst_none = "<none>",
    a = [0, [11, cst$9, [2, 0, [12, 32, [2, 0, [12, 10, 0]]]]], "  %s %s\n"],
    b =
      [0,
       [11, cst$9, [2, 0, [12, 32, [2, 0, [2, 0, [12, 10, 0]]]]]],
       "  %s %s%s\n"],
    c = [0, cst_help$3],
    cst_Display_this_list_of_optio = cst_Display_this_list_of_optio$1,
    cst_help = cst_help$3,
    cst_Display_this_list_of_optio$0 = cst_Display_this_list_of_optio$1,
    cst_help$0 = cst_help$4,
    cst_help$1 = cst_help$4,
    cst_help$2 = cst_help$3,
    d = [0, [2, 0, [12, 10, 0]], "%s\n"],
    e = [0, [2, 0, 0], cst_s];
   function assoc3(x, l$0){
    var l = l$0;
    for(;;){
     if(! l) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var match = l[1], y2 = match[2], y1 = match[1];
     if(caml_equal(y1, x)) return y2;
     var t = l[2];
     l = t;
    }
   }
   function make_symlist(prefix, sep, suffix, l){
    if(! l) return cst_none;
    var
     t = l[2],
     h = l[1],
     a = Stdlib[28].call(null, prefix, h),
     b =
       Stdlib_List[25].call
        (null,
         function(x, y){
          var a = Stdlib[28].call(null, sep, y);
          return Stdlib[28].call(null, x, a);
         },
         a,
         t);
    return Stdlib[28].call(null, b, suffix);
   }
   function help_action(param){
    throw caml_maybe_attach_backtrace([0, Stop, c], 1);
   }
   function add_help(speclist){
    try{assoc3(cst_help$2, speclist); var c = 0, add1 = c;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn, 0);
     var
      add1 =
        [0,
         [0, cst_help, [0, help_action], cst_Display_this_list_of_optio],
         0];
    }
    try{assoc3(cst_help$1, speclist); var b = 0, add2 = b;}
    catch(exn){
     var exn$0 = caml_wrap_exception(exn);
     if(exn$0 !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn$0, 0);
     var
      add2 =
        [0,
         [0, cst_help$0, [0, help_action], cst_Display_this_list_of_optio$0],
         0];
    }
    var a = Stdlib[37].call(null, add1, add2);
    return Stdlib[37].call(null, speclist, a);
   }
   function usage_b(buf, speclist, errmsg){
    caml_call1(Stdlib_Printf[5].call(null, buf, d), errmsg);
    var c = add_help(speclist);
    return Stdlib_List[17].call
            (null,
             function(param){
              var
               doc = param[3],
               spec = param[2],
               key = param[1],
               c = 0 < caml_ml_string_length(doc) ? 1 : 0;
              if(! c) return c;
              if(11 !== spec[0])
               return caml_call2
                       (Stdlib_Printf[5].call(null, buf, a), key, doc);
              var l = spec[1], d = make_symlist(cst$1, cst$0, cst, l);
              return caml_call3
                      (Stdlib_Printf[5].call(null, buf, b), key, d, doc);
             },
             c);
   }
   function usage_string(speclist, errmsg){
    var b = Stdlib_Buffer[1].call(null, 200);
    usage_b(b, speclist, errmsg);
    return Stdlib_Buffer[2].call(null, b);
   }
   function usage(speclist, errmsg){
    var a = usage_string(speclist, errmsg);
    return caml_call1(Stdlib_Printf[3].call(null, e), a);
   }
   var
    current = [0, 0],
    f =
      [0,
       [2, 0, [11, ": unknown option '", [2, 0, [11, "'.\n", 0]]]],
       "%s: unknown option '%s'.\n"],
    g = [0, cst_help$3],
    h = [0, cst_help$4],
    i =
      [0,
       [2,
        0,
        [11,
         ": wrong argument '",
         [2,
          0,
          [11,
           "'; option '",
           [2, 0, [11, "' expects ", [2, 0, [11, cst$8, 0]]]]]]]],
       "%s: wrong argument '%s'; option '%s' expects %s.\n"],
    j =
      [0,
       [2, 0, [11, ": option '", [2, 0, [11, "' needs an argument.\n", 0]]]],
       "%s: option '%s' needs an argument.\n"],
    k = [0, [2, 0, [11, ": ", [2, 0, [11, cst$8, 0]]]], "%s: %s.\n"],
    cst_no_argument = "no argument",
    cst_a_boolean = "a boolean",
    cst_an_integer = cst_an_integer$1,
    cst_an_integer$0 = cst_an_integer$1,
    cst_a_float = cst_a_float$1,
    cst_a_float$0 = cst_a_float$1,
    cst_one_of = "one of: ",
    cst_Arg_Expand_is_is_only_allo =
      "Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic",
    l = [0, [2, 0, 0], cst_s],
    m = [0, [2, 0, 0], cst_s],
    n = [0, [2, 0, 0], cst_s],
    o = [0, [2, 0, 0], cst_s],
    p = [0, [2, 0, 0], cst_s],
    q = [0, [2, 0, 0], cst_s],
    dummy = 0;
   function int_of_string_opt(x){
    try{var a = [0, runtime.caml_int_of_string(x)]; return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function float_of_string_opt(x){
    try{var a = [0, runtime.caml_float_of_string(x)]; return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function parse_and_expand_argv_dynamic_
   (allow_expand, current, argv, speclist, anonfun, errmsg){
    var initpos = current[1];
    function convert_error(error){
     var
      b = Stdlib_Buffer[1].call(null, 200),
      progname =
        initpos < argv[1].length - 1
         ? caml_check_bound(argv[1], initpos)[initpos + 1]
         : cst$2;
     switch(error[0]){
       case 0:
        var s = error[1];
        if(s !== cst_help$4 && s !== cst_help$3)
         caml_call2(Stdlib_Printf[5].call(null, b, f), progname, s);
        break;
       case 1:
        var expected = error[3], arg = error[2], opt = error[1];
        caml_call4
         (Stdlib_Printf[5].call(null, b, i), progname, arg, opt, expected);
        break;
       case 2:
        var s$0 = error[1];
        caml_call2(Stdlib_Printf[5].call(null, b, j), progname, s$0);
        break;
       default:
        var s$1 = error[1];
        caml_call2(Stdlib_Printf[5].call(null, b, k), progname, s$1);
     }
     usage_b(b, speclist[1], errmsg);
     if(! caml_equal(error, g) && ! caml_equal(error, h))
      return [0, Bad, Stdlib_Buffer[2].call(null, b)];
     return [0, Help, Stdlib_Buffer[2].call(null, b)];
    }
    current[1]++;
    for(;;){
     if(current[1] >= argv[1].length - 1) return 0;
     try{
      var a = current[1], s = caml_check_bound(argv[1], a)[a + 1];
      a:
      {
       if(1 <= caml_ml_string_length(s) && 45 === caml_string_get(s, 0)){
        try{
         var
          follow$1 = 0,
          c = assoc3(s, speclist[1]),
          follow$0 = follow$1,
          action = c;
        }
        catch(exn){
         var exn$0 = caml_wrap_exception(exn);
         if(exn$0 !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn$0, 0);
         try{
          var
           i$0 = Stdlib_String[35].call(null, s, 61),
           len = caml_ml_string_length(s),
           arg =
             Stdlib_String[15].call
              (null, s, i$0 + 1 | 0, len - (i$0 + 1 | 0) | 0),
           keyword = Stdlib_String[15].call(null, s, 0, i$0),
           follow = [0, arg],
           b = assoc3(keyword, speclist[1]),
           follow$0 = follow,
           action = b;
         }
         catch(exn){
          var exn$1 = caml_wrap_exception(exn);
          if(exn$1 === Stdlib[8])
           throw caml_maybe_attach_backtrace([0, Stop, [0, s]], 1);
          throw caml_maybe_attach_backtrace(exn$1, 0);
         }
        }
        let s$0 = s, follow$2 = follow$0;
        var
         no_arg =
           function(param){
            if(! follow$2) return;
            var arg = follow$2[1];
            throw caml_maybe_attach_backtrace
                   ([0, Stop, [1, s$0, arg, cst_no_argument]], 1);
           },
         get_arg =
           function(param){
            if(follow$2){var arg = follow$2[1]; return arg;}
            if((current[1] + 1 | 0) >= argv[1].length - 1)
             throw caml_maybe_attach_backtrace([0, Stop, [2, s$0]], 1);
            var a = current[1] + 1 | 0;
            return caml_check_bound(argv[1], a)[a + 1];
           },
         consume_arg =
           function(param){return follow$2 ? 0 : (current[1]++, 0);},
         treat_action =
           function(param){
            switch(param[0]){
              case 0:
               var f = param[1]; no_arg$0(0); return caml_call1(f, 0);
              case 1:
               var f$0 = param[1], arg = get_arg$0(0);
               try{var c = [0, Stdlib[32].call(null, arg)], match = c;}
               catch(exn$0){
                var exn = caml_wrap_exception(exn$0), tag = exn[1];
                if(tag !== Stdlib[6])
                 throw caml_maybe_attach_backtrace(exn, 0);
                var match = 0;
               }
               if(! match)
                throw caml_maybe_attach_backtrace
                       ([0, Stop, [1, s$0, arg, cst_a_boolean]], 1);
               var s = match[1];
               caml_call1(f$0, s);
               return consume_arg$0(0);
              case 2:
               var r = param[1]; no_arg$0(0); r[1] = 1; return 0;
              case 3:
               var r$0 = param[1]; no_arg$0(0); r$0[1] = 0; return 0;
              case 4:
               var f$1 = param[1], arg$0 = get_arg$0(0);
               caml_call1(f$1, arg$0);
               return consume_arg$0(0);
              case 5:
               var r$1 = param[1];
               r$1[1] = get_arg$0(0);
               return consume_arg$0(0);
              case 6:
               var
                f$2 = param[1],
                arg$1 = get_arg$0(0),
                match$0 = int_of_string_opt(arg$1);
               if(! match$0)
                throw caml_maybe_attach_backtrace
                       ([0, Stop, [1, s$0, arg$1, cst_an_integer]], 1);
               var x = match$0[1];
               caml_call1(f$2, x);
               return consume_arg$0(0);
              case 7:
               var
                r$2 = param[1],
                arg$2 = get_arg$0(0),
                match$1 = int_of_string_opt(arg$2);
               if(! match$1)
                throw caml_maybe_attach_backtrace
                       ([0, Stop, [1, s$0, arg$2, cst_an_integer$0]], 1);
               var x$0 = match$1[1];
               r$2[1] = x$0;
               return consume_arg$0(0);
              case 8:
               var
                f$3 = param[1],
                arg$3 = get_arg$0(0),
                match$2 = float_of_string_opt(arg$3);
               if(! match$2)
                throw caml_maybe_attach_backtrace
                       ([0, Stop, [1, s$0, arg$3, cst_a_float]], 1);
               var x$1 = match$2[1];
               caml_call1(f$3, x$1);
               return consume_arg$0(0);
              case 9:
               var
                r$3 = param[1],
                arg$4 = get_arg$0(0),
                match$3 = float_of_string_opt(arg$4);
               if(! match$3)
                throw caml_maybe_attach_backtrace
                       ([0, Stop, [1, s$0, arg$4, cst_a_float$0]], 1);
               var x$2 = match$3[1];
               r$3[1] = x$2;
               return consume_arg$0(0);
              case 10:
               var specs = param[1];
               no_arg$0(0);
               return Stdlib_List[17].call(null, treat_action$0, specs);
              case 11:
               var f$4 = param[2], symb = param[1], arg$5 = get_arg$0(0);
               if(Stdlib_List[36].call(null, arg$5, symb)){
                caml_call1(f$4, arg$5);
                return consume_arg$0(0);
               }
               var d = make_symlist(cst$5, cst$4, cst$3, symb);
               throw caml_maybe_attach_backtrace
                      ([0,
                        Stop,
                        [1, s$0, arg$5, Stdlib[28].call(null, cst_one_of, d)]],
                       1);
              case 12:
               var f$5 = param[1];
               no_arg$0(0);
               for(;;){
                if(current[1] >= (argv[1].length - 2 | 0)) return 0;
                var a = current[1] + 1 | 0;
                caml_call1(f$5, caml_check_bound(argv[1], a)[a + 1]);
                consume_arg$0(0);
               }
               break;
              case 13:
               var f$6 = param[1];
               no_arg$0(0);
               var acc = [0, 0];
               for(;;){
                if(current[1] >= (argv[1].length - 2 | 0))
                 return caml_call1(f$6, Stdlib_List[9].call(null, acc[1]));
                var b = current[1] + 1 | 0, e = acc[1];
                acc[1] = [0, caml_check_bound(argv[1], b)[b + 1], e];
                consume_arg$0(0);
               }
               break;
              default:
               var f$7 = param[1];
               if(1 - allow_expand)
                throw caml_maybe_attach_backtrace
                       ([0, Stdlib[6], cst_Arg_Expand_is_is_only_allo], 1);
               var arg$6 = get_arg$0(0), newarg = caml_call1(f$7, arg$6);
               consume_arg$0(0);
               var
                before =
                  Stdlib_Array[7].call(null, argv[1], 0, current[1] + 1 | 0),
                after =
                  Stdlib_Array[7].call
                   (null,
                    argv[1],
                    current[1] + 1 | 0,
                    (argv[1].length - 1 - current[1] | 0) - 1 | 0);
               argv[1] =
                Stdlib_Array[6].call
                 (null, [0, before, [0, newarg, [0, after, 0]]]);
               return 0;
            }
           };
        let
         no_arg$0 = no_arg,
         get_arg$0 = get_arg,
         consume_arg$0 = consume_arg,
         treat_action$0 = treat_action;
        treat_action(action);
        break a;
       }
       caml_call1(anonfun, s);
      }
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0), tag = exn[1];
      if(tag === Bad){
       var m = exn[2];
       throw caml_maybe_attach_backtrace(convert_error([3, m]), 1);
      }
      var tag$0 = exn[1];
      if(tag$0 !== Stop) throw caml_maybe_attach_backtrace(exn, 0);
      var e = exn[2];
      throw caml_maybe_attach_backtrace(convert_error(e), 1);
     }
     current[1]++;
    }
   }
   function parse_and_expand_argv_dynamic
   (current, argv, speclist, anonfun, errmsg){
    return parse_and_expand_argv_dynamic_
            (1, current, argv, speclist, anonfun, errmsg);
   }
   function parse_argv_dynamic(opt, argv, speclist, anonfun, errmsg){
    if(opt) var sth = opt[1], current$0 = sth; else var current$0 = current;
    return parse_and_expand_argv_dynamic_
            (0, current$0, [0, argv], speclist, anonfun, errmsg);
   }
   function parse_argv(opt, argv, speclist, anonfun, errmsg){
    if(opt) var sth = opt[1], current$0 = sth; else var current$0 = current;
    return parse_argv_dynamic
            ([0, current$0], argv, [0, speclist], anonfun, errmsg);
   }
   function parse(l$0, f, msg){
    try{var a = parse_argv(0, caml_sys_argv(0), l$0, f, msg); return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag === Bad){
      var msg$0 = exn[2];
      caml_call1(Stdlib_Printf[3].call(null, l), msg$0);
      return Stdlib[99].call(null, 2);
     }
     var tag$0 = exn[1];
     if(tag$0 !== Help) throw caml_maybe_attach_backtrace(exn, 0);
     var msg$1 = exn[2];
     caml_call1(Stdlib_Printf[2].call(null, m), msg$1);
     return Stdlib[99].call(null, 0);
    }
   }
   function parse_dynamic(l, f, msg){
    try{var a = parse_argv_dynamic(0, caml_sys_argv(0), l, f, msg); return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag === Bad){
      var msg$0 = exn[2];
      caml_call1(Stdlib_Printf[3].call(null, n), msg$0);
      return Stdlib[99].call(null, 2);
     }
     var tag$0 = exn[1];
     if(tag$0 !== Help) throw caml_maybe_attach_backtrace(exn, 0);
     var msg$1 = exn[2];
     caml_call1(Stdlib_Printf[2].call(null, o), msg$1);
     return Stdlib[99].call(null, 0);
    }
   }
   function parse_expand(l, f, msg){
    try{
     var
      argv = [0, caml_sys_argv(0)],
      spec = [0, l],
      current$0 = [0, current[1]],
      a = parse_and_expand_argv_dynamic(current$0, argv, spec, f, msg);
     return a;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag === Bad){
      var msg$0 = exn[2];
      caml_call1(Stdlib_Printf[3].call(null, p), msg$0);
      return Stdlib[99].call(null, 2);
     }
     var tag$0 = exn[1];
     if(tag$0 !== Help) throw caml_maybe_attach_backtrace(exn, 0);
     var msg$1 = exn[2];
     caml_call1(Stdlib_Printf[2].call(null, q), msg$1);
     return Stdlib[99].call(null, 0);
    }
   }
   function second_word(s){
    var len = caml_ml_string_length(s);
    function loop(n$1){
     var n = n$1;
     for(;;){
      if(len <= n) return len;
      if(32 !== caml_string_get(s, n)) return n;
      var n$0 = n + 1 | 0;
      n = n$0;
     }
    }
    try{var n$0 = Stdlib_String[35].call(null, s, 9);}
    catch(exn$1){
     var exn = caml_wrap_exception(exn$1);
     if(exn !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn, 0);
     try{var n = Stdlib_String[35].call(null, s, 32);}
     catch(exn){
      var exn$0 = caml_wrap_exception(exn);
      if(exn$0 === Stdlib[8]) return len;
      throw caml_maybe_attach_backtrace(exn$0, 0);
     }
     return loop(n + 1 | 0);
    }
    return loop(n$0 + 1 | 0);
   }
   function max_arg_len(cur, param){
    var doc = param[3], spec = param[2], kwd = param[1];
    if(11 === spec[0])
     return Stdlib_Int[11].call(null, cur, caml_ml_string_length(kwd));
    var a = caml_ml_string_length(kwd) + second_word(doc) | 0;
    return Stdlib_Int[11].call(null, cur, a);
   }
   function replace_leading_tab(s){
    var seen = [0, 0];
    return Stdlib_String[17].call
            (null,
             function(c){
              if(9 === c && ! seen[1]){seen[1] = 1; return 32;}
              return c;
             },
             s);
   }
   function align(opt, speclist){
    if(opt) var sth = opt[1], limit = sth; else var limit = Stdlib[19];
    var
     completed = add_help(speclist),
     len = Stdlib_List[25].call(null, max_arg_len, 0, completed),
     len$0 = Stdlib_Int[10].call(null, len, limit);
    return Stdlib_List[19].call
            (null,
             function(ksd){
              var kwd = ksd[1], spec = ksd[2];
              if(ksd[3] === cst$7) return ksd;
              if(11 === spec[0]){
               var
                msg$0 = ksd[3],
                cutcol$0 = second_word(msg$0),
                c = Stdlib_Int[11].call(null, 0, len$0 - cutcol$0 | 0) + 3 | 0,
                spaces$0 = Stdlib_String[1].call(null, c, 32),
                d = replace_leading_tab(msg$0),
                e = Stdlib[28].call(null, spaces$0, d);
               return [0, kwd, spec, Stdlib[28].call(null, cst$6, e)];
              }
              var
               msg = ksd[3],
               spec$0 = ksd[2],
               cutcol = second_word(msg),
               kwd_len = caml_ml_string_length(kwd),
               diff = (len$0 - kwd_len | 0) - cutcol | 0;
              if(0 >= diff) return [0, kwd, spec$0, replace_leading_tab(msg)];
              var
               spaces = Stdlib_String[1].call(null, diff, 32),
               a = replace_leading_tab(msg),
               prefix = Stdlib_String[15].call(null, a, 0, cutcol),
               suffix =
                 Stdlib_String[15].call
                  (null, msg, cutcol, caml_ml_string_length(msg) - cutcol | 0),
               b = Stdlib[28].call(null, spaces, suffix);
              return [0, kwd, spec$0, Stdlib[28].call(null, prefix, b)];
             },
             completed);
   }
   function read_aux(trim, sep, file){
    var
     ic = Stdlib[80].call(null, file),
     buf = Stdlib_Buffer[1].call(null, 200),
     words = [0, 0];
    function stash(param){
     var word = Stdlib_Buffer[2].call(null, buf);
     if(trim)
      var
       len = caml_ml_string_length(word),
       word$0 =
         0 < len
          ? 13
            === caml_string_get(word, len - 1 | 0)
            ? Stdlib_String[15].call(null, word, 0, len - 1 | 0)
            : word
          : word;
     else
      var word$0 = word;
     words[1] = [0, word$0, words[1]];
     return Stdlib_Buffer[8].call(null, buf);
    }
    try{
     for(;;){
      var c = Stdlib[82].call(null, ic);
      if(c === sep) stash(0); else Stdlib_Buffer[12].call(null, buf, c);
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn !== Stdlib[12]) throw caml_maybe_attach_backtrace(exn, 0);
     if(0 < Stdlib_Buffer[7].call(null, buf)) stash(0);
     Stdlib[93].call(null, ic);
     var a = Stdlib_List[9].call(null, words[1]);
     return Stdlib_Array[12].call(null, a);
    }
   }
   var r = 10, s = 1;
   function read_arg(a){return read_aux(s, r, a);}
   var t = 0, u = 0, v = [0, [2, 0, [0, 0]], "%s%c"];
   function read_arg0(a){return read_aux(u, t, a);}
   function write_aux(sep, file, args){
    var oc = Stdlib[61].call(null, file);
    Stdlib_Array[13].call
     (null,
      function(s){
       return caml_call2(Stdlib_Printf[1].call(null, oc, v), s, sep);
      },
      args);
    return Stdlib[76].call(null, oc);
   }
   var w = 10;
   function write_arg(a, b){return write_aux(w, a, b);}
   var x = 0;
   function write_arg0(a, b){return write_aux(x, a, b);}
   var
    Stdlib_Arg =
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
   runtime.caml_register_global(54, Stdlib_Arg, "Stdlib__Arg");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Atomic
//# unitInfo: Requires: CamlinternalAtomic
//# shape: Stdlib__Atomic:[F(1)*,F(1)*,F(2),F(2),F(3),F(2),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    CamlinternalAtomic = global_data.CamlinternalAtomic,
    make = CamlinternalAtomic[1],
    get = CamlinternalAtomic[2],
    set = CamlinternalAtomic[3],
    exchange = CamlinternalAtomic[4],
    compare_and_set = CamlinternalAtomic[5],
    fetch_and_add = CamlinternalAtomic[6],
    incr = CamlinternalAtomic[7],
    decr = CamlinternalAtomic[8],
    Stdlib_Atomic =
      [0,
       make,
       get,
       set,
       exchange,
       compare_and_set,
       fetch_and_add,
       incr,
       decr];
   runtime.caml_register_global(1, Stdlib_Atomic, "Stdlib__Atomic");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Printexc
//# unitInfo: Requires: Stdlib, Stdlib__Atomic, Stdlib__Buffer, Stdlib__Obj, Stdlib__Printf
//# shape: Stdlib__Printexc:[F(1),F(1),F(2),F(2),F(1),F(1),F(1),F(1),F(1),F(1),F(1)*,F(1)*,F(2),F(1),F(2),F(1),F(1),F(1),N,F(1)*,F(2),F(1),F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_s = "%s\n",
    cst_Program_not_linked_with_g_$0 =
      "(Program not linked with -g, cannot print stack backtrace)\n",
    cst_characters = ", characters ",
    cst_Fatal_error_exception = "Fatal error: exception ",
    cst_Fatal_error_exception_s = "Fatal error: exception %s\n",
    cst_Uncaught_exception = "Uncaught exception: ",
    cst_Uncaught_exception_s = "Uncaught exception: %s\n",
    caml_check_bound = runtime.caml_check_bound,
    caml_get_exception_raw_backtra = runtime.caml_get_exception_raw_backtrace,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) === 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$4,
    cst$3 = cst$4,
    partial = [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]],
    cst$1 = cst$4,
    cst$2 = cst$4,
    cst = "_",
    locfmt =
      [0,
       [11,
        'File "',
        [2,
         0,
         [11,
          '", line ',
          [4,
           0,
           0,
           0,
           [11,
            cst_characters,
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [11, ": ", [2, 0, 0]]]]]]]]]],
       'File "%s", line %d, characters %d-%d: %s'],
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Obj = global_data.Stdlib__Obj,
    printers = Stdlib_Atomic[1].call(null, 0),
    a = [0, [3, 0, 0], "%S"],
    b = [0, [4, 0, 0, 0, 0], "%d"],
    c = [0, [11, ", ", [2, 0, [2, 0, 0]]], ", %s%s"],
    d = [0, [12, 40, [2, 0, [2, 0, [12, 41, 0]]]], "(%s%s)"],
    e = [0, [12, 40, [2, 0, [12, 41, 0]]], "(%s)"],
    cst_Out_of_memory = "Out of memory",
    cst_Stack_overflow = "Stack overflow",
    cst_Pattern_matching_failed = "Pattern matching failed",
    cst_Assertion_failed = "Assertion failed",
    cst_Undefined_recursive_module = "Undefined recursive module",
    f =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    g =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    cst_Raised_at = "Raised at",
    cst_Re_raised_at = "Re-raised at",
    cst_Raised_by_primitive_operat = "Raised by primitive operation at",
    cst_Called_from = "Called from",
    cst_inlined = " (inlined)",
    h =
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           ' in file "',
           [2,
            0,
            [12,
             34,
             [2,
              0,
              [11, ", line ", [4, 0, 0, 0, [11, cst_characters, partial]]]]]]]]]],
       '%s %s in file "%s"%s, line %d, characters %d-%d'],
    i = [0, [2, 0, [11, " unknown location", 0]], "%s unknown location"],
    j = [0, [2, 0, [12, 10, 0]], cst_s],
    k =
      [0,
       [11, cst_Program_not_linked_with_g_$0, 0],
       cst_Program_not_linked_with_g_$0],
    l = [0, [2, 0, [12, 10, 0]], cst_s],
    cst_Program_not_linked_with_g_ = cst_Program_not_linked_with_g_$0;
   function field(x, i){
    var f = x[i + 1];
    if(! Stdlib_Obj[1].call(null, f))
     return caml_call1(Stdlib_Printf[4].call(null, b), f);
    var c = Stdlib_Obj[13];
    if(caml_obj_tag(f) === c)
     return caml_call1(Stdlib_Printf[4].call(null, a), f);
    var d = Stdlib_Obj[14];
    return caml_obj_tag(f) === d ? Stdlib[35].call(null, f) : cst;
   }
   function other_fields(x, i){
    if(x.length - 1 <= i) return cst$0;
    var a = other_fields(x, i + 1 | 0), b = field(x, i);
    return caml_call2(Stdlib_Printf[4].call(null, c), b, a);
   }
   function use_printers(x){
    var param = Stdlib_Atomic[2].call(null, printers);
    for(;;){
     if(! param) return 0;
     var tl = param[2], hd = param[1];
     try{var val = caml_call1(hd, x);}catch(a){param = tl; continue;}
     if(val){var s = val[1]; return [0, s];}
     param = tl;
    }
   }
   function to_string_default(x){
    if(x === Stdlib[9]) return cst_Out_of_memory;
    if(x === Stdlib[10]) return cst_Stack_overflow;
    var tag = x[1];
    if(tag === Stdlib[4]){
     var
      match$0 = x[2],
      char = match$0[3],
      line = match$0[2],
      file = match$0[1];
     return caml_call5
             (Stdlib_Printf[4].call(null, locfmt),
              file,
              line,
              char,
              char + 5 | 0,
              cst_Pattern_matching_failed);
    }
    var tag$0 = x[1];
    if(tag$0 === Stdlib[5]){
     var
      match$1 = x[2],
      char$0 = match$1[3],
      line$0 = match$1[2],
      file$0 = match$1[1];
     return caml_call5
             (Stdlib_Printf[4].call(null, locfmt),
              file$0,
              line$0,
              char$0,
              char$0 + 6 | 0,
              cst_Assertion_failed);
    }
    var tag$1 = x[1];
    if(tag$1 === Stdlib[15]){
     var
      match$2 = x[2],
      char$1 = match$2[3],
      line$1 = match$2[2],
      file$1 = match$2[1];
     return caml_call5
             (Stdlib_Printf[4].call(null, locfmt),
              file$1,
              line$1,
              char$1,
              char$1 + 6 | 0,
              cst_Undefined_recursive_module);
    }
    if(0 !== caml_obj_tag(x)) return x[1];
    var constructor = x[1][1], match = x.length - 1;
    if(2 < match >>> 0)
     var
      b = other_fields(x, 2),
      c = field(x, 1),
      a = caml_call2(Stdlib_Printf[4].call(null, d), c, b);
    else
     switch(match){
       case 2:
        var
         f = field(x, 1),
         a = caml_call1(Stdlib_Printf[4].call(null, e), f);
        break;
       case 0:
        var a = cst$1; break;
       default: var a = cst$2;
     }
    return Stdlib[28].call(null, constructor, a);
   }
   function to_string(e){
    var match = use_printers(e);
    if(! match) return to_string_default(e);
    var s = match[1];
    return s;
   }
   function print(fct, arg){
    try{var b = caml_call1(fct, arg); return b;}
    catch(x$0){
     var x = caml_wrap_exception(x$0), a = to_string(x);
     caml_call1(Stdlib_Printf[3].call(null, f), a);
     Stdlib[63].call(null, Stdlib[40]);
     throw caml_maybe_attach_backtrace(x, 0);
    }
   }
   function catch$(fct, arg){
    try{var b = caml_call1(fct, arg); return b;}
    catch(x$0){
     var x = caml_wrap_exception(x$0);
     Stdlib[63].call(null, Stdlib[39]);
     var a = to_string(x);
     caml_call1(Stdlib_Printf[3].call(null, g), a);
     return Stdlib[99].call(null, 2);
    }
   }
   function raw_backtrace_entries(bt){return bt;}
   function convert_raw_backtrace(bt){
    return [0, runtime.caml_convert_raw_backtrace(bt)];
   }
   function format_backtrace_slot(pos, slot){
    function info(is_raise){
     return is_raise
             ? 0 === pos ? cst_Raised_at : cst_Re_raised_at
             : 0 === pos ? cst_Raised_by_primitive_operat : cst_Called_from;
    }
    if(0 === slot[0]){
     var
      a = slot[5],
      b = slot[4],
      c = slot[3],
      d = slot[6] ? cst_inlined : cst$3,
      e = slot[2],
      f = slot[7],
      g = info(slot[1]);
     return [0,
             caml_call7(Stdlib_Printf[4].call(null, h), g, f, e, d, c, b, a)];
    }
    if(slot[1]) return 0;
    var j = info(0);
    return [0, caml_call1(Stdlib_Printf[4].call(null, i), j)];
   }
   function print_raw_backtrace(outchan, raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return Stdlib_Printf[1].call(null, outchan, k);
    var a = backtrace[1], b = a.length - 2 | 0, c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[i + 1]);
      if(match){
       var str = match[1];
       caml_call1(Stdlib_Printf[1].call(null, outchan, j), str);
      }
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return 0;
   }
   function print_backtrace(outchan){
    return print_raw_backtrace(outchan, caml_get_exception_raw_backtra(0));
   }
   function raw_backtrace_to_string(raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return cst_Program_not_linked_with_g_;
    var
     a = backtrace[1],
     b = Stdlib_Buffer[1].call(null, 1024),
     c = a.length - 2 | 0,
     d = 0;
    if(c >= 0){
     var i = d;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[i + 1]);
      if(match){
       var str = match[1];
       caml_call1(Stdlib_Printf[5].call(null, b, l), str);
      }
      var e = i + 1 | 0;
      if(c === i) break;
      i = e;
     }
    }
    return Stdlib_Buffer[2].call(null, b);
   }
   function backtrace_slot_is_raise(param){
    return 0 === param[0] ? param[1] : param[1];
   }
   function backtrace_slot_is_inline(param){return 0 === param[0] ? param[6] : 0;
   }
   function backtrace_slot_location(param){
    return 0 === param[0]
            ? [0, [0, param[2], param[3], param[4], param[5]]]
            : 0;
   }
   function backtrace_slot_defname(param){
    if(0 === param[0] && param[7] !== cst$4) return [0, param[7]];
    return 0;
   }
   function backtrace_slots(raw_backtrace){
    var match = convert_raw_backtrace(raw_backtrace);
    if(! match) return 0;
    var backtrace = match[1], i$1 = backtrace.length - 2 | 0, i = i$1;
    for(;;){
     if(-1 === i)
      var b = 0;
     else{
      var a = 0 === caml_check_bound(backtrace, i)[i + 1][0] ? 1 : 0;
      if(! a){var i$0 = i - 1 | 0; i = i$0; continue;}
      var b = a;
     }
     return b ? [0, backtrace] : 0;
    }
   }
   function backtrace_slots_of_raw_entry(entry){return backtrace_slots([0, entry]);
   }
   function raw_backtrace_length(bt){return bt.length - 1;}
   function get_backtrace(param){
    return raw_backtrace_to_string(caml_get_exception_raw_backtra(0));
   }
   function register_printer(fn){
    for(;;){
     var
      old_printers = Stdlib_Atomic[2].call(null, printers),
      new_printers = [0, fn, old_printers],
      success =
        Stdlib_Atomic[5].call(null, printers, old_printers, new_printers),
      a = 1 - success;
     if(! a) return a;
    }
   }
   function exn_slot(x){return 0 === caml_obj_tag(x) ? x[1] : x;}
   function exn_slot_id(x){var slot = exn_slot(x); return slot[2];}
   function exn_slot_name(x){var slot = exn_slot(x); return slot[1];}
   var
    errors =
      runtime.caml_obj_dup
       ([0,
         cst$4,
         "(Cannot print locations:\n bytecode executable program file not found)",
         "(Cannot print locations:\n bytecode executable program file appears to be corrupt)",
         "(Cannot print locations:\n bytecode executable program file has wrong magic number)",
         "(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)"]),
    m =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s];
   function default_uncaught_exception_han(exn, raw_backtrace){
    var b = to_string(exn);
    caml_call1(Stdlib_Printf[3].call(null, m), b);
    print_raw_backtrace(Stdlib[40], raw_backtrace);
    var status = runtime.caml_ml_debug_info_status(0);
    if(status < 0){
     var
      a = Stdlib[18].call(null, status),
      c = caml_check_bound(errors, a)[a + 1];
     Stdlib[53].call(null, c);
    }
    return Stdlib[63].call(null, Stdlib[40]);
   }
   var uncaught_exception_handler = [0, default_uncaught_exception_han];
   function set_uncaught_exception_handler(fn){
    uncaught_exception_handler[1] = fn;
    return 0;
   }
   var
    empty_backtrace = [0],
    cst_Fatal_error_out_of_memory_ =
      "Fatal error: out of memory in uncaught exception handler",
    n =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s],
    o =
      [0,
       [11,
        "Fatal error in uncaught exception handler: exception ",
        [2, 0, [12, 10, 0]]],
       "Fatal error in uncaught exception handler: exception %s\n"];
   function handle_uncaught_exception(exn$1, debugger_in_use){
    try{
     try{
      var
       raw_backtrace =
         debugger_in_use ? empty_backtrace : caml_get_exception_raw_backtra(0);
      try{Stdlib[103].call(null, 0);}catch(exn){}
      try{
       var
        e = caml_call2(uncaught_exception_handler[1], exn$1, raw_backtrace),
        a = e;
      }
      catch(exn){
       var
        exn$0 = caml_wrap_exception(exn),
        raw_backtrace$0 = caml_get_exception_raw_backtra(0),
        c = to_string(exn$1);
       caml_call1(Stdlib_Printf[3].call(null, n), c);
       print_raw_backtrace(Stdlib[40], raw_backtrace);
       var d = to_string(exn$0);
       caml_call1(Stdlib_Printf[3].call(null, o), d);
       print_raw_backtrace(Stdlib[40], raw_backtrace$0);
       var a = Stdlib[63].call(null, Stdlib[40]);
      }
      var b = a;
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn !== Stdlib[9]) throw caml_maybe_attach_backtrace(exn, 0);
      var b = Stdlib[53].call(null, cst_Fatal_error_out_of_memory_);
     }
     return b;
    }
    catch(exn){return 0;}
   }
   runtime.caml_register_named_value
    ("Printexc.handle_uncaught_exception", handle_uncaught_exception);
   var
    Stdlib_Printexc =
      [0,
       to_string,
       to_string_default,
       print,
       catch$,
       print_backtrace,
       get_backtrace,
       runtime.caml_record_backtrace,
       runtime.caml_backtrace_status,
       register_printer,
       use_printers,
       raw_backtrace_entries,
       caml_get_exception_raw_backtra,
       print_raw_backtrace,
       raw_backtrace_to_string,
       default_uncaught_exception_han,
       set_uncaught_exception_handler,
       backtrace_slots,
       backtrace_slots_of_raw_entry,
       [0,
        backtrace_slot_is_raise,
        backtrace_slot_is_inline,
        backtrace_slot_location,
        backtrace_slot_defname,
        format_backtrace_slot],
       raw_backtrace_length,
       runtime.caml_raw_backtrace_slot,
       runtime.caml_convert_raw_backtrace_slot,
       runtime.caml_raw_backtrace_next_slot,
       exn_slot_id,
       exn_slot_name];
   runtime.caml_register_global(42, Stdlib_Printexc, "Stdlib__Printexc");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Fun
//# unitInfo: Requires: Stdlib, Stdlib__Printexc
//# shape: Stdlib__Fun:[F(2)*,F(3),F(2),F(2),N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_restore_raw_backtrace = runtime.caml_restore_raw_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib = global_data.Stdlib;
   function const$(c, param){return c;}
   function flip(f, x, y){return caml_call2(f, y, x);}
   function negate(p, v){return 1 - caml_call1(p, v);}
   var
    Finally_raised =
      [248, "Stdlib.Fun.Finally_raised", runtime.caml_fresh_oo_id(0)],
    cst_Fun_Finally_raised = "Fun.Finally_raised: ";
   Stdlib_Printexc[9].call
    (null,
     function(param){
      var tag = param[1];
      if(tag !== Finally_raised) return 0;
      var exn = param[2], a = Stdlib_Printexc[1].call(null, exn);
      return [0, Stdlib[28].call(null, cst_Fun_Finally_raised, a)];
     });
   var dummy = 0;
   function protect(finally$, work){
    function finally_no_exn(param){
     try{caml_call1(finally$, 0); return;}
     catch(e$0){
      var
       e = caml_wrap_exception(e$0),
       bt = Stdlib_Printexc[12].call(null, 0),
       exn = [0, Finally_raised, e];
      caml_restore_raw_backtrace(exn, bt);
      throw caml_maybe_attach_backtrace(exn, 0);
     }
    }
    try{var result = caml_call1(work, 0);}
    catch(work_exn$0){
     var
      work_exn = caml_wrap_exception(work_exn$0),
      work_bt = Stdlib_Printexc[12].call(null, 0);
     finally_no_exn(0);
     caml_restore_raw_backtrace(work_exn, work_bt);
     throw caml_maybe_attach_backtrace(work_exn, 0);
    }
    finally_no_exn(0);
    return result;
   }
   var Stdlib_Fun = [0, const$, flip, negate, protect, Finally_raised];
   runtime.caml_register_global(4, Stdlib_Fun, "Stdlib__Fun");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Gc
//# unitInfo: Requires: Stdlib, Stdlib__Printf, Stdlib__Sys
//# shape: Stdlib__Gc:[F(1),F(1),F(2)*,F(2),F(1)*,F(1)*,F(1),N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "\n",
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Printf = global_data.Stdlib__Printf,
    a =
      [0,
       [11, "minor_collections:      ", [4, 0, 0, 0, [12, 10, 0]]],
       "minor_collections:      %d\n"],
    b =
      [0,
       [11, "major_collections:      ", [4, 0, 0, 0, [12, 10, 0]]],
       "major_collections:      %d\n"],
    c =
      [0,
       [11, "compactions:            ", [4, 0, 0, 0, [12, 10, 0]]],
       "compactions:            %d\n"],
    d =
      [0,
       [11, "forced_major_collections: ", [4, 0, 0, 0, [12, 10, 0]]],
       "forced_major_collections: %d\n"],
    e = [0, [12, 10, 0], cst],
    f = [0, [8, [0, 0, 0], 0, [0, 0], 0], "%.0f"],
    g =
      [0,
       [11, "minor_words:    ", [8, [0, 0, 0], [1, 1], [0, 0], [12, 10, 0]]],
       "minor_words:    %*.0f\n"],
    h =
      [0,
       [11, "promoted_words: ", [8, [0, 0, 0], [1, 1], [0, 0], [12, 10, 0]]],
       "promoted_words: %*.0f\n"],
    i =
      [0,
       [11, "major_words:    ", [8, [0, 0, 0], [1, 1], [0, 0], [12, 10, 0]]],
       "major_words:    %*.0f\n"],
    j = [0, [12, 10, 0], cst],
    k = [0, [4, 0, 0, 0, 0], "%d"],
    l =
      [0,
       [11, "top_heap_words: ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "top_heap_words: %*d\n"],
    m =
      [0,
       [11, "heap_words:     ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "heap_words:     %*d\n"],
    n =
      [0,
       [11, "live_words:     ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "live_words:     %*d\n"],
    o =
      [0,
       [11, "free_words:     ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "free_words:     %*d\n"],
    p =
      [0,
       [11, "largest_free:   ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "largest_free:   %*d\n"],
    q =
      [0,
       [11, "fragments:      ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "fragments:      %*d\n"],
    r = [0, [12, 10, 0], cst],
    s =
      [0,
       [11, "live_blocks: ", [4, 0, 0, 0, [12, 10, 0]]],
       "live_blocks: %d\n"],
    t =
      [0,
       [11, "free_blocks: ", [4, 0, 0, 0, [12, 10, 0]]],
       "free_blocks: %d\n"],
    u =
      [0,
       [11, "heap_chunks: ", [4, 0, 0, 0, [12, 10, 0]]],
       "heap_chunks: %d\n"];
   function print_stat(c$0){
    var st = runtime.caml_gc_stat(0), v = st[4];
    caml_call1(Stdlib_Printf[1].call(null, c$0, a), v);
    var w = st[5];
    caml_call1(Stdlib_Printf[1].call(null, c$0, b), w);
    var x = st[14];
    caml_call1(Stdlib_Printf[1].call(null, c$0, c), x);
    var y = st[17];
    caml_call1(Stdlib_Printf[1].call(null, c$0, d), y);
    Stdlib_Printf[1].call(null, c$0, e);
    var
     z = st[1],
     l1 = caml_ml_string_length(caml_call1(Stdlib_Printf[4].call(null, f), z)),
     A = st[1];
    caml_call2(Stdlib_Printf[1].call(null, c$0, g), l1, A);
    var B = st[2];
    caml_call2(Stdlib_Printf[1].call(null, c$0, h), l1, B);
    var C = st[3];
    caml_call2(Stdlib_Printf[1].call(null, c$0, i), l1, C);
    Stdlib_Printf[1].call(null, c$0, j);
    var
     D = st[15],
     l2 = caml_ml_string_length(caml_call1(Stdlib_Printf[4].call(null, k), D)),
     E = st[15];
    caml_call2(Stdlib_Printf[1].call(null, c$0, l), l2, E);
    var F = st[6];
    caml_call2(Stdlib_Printf[1].call(null, c$0, m), l2, F);
    var G = st[8];
    caml_call2(Stdlib_Printf[1].call(null, c$0, n), l2, G);
    var H = st[10];
    caml_call2(Stdlib_Printf[1].call(null, c$0, o), l2, H);
    var I = st[12];
    caml_call2(Stdlib_Printf[1].call(null, c$0, p), l2, I);
    var J = st[13];
    caml_call2(Stdlib_Printf[1].call(null, c$0, q), l2, J);
    Stdlib_Printf[1].call(null, c$0, r);
    var K = st[9];
    caml_call1(Stdlib_Printf[1].call(null, c$0, s), K);
    var L = st[11];
    caml_call1(Stdlib_Printf[1].call(null, c$0, t), L);
    var M = st[7];
    return caml_call1(Stdlib_Printf[1].call(null, c$0, u), M);
   }
   function allocated_bytes(param){
    var
     match = runtime.caml_gc_counters(0),
     ma = match[3],
     pro = match[2],
     mi = match[1];
    return (mi + ma - pro) * (Stdlib_Sys[9] / 8 | 0);
   }
   function create_alarm(f){return [0, 1];}
   function delete_alarm(a){a[1] = 0; return 0;}
   var
    null_tracker =
      [0,
       function(param){return 0;},
       function(param){return 0;},
       function(param){return 0;},
       function(param){return 0;},
       function(param){return 0;}];
   function start(sampling_rate, opt, tracker){
    if(opt)
     var sth = opt[1], callstack_size = sth;
    else
     var callstack_size = Stdlib[19];
    return runtime.caml_memprof_start(sampling_rate, callstack_size, tracker);
   }
   var
    Stdlib_Gc =
      [0,
       print_stat,
       allocated_bytes,
       runtime.caml_final_register,
       runtime.caml_final_register_called_without_value,
       runtime.caml_final_release,
       create_alarm,
       delete_alarm,
       [0, null_tracker, start, runtime.caml_memprof_stop]];
   runtime.caml_register_global(24, Stdlib_Gc, "Stdlib__Gc");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Digest
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Char, Stdlib__String
//# shape: Stdlib__Digest:[F(2)*,F(2)*,F(1),F(1),F(3),F(3),F(1),F(2),F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Digest_from_hex$1 = "Digest.from_hex",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_md5_string = runtime.caml_md5_string,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_String = global_data.Stdlib__String,
    compare = Stdlib_String[9],
    equal = Stdlib_String[8],
    cst_Digest_substring = "Digest.substring",
    cst_Digest_to_hex = "Digest.to_hex",
    cst_Digest_from_hex = cst_Digest_from_hex$1,
    cst_Digest_from_hex$0 = cst_Digest_from_hex$1;
   function string(str){
    return caml_md5_string(str, 0, caml_ml_string_length(str));
   }
   function bytes(b){return string(Stdlib_Bytes[48].call(null, b));}
   function substring(str, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(str) - len | 0) >= ofs)
     return caml_md5_string(str, ofs, len);
    return Stdlib[1].call(null, cst_Digest_substring);
   }
   function subbytes(b, ofs, len){
    return substring(Stdlib_Bytes[48].call(null, b), ofs, len);
   }
   function file(filename){
    var ic = Stdlib[80].call(null, filename);
    try{var d = runtime.caml_md5_chan(ic, -1);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     Stdlib[93].call(null, ic);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    Stdlib[93].call(null, ic);
    return d;
   }
   function output(chan, digest){return Stdlib[66].call(null, chan, digest);}
   function input(chan){return Stdlib[86].call(null, chan, 16);}
   function char_hex(n){var a = 10 <= n ? 87 : 48; return n + a | 0;}
   function to_hex(d){
    if(16 !== caml_ml_string_length(d))
     Stdlib[1].call(null, cst_Digest_to_hex);
    var result = caml_create_bytes(32), i = 0;
    for(;;){
     var x = caml_string_get(d, i);
     caml_bytes_unsafe_set(result, i * 2 | 0, char_hex(x >>> 4 | 0));
     caml_bytes_unsafe_set(result, (i * 2 | 0) + 1 | 0, char_hex(x & 15));
     var a = i + 1 | 0;
     if(15 === i) return Stdlib_Bytes[48].call(null, result);
     i = a;
    }
   }
   function from_hex(s){
    if(32 !== caml_ml_string_length(s))
     Stdlib[1].call(null, cst_Digest_from_hex);
    function digit(c){
     if(65 <= c){
      if(97 <= c){
       if(103 > c) return (c - 97 | 0) + 10 | 0;
      }
      else if(71 > c) return (c - 65 | 0) + 10 | 0;
     }
     else if(9 >= c - 48 >>> 0) return c - 48 | 0;
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_Digest_from_hex$0], 1);
    }
    var result = caml_create_bytes(16), i = 0;
    for(;;){
     var
      i$0 = 2 * i | 0,
      a = digit(caml_string_get(s, i$0 + 1 | 0)),
      b = (digit(caml_string_get(s, i$0)) << 4) + a | 0;
     runtime.caml_bytes_set(result, i, Stdlib_Char[1].call(null, b));
     var c = i + 1 | 0;
     if(15 === i) return Stdlib_Bytes[48].call(null, result);
     i = c;
    }
   }
   var
    Stdlib_Digest =
      [0,
       compare,
       equal,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output,
       input,
       to_hex,
       from_hex];
   runtime.caml_register_global(8, Stdlib_Digest, "Stdlib__Digest");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Random
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Digest, Stdlib__Int, Stdlib__Int32, Stdlib__Int64, Stdlib__Nativeint
//# shape: Stdlib__Random:[F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),N,F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_create_lo_mi_hi = runtime.caml_int64_create_lo_mi_hi,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessequal = runtime.caml_lessequal,
    caml_mod = runtime.caml_mod,
    caml_string_get = runtime.caml_string_get,
    caml_sys_random_seed = runtime.caml_sys_random_seed,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Digest = global_data.Stdlib__Digest,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    cst_x = "x",
    cst_Random_int = "Random.int",
    cst_Random_full_int = "Random.full_int",
    cst_Random_int32 = "Random.int32",
    a = caml_int64_create_lo_mi_hi(1, 0, 0),
    b = caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_Random_int64 = "Random.int64";
   function new_state(param){return [0, runtime.caml_make_vect(55, 0), 0];}
   function assign(st1, st2){
    Stdlib_Array[10].call(null, st2[1], 0, st1[1], 0, 55);
    st1[2] = st2[2];
    return 0;
   }
   function full_init(s, seed){
    var
     seed$0 = 0 === seed.length - 1 ? [0, 0] : seed,
     l = seed$0.length - 1,
     i$0 = 0;
    for(;;){
     caml_check_bound(s[1], i$0)[i$0 + 1] = i$0;
     var p = i$0 + 1 | 0;
     if(54 === i$0) break;
     i$0 = p;
    }
    var
     accu = [0, cst_x],
     a = 54 + Stdlib_Int[11].call(null, 55, l) | 0,
     m = 0;
    if(a >= 0){
     var i = m;
     for(;;){
      var
       j = i % 55 | 0,
       k = caml_mod(i, l),
       x = caml_check_bound(seed$0, k)[k + 1],
       accu$0 = accu[1],
       b = Stdlib_Int[12].call(null, x),
       c = Stdlib[28].call(null, accu$0, b);
      accu[1] = Stdlib_Digest[3].call(null, c);
      var
       d = accu[1],
       e = caml_string_get(d, 3) << 24,
       f = caml_string_get(d, 2) << 16,
       g = caml_string_get(d, 1) << 8,
       h = ((caml_string_get(d, 0) + g | 0) + f | 0) + e | 0,
       n = (caml_check_bound(s[1], j)[j + 1] ^ h) & 1073741823;
      caml_check_bound(s[1], j)[j + 1] = n;
      var o = i + 1 | 0;
      if(a === i) break;
      i = o;
     }
    }
    s[2] = 0;
    return 0;
   }
   function make(seed){
    var result = new_state(0);
    full_init(result, seed);
    return result;
   }
   function make_self_init(param){return make(caml_sys_random_seed(0));}
   function copy(s){
    var result = new_state(0);
    assign(result, s);
    return result;
   }
   function bits(s){
    s[2] = (s[2] + 1 | 0) % 55 | 0;
    var
     a = s[2],
     curval = caml_check_bound(s[1], a)[a + 1],
     b = (s[2] + 24 | 0) % 55 | 0,
     newval =
       caml_check_bound(s[1], b)[b + 1] + (curval ^ (curval >>> 25 | 0) & 31)
       | 0,
     newval30 = newval & 1073741823,
     c = s[2];
    caml_check_bound(s[1], c)[c + 1] = newval30;
    return newval30;
   }
   function intaux(s, n){
    for(;;){
     var r = bits(s), v = caml_mod(r, n);
     if(((1073741823 - n | 0) + 1 | 0) >= (r - v | 0)) return v;
    }
   }
   function int(s, bound){
    if(1073741823 >= bound && 0 < bound) return intaux(s, bound);
    return Stdlib[1].call(null, cst_Random_int);
   }
   function full_int(s, bound){
    if(0 >= bound) return Stdlib[1].call(null, cst_Random_full_int);
    if(1073741823 >= bound) return intaux(s, bound);
    for(;;){
     var b1 = bits(s), b2 = bits(s), max_int_32 = 2147483647;
     if(bound <= 2147483647)
      var
       bpos = (b2 & 1073725440) << 1 | b1 >>> 15 | 0,
       max_int = max_int_32,
       r = bpos;
     else
      var
       b3 = bits(s),
       r$0 = ((b3 & 1073741312) << 12 | b2 >>> 9 | 0) << 20 | b1 >>> 10 | 0,
       max_int$0 = Stdlib[19],
       max_int = max_int$0,
       r = r$0;
     var v = caml_mod(r, bound);
     if(((max_int - bound | 0) + 1 | 0) >= (r - v | 0)) return v;
    }
   }
   function int32(s, bound){
    if(caml_lessequal(bound, 0))
     return Stdlib[1].call(null, cst_Random_int32);
    for(;;){
     var
      b1 = bits(s),
      b2 = (bits(s) & 1) << 30,
      r = b1 | b2,
      v = caml_mod(r, bound);
     if(! caml_greaterthan(r - v | 0, (Stdlib_Int32[9] - bound | 0) + 1 | 0))
      return v;
    }
   }
   function int64(s, bound){
    if(caml_lessequal(bound, b))
     return Stdlib[1].call(null, cst_Random_int64);
    for(;;){
     var
      b1 = caml_int64_of_int32(bits(s)),
      b2 = caml_int64_shift_left(caml_int64_of_int32(bits(s)), 30),
      b3 = caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7), 60),
      r = caml_int64_or(b1, caml_int64_or(b2, b3)),
      v = runtime.caml_int64_mod(r, bound);
     if
      (!
       caml_greaterthan
        (caml_int64_sub(r, v),
         runtime.caml_int64_add(caml_int64_sub(Stdlib_Int64[9], bound), a)))
      return v;
    }
   }
   var
    c =
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
    nativeint =
      32 === Stdlib_Nativeint[9]
       ? function(s, bound){return int32(s, bound);}
       : function
        (s, bound){
         return caml_int64_to_int32(int64(s, caml_int64_of_int32(bound)));
        };
   function float(s, bound){
    var r1 = bits(s), r2 = bits(s);
    return (r1 / 1073741824. + r2) / 1073741824. * bound;
   }
   function bool(s){return 0 === (bits(s) & 1) ? 1 : 0;}
   function bits32(s){
    var b1 = bits(s) >>> 14 | 0, b2 = bits(s) >>> 14 | 0;
    return b1 | b2 << 16;
   }
   function bits64(s){
    var
     b1 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 9),
     b2 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 9),
     b3 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 8);
    return caml_int64_or
            (b1,
             caml_int64_or
              (caml_int64_shift_left(b2, 21), caml_int64_shift_left(b3, 42)));
   }
   var
    nativebits =
      32 === Stdlib_Nativeint[9]
       ? function(s){return bits32(s);}
       : function(s){return caml_int64_to_int32(bits64(s));},
    default$ = [0, runtime.caml_obj_dup(c), 0];
   function bits$0(param){return bits(default$);}
   function int$0(bound){return int(default$, bound);}
   function full_int$0(bound){return full_int(default$, bound);}
   function int32$0(bound){return int32(default$, bound);}
   function nativeint$0(bound){return nativeint(default$, bound);}
   function int64$0(bound){return int64(default$, bound);}
   function float$0(scale){return float(default$, scale);}
   function bool$0(param){return bool(default$);}
   function bits32$0(param){return bits32(default$);}
   function bits64$0(param){return bits64(default$);}
   function nativebits$0(param){return nativebits(default$);}
   function full_init$0(seed){return full_init(default$, seed);}
   function init(seed){return full_init(default$, [0, seed]);}
   function self_init(param){
    var seed = caml_sys_random_seed(0);
    return full_init(default$, seed);
   }
   function get_state(param){return copy(default$);}
   function set_state(s){return assign(default$, s);}
   var
    Stdlib_Random =
      [0,
       init,
       full_init$0,
       self_init,
       bits$0,
       int$0,
       full_int$0,
       int32$0,
       nativeint$0,
       int64$0,
       float$0,
       bool$0,
       bits32$0,
       bits64$0,
       nativebits$0,
       [0,
        make,
        make_self_init,
        copy,
        bits,
        int,
        full_int,
        int32,
        nativeint,
        int64,
        float,
        bool,
        bits32,
        bits64,
        nativebits],
       get_state,
       set_state];
   runtime.caml_register_global(18, Stdlib_Random, "Stdlib__Random");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Hashtbl
//# unitInfo: Requires: Assert_failure, CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Int, Stdlib__Random, Stdlib__Seq, Stdlib__String, Stdlib__Sys
//# shape: Stdlib__Hashtbl:[F(2),F(1),F(1),F(1),F(3),F(2),F(2),F(2),F(2),F(2),F(3),F(2),F(2),F(3),F(1)*,F(1),F(1)*,F(2),F(1),F(1)*->F(1),F(1)*->F(1),F(1)*->F(1),F(2),F(2),F(1),F(1)*,F(1)*,F(1)*,F(2)*,F(3)*,F(4)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_compare = runtime.caml_compare,
    caml_hash = runtime.caml_hash,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    a = [0, 0],
    cst = "",
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib = global_data.Stdlib,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array;
   global_data.Assert_failure;
   var Stdlib_String = global_data.Stdlib__String;
   function ongoing_traversal(h){
    var a = h.length - 1 < 4 ? 1 : 0, b = a || (h[4] < 0 ? 1 : 0);
    return b;
   }
   function flip_ongoing_traversal(h){h[4] = - h[4] | 0; return 0;}
   var
    cst_Hashtbl_unsupported_hash_t = "Hashtbl: unsupported hash table format";
   try{var c = caml_sys_getenv("OCAMLRUNPARAM"), params = c;}
   catch(exn$1){
    var exn = caml_wrap_exception(exn$1);
    if(exn !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn, 0);
    try{var b = caml_sys_getenv("CAMLRUNPARAM"), params = b;}
    catch(exn){
     var exn$0 = caml_wrap_exception(exn);
     if(exn$0 !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn$0, 0);
     var params = cst;
    }
   }
   var
    randomized_default = Stdlib_String[14].call(null, params, 82),
    randomized = [0, randomized_default];
   function randomize(param){randomized[1] = 1; return 0;}
   function is_randomized(param){return randomized[1];}
   var prng = [246, function(a){return caml_call1(Stdlib_Random[15][2], 0);}];
   function power_2_above(x$1, n){
    var x = x$1;
    for(;;){
     if(n <= x) return x;
     if(Stdlib_Sys[13] < (x * 2 | 0)) return x;
     var x$0 = x * 2 | 0;
     x = x$0;
    }
   }
   function create(opt, initial_size){
    if(opt) var sth = opt[1], random = sth; else var random = randomized[1];
    var s = power_2_above(16, initial_size);
    if(random)
     var
      a = caml_obj_tag(prng),
      b =
        250 === a
         ? prng[1]
         : 246 === a ? CamlinternalLazy[2].call(null, prng) : prng,
      seed = caml_call1(Stdlib_Random[15][4], b);
    else
     var seed = 0;
    return [0, 0, caml_make_vect(s, 0), seed, s];
   }
   function clear(h){
    var a = 0 < h[1] ? 1 : 0;
    return a
            ? (h
               [1]
              = 0,
              Stdlib_Array[9].call(null, h[2], 0, h[2].length - 1, 0))
            : a;
   }
   function reset(h){
    var len = h[2].length - 1;
    if(4 <= h.length - 1 && len !== Stdlib[18].call(null, h[4])){
     h[1] = 0;
     h[2] = caml_make_vect(Stdlib[18].call(null, h[4]), 0);
     return 0;
    }
    return clear(h);
   }
   function copy_bucketlist(param){
    if(! param) return 0;
    var
     key = param[1],
     data = param[2],
     next = param[3],
     prec$1 = [0, key, data, next],
     prec = prec$1,
     param$0 = next;
    for(;;){
     if(! param$0) return prec$1;
     var
      key$0 = param$0[1],
      data$0 = param$0[2],
      next$0 = param$0[3],
      prec$0 = [0, key$0, data$0, next$0];
     prec[3] = prec$0;
     prec = prec$0;
     param$0 = next$0;
    }
   }
   function copy(h){
    var
     a = h[4],
     b = h[3],
     c = Stdlib_Array[15].call(null, copy_bucketlist, h[2]);
    return [0, h[1], c, b, a];
   }
   function length(h){return h[1];}
   function insert_all_buckets(indexfun, inplace, odata, ndata){
    var
     nsize = ndata.length - 1,
     ndata_tail = caml_make_vect(nsize, 0),
     a = odata.length - 2 | 0,
     d = 0;
    if(a >= 0){
     var i$0 = d;
     a:
     for(;;){
      var cell$1 = caml_check_bound(odata, i$0)[i$0 + 1], cell = cell$1;
      for(;;){
       if(! cell){var g = i$0 + 1 | 0; if(a === i$0) break a; i$0 = g; break;}
       var
        key = cell[1],
        data = cell[2],
        next = cell[3],
        cell$0 = inplace ? cell : [0, key, data, 0],
        nidx = caml_call1(indexfun, key),
        match = caml_check_bound(ndata_tail, nidx)[nidx + 1];
       if(match)
        match[3] = cell$0;
       else
        caml_check_bound(ndata, nidx)[nidx + 1] = cell$0;
       caml_check_bound(ndata_tail, nidx)[nidx + 1] = cell$0;
       cell = next;
      }
     }
    }
    if(inplace){
     var b = nsize - 1 | 0, e = 0;
     if(b >= 0){
      var i = e;
      for(;;){
       var match$0 = caml_check_bound(ndata_tail, i)[i + 1];
       if(match$0) match$0[3] = 0;
       var f = i + 1 | 0;
       if(b === i) break;
       i = f;
      }
     }
     var c = 0;
    }
    else
     var c = inplace;
    return c;
   }
   function resize(indexfun, h){
    var
     odata = h[2],
     osize = odata.length - 1,
     nsize = osize * 2 | 0,
     a = nsize < Stdlib_Sys[13] ? 1 : 0;
    if(! a) return a;
    var ndata = caml_make_vect(nsize, 0), inplace = 1 - ongoing_traversal(h);
    h[2] = ndata;
    return insert_all_buckets(caml_call1(indexfun, h), inplace, odata, ndata);
   }
   function iter(f, h){
    var old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var d = h[2], a = d.length - 2 | 0, c = 0;
     if(a >= 0){
      var i = c;
      a:
      for(;;){
       var param = caml_check_bound(d, i)[i + 1];
       for(;;){
        if(! param){var g = i + 1 | 0; if(a === i) break a; i = g; break;}
        var key = param[1], data = param[2], next = param[3];
        caml_call2(f, key, data);
        param = next;
       }
      }
     }
     var b = 1 - old_trav, e = b ? flip_ongoing_traversal(h) : b;
     return e;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function filter_map_inplace(f, h){
    var d = h[2], old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var a = d.length - 2 | 0, c = 0;
     if(a >= 0){
      var i = c;
      a:
      for(;;){
       var slot$0 = caml_check_bound(h[2], i)[i + 1], prec = 0, slot = slot$0;
       for(;;){
        if(! slot){
         if(prec) prec[3] = 0; else caml_check_bound(h[2], i)[i + 1] = 0;
         var g = i + 1 | 0;
         if(a === i) break a;
         i = g;
         break;
        }
        var
         key = slot[1],
         data = slot[2],
         next = slot[3],
         match = caml_call2(f, key, data);
        if(match){
         var data$0 = match[1];
         if(prec)
          prec[3] = slot;
         else
          caml_check_bound(h[2], i)[i + 1] = slot;
         slot[2] = data$0;
         prec = slot;
         slot = next;
        }
        else{h[1] = h[1] - 1 | 0; slot = next;}
       }
      }
     }
     var b = 1 - old_trav, e = b ? flip_ongoing_traversal(h) : b;
     return e;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function fold(f, h, init){
    var old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var d = h[2], accu$1 = [0, init], a = d.length - 2 | 0, c = 0;
     if(a >= 0){
      var i = c;
      a:
      for(;;){
       var
        accu$2 = accu$1[1],
        b$0 = caml_check_bound(d, i)[i + 1],
        b = b$0,
        accu = accu$2;
       for(;;){
        if(! b){
         accu$1[1] = accu;
         var g = i + 1 | 0;
         if(a === i) break a;
         i = g;
         break;
        }
        var
         key = b[1],
         data = b[2],
         next = b[3],
         accu$0 = caml_call3(f, key, data, accu);
        b = next;
        accu = accu$0;
       }
      }
     }
     if(1 - old_trav) flip_ongoing_traversal(h);
     var e = accu$1[1];
     return e;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function bucket_length(accu$1, param$0){
    var accu = accu$1, param = param$0;
    for(;;){
     if(! param) return accu;
     var next = param[3], accu$0 = accu + 1 | 0;
     accu = accu$0;
     param = next;
    }
   }
   function stats(h){
    var
     mbl =
       Stdlib_Array[17].call
        (null,
         function(m, b){
          var a = bucket_length(0, b);
          return Stdlib_Int[11].call(null, m, a);
         },
         0,
         h[2]),
     histo = caml_make_vect(mbl + 1 | 0, 0);
    Stdlib_Array[13].call
     (null,
      function(b){
       var l = bucket_length(0, b);
       histo[l + 1] = caml_check_bound(histo, l)[l + 1] + 1 | 0;
       return 0;
      },
      h[2]);
    return [0, h[1], h[2].length - 1, mbl, histo];
   }
   function to_seq(tbl){
    var tbl_data = tbl[2];
    function aux(i$1, buck$1, param){
     var i = i$1, buck = buck$1;
     for(;;){
      if(buck) break;
      if(i === tbl_data.length - 1) return 0;
      var buck$0 = caml_check_bound(tbl_data, i)[i + 1], i$0 = i + 1 | 0;
      i = i$0;
      buck = buck$0;
     }
     var key = buck[1], data = buck[2], next = buck[3];
     return [0, [0, key, data], function(a){return aux(i, next, a);}];
    }
    var a = 0, b = 0;
    return function(c){return aux(b, a, c);};
   }
   function to_seq_keys(m){
    var a = to_seq(m);
    function b(a){return a[1];}
    var c = Stdlib_Seq[27];
    return function(d){return c(b, a, d);};
   }
   function to_seq_values(m){
    var a = to_seq(m);
    function b(a){return a[2];}
    var c = Stdlib_Seq[27];
    return function(d){return c(b, a, d);};
   }
   function MakeSeeded(H){
    function key_index(h, key){
     var a = h[2].length - 2 | 0;
     return caml_call2(H[2], h[3], key) & a;
    }
    function add(h, key, data){
     var
      i = key_index(h, key),
      bucket = [0, key, data, caml_check_bound(h[2], i)[i + 1]];
     caml_check_bound(h[2], i)[i + 1] = bucket;
     h[1] = h[1] + 1 | 0;
     var a = h[2].length - 1 << 1 < h[1] ? 1 : 0;
     return a ? resize(key_index, h) : a;
    }
    function remove(h, key){
     var
      i = key_index(h, key),
      prec$1 = caml_check_bound(h[2], i)[i + 1],
      prec$0 = 0,
      prec = prec$1;
     for(;;){
      if(! prec) return 0;
      var k = prec[1], next = prec[3];
      if(caml_call2(H[1], k, key)){
       h[1] = h[1] - 1 | 0;
       return prec$0
               ? (prec$0[3] = next, 0)
               : (caml_check_bound(h[2], i)[i + 1] = next, 0);
      }
      prec$0 = prec;
      prec = next;
     }
    }
    function find(h, key){
     var a = key_index(h, key), match = caml_check_bound(h[2], a)[a + 1];
     if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k1 = match[1], d1 = match[2], next1 = match[3];
     if(caml_call2(H[1], key, k1)) return d1;
     if(! next1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k2 = next1[1], d2 = next1[2], next2 = next1[3];
     if(caml_call2(H[1], key, k2)) return d2;
     if(! next2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k3 = next2[1], d3 = next2[2], next3 = next2[3];
     if(caml_call2(H[1], key, k3)) return d3;
     var param = next3;
     for(;;){
      if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var k = param[1], data = param[2], next = param[3];
      if(caml_call2(H[1], key, k)) return data;
      param = next;
     }
    }
    function find_opt(h, key){
     var a = key_index(h, key), match = caml_check_bound(h[2], a)[a + 1];
     if(! match) return 0;
     var k1 = match[1], d1 = match[2], next1 = match[3];
     if(caml_call2(H[1], key, k1)) return [0, d1];
     if(! next1) return 0;
     var k2 = next1[1], d2 = next1[2], next2 = next1[3];
     if(caml_call2(H[1], key, k2)) return [0, d2];
     if(! next2) return 0;
     var k3 = next2[1], d3 = next2[2], next3 = next2[3];
     if(caml_call2(H[1], key, k3)) return [0, d3];
     var param = next3;
     for(;;){
      if(! param) return 0;
      var k = param[1], data = param[2], next = param[3];
      if(caml_call2(H[1], key, k)) return [0, data];
      param = next;
     }
    }
    function find_all(h, key){
     function find_in_bucket(param$0){
      var param = param$0;
      for(;;){
       if(! param) return 0;
       var k = param[1], d = param[2], next = param[3];
       if(caml_call2(H[1], k, key)) return [0, d, find_in_bucket(next)];
       param = next;
      }
     }
     var a = key_index(h, key);
     return find_in_bucket(caml_check_bound(h[2], a)[a + 1]);
    }
    function replace(h, key, data){
     var
      i = key_index(h, key),
      l = caml_check_bound(h[2], i)[i + 1],
      param = l;
     for(;;){
      if(param){
       var k = param[1], next = param[3];
       if(! caml_call2(H[1], k, key)){param = next; continue;}
       param[1] = key;
       param[2] = data;
       var a = 0;
      }
      else
       var a = 1;
      if(a){
       caml_check_bound(h[2], i)[i + 1] = [0, key, data, l];
       h[1] = h[1] + 1 | 0;
       var b = h[2].length - 1 << 1 < h[1] ? 1 : 0;
       if(b) return resize(key_index, h);
       var c = b;
      }
      else
       var c = a;
      return c;
     }
    }
    function mem(h, key){
     var b = key_index(h, key), param = caml_check_bound(h[2], b)[b + 1];
     for(;;){
      if(! param) return 0;
      var k = param[1], next = param[3], a = caml_call2(H[1], k, key);
      if(a) return a;
      param = next;
     }
    }
    function add_seq(tbl, i){
     return Stdlib_Seq[4].call
             (null,
              function(param){
               var v = param[2], k = param[1];
               return add(tbl, k, v);
              },
              i);
    }
    function replace_seq(tbl, i){
     return Stdlib_Seq[4].call
             (null,
              function(param){
               var v = param[2], k = param[1];
               return replace(tbl, k, v);
              },
              i);
    }
    function of_seq(i){
     var tbl = create(0, 16);
     replace_seq(tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq];
   }
   function Make(H){
    var equal = H[1];
    function hash(seed, x){return caml_call1(H[2], x);}
    var
     include = MakeSeeded([0, equal, hash]),
     b = include[1],
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     iter = include[12],
     filter_map_inplace = include[13],
     fold = include[14],
     length = include[15],
     stats = include[16],
     to_seq = include[17],
     to_seq_keys = include[18],
     to_seq_values = include[19],
     add_seq = include[20],
     replace_seq = include[21];
    function create(sz){return caml_call2(b, a, sz);}
    function of_seq(i){
     var tbl = caml_call2(b, a, 16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq];
   }
   function hash(x){return caml_hash(10, 100, 0, x);}
   function hash_param(n1, n2, x){return caml_hash(n1, n2, 0, x);}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function key_index(h, key){
    return 4 <= h.length - 1
            ? caml_hash(10, 100, h[3], key) & (h[2].length - 2 | 0)
            : Stdlib[1].call(null, cst_Hashtbl_unsupported_hash_t);
   }
   function add(h, key, data){
    var
     i = key_index(h, key),
     bucket = [0, key, data, caml_check_bound(h[2], i)[i + 1]];
    caml_check_bound(h[2], i)[i + 1] = bucket;
    h[1] = h[1] + 1 | 0;
    var a = h[2].length - 1 << 1 < h[1] ? 1 : 0;
    return a ? resize(key_index, h) : a;
   }
   function remove(h, key){
    var
     i = key_index(h, key),
     prec$1 = caml_check_bound(h[2], i)[i + 1],
     prec$0 = 0,
     prec = prec$1;
    for(;;){
     if(! prec) return 0;
     var k = prec[1], next = prec[3];
     if(0 === caml_compare(k, key)){
      h[1] = h[1] - 1 | 0;
      return prec$0
              ? (prec$0[3] = next, 0)
              : (caml_check_bound(h[2], i)[i + 1] = next, 0);
     }
     prec$0 = prec;
     prec = next;
    }
   }
   function find(h, key){
    var a = key_index(h, key), match = caml_check_bound(h[2], a)[a + 1];
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if(0 === caml_compare(key, k1)) return d1;
    if(! next1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if(0 === caml_compare(key, k2)) return d2;
    if(! next2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if(0 === caml_compare(key, k3)) return d3;
    var param = next3;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(key, k)) return data;
     param = next;
    }
   }
   function find_opt(h, key){
    var a = key_index(h, key), match = caml_check_bound(h[2], a)[a + 1];
    if(! match) return 0;
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if(0 === caml_compare(key, k1)) return [0, d1];
    if(! next1) return 0;
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if(0 === caml_compare(key, k2)) return [0, d2];
    if(! next2) return 0;
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if(0 === caml_compare(key, k3)) return [0, d3];
    var param = next3;
    for(;;){
     if(! param) return 0;
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(key, k)) return [0, data];
     param = next;
    }
   }
   function find_all(h, key){
    function find_in_bucket(param$0){
     var param = param$0;
     for(;;){
      if(! param) return 0;
      var k = param[1], data = param[2], next = param[3];
      if(0 === caml_compare(k, key)) return [0, data, find_in_bucket(next)];
      param = next;
     }
    }
    var a = key_index(h, key);
    return find_in_bucket(caml_check_bound(h[2], a)[a + 1]);
   }
   function replace(h, key, data){
    var
     i = key_index(h, key),
     l = caml_check_bound(h[2], i)[i + 1],
     param = l;
    for(;;){
     if(param){
      var k = param[1], next = param[3];
      if(0 !== caml_compare(k, key)){param = next; continue;}
      param[1] = key;
      param[2] = data;
      var a = 0;
     }
     else
      var a = 1;
     if(a){
      caml_check_bound(h[2], i)[i + 1] = [0, key, data, l];
      h[1] = h[1] + 1 | 0;
      var b = h[2].length - 1 << 1 < h[1] ? 1 : 0;
      if(b) return resize(key_index, h);
      var c = b;
     }
     else
      var c = a;
     return c;
    }
   }
   function mem(h, key){
    var b = key_index(h, key), param = caml_check_bound(h[2], b)[b + 1];
    for(;;){
     if(! param) return 0;
     var
      k = param[1],
      next = param[3],
      a = 0 === caml_compare(k, key) ? 1 : 0;
     if(a) return a;
     param = next;
    }
   }
   function add_seq(tbl, i){
    return Stdlib_Seq[4].call
            (null,
             function(param){
              var v = param[2], k = param[1];
              return add(tbl, k, v);
             },
             i);
   }
   function replace_seq(tbl, i){
    return Stdlib_Seq[4].call
            (null,
             function(param){
              var v = param[2], k = param[1];
              return replace(tbl, k, v);
             },
             i);
   }
   function of_seq(i){
    var tbl = create(0, 16);
    replace_seq(tbl, i);
    return tbl;
   }
   function rebuild(opt, h){
    if(opt) var sth = opt[1], random = sth; else var random = randomized[1];
    var s = power_2_above(16, h[2].length - 1);
    if(random)
     var
      a = caml_obj_tag(prng),
      b =
        250 === a
         ? prng[1]
         : 246 === a ? CamlinternalLazy[2].call(null, prng) : prng,
      seed = caml_call1(Stdlib_Random[15][4], b);
    else
     var seed = 4 <= h.length - 1 ? h[3] : 0;
    var
     c = 4 <= h.length - 1 ? h[4] : s,
     h$0 = [0, h[1], caml_make_vect(s, 0), seed, c];
    insert_all_buckets
     (function(a){return key_index(h$0, a);}, 0, h[2], h$0[2]);
    return h$0;
   }
   var
    Stdlib_Hashtbl =
      [0,
       create,
       clear,
       reset,
       copy,
       add,
       find,
       find_opt,
       find_all,
       mem,
       remove,
       replace,
       iter,
       filter_map_inplace,
       fold,
       length,
       randomize,
       is_randomized,
       rebuild,
       stats,
       to_seq,
       to_seq_keys,
       to_seq_values,
       add_seq,
       replace_seq,
       of_seq,
       Make,
       MakeSeeded,
       hash,
       seeded_hash,
       hash_param,
       caml_hash];
   runtime.caml_register_global(15, Stdlib_Hashtbl, "Stdlib__Hashtbl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Weak
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Int, Stdlib__Obj, Stdlib__Sys
//# shape: Stdlib__Weak:[F(1),F(1)*,F(3),F(2),F(2),F(2),F(4),F(5),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mod = runtime.caml_mod;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Obj = global_data.Stdlib__Obj,
    cst_Weak_create = "Weak.create",
    cst_Weak_set = "Weak.set",
    cst_Weak_get = "Weak.get",
    cst_Weak_get_copy = "Weak.get_copy",
    cst_Weak_check = "Weak.check",
    cst_Weak_blit = "Weak.blit",
    cst_Weak_fill = "Weak.fill",
    cst_Weak_Make_hash_bucket_cann = "Weak.Make: hash bucket cannot grow more";
   function create(l){
    var a = 0 <= l ? 1 : 0, b = a ? l <= Stdlib_Obj[26][15] ? 1 : 0 : a;
    if(1 - b) Stdlib[1].call(null, cst_Weak_create);
    return runtime.caml_weak_create(l);
   }
   function length(x){return x.length - 3 | 0;}
   function raise_if_invalid_offset(e, o, msg){
    var a = 0 <= o ? 1 : 0, c = a ? o < length(e) ? 1 : 0 : a, b = 1 - c;
    return b ? Stdlib[1].call(null, msg) : b;
   }
   function set(e, o, x){
    raise_if_invalid_offset(e, o, cst_Weak_set);
    if(! x) return runtime.caml_ephe_unset_key(e, o);
    var x$0 = x[1];
    return runtime.caml_ephe_set_key(e, o, x$0);
   }
   function get(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_get);
    return runtime.caml_ephe_get_key(e, o);
   }
   function get_copy(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_get_copy);
    return runtime.caml_ephe_get_key_copy(e, o);
   }
   function check(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_check);
    return runtime.caml_ephe_check_key(e, o);
   }
   function blit(e1, o1, e2, o2, l){
    if
     (0 <= l
      &&
       0 <= o1
       && (length(e1) - l | 0) >= o1 && 0 <= o2 && (length(e2) - l | 0) >= o2){
     var
      a = 0 !== l ? 1 : 0,
      b = a ? runtime.caml_ephe_blit_key(e1, o1, e2, o2, l) : a;
     return b;
    }
    return Stdlib[1].call(null, cst_Weak_blit);
   }
   function fill(ar, ofs, len, x){
    if(0 <= ofs && 0 <= len && (length(ar) - len | 0) >= ofs){
     var a = (ofs + len | 0) - 1 | 0;
     if(a >= ofs){
      var i = ofs;
      for(;;){set(ar, i, x); var b = i + 1 | 0; if(a === i) break; i = b;}
     }
     return 0;
    }
    throw caml_maybe_attach_backtrace([0, Stdlib[6], cst_Weak_fill], 1);
   }
   function Make(H){
    var emptybucket = create(0);
    function get_index(t, h){
     return caml_mod(h & Stdlib[19], t[1].length - 1);
    }
    var limit = 7;
    function create$0(sz){
     var
      sz$0 = 7 <= sz ? sz : 7,
      sz$1 = Stdlib_Sys[13] < sz$0 ? Stdlib_Sys[13] : sz$0;
     return [0,
             caml_make_vect(sz$1, emptybucket),
             caml_make_vect(sz$1, [0]),
             limit,
             0,
             0];
    }
    function clear(t){
     var a = t[1].length - 2 | 0, b = 0;
     if(a >= 0){
      var i = b;
      for(;;){
       caml_check_bound(t[1], i)[i + 1] = emptybucket;
       caml_check_bound(t[2], i)[i + 1] = [0];
       var c = i + 1 | 0;
       if(a === i) break;
       i = c;
      }
     }
     t[3] = limit;
     t[4] = 0;
     return 0;
    }
    function fold(f, t, init){
     var i = 0;
     return Stdlib_Array[19].call
             (null,
              function(b, accu$1){
               var i$0 = i, accu = accu$1;
               for(;;){
                if(length(b) <= i$0) return accu;
                var match = get(b, i$0);
                if(match){
                 var
                  v = match[1],
                  accu$0 = caml_call2(f, v, accu),
                  i$1 = i$0 + 1 | 0;
                 i$0 = i$1;
                 accu = accu$0;
                }
                else{var i$2 = i$0 + 1 | 0; i$0 = i$2;}
               }
              },
              t[1],
              init);
    }
    function iter(f, t){
     var i = 0;
     return Stdlib_Array[13].call
             (null,
              function(b){
               var i$0 = i;
               for(;;){
                if(length(b) <= i$0) return 0;
                var match = get(b, i$0);
                if(match){
                 var v = match[1];
                 caml_call1(f, v);
                 var i$1 = i$0 + 1 | 0;
                 i$0 = i$1;
                }
                else{var i$2 = i$0 + 1 | 0; i$0 = i$2;}
               }
              },
              t[1]);
    }
    function iter_weak(f, t){
     var i = 0;
     return Stdlib_Array[14].call
             (null,
              function(j, b){
               var i$0 = i;
               for(;;){
                if(length(b) <= i$0) return 0;
                if(check(b, i$0)){
                 caml_call3(f, b, caml_check_bound(t[2], j)[j + 1], i$0);
                 var i$1 = i$0 + 1 | 0;
                 i$0 = i$1;
                }
                else{var i$2 = i$0 + 1 | 0; i$0 = i$2;}
               }
              },
              t[1]);
    }
    function count_bucket(i$1, b, accu$1){
     var i = i$1, accu = accu$1;
     for(;;){
      if(length(b) <= i) return accu;
      var a = check(b, i) ? 1 : 0, accu$0 = accu + a | 0, i$0 = i + 1 | 0;
      i = i$0;
      accu = accu$0;
     }
    }
    function count(t){
     var a = 0;
     return Stdlib_Array[19].call
             (null, function(b, c){return count_bucket(a, b, c);}, t[1], 0);
    }
    function resize(t){
     var
      oldlen = t[1].length - 1,
      newlen =
        Stdlib_Int[10].call
         (null, ((3 * oldlen | 0) / 2 | 0) + 3 | 0, Stdlib_Sys[13]);
     if(oldlen < newlen){
      var
       newt = create$0(newlen),
       add_weak =
         function(ob, oh, oi){
          function setter(nb, ni, param){return blit(ob, oi, nb, ni, 1);}
          var h = caml_check_bound(oh, oi)[oi + 1];
          return add_aux(newt, setter, 0, h, get_index(newt, h));
         };
      iter_weak(add_weak, t);
      t[1] = newt[1];
      t[2] = newt[2];
      t[3] = newt[3];
      t[4] = newt[4];
      t[5] = caml_mod(t[5], newt[1].length - 1);
      return 0;
     }
     t[3] = Stdlib[19];
     t[4] = 0;
     return 0;
    }
    function add_aux(t, setter, d, h, index){
     var
      bucket = caml_check_bound(t[1], index)[index + 1],
      hashes = caml_check_bound(t[2], index)[index + 1],
      sz = length(bucket);
     function loop(i$5){
      var i$2 = i$5;
      for(;;){
       if(sz <= i$2) break;
       if(! check(bucket, i$2)){
        caml_call3(setter, bucket, i$2, d);
        caml_check_bound(hashes, i$2)[i$2 + 1] = h;
        return 0;
       }
       var i$4 = i$2 + 1 | 0;
       i$2 = i$4;
      }
      var
       newsz =
         Stdlib_Int[10].call
          (null, ((3 * sz | 0) / 2 | 0) + 3 | 0, Stdlib_Sys[13] - 2 | 0);
      if(newsz <= sz) Stdlib[2].call(null, cst_Weak_Make_hash_bucket_cann);
      var newbucket$0 = create(newsz), newhashes = caml_make_vect(newsz, 0);
      blit(bucket, 0, newbucket$0, 0, sz);
      Stdlib_Array[10].call(null, hashes, 0, newhashes, 0, sz);
      caml_call3(setter, newbucket$0, sz, d);
      caml_check_bound(newhashes, sz)[sz + 1] = h;
      caml_check_bound(t[1], index)[index + 1] = newbucket$0;
      caml_check_bound(t[2], index)[index + 1] = newhashes;
      var l = sz <= t[3] ? 1 : 0, q = l ? t[3] < newsz ? 1 : 0 : l;
      if(q){
       t[4] = t[4] + 1 | 0;
       var i$3 = 0;
       for(;;){
        var
         a = t[5],
         bucket$0 = caml_check_bound(t[1], a)[a + 1],
         b = t[5],
         hbucket = caml_check_bound(t[2], b)[b + 1],
         len = length(bucket$0),
         prev_len = (((len - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
         live = count_bucket(0, bucket$0, 0);
        if(live <= prev_len){
         var j$2 = length(bucket$0) - 1 | 0, i = 0, j = j$2;
         for(;;){
          if(prev_len > j) break;
          if(check(bucket$0, i)){
           var i$0 = i + 1 | 0;
           i = i$0;
          }
          else if(check(bucket$0, j)){
           blit(bucket$0, j, bucket$0, i, 1);
           var n = caml_check_bound(hbucket, j)[j + 1];
           caml_check_bound(hbucket, i)[i + 1] = n;
           var j$0 = j - 1 | 0, i$1 = i + 1 | 0;
           i = i$1;
           j = j$0;
          }
          else{var j$1 = j - 1 | 0; j = j$1;}
         }
         if(0 === prev_len){
          var c = t[5];
          caml_check_bound(t[1], c)[c + 1] = emptybucket;
          var e = t[5];
          caml_check_bound(t[2], e)[e + 1] = [0];
         }
         else{
          var newbucket = create(prev_len);
          blit(bucket$0, 0, newbucket, 0, prev_len);
          var g = t[5];
          caml_check_bound(t[1], g)[g + 1] = newbucket;
          var p = Stdlib_Array[7].call(null, hbucket, 0, prev_len), k = t[5];
          caml_check_bound(t[2], k)[k + 1] = p;
         }
         var f = t[3] < len ? 1 : 0, o = f ? prev_len <= t[3] ? 1 : 0 : f;
         if(o) t[4] = t[4] - 1 | 0;
        }
        t[5] = caml_mod(t[5] + 1 | 0, t[1].length - 1);
        var r = i$3 + 1 | 0;
        if(2 === i$3) break;
        i$3 = r;
       }
      }
      var m = ((t[1].length - 1) / 2 | 0) < t[4] ? 1 : 0;
      return m ? resize(t) : m;
     }
     return loop(0);
    }
    function add(t, d){
     var h = caml_call1(H[2], d);
     return add_aux(t, set, [0, d], h, get_index(t, h));
    }
    function find_or(t, d, ifnotfound){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[index + 1],
      hashes = caml_check_bound(t[2], index)[index + 1],
      sz = length(bucket),
      i = 0;
     for(;;){
      if(sz <= i) return caml_call2(ifnotfound, h, index);
      if(h === caml_check_bound(hashes, i)[i + 1]){
       var match = get_copy(bucket, i);
       if(match){
        var v = match[1];
        if(caml_call2(H[1], v, d)){
         var match$0 = get(bucket, i);
         if(match$0){var v$0 = match$0[1]; return v$0;}
         var i$0 = i + 1 | 0;
         i = i$0;
         continue;
        }
       }
       var i$1 = i + 1 | 0;
       i = i$1;
      }
      else{var i$2 = i + 1 | 0; i = i$2;}
     }
    }
    function merge(t, d){
     return find_or
             (t,
              d,
              function(h, index){add_aux(t, set, [0, d], h, index); return d;});
    }
    function find(t, d){
     return find_or
             (t,
              d,
              function(h, index){
               throw caml_maybe_attach_backtrace(Stdlib[8], 1);
              });
    }
    function find_opt(t, d){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[index + 1],
      hashes = caml_check_bound(t[2], index)[index + 1],
      sz = length(bucket),
      i = 0;
     for(;;){
      if(sz <= i) return 0;
      if(h === caml_check_bound(hashes, i)[i + 1]){
       var match = get_copy(bucket, i);
       if(match){
        var v = match[1];
        if(caml_call2(H[1], v, d)){
         var v$0 = get(bucket, i);
         if(v$0) return v$0;
         var i$0 = i + 1 | 0;
         i = i$0;
         continue;
        }
       }
       var i$1 = i + 1 | 0;
       i = i$1;
      }
      else{var i$2 = i + 1 | 0; i = i$2;}
     }
    }
    function find_shadow(t, d, iffound, ifnotfound){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[index + 1],
      hashes = caml_check_bound(t[2], index)[index + 1],
      sz = length(bucket),
      i = 0;
     for(;;){
      if(sz <= i) return ifnotfound;
      if(h === caml_check_bound(hashes, i)[i + 1]){
       var match = get_copy(bucket, i);
       if(match){
        var v = match[1];
        if(caml_call2(H[1], v, d)) return caml_call2(iffound, bucket, i);
       }
       var i$0 = i + 1 | 0;
       i = i$0;
      }
      else{var i$1 = i + 1 | 0; i = i$1;}
     }
    }
    function remove(t, d){
     return find_shadow(t, d, function(w, i){return set(w, i, 0);}, 0);
    }
    function mem(t, d){
     return find_shadow(t, d, function(w, i){return 1;}, 0);
    }
    function find_all(t, d){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[index + 1],
      hashes = caml_check_bound(t[2], index)[index + 1],
      sz = length(bucket),
      i = 0,
      accu = 0;
     for(;;){
      if(sz <= i) return accu;
      if(h === caml_check_bound(hashes, i)[i + 1]){
       var match = get_copy(bucket, i);
       if(match){
        var v = match[1];
        if(caml_call2(H[1], v, d)){
         var match$0 = get(bucket, i);
         if(match$0){
          var v$0 = match$0[1], accu$0 = [0, v$0, accu], i$0 = i + 1 | 0;
          i = i$0;
          accu = accu$0;
          continue;
         }
         var i$1 = i + 1 | 0;
         i = i$1;
         continue;
        }
       }
       var i$2 = i + 1 | 0;
       i = i$2;
      }
      else{var i$3 = i + 1 | 0; i = i$3;}
     }
    }
    function stats(t){
     var
      len = t[1].length - 1,
      lens = Stdlib_Array[15].call(null, length, t[1]);
     Stdlib_Array[32].call(null, runtime.caml_int_compare, lens);
     var
      totlen =
        Stdlib_Array[17].call
         (null, function(b, a){return b + a | 0;}, 0, lens),
      a = len - 1 | 0,
      b = len / 2 | 0,
      c = caml_check_bound(lens, a)[a + 1],
      d = caml_check_bound(lens, b)[b + 1],
      e = caml_check_bound(lens, 0)[1];
     return [0, len, count(t), totlen, e, d, c];
    }
    return [0,
            create$0,
            clear,
            merge,
            add,
            remove,
            find,
            find_opt,
            find_all,
            mem,
            iter,
            fold,
            count,
            stats];
   }
   var
    Stdlib_Weak =
      [0, create, length, set, get, get_copy, check, fill, blit, Make];
   runtime.caml_register_global(13, Stdlib_Weak, "Stdlib__Weak");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Format
//# unitInfo: Requires: CamlinternalFormat, Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Int, Stdlib__List, Stdlib__Queue, Stdlib__Stack, Stdlib__String
//# shape: Stdlib__Format:[F(2),F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(3),F(2),F(2),F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(3),F(2),F(3),F(2),F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(2)*,F(1)*,F(2),F(1),F(2)*,F(1)*,F(1)*,F(3),F(2),F(3),F(2),F(2),F(1),F(2)*,F(1)*,F(2),F(1),F(2)*,F(1)*,F(2)*,F(1)*,F(2),F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(3),F(2),F(2),F(1),F(2)*,F(1)*,N,F(2),F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(2)*,F(1)*,F(2)*,F(1)*,F(2),F(1),F(3),F(2),F(2)*,F(1)*,F(2),F(1),F(2)*,F(1)*,F(2),F(1),F(2)*,F(1)*,F(1),N,N,F(1),N,N,F(1),F(2),F(1),F(1)*,F(1),F(1),F(1),F(2),F(1),F(4),F(4),F(2),F(4),F(4),F(4),F(1)*->F(1),F(1),F(1),F(1),F(1),F(1),F(2),F(3),F(2),F(3),F(2),F(2),F(2),F(2),F(4),F(1)*,F(5),F(2)*,F(2),F(1),F(2),F(1),F(2),F(1),F(2)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$17 = "",
    cst$18 = ">",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    cst$15 = cst$17,
    cst$16 = cst$17,
    cst$14 = ".",
    cst$11 = cst$18,
    cst$12 = "<\/",
    cst$13 = cst$17,
    cst$8 = cst$18,
    cst$9 = "<",
    cst$10 = cst$17,
    cst$7 = "\n",
    cst$3 = cst$17,
    cst$4 = cst$17,
    cst$5 = cst$17,
    cst$6 = cst$17,
    cst = cst$17,
    cst$0 = cst$17,
    cst$1 = cst$17,
    cst$2 = cst$17,
    a = [0, cst$17, 0, cst$17],
    Stdlib_Queue = global_data.Stdlib__Queue,
    CamlinternalFormat = global_data.CamlinternalFormat,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Stack = global_data.Stdlib__Stack,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Bytes = global_data.Stdlib__Bytes;
   function id(x){return x;}
   var
    zero = 0,
    unknown = -1,
    String_tag =
      [248, "Stdlib.Format.String_tag", runtime.caml_fresh_oo_id(0)];
   function pp_enqueue(state, token){
    state[13] = state[13] + token[3] | 0;
    return Stdlib_Queue[3].call(null, token, state[28]);
   }
   var
    pp_infinity = 1000000010,
    b = [0, cst$17],
    c = [1, "margin <= max_indent"],
    d = [0, 0],
    e = [1, "max_indent < 2"],
    cst_Format_pp_set_geometry = "Format.pp_set_geometry: ";
   function pp_output_string(state, s){
    return caml_call3(state[17], s, 0, caml_ml_string_length(s));
   }
   function pp_output_newline(state){return caml_call1(state[19], 0);}
   function format_pp_text(state, size, text){
    state[9] = state[9] - size | 0;
    pp_output_string(state, text);
    state[11] = 0;
   }
   function format_string(state, s){
    var a = s !== cst$17 ? 1 : 0;
    return a ? format_pp_text(state, caml_ml_string_length(s), s) : a;
   }
   function break_new_line(state, param, width){
    var after = param[3], offset = param[2], before = param[1];
    format_string(state, before);
    pp_output_newline(state);
    state[11] = 1;
    var
     indent = (state[6] - width | 0) + offset | 0,
     real_indent = Stdlib_Int[10].call(null, state[8], indent);
    state[10] = real_indent;
    state[9] = state[6] - state[10] | 0;
    var n = state[10];
    caml_call1(state[21], n);
    return format_string(state, after);
   }
   function break_same_line(state, param){
    var after = param[3], width = param[2], before = param[1];
    format_string(state, before);
    state[9] = state[9] - width | 0;
    caml_call1(state[20], width);
    return format_string(state, after);
   }
   function format_pp_token(state, size$0, param){
    if(typeof param === "number")
     switch(param){
       case 0:
        var match$3 = Stdlib_Stack[7].call(null, state[3]);
        if(! match$3) return;
        var
         tabs = match$3[1][1],
         add_tab =
           function(n, ls){
            if(! ls) return [0, n, 0];
            var l = ls[2], x = ls[1];
            return runtime.caml_lessthan(n, x)
                    ? [0, n, ls]
                    : [0, x, add_tab(n, l)];
           };
        tabs[1] = add_tab(state[6] - state[9] | 0, tabs[1]);
        return;
       case 1:
        Stdlib_Stack[5].call(null, state[2]); return;
       case 2:
        Stdlib_Stack[5].call(null, state[3]); return;
       case 3:
        var match$4 = Stdlib_Stack[7].call(null, state[2]);
        if(! match$4) return pp_output_newline(state);
        var width$0 = match$4[1][2];
        return break_new_line(state, a, width$0);
       case 4:
        var b = state[10] !== (state[6] - state[9] | 0) ? 1 : 0;
        if(! b) return b;
        var match$1 = Stdlib_Queue[6].call(null, state[28]);
        if(! match$1) return;
        var match$2 = match$1[1], size = match$2[1], length = match$2[3];
        state[12] = state[12] - length | 0;
        state[9] = state[9] + size | 0;
        return;
       default:
        var match$5 = Stdlib_Stack[5].call(null, state[5]);
        if(! match$5) return;
        var tag_name = match$5[1], marker = caml_call1(state[25], tag_name);
        return pp_output_string(state, marker);
     }
    switch(param[0]){
      case 0:
       var s = param[1]; return format_pp_text(state, size$0, s);
      case 1:
       var
        breaks = param[2],
        fits = param[1],
        off = breaks[2],
        before = breaks[1],
        match$6 = Stdlib_Stack[7].call(null, state[2]);
       if(! match$6) return;
       var
        match$7 = match$6[1],
        width$1 = match$7[2],
        box_type$0 = match$7[1];
       switch(box_type$0){
         case 3:
          return state[9] < (size$0 + caml_ml_string_length(before) | 0)
                  ? break_new_line(state, breaks, width$1)
                  : break_same_line(state, fits);
         case 4:
          return state[11]
                  ? break_same_line(state, fits)
                  : state
                     [9]
                    < (size$0 + caml_ml_string_length(before) | 0)
                    ? break_new_line(state, breaks, width$1)
                    : ((state
                       [6]
                      - width$1
                      | 0)
                      + off
                      | 0)
                      < state[10]
                      ? break_new_line(state, breaks, width$1)
                      : break_same_line(state, fits);
         case 0:
         case 5:
          return break_same_line(state, fits);
         default: return break_new_line(state, breaks, width$1);
       }
      case 2:
       var
        off$0 = param[2],
        n = param[1],
        insertion_point = state[6] - state[9] | 0,
        match$8 = Stdlib_Stack[7].call(null, state[3]);
       if(! match$8) return;
       var tabs$0 = match$8[1][1], match$9 = tabs$0[1];
       if(match$9){
        var first = match$9[1], param$0 = tabs$0[1];
        for(;;){
         if(! param$0){var tab = first; break;}
         var tail = param$0[2], head = param$0[1];
         if(insertion_point <= head){var tab = head; break;}
         param$0 = tail;
        }
       }
       else
        var tab = insertion_point;
       var offset = tab - insertion_point | 0;
       return 0 <= offset
               ? break_same_line(state, [0, cst$0, offset + n | 0, cst])
               : break_new_line
                 (state, [0, cst$2, tab + off$0 | 0, cst$1], state[6]);
      case 3:
       var
        ty = param[2],
        off$1 = param[1],
        insertion_point$0 = state[6] - state[9] | 0;
       if(state[8] < insertion_point$0){
        var match = Stdlib_Stack[7].call(null, state[2]);
        if(match){
         var match$0 = match[1], width = match$0[2], box_type = match$0[1];
         if(state[9] < width && 3 >= box_type - 1 >>> 0)
          break_new_line(state, a, width);
        }
        else
         pp_output_newline(state);
       }
       var
        width$2 = state[9] - off$1 | 0,
        box_type$1 = 1 === ty ? 1 : state[9] < size$0 ? ty : 5;
       return Stdlib_Stack[3].call(null, [0, box_type$1, width$2], state[2]);
      case 4:
       var tbox = param[1]; return Stdlib_Stack[3].call(null, tbox, state[3]);
      default:
       var
        tag_name$0 = param[1],
        marker$0 = caml_call1(state[24], tag_name$0);
       pp_output_string(state, marker$0);
       return Stdlib_Stack[3].call(null, tag_name$0, state[5]);
    }
   }
   function advance_left(state){
    for(;;){
     var match = Stdlib_Queue[9].call(null, state[28]);
     if(! match) return 0;
     var
      match$0 = match[1],
      size = match$0[1],
      length = match$0[3],
      token = match$0[2],
      pending_count = state[13] - state[12] | 0,
      b = 0 <= size ? 1 : 0,
      a = b || (state[9] <= pending_count ? 1 : 0);
     if(! a) return a;
     Stdlib_Queue[5].call(null, state[28]);
     var size$0 = 0 <= size ? size : pp_infinity;
     format_pp_token(state, size$0, token);
     state[12] = length + state[12] | 0;
    }
   }
   function enqueue_advance(state, tok){
    pp_enqueue(state, tok);
    return advance_left(state);
   }
   function enqueue_string_as(state, size, s){
    return enqueue_advance(state, [0, size, [0, s], size]);
   }
   function initialize_scan_stack(stack){
    Stdlib_Stack[8].call(null, stack);
    var queue_elem = [0, unknown, b, 0];
    return Stdlib_Stack[3].call(null, [0, -1, queue_elem], stack);
   }
   function set_size(state, ty){
    var match = Stdlib_Stack[7].call(null, state[1]);
    if(! match) return;
    var
     match$0 = match[1],
     queue_elem = match$0[2],
     left_total = match$0[1],
     size = queue_elem[1];
    if(left_total < state[12]) return initialize_scan_stack(state[1]);
    var match$1 = queue_elem[2];
    if(typeof match$1 !== "number")
     switch(match$1[0]){
       case 3:
        if(1 - ty){
         var x$0 = state[13] + size | 0;
         queue_elem[1] = x$0;
         Stdlib_Stack[5].call(null, state[1]);
        }
        return;
       case 1:
       case 2:
        if(ty){
         var x = state[13] + size | 0;
         queue_elem[1] = x;
         Stdlib_Stack[5].call(null, state[1]);
        }
        return;
     }
   }
   function scan_push(state, b, token){
    pp_enqueue(state, token);
    if(b) set_size(state, 1);
    var elem = [0, state[13], token];
    return Stdlib_Stack[3].call(null, elem, state[1]);
   }
   function pp_open_box_gen(state, indent, br_ty){
    state[14] = state[14] + 1 | 0;
    if(state[14] < state[15]){
     var size = - state[13] | 0, elem = [0, size, [3, indent, br_ty], 0];
     return scan_push(state, 0, elem);
    }
    var a = state[14] === state[15] ? 1 : 0;
    if(! a) return a;
    var s = state[16], x = caml_ml_string_length(s);
    return enqueue_string_as(state, x, s);
   }
   function pp_close_box(state, param){
    var a = 1 < state[14] ? 1 : 0;
    if(a){
     if(state[14] < state[15]){
      pp_enqueue(state, [0, zero, 1, 0]);
      set_size(state, 1);
      set_size(state, 0);
     }
     state[14] = state[14] - 1 | 0;
     var b = 0;
    }
    else
     var b = a;
    return b;
   }
   function pp_open_stag(state, tag_name){
    if(state[22]){
     Stdlib_Stack[3].call(null, tag_name, state[4]);
     caml_call1(state[26], tag_name);
    }
    var a = state[23];
    if(! a) return a;
    var token = [5, tag_name];
    return pp_enqueue(state, [0, zero, token, 0]);
   }
   function pp_close_stag(state, param){
    if(state[23]) pp_enqueue(state, [0, zero, 5, 0]);
    var a = state[22];
    if(a){
     var match = Stdlib_Stack[5].call(null, state[4]);
     if(match){
      var tag_name = match[1];
      return caml_call1(state[27], tag_name);
     }
     var b = 0;
    }
    else
     var b = a;
    return b;
   }
   function pp_open_tag(state, s){
    return pp_open_stag(state, [0, String_tag, s]);
   }
   function pp_close_tag(state, param){return pp_close_stag(state, 0);}
   function pp_set_print_tags(state, b){state[22] = b; return 0;}
   function pp_set_mark_tags(state, b){state[23] = b; return 0;}
   function pp_get_print_tags(state, param){return state[22];}
   function pp_get_mark_tags(state, param){return state[23];}
   function pp_set_tags(state, b){
    pp_set_print_tags(state, b);
    return pp_set_mark_tags(state, b);
   }
   function pp_get_formatter_stag_function(state, param){
    return [0, state[24], state[25], state[26], state[27]];
   }
   function pp_set_formatter_stag_function(state, param){
    var pct = param[4], pot = param[3], mct = param[2], mot = param[1];
    state[24] = mot;
    state[25] = mct;
    state[26] = pot;
    state[27] = pct;
    return 0;
   }
   function pp_rinit(state){
    state[12] = 1;
    state[13] = 1;
    Stdlib_Queue[11].call(null, state[28]);
    initialize_scan_stack(state[1]);
    Stdlib_Stack[8].call(null, state[2]);
    Stdlib_Stack[8].call(null, state[3]);
    Stdlib_Stack[8].call(null, state[4]);
    Stdlib_Stack[8].call(null, state[5]);
    state[10] = 0;
    state[14] = 0;
    state[9] = state[6];
    return pp_open_box_gen(state, 0, 3);
   }
   function pp_flush_queue(state, b){
    Stdlib_Stack[12].call
     (null, function(param){return pp_close_tag(state, 0);}, state[4]);
    for(;;){
     if(1 >= state[14]){
      state[13] = pp_infinity;
      advance_left(state);
      if(b) pp_output_newline(state);
      return pp_rinit(state);
     }
     pp_close_box(state, 0);
    }
   }
   function pp_print_as_size(state, size, s){
    var a = state[14] < state[15] ? 1 : 0;
    return a ? enqueue_string_as(state, size, s) : a;
   }
   function pp_print_as(state, isize, s){
    return pp_print_as_size(state, isize, s);
   }
   function pp_print_string(state, s){
    var isize = caml_ml_string_length(s);
    return pp_print_as_size(state, isize, s);
   }
   function pp_print_bytes(state, s){
    var
     s$0 = Stdlib_Bytes[6].call(null, s),
     isize = runtime.caml_ml_bytes_length(s);
    return pp_print_as_size(state, isize, s$0);
   }
   function pp_print_int(state, i){
    return pp_print_string(state, Stdlib_Int[12].call(null, i));
   }
   function pp_print_float(state, f){
    return pp_print_string(state, Stdlib[35].call(null, f));
   }
   function pp_print_bool(state, b){
    return pp_print_string(state, Stdlib[30].call(null, b));
   }
   function pp_print_char(state, c){
    var s = Stdlib_String[1].call(null, 1, c);
    return pp_print_as_size(state, 1, s);
   }
   function pp_open_hbox(state, param){return pp_open_box_gen(state, 0, 0);}
   function pp_open_vbox(state, indent){
    return pp_open_box_gen(state, indent, 1);
   }
   function pp_open_hvbox(state, indent){
    return pp_open_box_gen(state, indent, 2);
   }
   function pp_open_hovbox(state, indent){
    return pp_open_box_gen(state, indent, 3);
   }
   function pp_open_box(state, indent){
    return pp_open_box_gen(state, indent, 4);
   }
   function pp_print_newline(state, param){
    pp_flush_queue(state, 1);
    return caml_call1(state[18], 0);
   }
   function pp_print_flush(state, param){
    pp_flush_queue(state, 0);
    return caml_call1(state[18], 0);
   }
   function pp_force_newline(state, param){
    var a = state[14] < state[15] ? 1 : 0;
    return a ? enqueue_advance(state, [0, zero, 3, 0]) : a;
   }
   function pp_print_if_newline(state, param){
    var a = state[14] < state[15] ? 1 : 0;
    return a ? enqueue_advance(state, [0, zero, 4, 0]) : a;
   }
   function pp_print_custom_break(state, fits, breaks){
    var
     after = fits[3],
     width = fits[2],
     before = fits[1],
     a = state[14] < state[15] ? 1 : 0;
    if(! a) return a;
    var
     size = - state[13] | 0,
     token = [1, fits, breaks],
     length =
       (caml_ml_string_length(before) + width | 0)
       + caml_ml_string_length(after)
       | 0,
     elem = [0, size, token, length];
    return scan_push(state, 1, elem);
   }
   function pp_print_break(state, width, offset){
    return pp_print_custom_break
            (state, [0, cst$6, width, cst$5], [0, cst$4, offset, cst$3]);
   }
   function pp_print_space(state, param){return pp_print_break(state, 1, 0);}
   function pp_print_cut(state, param){return pp_print_break(state, 0, 0);}
   function pp_open_tbox(state, param){
    state[14] = state[14] + 1 | 0;
    var a = state[14] < state[15] ? 1 : 0;
    if(! a) return a;
    var elem = [0, zero, [4, [0, [0, 0]]], 0];
    return enqueue_advance(state, elem);
   }
   function pp_close_tbox(state, param){
    var b = 1 < state[14] ? 1 : 0;
    if(b){
     var c = state[14] < state[15] ? 1 : 0;
     if(c){
      var elem = [0, zero, 2, 0];
      enqueue_advance(state, elem);
      state[14] = state[14] - 1 | 0;
      var a = 0;
     }
     else
      var a = c;
    }
    else
     var a = b;
    return a;
   }
   function pp_print_tbreak(state, width, offset){
    var a = state[14] < state[15] ? 1 : 0;
    if(! a) return a;
    var size = - state[13] | 0, elem = [0, size, [2, width, offset], width];
    return scan_push(state, 1, elem);
   }
   function pp_print_tab(state, param){return pp_print_tbreak(state, 0, 0);}
   function pp_set_tab(state, param){
    var a = state[14] < state[15] ? 1 : 0;
    if(! a) return a;
    var elem = [0, zero, 0, 0];
    return enqueue_advance(state, elem);
   }
   function pp_set_max_boxes(state, n){
    var a = 1 < n ? 1 : 0, b = a ? (state[15] = n, 0) : a;
    return b;
   }
   function pp_get_max_boxes(state, param){return state[15];}
   function pp_over_max_boxes(state, param){return state[14] === state[15] ? 1 : 0;
   }
   function pp_set_ellipsis_text(state, s){state[16] = s; return 0;}
   function pp_get_ellipsis_text(state, param){return state[16];}
   function pp_limit(n){return n < 1000000010 ? n : 1000000009;}
   function pp_set_max_indent(state, n$0){
    var b = 1 < n$0 ? 1 : 0;
    if(! b) return b;
    var n$1 = state[6] - n$0 | 0, a = 1 <= n$1 ? 1 : 0;
    if(! a) return a;
    var n = pp_limit(n$1);
    state[7] = n;
    state[8] = state[6] - state[7] | 0;
    return pp_rinit(state);
   }
   function pp_get_max_indent(state, param){return state[8];}
   function pp_set_margin(state, n){
    var a = 1 <= n ? 1 : 0;
    if(! a) return a;
    var n$0 = pp_limit(n);
    state[6] = n$0;
    if(state[8] <= state[6])
     var new_max_indent = state[8];
    else
     var
      b = Stdlib_Int[11].call(null, state[6] - state[7] | 0, state[6] / 2 | 0),
      new_max_indent = Stdlib_Int[11].call(null, b, 1);
    return pp_set_max_indent(state, new_max_indent);
   }
   function validate_geometry(param){
    var margin = param[2], max_indent = param[1];
    return 2 <= max_indent ? margin <= max_indent ? c : d : e;
   }
   function check_geometry(geometry){
    return 0 === validate_geometry(geometry)[0] ? 1 : 0;
   }
   function pp_get_margin(state, param){return state[6];}
   function pp_set_full_geometry(state, param){
    var margin = param[2], max_indent = param[1];
    pp_set_margin(state, margin);
    pp_set_max_indent(state, max_indent);
    return 0;
   }
   function pp_set_geometry(state, max_indent, margin){
    var
     geometry = [0, max_indent, margin],
     match = validate_geometry(geometry);
    if(0 === match[0]) return pp_set_full_geometry(state, geometry);
    var
     msg = match[1],
     a = Stdlib[28].call(null, cst_Format_pp_set_geometry, msg);
    throw caml_maybe_attach_backtrace([0, Stdlib[6], a], 1);
   }
   function pp_safe_set_geometry(state, max_indent, margin){
    var geometry = [0, max_indent, margin];
    return 0 === validate_geometry(geometry)[0]
            ? pp_set_full_geometry(state, geometry)
            : 0;
   }
   function pp_get_geometry(state, param){return [0, state[8], state[6]];}
   function pp_update_geometry(state, update){
    var geometry = pp_get_geometry(state, 0);
    return pp_set_full_geometry(state, caml_call1(update, geometry));
   }
   function pp_set_formatter_out_functions(state, param){
    var j = param[5], i = param[4], h = param[3], g = param[2], f = param[1];
    state[17] = f;
    state[18] = g;
    state[19] = h;
    state[20] = i;
    state[21] = j;
    return 0;
   }
   function pp_get_formatter_out_functions(state, param){
    return [0, state[17], state[18], state[19], state[20], state[21]];
   }
   function pp_set_formatter_output_functi(state, f, g){state[17] = f; state[18] = g; return 0;
   }
   function pp_get_formatter_output_functi(state, param){return [0, state[17], state[18]];
   }
   function display_newline(state, param){
    return caml_call3(state[17], cst$7, 0, 1);
   }
   var blank_line = Stdlib_String[1].call(null, 80, 32), f = [3, 0, 3];
   function display_blanks(state, n$1){
    var n = n$1;
    for(;;){
     var a = 0 < n ? 1 : 0;
     if(! a) return a;
     if(80 >= n) return caml_call3(state[17], blank_line, 0, n);
     caml_call3(state[17], blank_line, 0, 80);
     var n$0 = n - 80 | 0;
     n = n$0;
    }
   }
   function pp_set_formatter_out_channel(state, oc){
    var a = Stdlib[69];
    state[17] = function(b, c, d){return a(oc, b, c, d);};
    state[18] = function(param){return Stdlib[63].call(null, oc);};
    state[19] = function(a){return display_newline(state, a);};
    state[20] = function(a){return display_blanks(state, a);};
    state[21] = function(a){return display_blanks(state, a);};
    return 0;
   }
   function default_pp_mark_open_tag(param){
    var tag = param[1];
    if(tag !== String_tag) return cst$10;
    var s = param[2], a = Stdlib[28].call(null, s, cst$8);
    return Stdlib[28].call(null, cst$9, a);
   }
   function default_pp_mark_close_tag(param){
    var tag = param[1];
    if(tag !== String_tag) return cst$13;
    var s = param[2], a = Stdlib[28].call(null, s, cst$11);
    return Stdlib[28].call(null, cst$12, a);
   }
   function default_pp_print_open_tag(a){return 0;}
   function default_pp_print_close_tag(a){return 0;}
   function pp_make_formatter(f$0, g, h, i, j){
    var
     pp_queue = Stdlib_Queue[2].call(null, 0),
     sys_tok = [0, unknown, f, 0];
    Stdlib_Queue[3].call(null, sys_tok, pp_queue);
    var scan_stack = Stdlib_Stack[2].call(null, 0);
    initialize_scan_stack(scan_stack);
    Stdlib_Stack[3].call(null, [0, 1, sys_tok], scan_stack);
    var
     pp_margin = 78,
     a = Stdlib[19],
     b = Stdlib_Stack[2].call(null, 0),
     c = Stdlib_Stack[2].call(null, 0),
     d = Stdlib_Stack[2].call(null, 0);
    return [0,
            scan_stack,
            Stdlib_Stack[2].call(null, 0),
            d,
            c,
            b,
            pp_margin,
            10,
            68,
            pp_margin,
            0,
            1,
            1,
            1,
            1,
            a,
            cst$14,
            f$0,
            g,
            h,
            i,
            j,
            0,
            0,
            default_pp_mark_open_tag,
            default_pp_mark_close_tag,
            default_pp_print_open_tag,
            default_pp_print_close_tag,
            pp_queue];
   }
   function formatter_of_out_functions(out_funs){
    return pp_make_formatter
            (out_funs[1], out_funs[2], out_funs[3], out_funs[4], out_funs[5]);
   }
   function make_formatter(output, flush){
    var
     ppf =
       pp_make_formatter
        (output,
         flush,
         function(a){return 0;},
         function(a){return 0;},
         function(a){return 0;});
    ppf[19] = function(a){return display_newline(ppf, a);};
    ppf[20] = function(a){return display_blanks(ppf, a);};
    ppf[21] = function(a){return display_blanks(ppf, a);};
    return ppf;
   }
   function formatter_of_out_channel(oc){
    var a = Stdlib[69];
    return make_formatter
            (function(b, c, d){return a(oc, b, c, d);},
             function(param){return Stdlib[63].call(null, oc);});
   }
   function formatter_of_buffer(b){
    var a = Stdlib_Buffer[18];
    return make_formatter
            (function(c, d, e){return a(b, c, d, e);}, function(a){return 0;});
   }
   var pp_buffer_size = 512;
   function pp_make_buffer(param){
    return Stdlib_Buffer[1].call(null, pp_buffer_size);
   }
   var
    stdbuf = pp_make_buffer(0),
    std_formatter = formatter_of_out_channel(Stdlib[39]),
    err_formatter = formatter_of_out_channel(Stdlib[40]),
    str_formatter = formatter_of_buffer(stdbuf);
   function flush_buffer_formatter(buf, ppf){
    pp_flush_queue(ppf, 0);
    var s = Stdlib_Buffer[2].call(null, buf);
    Stdlib_Buffer[9].call(null, buf);
    return s;
   }
   function flush_str_formatter(param){
    return flush_buffer_formatter(stdbuf, str_formatter);
   }
   function make_symbolic_output_buffer(param){return [0, 0];}
   function clear_symbolic_output_buffer(sob){sob[1] = 0; return 0;}
   function get_symbolic_output_buffer(sob){
    return Stdlib_List[9].call(null, sob[1]);
   }
   function flush_symbolic_output_buffer(sob){
    var items = get_symbolic_output_buffer(sob);
    clear_symbolic_output_buffer(sob);
    return items;
   }
   function add_symbolic_output_item(sob, item){sob[1] = [0, item, sob[1]]; return 0;
   }
   function formatter_of_symbolic_output_b(sob){
    function f(s, i, n){
     return add_symbolic_output_item
             (sob, [0, Stdlib_String[15].call(null, s, i, n)]);
    }
    function g(param){return add_symbolic_output_item(sob, 0);}
    function h(param){return add_symbolic_output_item(sob, 1);}
    function i(n){return add_symbolic_output_item(sob, [1, n]);}
    function j(n){return add_symbolic_output_item(sob, [2, n]);}
    return pp_make_formatter(f, g, h, i, j);
   }
   function open_hbox(a){return pp_open_hbox(std_formatter, a);}
   function open_vbox(a){return pp_open_vbox(std_formatter, a);}
   function open_hvbox(a){return pp_open_hvbox(std_formatter, a);}
   function open_hovbox(a){return pp_open_hovbox(std_formatter, a);}
   function open_box(a){return pp_open_box(std_formatter, a);}
   function close_box(a){return pp_close_box(std_formatter, a);}
   function open_tag(a){return pp_open_tag(std_formatter, a);}
   function close_tag(a){return pp_close_tag(std_formatter, a);}
   function open_stag(a){return pp_open_stag(std_formatter, a);}
   function close_stag(a){return pp_close_stag(std_formatter, a);}
   function print_as(isize, s){
    return pp_print_as_size(std_formatter, isize, s);
   }
   function print_string(a){return pp_print_string(std_formatter, a);}
   function print_bytes(a){return pp_print_bytes(std_formatter, a);}
   function print_int(a){return pp_print_int(std_formatter, a);}
   function print_float(a){return pp_print_float(std_formatter, a);}
   function print_char(a){return pp_print_char(std_formatter, a);}
   function print_bool(a){return pp_print_bool(std_formatter, a);}
   function print_break(a, b){return pp_print_break(std_formatter, a, b);}
   function print_cut(a){return pp_print_cut(std_formatter, a);}
   function print_space(a){return pp_print_space(std_formatter, a);}
   function force_newline(a){return pp_force_newline(std_formatter, a);}
   function print_flush(a){return pp_print_flush(std_formatter, a);}
   function print_newline(a){return pp_print_newline(std_formatter, a);}
   function print_if_newline(a){return pp_print_if_newline(std_formatter, a);}
   function open_tbox(a){return pp_open_tbox(std_formatter, a);}
   function close_tbox(a){return pp_close_tbox(std_formatter, a);}
   function print_tbreak(a, b){return pp_print_tbreak(std_formatter, a, b);}
   function set_tab(a){return pp_set_tab(std_formatter, a);}
   function print_tab(a){return pp_print_tab(std_formatter, a);}
   function set_margin(a){return pp_set_margin(std_formatter, a);}
   function get_margin(param){return std_formatter[6];}
   function set_max_indent(a){return pp_set_max_indent(std_formatter, a);}
   function get_max_indent(param){return std_formatter[8];}
   function set_geometry(a, b){return pp_set_geometry(std_formatter, a, b);}
   function safe_set_geometry(a, b){
    return pp_safe_set_geometry(std_formatter, a, b);
   }
   function get_geometry(a){return pp_get_geometry(std_formatter, a);}
   function update_geometry(a){return pp_update_geometry(std_formatter, a);}
   function set_max_boxes(a){return pp_set_max_boxes(std_formatter, a);}
   function get_max_boxes(param){return std_formatter[15];}
   function over_max_boxes(a){return pp_over_max_boxes(std_formatter, a);}
   function set_ellipsis_text(a){
    return pp_set_ellipsis_text(std_formatter, a);
   }
   function get_ellipsis_text(param){return std_formatter[16];}
   function set_formatter_out_channel(a){
    return pp_set_formatter_out_channel(std_formatter, a);
   }
   function set_formatter_out_functions(a){
    return pp_set_formatter_out_functions(std_formatter, a);
   }
   function get_formatter_out_functions(a){
    return pp_get_formatter_out_functions(std_formatter, a);
   }
   function set_formatter_output_functions(a, b){
    return pp_set_formatter_output_functi(std_formatter, a, b);
   }
   function get_formatter_output_functions(a){
    return pp_get_formatter_output_functi(std_formatter, a);
   }
   function set_formatter_stag_functions(a){
    return pp_set_formatter_stag_function(std_formatter, a);
   }
   function get_formatter_stag_functions(a){
    return pp_get_formatter_stag_function(std_formatter, a);
   }
   function set_print_tags(a){return pp_set_print_tags(std_formatter, a);}
   function get_print_tags(param){return std_formatter[22];}
   function set_mark_tags(a){return pp_set_mark_tags(std_formatter, a);}
   function get_mark_tags(param){return std_formatter[23];}
   function set_tags(a){return pp_set_tags(std_formatter, a);}
   function pp_print_list(opt$1, pp_v, ppf, param$0){
    var opt = opt$1, param = param$0;
    for(;;){
     if(opt) var sth = opt[1], pp_sep = sth; else var pp_sep = pp_print_cut;
     if(! param) return 0;
     var v = param[1];
     if(! param[2]) return caml_call2(pp_v, ppf, v);
     var vs = param[2];
     caml_call2(pp_v, ppf, v);
     caml_call2(pp_sep, ppf, 0);
     var opt$0 = [0, pp_sep];
     opt = opt$0;
     param = vs;
    }
   }
   function pp_print_seq(opt, pp_v, ppf, seq$1){
    if(opt) var sth = opt[1], pp_sep = sth; else var pp_sep = pp_print_cut;
    var match$0 = caml_call1(seq$1, 0);
    if(! match$0) return 0;
    var seq$2 = match$0[2], v$0 = match$0[1];
    caml_call2(pp_v, ppf, v$0);
    var seq = seq$2;
    for(;;){
     var match = caml_call1(seq, 0);
     if(! match) return 0;
     var seq$0 = match[2], v = match[1];
     caml_call2(pp_sep, ppf, 0);
     caml_call2(pp_v, ppf, v);
     seq = seq$0;
    }
   }
   function pp_print_text(ppf, s){
    var len = caml_ml_string_length(s), left = [0, 0], right = [0, 0];
    function flush(param){
     pp_print_string
      (ppf, Stdlib_String[15].call(null, s, left[1], right[1] - left[1] | 0));
     right[1]++;
     left[1] = right[1];
     return 0;
    }
    for(;;){
     if(right[1] === len){
      var a = left[1] !== len ? 1 : 0;
      return a ? flush(0) : a;
     }
     var match = runtime.caml_string_get(s, right[1]);
     if(10 === match){
      flush(0);
      pp_force_newline(ppf, 0);
     }
     else if(32 === match){flush(0); pp_print_space(ppf, 0);} else right[1]++;
    }
   }
   function pp_print_option(opt, pp_v, ppf, param){
    if(opt)
     var sth = opt[1], none = sth;
    else
     var none = function(param, a){return 0;};
    if(! param) return caml_call2(none, ppf, 0);
    var v = param[1];
    return caml_call2(pp_v, ppf, v);
   }
   function pp_print_result(ok, error, ppf, param){
    if(0 === param[0]){var v = param[1]; return caml_call2(ok, ppf, v);}
    var e = param[1];
    return caml_call2(error, ppf, e);
   }
   function pp_print_either(left, right, ppf, param){
    if(0 === param[0]){var l = param[1]; return caml_call2(left, ppf, l);}
    var r = param[1];
    return caml_call2(right, ppf, r);
   }
   function compute_tag(output, tag_acc){
    var buf = Stdlib_Buffer[1].call(null, 16), ppf = formatter_of_buffer(buf);
    caml_call2(output, ppf, tag_acc);
    pp_print_flush(ppf, 0);
    var len = Stdlib_Buffer[7].call(null, buf);
    return 2 <= len
            ? Stdlib_Buffer[4].call(null, buf, 1, len - 2 | 0)
            : Stdlib_Buffer[2].call(null, buf);
   }
   function output_formatting_lit(ppf, fmting_lit){
    if(typeof fmting_lit === "number")
     switch(fmting_lit){
       case 0:
        return pp_close_box(ppf, 0);
       case 1:
        return pp_close_tag(ppf, 0);
       case 2:
        return pp_print_flush(ppf, 0);
       case 3:
        return pp_force_newline(ppf, 0);
       case 4:
        return pp_print_newline(ppf, 0);
       case 5:
        return pp_print_char(ppf, 64);
       default: return pp_print_char(ppf, 37);
     }
    switch(fmting_lit[0]){
      case 0:
       var offset = fmting_lit[3], width = fmting_lit[2];
       return pp_print_break(ppf, width, offset);
      case 1:
       return 0;
      default:
       var c = fmting_lit[1];
       pp_print_char(ppf, 64);
       return pp_print_char(ppf, c);
    }
   }
   function output_acc(ppf, acc){
    if(typeof acc === "number") return 0;
    a:
    {
     b:
     {
      c:
      {
       switch(acc[0]){
         case 0:
          var f = acc[2], p = acc[1];
          output_acc(ppf, p);
          return output_formatting_lit(ppf, f);
         case 1:
          var match = acc[2], p$0 = acc[1];
          if(0 === match[0]){
           var acc$0 = match[1];
           output_acc(ppf, p$0);
           return pp_open_stag
                   (ppf, [0, String_tag, compute_tag(output_acc, acc$0)]);
          }
          var acc$1 = match[1];
          output_acc(ppf, p$0);
          var
           k = compute_tag(output_acc, acc$1),
           match$0 = CamlinternalFormat[20].call(null, k),
           bty = match$0[2],
           indent = match$0[1];
          return pp_open_box_gen(ppf, indent, bty);
         case 2:
          var a = acc[1];
          if(typeof a !== "number" && 0 === a[0]){
           var g = a[2];
           if(typeof g !== "number" && 1 === g[0]){
            var s$0 = acc[2], size = g[2], p$2 = a[1];
            break a;
           }
          }
          var s = acc[2], p$1 = a;
          break b;
         case 3:
          var b = acc[1];
          if(typeof b !== "number" && 0 === b[0]){
           var h = b[2];
           if(typeof h !== "number" && 1 === h[0]){
            var c$0 = acc[2], size$0 = h[2], p$4 = b[1];
            break c;
           }
          }
          var c = acc[2], p$3 = b;
          break;
         case 4:
          var d = acc[1];
          if(typeof d !== "number" && 0 === d[0]){
           var i = d[2];
           if(typeof i !== "number" && 1 === i[0]){
            var s$0 = acc[2], size = i[2], p$2 = d[1];
            break a;
           }
          }
          var s = acc[2], p$1 = d;
          break b;
         case 5:
          var e = acc[1];
          if(typeof e !== "number" && 0 === e[0]){
           var j = e[2];
           if(typeof j !== "number" && 1 === j[0]){
            var c$0 = acc[2], size$0 = j[2], p$4 = e[1];
            break c;
           }
          }
          var c = acc[2], p$3 = e;
          break;
         case 6:
          var f$0 = acc[2], p$5 = acc[1];
          output_acc(ppf, p$5);
          return caml_call1(f$0, ppf);
         case 7:
          var p$6 = acc[1];
          output_acc(ppf, p$6);
          return pp_print_flush(ppf, 0);
         default:
          var msg = acc[2], p$7 = acc[1];
          output_acc(ppf, p$7);
          return Stdlib[1].call(null, msg);
       }
       output_acc(ppf, p$3);
       return pp_print_char(ppf, c);
      }
      output_acc(ppf, p$4);
      return pp_print_as_size
              (ppf, size$0, Stdlib_String[1].call(null, 1, c$0));
     }
     output_acc(ppf, p$1);
     return pp_print_string(ppf, s);
    }
    output_acc(ppf, p$2);
    return pp_print_as_size(ppf, size, s$0);
   }
   function strput_acc(ppf, acc){
    if(typeof acc === "number") return 0;
    a:
    {
     b:
     {
      c:
      {
       switch(acc[0]){
         case 0:
          var f = acc[2], p = acc[1];
          strput_acc(ppf, p);
          return output_formatting_lit(ppf, f);
         case 1:
          var match = acc[2], p$0 = acc[1];
          if(0 === match[0]){
           var acc$0 = match[1];
           strput_acc(ppf, p$0);
           return pp_open_stag
                   (ppf, [0, String_tag, compute_tag(strput_acc, acc$0)]);
          }
          var acc$1 = match[1];
          strput_acc(ppf, p$0);
          var
           k = compute_tag(strput_acc, acc$1),
           match$0 = CamlinternalFormat[20].call(null, k),
           bty = match$0[2],
           indent = match$0[1];
          return pp_open_box_gen(ppf, indent, bty);
         case 2:
          var a = acc[1];
          if(typeof a !== "number" && 0 === a[0]){
           var g = a[2];
           if(typeof g !== "number" && 1 === g[0]){
            var s$0 = acc[2], size = g[2], p$2 = a[1];
            break a;
           }
          }
          var s = acc[2], p$1 = a;
          break b;
         case 3:
          var b = acc[1];
          if(typeof b !== "number" && 0 === b[0]){
           var h = b[2];
           if(typeof h !== "number" && 1 === h[0]){
            var c$0 = acc[2], size$0 = h[2], p$4 = b[1];
            break c;
           }
          }
          var c = acc[2], p$3 = b;
          break;
         case 4:
          var d = acc[1];
          if(typeof d !== "number" && 0 === d[0]){
           var i = d[2];
           if(typeof i !== "number" && 1 === i[0]){
            var s$0 = acc[2], size = i[2], p$2 = d[1];
            break a;
           }
          }
          var s = acc[2], p$1 = d;
          break b;
         case 5:
          var e = acc[1];
          if(typeof e !== "number" && 0 === e[0]){
           var j = e[2];
           if(typeof j !== "number" && 1 === j[0]){
            var c$0 = acc[2], size$0 = j[2], p$4 = e[1];
            break c;
           }
          }
          var c = acc[2], p$3 = e;
          break;
         case 6:
          var p$5 = acc[1];
          if(typeof p$5 !== "number" && 0 === p$5[0]){
           var match$1 = p$5[2];
           if(typeof match$1 !== "number" && 1 === match$1[0]){
            var f$1 = acc[2], size$1 = match$1[2], p$6 = p$5[1];
            strput_acc(ppf, p$6);
            return pp_print_as_size(ppf, size$1, caml_call1(f$1, 0));
           }
          }
          var f$0 = acc[2];
          strput_acc(ppf, p$5);
          return pp_print_string(ppf, caml_call1(f$0, 0));
         case 7:
          var p$7 = acc[1];
          strput_acc(ppf, p$7);
          return pp_print_flush(ppf, 0);
         default:
          var msg = acc[2], p$8 = acc[1];
          strput_acc(ppf, p$8);
          return Stdlib[1].call(null, msg);
       }
       strput_acc(ppf, p$3);
       return pp_print_char(ppf, c);
      }
      strput_acc(ppf, p$4);
      return pp_print_as_size
              (ppf, size$0, Stdlib_String[1].call(null, 1, c$0));
     }
     strput_acc(ppf, p$1);
     return pp_print_string(ppf, s);
    }
    strput_acc(ppf, p$2);
    return pp_print_as_size(ppf, size, s$0);
   }
   function kfprintf(k, ppf, param){
    var fmt = param[1];
    return CamlinternalFormat[7].call
            (null,
             function(acc){output_acc(ppf, acc); return caml_call1(k, ppf);},
             0,
             fmt);
   }
   function ikfprintf(k, ppf, param){
    var fmt = param[1];
    return CamlinternalFormat[8].call(null, k, ppf, fmt);
   }
   function ifprintf(ppf, param){
    var fmt = param[1];
    return CamlinternalFormat[8].call(null, function(a){return 0;}, 0, fmt);
   }
   function fprintf(ppf){
    function a(a){return 0;}
    return function(b){return kfprintf(a, ppf, b);};
   }
   function printf(fmt){return fprintf(std_formatter)(fmt);}
   function eprintf(fmt){return fprintf(err_formatter)(fmt);}
   function kdprintf(k, param){
    var fmt = param[1];
    return CamlinternalFormat[7].call
            (null,
             function(acc){
              return caml_call1
                      (k, function(ppf){return output_acc(ppf, acc);});
             },
             0,
             fmt);
   }
   function dprintf(fmt){return kdprintf(function(i){return i;}, fmt);}
   function ksprintf(k, param){
    var fmt = param[1], b = pp_make_buffer(0), ppf = formatter_of_buffer(b);
    function k$0(acc){
     strput_acc(ppf, acc);
     return caml_call1(k, flush_buffer_formatter(b, ppf));
    }
    return CamlinternalFormat[7].call(null, k$0, 0, fmt);
   }
   function sprintf(fmt){return ksprintf(id, fmt);}
   function kasprintf(k, param){
    var fmt = param[1], b = pp_make_buffer(0), ppf = formatter_of_buffer(b);
    function k$0(acc){
     output_acc(ppf, acc);
     return caml_call1(k, flush_buffer_formatter(b, ppf));
    }
    return CamlinternalFormat[7].call(null, k$0, 0, fmt);
   }
   function asprintf(fmt){return kasprintf(id, fmt);}
   function flush_standard_formatters(param){
    pp_print_flush(std_formatter, 0);
    return pp_print_flush(err_formatter, 0);
   }
   Stdlib[100].call(null, flush_standard_formatters);
   function pp_set_all_formatter_output_fu(state, f, g, h, i){
    pp_set_formatter_output_functi(state, f, g);
    state[19] = h;
    state[20] = i;
    return 0;
   }
   function pp_get_all_formatter_output_fu(state, param){
    return [0, state[17], state[18], state[19], state[20]];
   }
   function set_all_formatter_output_funct(a, b, c, d){
    return pp_set_all_formatter_output_fu(std_formatter, a, b, c, d);
   }
   function get_all_formatter_output_funct(a){
    return pp_get_all_formatter_output_fu(std_formatter, a);
   }
   function bprintf(b, param){
    var fmt = param[1], ppf = formatter_of_buffer(b);
    function k(acc){output_acc(ppf, acc); return pp_flush_queue(ppf, 0);}
    return CamlinternalFormat[7].call(null, k, 0, fmt);
   }
   function pp_set_formatter_tag_functions(state, param){
    var pct = param[4], pot = param[3], mct = param[2], mot = param[1];
    function stringify(f, e, param){
     var tag = param[1];
     if(tag !== String_tag) return e;
     var s = param[2];
     return caml_call1(f, s);
    }
    state[24] = function(a){return stringify(mot, cst$15, a);};
    state[25] = function(a){return stringify(mct, cst$16, a);};
    var a = 0;
    state[26] = function(b){return stringify(pot, a, b);};
    var b = 0;
    state[27] = function(a){return stringify(pct, b, a);};
    return 0;
   }
   function pp_get_formatter_tag_functions(fmt, param){
    var funs = pp_get_formatter_stag_function(fmt, 0);
    function mark_open_tag(s){return caml_call1(funs[1], [0, String_tag, s]);}
    function mark_close_tag(s){
     return caml_call1(funs[2], [0, String_tag, s]);
    }
    function print_open_tag(s){
     return caml_call1(funs[3], [0, String_tag, s]);
    }
    function print_close_tag(s){
     return caml_call1(funs[4], [0, String_tag, s]);
    }
    return [0, mark_open_tag, mark_close_tag, print_open_tag, print_close_tag];
   }
   function set_formatter_tag_functions(a){
    return pp_set_formatter_tag_functions(std_formatter, a);
   }
   function get_formatter_tag_functions(a){
    return pp_get_formatter_tag_functions(std_formatter, a);
   }
   var
    Stdlib_Format =
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string,
       pp_print_bytes,
       print_bytes,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int,
       pp_print_float,
       print_float,
       pp_print_char,
       print_char,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_update_geometry,
       update_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functi,
       set_formatter_output_functions,
       pp_get_formatter_output_functi,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_function,
       set_formatter_stag_functions,
       pp_get_formatter_stag_function,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_b,
       pp_print_list,
       pp_print_seq,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       pp_print_either,
       fprintf,
       printf,
       eprintf,
       sprintf,
       asprintf,
       dprintf,
       ifprintf,
       kfprintf,
       kdprintf,
       ikfprintf,
       ksprintf,
       kasprintf,
       bprintf,
       ksprintf,
       set_all_formatter_output_funct,
       get_all_formatter_output_funct,
       pp_set_all_formatter_output_fu,
       pp_get_all_formatter_output_fu,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions];
   runtime.caml_register_global(36, Stdlib_Format, "Stdlib__Format");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Scanf
//# unitInfo: Requires: Assert_failure, CamlinternalFormat, CamlinternalFormatBasics, Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Int, Stdlib__List, Stdlib__Printf, Stdlib__String
//# shape: Stdlib__Scanf:[N,N,F(2),F(2),F(1),F(3),F(3),F(3),F(3),F(2),F(1),F(2),F(3)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = '"',
    cst$6 = "-",
    cst_character = "character ",
    cst_scanf_ml = "scanf.ml",
    cst_scanf_bad_conversion$3 = 'scanf: bad conversion "%*"',
    cst_scanning_of = "scanning of ",
    caml_bytes_get = runtime.caml_bytes_get,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$5,
    cst$4 = cst$5,
    cst$1 = cst$5,
    cst$2 = cst$5,
    cst$0 = cst$5,
    cst_not_a_valid_float_in_hexad =
      "not a valid float in hexadecimal notation",
    cst_no_dot_or_exponent_part_fo =
      "no dot or exponent part found in float token",
    cst = cst$6,
    cst_binary = "binary",
    cst_octal = "octal",
    cst_hexadecimal = "hexadecimal",
    cst_a_Char = "a Char",
    cst_a_String = "a String",
    CamlinternalFormat = global_data.CamlinternalFormat,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    null_char = 0,
    cst_unnamed_function = "unnamed function",
    cst_unnamed_character_string = "unnamed character string",
    cst_unnamed_Stdlib_input_chann = "unnamed Stdlib input channel";
   function next_char(ib){
    try{
     var c = caml_call1(ib[7], 0);
     ib[2] = c;
     ib[3] = 1;
     ib[4] = ib[4] + 1 | 0;
     if(10 === c) ib[5] = ib[5] + 1 | 0;
     return c;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn !== Stdlib[12]) throw caml_maybe_attach_backtrace(exn, 0);
     ib[2] = null_char;
     ib[3] = 0;
     ib[1] = 1;
     return null_char;
    }
   }
   function peek_char(ib){return ib[3] ? ib[2] : next_char(ib);}
   function checked_peek_char(ib){
    var c = peek_char(ib);
    if(ib[1]) throw caml_maybe_attach_backtrace(Stdlib[12], 1);
    return c;
   }
   function end_of_input(ib){peek_char(ib); return ib[1];}
   function beginning_of_input(ib){return 0 === ib[4] ? 1 : 0;}
   function name_of_input(ib){
    var match = ib[9];
    if(typeof match === "number")
     return 0 === match ? cst_unnamed_function : cst_unnamed_character_string;
    if(0 === match[0]) return cst_unnamed_Stdlib_input_chann;
    var fname = match[1];
    return fname;
   }
   function char_count(ib){return ib[3] ? ib[4] - 1 | 0 : ib[4];}
   function invalidate_current_char(ib){ib[3] = 0; return 0;}
   function token_string(ib){
    var token_buffer = ib[8], tok = Stdlib_Buffer[2].call(null, token_buffer);
    Stdlib_Buffer[8].call(null, token_buffer);
    ib[6] = ib[6] + 1 | 0;
    return tok;
   }
   function ignore_char(width, ib){
    var width$0 = width - 1 | 0;
    invalidate_current_char(ib);
    return width$0;
   }
   function store_char(width, ib, c){
    Stdlib_Buffer[12].call(null, ib[8], c);
    return ignore_char(width, ib);
   }
   var default_token_buffer_size = 1024;
   function create(iname, next){
    return [0,
            0,
            null_char,
            0,
            0,
            0,
            0,
            next,
            Stdlib_Buffer[1].call(null, default_token_buffer_size),
            iname];
   }
   function from_string(s){
    var i = [0, 0], len = caml_ml_string_length(s);
    function next(param){
     if(len <= i[1]) throw caml_maybe_attach_backtrace(Stdlib[12], 1);
     var c = caml_string_get(s, i[1]);
     i[1]++;
     return c;
    }
    return create(1, next);
   }
   var a = 0;
   function from_function(b){return create(a, b);}
   var len = 1024;
   function scan_close_at_end(ic){
    Stdlib[93].call(null, ic);
    throw caml_maybe_attach_backtrace(Stdlib[12], 1);
   }
   function scan_raise_at_end(ic){
    throw caml_maybe_attach_backtrace(Stdlib[12], 1);
   }
   function from_ic(scan_close_ic, iname, ic){
    var
     buf = runtime.caml_create_bytes(1024),
     i = [0, 0],
     lim = [0, 0],
     eof = [0, 0];
    function next(param){
     if(i[1] < lim[1]){var c = caml_bytes_get(buf, i[1]); i[1]++; return c;}
     if(eof[1]) throw caml_maybe_attach_backtrace(Stdlib[12], 1);
     lim[1] = Stdlib[84].call(null, ic, buf, 0, len);
     return 0 === lim[1]
             ? (eof[1] = 1, caml_call1(scan_close_ic, ic))
             : (i[1] = 1, caml_bytes_get(buf, 0));
    }
    return create(iname, next);
   }
   var stdin = from_ic(scan_raise_at_end, [1, cst, Stdlib[38]], Stdlib[38]);
   function open_in_file(open_in, fname){
    if(fname === cst$6) return stdin;
    var ic = caml_call1(open_in, fname);
    return from_ic(scan_close_at_end, [1, fname, ic], ic);
   }
   var b = Stdlib[79];
   function open_in(a){return open_in_file(b, a);}
   var c = Stdlib[80];
   function open_in_bin(a){return open_in_file(c, a);}
   function from_channel(ic){return from_ic(scan_raise_at_end, [0, ic], ic);}
   function close_in(ib){
    var match = ib[9];
    if(typeof match === "number") return 0;
    if(0 === match[0]){var ic = match[1]; return Stdlib[93].call(null, ic);}
    var ic$0 = match[2];
    return Stdlib[93].call(null, ic$0);
   }
   var memo = [0, 0];
   function memo_from_channel(ic){
    try{var a = Stdlib_List[48].call(null, ic, memo[1]); return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn, 0);
     var ib = from_ic(scan_raise_at_end, [0, ic], ic);
     memo[1] = [0, [0, ic, ib], memo[1]];
     return ib;
    }
   }
   var
    Scan_failure =
      [248, "Stdlib.Scanf.Scan_failure", runtime.caml_fresh_oo_id(0)],
    d =
      [0,
       [11, "illegal escape character ", [1, 0]],
       "illegal escape character %C"],
    e =
      [0,
       [11,
        cst_scanning_of,
        [2,
         0,
         [11, " failed: the specified length was too short for token", 0]]],
       "scanning of %s failed: the specified length was too short for token"],
    f =
      [0,
       [11,
        cst_scanning_of,
        [2,
         0,
         [11,
          " failed: premature end of file occurred before end of token",
          0]]],
       "scanning of %s failed: premature end of file occurred before end of token"],
    g =
      [0,
       [11, "looking for ", [1, [11, ", found ", [1, 0]]]],
       "looking for %C, found %C"],
    h =
      [0,
       [11, "invalid boolean '", [2, 0, [12, 39, 0]]],
       "invalid boolean '%s'"],
    i = [0, cst_scanf_ml, 555, 9],
    cst_0b = "0b",
    cst_0o = "0o",
    cst_0u = "0u",
    cst_0x = "0x",
    cst_decimal_digits = "decimal digits",
    j =
      [0,
       [11, cst_character, [1, [11, " is not a decimal digit", 0]]],
       "character %C is not a decimal digit"],
    cst_digits = "digits",
    k =
      [0,
       [11,
        cst_character,
        [1, [11, " is not a valid ", [2, 0, [11, " digit", 0]]]]],
       "character %C is not a valid %s digit"],
    cst_an = "an",
    cst_nfinity = "nfinity",
    cst_x = "x",
    l =
      [0,
       [11, "bad character decimal encoding \\", [0, [0, [0, 0]]]],
       "bad character decimal encoding \\%c%c%c"],
    m =
      [0,
       [11, "bad character hexadecimal encoding \\", [0, [0, 0]]],
       "bad character hexadecimal encoding \\%c%c"],
    n =
      [0,
       [11, "the character ", [1, [11, " cannot start a boolean", 0]]],
       "the character %C cannot start a boolean"],
    o =
      [0,
       [11,
        "scanf: bad input at char number ",
        [4, 3, 0, 0, [11, ": ", [2, 0, 0]]]],
       "scanf: bad input at char number %i: %s"],
    p = [0, 37, ""],
    q = [0, 123],
    r = [0, 91],
    cst_end_of_input_not_found = "end of input not found",
    cst_scanf_bad_conversion_a = 'scanf: bad conversion "%a"',
    cst_scanf_bad_conversion_t = 'scanf: bad conversion "%t"',
    cst_scanf_missing_reader = "scanf: missing reader",
    s = [0, cst_scanf_ml, 1453, 13],
    cst_scanf_bad_conversion_custo =
      'scanf: bad conversion "%?" (custom converter)',
    cst_scanf_bad_conversion = cst_scanf_bad_conversion$3,
    cst_scanf_bad_conversion$0 = cst_scanf_bad_conversion$3,
    cst_scanf_bad_conversion$1 = 'scanf: bad conversion "%-"',
    cst_scanf_bad_conversion$2 = cst_scanf_bad_conversion$3,
    cst_in_format = ' in format "',
    t = [0, [3, 0, [10, 0]], "%S%!"];
   function bad_input(s){
    throw caml_maybe_attach_backtrace([0, Scan_failure, s], 1);
   }
   function bad_input_escape(c){
    return bad_input(caml_call1(Stdlib_Printf[4].call(null, d), c));
   }
   function bad_token_length(message){
    return bad_input(caml_call1(Stdlib_Printf[4].call(null, e), message));
   }
   function bad_hex_float(param){
    return bad_input(cst_not_a_valid_float_in_hexad);
   }
   function character_mismatch(c, ci){
    return bad_input(caml_call2(Stdlib_Printf[4].call(null, g), c, ci));
   }
   function check_char(ib, c$0){
    if(10 === c$0){
     var ci = checked_peek_char(ib);
     return 10 === ci
             ? invalidate_current_char(ib)
             : 13
               === ci
               ? (invalidate_current_char(ib), check_this_char(ib, 10))
               : character_mismatch(10, ci);
    }
    if(32 !== c$0) return check_this_char(ib, c$0);
    for(;;){
     var c = peek_char(ib), b = 1 - ib[1];
     if(! b) return b;
     var a = c - 9 | 0;
     a:
     {
      if(4 < a >>> 0){
       if(23 !== a) break a;
      }
      else if(1 >= a - 2 >>> 0) break a;
      invalidate_current_char(ib);
      continue;
     }
     return 0;
    }
   }
   function check_this_char(ib, c){
    var ci = checked_peek_char(ib);
    return ci === c ? invalidate_current_char(ib) : character_mismatch(c, ci);
   }
   function token_char(ib){return caml_string_get(token_string(ib), 0);}
   function token_bool(ib){
    var s = token_string(ib);
    return s !== "false"
            ? s
              !== "true"
              ? bad_input(caml_call1(Stdlib_Printf[4].call(null, h), s))
              : 1
            : 0;
   }
   function integer_conversion_of_char(param){
    var switcher = param - 88 | 0;
    if(32 >= switcher >>> 0)
     switch(switcher){
       case 10:
        return 0;
       case 12:
        return 1;
       case 17:
        return 2;
       case 23:
        return 3;
       case 29:
        return 4;
       case 0:
       case 32:
        return 5;
     }
    throw caml_maybe_attach_backtrace([0, Assert_failure, i], 1);
   }
   function token_int_literal(conv, ib){
    switch(conv){
      case 0:
       var a = token_string(ib), tok = Stdlib[28].call(null, cst_0b, a);
       break;
      case 3:
       var b = token_string(ib), tok = Stdlib[28].call(null, cst_0o, b);
       break;
      case 4:
       var c = token_string(ib), tok = Stdlib[28].call(null, cst_0u, c);
       break;
      case 5:
       var d = token_string(ib), tok = Stdlib[28].call(null, cst_0x, d);
       break;
      default: var tok = token_string(ib);
    }
    var l = caml_ml_string_length(tok);
    if(0 !== l && 43 === caml_string_get(tok, 0))
     return Stdlib_String[15].call(null, tok, 1, l - 1 | 0);
    return tok;
   }
   function token_float(ib){
    return runtime.caml_float_of_string(token_string(ib));
   }
   function scan_decimal_digit_star(width$2, ib){
    var width = width$2;
    for(;;){
     if(0 === width) return width;
     var c = peek_char(ib);
     if(ib[1]) return width;
     if(58 <= c){
      if(95 === c){
       var width$0 = ignore_char(width, ib);
       width = width$0;
       continue;
      }
     }
     else if(48 <= c){
      var width$1 = store_char(width, ib, c);
      width = width$1;
      continue;
     }
     return width;
    }
   }
   function scan_decimal_digit_plus(width, ib){
    if(0 === width) return bad_token_length(cst_decimal_digits);
    var c = checked_peek_char(ib);
    if(9 < c - 48 >>> 0)
     return bad_input(caml_call1(Stdlib_Printf[4].call(null, j), c));
    var width$0 = store_char(width, ib, c);
    return scan_decimal_digit_star(width$0, ib);
   }
   function scan_digit_plus(basis, digitp, width$2, ib){
    if(0 === width$2) return bad_token_length(cst_digits);
    var c$0 = checked_peek_char(ib);
    if(! caml_call1(digitp, c$0))
     return bad_input(caml_call2(Stdlib_Printf[4].call(null, k), c$0, basis));
    var width$3 = store_char(width$2, ib, c$0), width = width$3;
    for(;;){
     if(0 === width) return width;
     var c = peek_char(ib);
     if(ib[1]) return width;
     if(caml_call1(digitp, c)){
      var width$0 = store_char(width, ib, c);
      width = width$0;
     }
     else{
      if(95 !== c) return width;
      var width$1 = ignore_char(width, ib);
      width = width$1;
     }
    }
   }
   function is_binary_digit(param){return 1 < param - 48 >>> 0 ? 0 : 1;}
   function is_octal_digit(param){return 7 < param - 48 >>> 0 ? 0 : 1;}
   function is_hexa_digit(param){
    var a = param - 48 | 0;
    a:
    {
     if(22 < a >>> 0){
      if(5 < a - 49 >>> 0) break a;
     }
     else if(6 >= a - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function scan_sign(width, ib){
    var c = checked_peek_char(ib), switcher = c - 43 | 0;
    if(2 >= switcher >>> 0 && 1 !== switcher) return store_char(width, ib, c);
    return width;
   }
   function scan_optionally_signed_decimal(width, ib){
    var width$0 = scan_sign(width, ib);
    return scan_decimal_digit_plus(width$0, ib);
   }
   function scan_int_conversion(conv, width$1, ib){
    switch(conv){
      case 0:
       return scan_digit_plus(cst_binary, is_binary_digit, width$1, ib);
      case 1:
       return scan_optionally_signed_decimal(width$1, ib);
      case 2:
       var width$0 = scan_sign(width$1, ib), c = checked_peek_char(ib);
       if(48 !== c) return scan_decimal_digit_plus(width$0, ib);
       var width = store_char(width$0, ib, c);
       if(0 === width) return width;
       var c$0 = peek_char(ib);
       if(ib[1]) return width;
       a:
       {
        if(99 <= c$0){
         if(111 === c$0)
          return scan_digit_plus
                  (cst_octal, is_octal_digit, store_char(width, ib, c$0), ib);
         if(120 !== c$0) break a;
        }
        else if(88 !== c$0){
         if(98 <= c$0)
          return scan_digit_plus
                  (cst_binary,
                   is_binary_digit,
                   store_char(width, ib, c$0),
                   ib);
         break a;
        }
        return scan_digit_plus
                (cst_hexadecimal,
                 is_hexa_digit,
                 store_char(width, ib, c$0),
                 ib);
       }
       return scan_decimal_digit_star(width, ib);
      case 3:
       return scan_digit_plus(cst_octal, is_octal_digit, width$1, ib);
      case 4:
       return scan_decimal_digit_plus(width$1, ib);
      default:
       return scan_digit_plus(cst_hexadecimal, is_hexa_digit, width$1, ib);
    }
   }
   function scan_fractional_part(width, ib){
    if(0 === width) return width;
    var c = peek_char(ib);
    return ib[1]
            ? width
            : 9
              < c - 48 >>> 0
              ? width
              : scan_decimal_digit_star(store_char(width, ib, c), ib);
   }
   function scan_exponent_part(width, ib){
    if(0 === width) return width;
    var c = peek_char(ib);
    if(ib[1]) return width;
    if(69 !== c && 101 !== c) return width;
    return scan_optionally_signed_decimal(store_char(width, ib, c), ib);
   }
   function scan_float(width$1, precision, ib){
    var
     width = scan_sign(width$1, ib),
     width$0 = scan_decimal_digit_star(width, ib);
    if(0 === width$0) return [0, width$0, precision];
    var c = peek_char(ib);
    if(ib[1]) return [0, width$0, precision];
    if(46 !== c) return [0, scan_exponent_part(width$0, ib), precision];
    var
     width$2 = store_char(width$0, ib, c),
     precision$0 = Stdlib_Int[10].call(null, width$2, precision),
     width$3 =
       width$2 - (precision$0 - scan_fractional_part(precision$0, ib) | 0) | 0;
    return [0, scan_exponent_part(width$3, ib), precision$0];
   }
   function check_case_insensitive_string(width, ib, error, str){
    function lowercase(c){
     return 25 < c - 65 >>> 0
             ? c
             : Stdlib[29].call(null, (c - 65 | 0) + 97 | 0);
    }
    var
     len = caml_ml_string_length(str),
     width$0 = [0, width],
     a = len - 1 | 0,
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var c = peek_char(ib), d = lowercase(caml_string_get(str, i));
      if(lowercase(c) !== d) caml_call1(error, 0);
      if(0 === width$0[1]) caml_call1(error, 0);
      width$0[1] = store_char(width$0[1], ib, c);
      var e = i + 1 | 0;
      if(a === i) break;
      i = e;
     }
    }
    return width$0[1];
   }
   function scan_hex_float(width, precision, ib){
    var b = 0 === width ? 1 : 0, d = b || end_of_input(ib);
    if(d) bad_input(cst_not_a_valid_float_in_hexad);
    var
     width$0 = scan_sign(width, ib),
     e = 0 === width$0 ? 1 : 0,
     f = e || end_of_input(ib);
    if(f) bad_input(cst_not_a_valid_float_in_hexad);
    var c = peek_char(ib);
    a:
    {
     if(78 <= c){
      var switcher = c - 79 | 0;
      if(30 < switcher >>> 0){
       if(32 <= switcher) break a;
       var
        width$1 = store_char(width$0, ib, c),
        g = 0 === width$1 ? 1 : 0,
        h = g || end_of_input(ib);
       if(h) bad_input(cst_not_a_valid_float_in_hexad);
       return check_case_insensitive_string
               (width$1, ib, bad_hex_float, cst_an);
      }
      if(26 !== switcher) break a;
     }
     else{
      if(48 === c){
       var
        width$3 = store_char(width$0, ib, c),
        k = 0 === width$3 ? 1 : 0,
        l = k || end_of_input(ib);
       if(l) bad_input(cst_not_a_valid_float_in_hexad);
       var
        width$4 =
          check_case_insensitive_string(width$3, ib, bad_hex_float, cst_x);
       if(0 !== width$4 && ! end_of_input(ib)){
        var a = peek_char(ib) - 46 | 0;
        b:
        {
         if(34 < a >>> 0){
          if(66 === a){var width$5 = width$4; break b;}
         }
         else if(32 < a - 1 >>> 0){var width$5 = width$4; break b;}
         var
          width$5 =
            scan_digit_plus(cst_hexadecimal, is_hexa_digit, width$4, ib);
        }
        if(0 !== width$5 && ! end_of_input(ib)){
         var c$0 = peek_char(ib);
         if(46 === c$0){
          var width$6 = store_char(width$5, ib, c$0);
          if(0 === width$6)
           var width$7 = width$6;
          else if(end_of_input(ib))
           var width$7 = width$6;
          else{
           var match = peek_char(ib);
           if(80 === match || 112 === match)
            var width$7 = width$6;
           else
            var
             precision$0 = Stdlib_Int[10].call(null, width$6, precision),
             width$7 =
               width$6
               -
                (precision$0
                -
                 scan_digit_plus
                  (cst_hexadecimal, is_hexa_digit, precision$0, ib)
                | 0)
               | 0;
          }
         }
         else
          var width$7 = width$5;
         if(0 !== width$7 && ! end_of_input(ib)){
          var c$1 = peek_char(ib);
          if(80 !== c$1 && 112 !== c$1) return width$7;
          var
           width$8 = store_char(width$7, ib, c$1),
           m = 0 === width$8 ? 1 : 0,
           n = m || end_of_input(ib);
          if(n) bad_input(cst_not_a_valid_float_in_hexad);
          return scan_optionally_signed_decimal(width$8, ib);
         }
         return width$7;
        }
        return width$5;
       }
       return width$4;
      }
      if(73 !== c) break a;
     }
     var
      width$2 = store_char(width$0, ib, c),
      i = 0 === width$2 ? 1 : 0,
      j = i || end_of_input(ib);
     if(j) bad_input(cst_not_a_valid_float_in_hexad);
     return check_case_insensitive_string
             (width$2, ib, bad_hex_float, cst_nfinity);
    }
    return bad_input(cst_not_a_valid_float_in_hexad);
   }
   function scan_caml_float_rest(width, precision, ib){
    var a = 0 === width ? 1 : 0, b = a || end_of_input(ib);
    if(b) bad_input(cst_no_dot_or_exponent_part_fo);
    var
     width$0 = scan_decimal_digit_star(width, ib),
     d = 0 === width$0 ? 1 : 0,
     e = d || end_of_input(ib);
    if(e) bad_input(cst_no_dot_or_exponent_part_fo);
    var c = peek_char(ib), switcher = c - 69 | 0;
    if(32 < switcher >>> 0){
     if(-23 === switcher){
      var
       width$1 = store_char(width$0, ib, c),
       precision$0 = Stdlib_Int[10].call(null, width$1, precision),
       width_precision = scan_fractional_part(precision$0, ib),
       frac_width = precision$0 - width_precision | 0,
       width$2 = width$1 - frac_width | 0;
      return scan_exponent_part(width$2, ib);
     }
    }
    else if(30 < switcher - 1 >>> 0) return scan_exponent_part(width$0, ib);
    return bad_input(cst_no_dot_or_exponent_part_fo);
   }
   function scan_caml_float(width, precision, ib){
    var a = 0 === width ? 1 : 0, b = a || end_of_input(ib);
    if(b) bad_input(cst_no_dot_or_exponent_part_fo);
    var
     width$0 = scan_sign(width, ib),
     d = 0 === width$0 ? 1 : 0,
     e = d || end_of_input(ib);
    if(e) bad_input(cst_no_dot_or_exponent_part_fo);
    var c = peek_char(ib);
    if(49 <= c){
     if(58 > c){
      var
       width$1 = store_char(width$0, ib, c),
       f = 0 === width$1 ? 1 : 0,
       g = f || end_of_input(ib);
      if(g) bad_input(cst_no_dot_or_exponent_part_fo);
      return scan_caml_float_rest(width$1, precision, ib);
     }
    }
    else if(48 <= c){
     var
      width$2 = store_char(width$0, ib, c),
      h = 0 === width$2 ? 1 : 0,
      i = h || end_of_input(ib);
     if(i) bad_input(cst_no_dot_or_exponent_part_fo);
     var c$0 = peek_char(ib);
     if(88 !== c$0 && 120 !== c$0)
      return scan_caml_float_rest(width$2, precision, ib);
     var
      width$3 = store_char(width$2, ib, c$0),
      j = 0 === width$3 ? 1 : 0,
      k = j || end_of_input(ib);
     if(k) bad_input(cst_no_dot_or_exponent_part_fo);
     var
      width$7 = scan_digit_plus(cst_hexadecimal, is_hexa_digit, width$3, ib),
      l = 0 === width$7 ? 1 : 0,
      m = l || end_of_input(ib);
     if(m) bad_input(cst_no_dot_or_exponent_part_fo);
     var c$1 = peek_char(ib), switcher = c$1 - 80 | 0;
     a:
     {
      if(32 < switcher >>> 0){
       if(-34 === switcher){
        var width$4 = store_char(width$7, ib, c$1);
        if(0 === width$4){var width$5 = width$4; break a;}
        if(end_of_input(ib)){var width$5 = width$4; break a;}
        var match = peek_char(ib);
        if(80 === match){var width$5 = width$4; break a;}
        if(112 === match){var width$5 = width$4; break a;}
        var
         precision$0 = Stdlib_Int[10].call(null, width$4, precision),
         width$5 =
           width$4
           -
            (precision$0
            - scan_digit_plus(cst_hexadecimal, is_hexa_digit, precision$0, ib)
            | 0)
           | 0;
        break a;
       }
      }
      else if(30 < switcher - 1 >>> 0){var width$5 = width$7; break a;}
      var width$5 = bad_input(cst_no_dot_or_exponent_part_fo);
     }
     if(0 !== width$5 && ! end_of_input(ib)){
      var c$2 = peek_char(ib);
      if(80 !== c$2 && 112 !== c$2) return width$5;
      var
       width$6 = store_char(width$5, ib, c$2),
       n = 0 === width$6 ? 1 : 0,
       o = n || end_of_input(ib);
      if(o) bad_input(cst_not_a_valid_float_in_hexad);
      return scan_optionally_signed_decimal(width$6, ib);
     }
     return width$5;
    }
    return bad_input(cst_no_dot_or_exponent_part_fo);
   }
   function scan_string(stp, width, ib){
    var width$0 = width;
    for(;;){
     if(0 === width$0) return width$0;
     var c = peek_char(ib);
     if(ib[1]) return width$0;
     if(stp){
      var c$0 = stp[1];
      if(c === c$0){invalidate_current_char(ib); return width$0;}
      var width$1 = store_char(width$0, ib, c);
      width$0 = width$1;
     }
     else{
      var a = c - 9 | 0;
      a:
      {
       if(4 < a >>> 0){
        if(23 !== a) break a;
       }
       else if(1 >= a - 2 >>> 0) break a;
       return width$0;
      }
      var width$2 = store_char(width$0, ib, c);
      width$0 = width$2;
     }
    }
   }
   function hexadecimal_value_of_char(c){
    return 97 <= c ? c - 87 | 0 : 65 <= c ? c - 55 | 0 : c - 48 | 0;
   }
   function check_next_char(message, width, ib){
    if(0 === width) return bad_token_length(message);
    var c = peek_char(ib);
    return ib[1]
            ? bad_input(caml_call1(Stdlib_Printf[4].call(null, f), message))
            : c;
   }
   function scan_backslash_char(width, ib){
    var c0 = check_next_char(cst_a_Char, width, ib);
    a:
    {
     if(40 <= c0){
      if(58 > c0){
       if(48 > c0) break a;
       var
        get_digit$0 =
          function(param){
           var c = next_char(ib);
           return 9 < c - 48 >>> 0 ? bad_input_escape(c) : c;
          },
        c1$0 = get_digit$0(0),
        c2$0 = get_digit$0(0),
        c =
          ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
          + (c2$0 - 48 | 0)
          | 0;
       b:
       {
        if(0 <= c && 255 >= c){var d = Stdlib[29].call(null, c); break b;}
        var
         d =
           bad_input
            (caml_call3(Stdlib_Printf[4].call(null, l), c0, c1$0, c2$0));
       }
       return store_char(width - 2 | 0, ib, d);
      }
      var switcher = c0 - 92 | 0;
      if(28 < switcher >>> 0) break a;
      switch(switcher){
        case 28:
         var
          get_digit =
            function(param){
             var c = next_char(ib), a = c - 48 | 0;
             a:
             {
              if(22 < a >>> 0){
               if(5 < a - 49 >>> 0) break a;
              }
              else if(6 >= a - 10 >>> 0) break a;
              return c;
             }
             return bad_input_escape(c);
            },
          c1 = get_digit(0),
          c2 = get_digit(0),
          e = hexadecimal_value_of_char(c2),
          c$0 = (16 * hexadecimal_value_of_char(c1) | 0) + e | 0;
         b:
         {
          if(0 <= c$0 && 255 >= c$0){
           var b = Stdlib[29].call(null, c$0);
           break b;
          }
          var
           b = bad_input(caml_call2(Stdlib_Printf[4].call(null, m), c1, c2));
         }
         return store_char(width - 2 | 0, ib, b);
        case 0:
        case 6:
        case 18:
        case 22:
        case 24: break;
        default: break a;
      }
     }
     else if(34 !== c0 && 39 > c0) break a;
     if(110 <= c0)
      if(117 <= c0)
       var a = c0;
      else
       switch(c0 - 110 | 0){
         case 0:
          var a = 10; break;
         case 4:
          var a = 13; break;
         case 6:
          var a = 9; break;
         default: var a = c0;
       }
     else
      var a = 98 === c0 ? 8 : c0;
     return store_char(width, ib, a);
    }
    return bad_input_escape(c0);
   }
   function scan_caml_string(width, ib){
    function find_stop$0(counter, width$5){
     var width = width$5;
     for(;;){
      var c = check_next_char(cst_a_String, width, ib);
      if(34 === c) return ignore_char(width, ib);
      if(92 === c){
       var
        width$0 = ignore_char(width, ib),
        match = check_next_char(cst_a_String, width$0, ib);
       if(10 === match){
        var a = ignore_char(width$0, ib);
        if(counter >= 50) return caml_trampoline_return(skip_spaces, [0, a]);
        var counter$0 = counter + 1 | 0;
        return skip_spaces(counter$0, a);
       }
       if(13 === match){
        var width$2 = ignore_char(width$0, ib);
        if(10 === check_next_char(cst_a_String, width$2, ib)){
         var b = ignore_char(width$2, ib);
         if(counter >= 50) return caml_trampoline_return(skip_spaces, [0, b]);
         var counter$1 = counter + 1 | 0;
         return skip_spaces(counter$1, b);
        }
        var width$4 = store_char(width$2, ib, 13);
        width = width$4;
       }
       else{var width$3 = scan_backslash_char(width$0, ib); width = width$3;}
      }
      else{var width$1 = store_char(width, ib, c); width = width$1;}
     }
    }
    function find_stop(width){return caml_trampoline(find_stop$0(0, width));}
    function skip_spaces(counter, width$1){
     var width = width$1;
     for(;;){
      if(32 !== check_next_char(cst_a_String, width, ib)){
       if(counter >= 50)
        return caml_trampoline_return(find_stop$0, [0, width]);
       var counter$0 = counter + 1 | 0;
       return find_stop$0(counter$0, width);
      }
      var width$0 = ignore_char(width, ib);
      width = width$0;
     }
    }
    var c = checked_peek_char(ib);
    return 34 === c
            ? find_stop(ignore_char(width, ib))
            : character_mismatch(34, c);
   }
   function scan_chars_in_char_set(char_set, scan_indic, width, ib){
    function scan_chars(i$1, stp){
     var i = i$1;
     for(;;){
      var c = peek_char(ib), b = 0 < i ? 1 : 0;
      if(b){
       var d = 1 - ib[1];
       if(d)
        var
         e = CamlinternalFormat[1].call(null, char_set, c),
         a = e ? c !== stp ? 1 : 0 : e;
       else
        var a = d;
      }
      else
       var a = b;
      if(! a) return a;
      store_char(Stdlib[19], ib, c);
      var i$0 = i - 1 | 0;
      i = i$0;
     }
    }
    if(! scan_indic) return scan_chars(width, -1);
    var c = scan_indic[1];
    scan_chars(width, c);
    var a = 1 - ib[1];
    if(! a) return a;
    var ci = peek_char(ib);
    return c === ci ? invalidate_current_char(ib) : character_mismatch(c, ci);
   }
   function scanf_bad_input(ib, x){
    if(x[1] === Scan_failure)
     var s = x[2];
    else{
     var tag = x[1];
     if(tag !== Stdlib[7]) throw caml_maybe_attach_backtrace(x, 1);
     var s = x[2];
    }
    var i = char_count(ib);
    return bad_input(caml_call2(Stdlib_Printf[4].call(null, o), i, s));
   }
   function width_of_pad_opt(pad_opt){
    if(! pad_opt) return Stdlib[19];
    var width = pad_opt[1];
    return width;
   }
   function stopper_of_formatting_lit(fmting){
    if(6 === fmting) return p;
    var
     str = CamlinternalFormat[17].call(null, fmting),
     stp = caml_string_get(str, 1),
     sub_str =
       Stdlib_String[15].call
        (null, str, 2, caml_ml_string_length(str) - 2 | 0);
    return [0, stp, sub_str];
   }
   function take_format_readers$0(counter, k, fmt$4){
    a:
    {
     var fmt = fmt$4;
     b:
     for(;;){
      if(typeof fmt === "number") return caml_call1(k, 0);
      switch(fmt[0]){
        case 14:
         var
          rest$3 = fmt[3],
          fmtty = fmt[2],
          c = CamlinternalFormat[21].call(null, fmtty),
          b = CamlinternalFormatBasics[2].call(null, c);
         if(counter >= 50)
          return caml_trampoline_return
                  (take_fmtty_format_readers$0, [0, k, b, rest$3]);
         var counter$0 = counter + 1 | 0;
         return take_fmtty_format_readers$0(counter$0, k, b, rest$3);
        case 18:
         var a = fmt[1];
         if(0 === a[0]){
          var
           rest$4 = fmt[2],
           fmt$0 = a[1][1],
           fmt$1 = CamlinternalFormatBasics[3].call(null, fmt$0, rest$4);
          fmt = fmt$1;
         }
         else{
          var
           rest$5 = fmt[2],
           fmt$2 = a[1][1],
           fmt$3 = CamlinternalFormatBasics[3].call(null, fmt$2, rest$5);
          fmt = fmt$3;
         }
         break;
        case 19:
         break a;
        case 23:
         var rest$6 = fmt[2], ign = fmt[1];
         if(typeof ign === "number"){
          if(2 === ign) break b;
          fmt = rest$6;
         }
         else{
          if(9 === ign[0]){
           var fmtty$0 = ign[2];
           if(counter >= 50)
            return caml_trampoline_return
                    (take_fmtty_format_readers$0, [0, k, fmtty$0, rest$6]);
           var counter$1 = counter + 1 | 0;
           return take_fmtty_format_readers$0(counter$1, k, fmtty$0, rest$6);
          }
          fmt = rest$6;
         }
         break;
        case 13:
        case 20:
        case 24:
         var rest$2 = fmt[3]; fmt = rest$2; break;
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
         var rest$1 = fmt[4]; fmt = rest$1; break;
        case 0:
        case 1:
        case 10:
        case 15:
        case 16:
        case 22:
         var rest = fmt[1]; fmt = rest; break;
        default: var rest$0 = fmt[2]; fmt = rest$0;
      }
     }
     return function(reader){
      function new_k(readers_rest){
       return caml_call1(k, [0, reader, readers_rest]);
      }
      return take_format_readers(new_k, rest$6);};
    }
    var fmt_rest = fmt[1];
    return function(reader){
     function new_k(readers_rest){
      return caml_call1(k, [0, reader, readers_rest]);
     }
     return take_format_readers(new_k, fmt_rest);};
   }
   function take_format_readers(k, fmt){
    return caml_trampoline(take_format_readers$0(0, k, fmt));
   }
   function take_fmtty_format_readers$0(counter, k, fmtty$3, fmt){
    a:
    {
     var fmtty = fmtty$3;
     b:
     for(;;){
      if(typeof fmtty === "number"){
       if(counter >= 50)
        return caml_trampoline_return(take_format_readers$0, [0, k, fmt]);
       var counter$0 = counter + 1 | 0;
       return take_format_readers$0(counter$0, k, fmt);
      }
      switch(fmtty[0]){
        case 8:
         var fmtty$1 = fmtty[2]; fmtty = fmtty$1; break;
        case 9:
         var
          rest = fmtty[3],
          ty2 = fmtty[2],
          ty1 = fmtty[1],
          a = CamlinternalFormat[21].call(null, ty1),
          ty = CamlinternalFormat[22].call(null, a, ty2),
          fmtty$2 = CamlinternalFormatBasics[1].call(null, ty, rest);
         fmtty = fmtty$2;
         break;
        case 13:
         break a;
        case 14:
         break b;
        default: var fmtty$0 = fmtty[1]; fmtty = fmtty$0;
      }
     }
     var fmt_rest$0 = fmtty[1];
     return function(reader){
      function new_k(readers_rest){
       return caml_call1(k, [0, reader, readers_rest]);
      }
      return take_fmtty_format_readers(new_k, fmt_rest$0, fmt);};
    }
    var fmt_rest = fmtty[1];
    return function(reader){
     function new_k(readers_rest){
      return caml_call1(k, [0, reader, readers_rest]);
     }
     return take_fmtty_format_readers(new_k, fmt_rest, fmt);};
   }
   function take_fmtty_format_readers(k, fmtty, fmt){
    return caml_trampoline(take_fmtty_format_readers$0(0, k, fmtty, fmt));
   }
   function make_scanf(ib, fmt$13, readers){
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           h:
           {
            i:
            {
             var fmt = fmt$13;
             j:
             for(;;){
              if(typeof fmt === "number") return 0;
              switch(fmt[0]){
                case 0:
                 var rest = fmt[1];
                 store_char(0, ib, checked_peek_char(ib));
                 var c$0 = token_char(ib);
                 return [0, c$0, make_scanf(ib, rest, readers)];
                case 1:
                 break a;
                case 2:
                 break b;
                case 3:
                 break c;
                case 4:
                 break d;
                case 5:
                 break e;
                case 6:
                 break f;
                case 7:
                 break g;
                case 8:
                 switch(fmt[1][2]){
                   case 5:
                   case 8:
                    var rest$11 = fmt[4], prec$4 = fmt[3], pad$6 = fmt[2];
                    return pad_prec_scanf
                            (ib,
                             rest$11,
                             readers,
                             pad$6,
                             prec$4,
                             scan_caml_float,
                             token_float);
                   case 6:
                   case 7:
                    var rest$12 = fmt[4], prec$5 = fmt[3], pad$7 = fmt[2];
                    return pad_prec_scanf
                            (ib,
                             rest$12,
                             readers,
                             pad$7,
                             prec$5,
                             scan_hex_float,
                             token_float);
                   default:
                    var rest$10 = fmt[4], prec$3 = fmt[3], pad$5 = fmt[2];
                    return pad_prec_scanf
                            (ib,
                             rest$10,
                             readers,
                             pad$5,
                             prec$3,
                             scan_float,
                             token_float);
                 }
                case 9:
                 break h;
                case 10:
                 var rest$14 = fmt[1];
                 if(! end_of_input(ib))
                  return bad_input(cst_end_of_input_not_found);
                 fmt = rest$14;
                 break;
                case 11:
                 var rest$15 = fmt[2], str$0 = fmt[1];
                 Stdlib_String[29].call
                  (null, function(a){return check_char(ib, a);}, str$0);
                 fmt = rest$15;
                 break;
                case 12:
                 var rest$16 = fmt[2], chr = fmt[1];
                 check_char(ib, chr);
                 fmt = rest$16;
                 break;
                case 13:
                 var rest$17 = fmt[3], fmtty = fmt[2], pad_opt = fmt[1];
                 scan_caml_string(width_of_pad_opt(pad_opt), ib);
                 var s$0 = token_string(ib);
                 try{
                  var
                   e = CamlinternalFormat[14].call(null, s$0, fmtty),
                   fmt$2 = e;
                 }
                 catch(exn$0){
                  var exn = caml_wrap_exception(exn$0), tag = exn[1];
                  if(tag !== Stdlib[7])
                   throw caml_maybe_attach_backtrace(exn, 0);
                  var msg = exn[2], fmt$2 = bad_input(msg);
                 }
                 return [0, fmt$2, make_scanf(ib, rest$17, readers)];
                case 14:
                 break i;
                case 15:
                 return Stdlib[1].call(null, cst_scanf_bad_conversion_a);
                case 16:
                 return Stdlib[1].call(null, cst_scanf_bad_conversion_t);
                case 17:
                 var
                  rest$19 = fmt[2],
                  formatting_lit = fmt[1],
                  j = CamlinternalFormat[17].call(null, formatting_lit);
                 Stdlib_String[29].call
                  (null, function(a){return check_char(ib, a);}, j);
                 fmt = rest$19;
                 break;
                case 18:
                 var b = fmt[1];
                 if(0 === b[0]){
                  var rest$20 = fmt[2], fmt$8 = b[1][1];
                  check_char(ib, 64);
                  check_char(ib, 123);
                  var
                   fmt$9 =
                     CamlinternalFormatBasics[3].call(null, fmt$8, rest$20);
                  fmt = fmt$9;
                 }
                 else{
                  var rest$21 = fmt[2], fmt$10 = b[1][1];
                  check_char(ib, 64);
                  check_char(ib, 91);
                  var
                   fmt$11 =
                     CamlinternalFormatBasics[3].call(null, fmt$10, rest$21);
                  fmt = fmt$11;
                 }
                 break;
                case 19:
                 var fmt_rest = fmt[1];
                 if(! readers)
                  return Stdlib[1].call(null, cst_scanf_missing_reader);
                 var
                  readers_rest = readers[2],
                  reader = readers[1],
                  x = caml_call1(reader, ib);
                 return [0, x, make_scanf(ib, fmt_rest, readers_rest)];
                case 20:
                 break j;
                case 21:
                 var rest$24 = fmt[2], counter = fmt[1];
                 switch(counter){
                   case 0:
                    var count = ib[5]; break;
                   case 1:
                    var count = char_count(ib); break;
                   default: var count = ib[6];
                 }
                 return [0, count, make_scanf(ib, rest$24, readers)];
                case 22:
                 var rest$25 = fmt[1], c$2 = checked_peek_char(ib);
                 return [0, c$2, make_scanf(ib, rest$25, readers)];
                case 23:
                 var
                  rest$26 = fmt[2],
                  ign = fmt[1],
                  fmt$12 = CamlinternalFormat[6].call(null, ign, rest$26)[1],
                  match$3 = make_scanf(ib, fmt$12, readers);
                 if(! match$3)
                  throw caml_maybe_attach_backtrace([0, Assert_failure, s], 1);
                 var arg_rest = match$3[2];
                 return arg_rest;
                default:
                 return Stdlib[1].call(null, cst_scanf_bad_conversion_custo);
              }
             }
             var width_opt = fmt[1], match$1 = fmt[3];
             if(typeof match$1 !== "number" && 17 === match$1[0]){
              var
               rest$23 = match$1[2],
               fmting_lit$0 = match$1[1],
               char_set$0 = fmt[2],
               match$2 = stopper_of_formatting_lit(fmting_lit$0),
               str$1 = match$2[2],
               stp$0 = match$2[1],
               width$2 = width_of_pad_opt(width_opt);
              scan_chars_in_char_set(char_set$0, [0, stp$0], width$2, ib);
              var s$3 = token_string(ib), str_rest$0 = [11, str$1, rest$23];
              return [0, s$3, make_scanf(ib, str_rest$0, readers)];
             }
             var
              rest$22 = fmt[3],
              char_set = fmt[2],
              width$1 = width_of_pad_opt(width_opt);
             scan_chars_in_char_set(char_set, 0, width$1, ib);
             var s$2 = token_string(ib);
             return [0, s$2, make_scanf(ib, rest$22, readers)];
            }
            var rest$18 = fmt[3], fmtty$0 = fmt[2], pad_opt$0 = fmt[1];
            scan_caml_string(width_of_pad_opt(pad_opt$0), ib);
            var s$1 = token_string(ib);
            try{
             var
              fmt$5 = CamlinternalFormat[13].call(null, 0, s$1)[1],
              fmt$6 = CamlinternalFormat[13].call(null, 0, s$1)[1],
              f = CamlinternalFormat[21].call(null, fmtty$0),
              g = CamlinternalFormatBasics[2].call(null, f),
              fmt$7 = CamlinternalFormat[12].call(null, fmt$6, g),
              h = CamlinternalFormatBasics[2].call(null, fmtty$0),
              i = CamlinternalFormat[12].call(null, fmt$5, h),
              fmt$4 = fmt$7,
              fmt$3 = i;
            }
            catch(exn){
             var exn$0 = caml_wrap_exception(exn), tag$0 = exn$0[1];
             if(tag$0 !== Stdlib[7])
              throw caml_maybe_attach_backtrace(exn$0, 0);
             var
              msg$0 = exn$0[2],
              d = bad_input(msg$0),
              fmt$4 = d[2],
              fmt$3 = d[1];
            }
            return [0,
                    [0, fmt$3, s$1],
                    make_scanf
                     (ib,
                      CamlinternalFormatBasics[3].call(null, fmt$4, rest$18),
                      readers)];
           }
           var
            rest$13 = fmt[2],
            pad$8 = fmt[1],
            scan$8 =
              function(param, a, ib){
               var
                c = checked_peek_char(ib),
                m =
                  102 === c
                   ? 5
                   : 116
                     === c
                     ? 4
                     : bad_input(caml_call1(Stdlib_Printf[4].call(null, n), c));
               return scan_string(0, m, ib);
              };
           return pad_prec_scanf
                   (ib, rest$13, readers, pad$8, 0, scan$8, token_bool);
          }
          var
           rest$9 = fmt[4],
           prec$2 = fmt[3],
           pad$4 = fmt[2],
           iconv$2 = fmt[1],
           conv$2 =
             integer_conversion_of_char
              (CamlinternalFormat[16].call(null, iconv$2)),
           scan$7 =
             function(width, param, ib){
              return scan_int_conversion(conv$2, width, ib);
             };
          return pad_prec_scanf
                  (ib,
                   rest$9,
                   readers,
                   pad$4,
                   prec$2,
                   scan$7,
                   function(ib){
                    return runtime.caml_int64_of_string
                            (token_int_literal(conv$2, ib));
                   });
         }
         var
          rest$8 = fmt[4],
          prec$1 = fmt[3],
          pad$3 = fmt[2],
          iconv$1 = fmt[1],
          conv$1 =
            integer_conversion_of_char
             (CamlinternalFormat[16].call(null, iconv$1)),
          scan$6 =
            function(width, param, ib){
             return scan_int_conversion(conv$1, width, ib);
            };
         return pad_prec_scanf
                 (ib,
                  rest$8,
                  readers,
                  pad$3,
                  prec$1,
                  scan$6,
                  function(ib){
                   return caml_int_of_string(token_int_literal(conv$1, ib));
                  });
        }
        var
         rest$7 = fmt[4],
         prec$0 = fmt[3],
         pad$2 = fmt[2],
         iconv$0 = fmt[1],
         conv$0 =
           integer_conversion_of_char
            (CamlinternalFormat[16].call(null, iconv$0)),
         scan$5 =
           function(width, param, ib){
            return scan_int_conversion(conv$0, width, ib);
           };
        return pad_prec_scanf
                (ib,
                 rest$7,
                 readers,
                 pad$2,
                 prec$0,
                 scan$5,
                 function(ib){
                  return caml_int_of_string(token_int_literal(conv$0, ib));
                 });
       }
       var
        rest$6 = fmt[4],
        prec = fmt[3],
        pad$1 = fmt[2],
        iconv = fmt[1],
        conv =
          integer_conversion_of_char(CamlinternalFormat[16].call(null, iconv)),
        scan$4 =
          function(width, param, ib){
           return scan_int_conversion(conv, width, ib);
          };
       return pad_prec_scanf
               (ib,
                rest$6,
                readers,
                pad$1,
                prec,
                scan$4,
                function(ib){
                 return caml_int_of_string(token_int_literal(conv, ib));
                });
      }
      var
       rest$5 = fmt[2],
       pad$0 = fmt[1],
       scan$3 =
         function(width, param, ib){return scan_caml_string(width, ib);};
      return pad_prec_scanf
              (ib, rest$5, readers, pad$0, 0, scan$3, token_string);
     }
     var pad = fmt[1], match = fmt[2];
     if(typeof match !== "number")
      switch(match[0]){
        case 17:
         var
          rest$2 = match[2],
          fmting_lit = match[1],
          match$0 = stopper_of_formatting_lit(fmting_lit),
          str = match$0[2],
          stp = match$0[1],
          scan$0 =
            function(width, param, ib){
             return scan_string([0, stp], width, ib);
            },
          str_rest = [11, str, rest$2];
         return pad_prec_scanf
                 (ib, str_rest, readers, pad, 0, scan$0, token_string);
        case 18:
         var a = match[1];
         if(0 === a[0]){
          var
           rest$3 = match[2],
           fmt$0 = a[1][1],
           scan$1 =
             function(width, param, ib){return scan_string(q, width, ib);};
          return pad_prec_scanf
                  (ib,
                   CamlinternalFormatBasics[3].call(null, fmt$0, rest$3),
                   readers,
                   pad,
                   0,
                   scan$1,
                   token_string);
         }
         var
          rest$4 = match[2],
          fmt$1 = a[1][1],
          scan$2 =
            function(width, param, ib){return scan_string(r, width, ib);};
         return pad_prec_scanf
                 (ib,
                  CamlinternalFormatBasics[3].call(null, fmt$1, rest$4),
                  readers,
                  pad,
                  0,
                  scan$2,
                  token_string);
      }
     var
      rest$1 = fmt[2],
      scan = function(width, param, ib){return scan_string(0, width, ib);};
     return pad_prec_scanf(ib, rest$1, readers, pad, 0, scan, token_string);
    }
    var rest$0 = fmt[1];
    function find_stop(width){
     var c = check_next_char(cst_a_Char, width, ib);
     return 39 === c ? ignore_char(width, ib) : character_mismatch(39, c);
    }
    var c = checked_peek_char(ib), width$0 = 0;
    if(39 === c){
     var
      width = ignore_char(width$0, ib),
      c$3 = check_next_char(cst_a_Char, width, ib);
     if(92 === c$3)
      find_stop(scan_backslash_char(ignore_char(width, ib), ib));
     else
      find_stop(store_char(width, ib, c$3));
    }
    else
     character_mismatch(39, c);
    var c$1 = token_char(ib);
    return [0, c$1, make_scanf(ib, rest$0, readers)];
   }
   function pad_prec_scanf(ib, fmt, readers, pad, prec, scan, token){
    if(typeof pad === "number"){
     if(typeof prec !== "number"){
      var p = prec[1];
      caml_call3(scan, Stdlib[19], p, ib);
      var x$0 = caml_call1(token, ib);
      return [0, x$0, make_scanf(ib, fmt, readers)];
     }
     if(prec) return Stdlib[1].call(null, cst_scanf_bad_conversion);
     caml_call3(scan, Stdlib[19], Stdlib[19], ib);
     var x = caml_call1(token, ib);
     return [0, x, make_scanf(ib, fmt, readers)];
    }
    if(0 !== pad[0]) return Stdlib[1].call(null, cst_scanf_bad_conversion$2);
    if(! pad[1]) return Stdlib[1].call(null, cst_scanf_bad_conversion$1);
    var w = pad[2];
    if(typeof prec !== "number"){
     var p$0 = prec[1];
     caml_call3(scan, w, p$0, ib);
     var x$2 = caml_call1(token, ib);
     return [0, x$2, make_scanf(ib, fmt, readers)];
    }
    if(prec) return Stdlib[1].call(null, cst_scanf_bad_conversion$0);
    caml_call3(scan, w, Stdlib[19], ib);
    var x$1 = caml_call1(token, ib);
    return [0, x$1, make_scanf(ib, fmt, readers)];
   }
   function kscanf(ib, ef, param){
    var str = param[2], fmt = param[1];
    function k(readers, f$1){
     Stdlib_Buffer[9].call(null, ib[8]);
     a:
     try{var e = [0, make_scanf(ib, fmt, readers)], match = e;}
     catch(exc$0){
      var exc = caml_wrap_exception(exc$0);
      if
       (exc[1] !== Scan_failure && exc[1] !== Stdlib[7] && exc !== Stdlib[12]){
       var tag = exc[1];
       if(tag !== Stdlib[6]) throw caml_maybe_attach_backtrace(exc, 0);
       var
        msg = exc[2],
        a = Stdlib_String[24].call(null, str),
        b = Stdlib[28].call(null, a, cst$0),
        c = Stdlib[28].call(null, cst_in_format, b),
        d = Stdlib[28].call(null, msg, c),
        match = Stdlib[1].call(null, d);
       break a;
      }
      var match = [1, exc];
     }
     if(0 !== match[0]){
      var exc$0 = match[1];
      return caml_call2(ef, ib, exc$0);
     }
     var args$1 = match[1], f = f$1, args = args$1;
     for(;;){
      if(! args) return f;
      var args$0 = args[2], x = args[1], f$0 = caml_call1(f, x);
      f = f$0;
      args = args$0;
     }
    }
    return take_format_readers(k, fmt);
   }
   function bscanf(ib, fmt){return kscanf(ib, scanf_bad_input, fmt);}
   function ksscanf(s, ef, fmt){return kscanf(from_string(s), ef, fmt);}
   function sscanf(s, fmt){
    return kscanf(from_string(s), scanf_bad_input, fmt);
   }
   function scanf(fmt){return kscanf(stdin, scanf_bad_input, fmt);}
   function bscanf_format(ib, format, f){
    scan_caml_string(Stdlib[19], ib);
    var str = token_string(ib);
    try{var a = CamlinternalFormat[15].call(null, str, format), fmt = a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag !== Stdlib[7]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2], fmt = bad_input(msg);
    }
    return caml_call1(f, fmt);
   }
   function sscanf_format(s, format, f){
    return bscanf_format(from_string(s), format, f);
   }
   function format_from_string(s, fmt){
    var
     a = Stdlib_String[24].call(null, s),
     b = Stdlib[28].call(null, a, cst$1);
    return sscanf_format
            (Stdlib[28].call(null, cst$2, b), fmt, function(x){return x;});
   }
   function unescaped(s){
    var a = Stdlib[28].call(null, s, cst$3);
    return caml_call1
            (sscanf(Stdlib[28].call(null, cst$4, a), t),
             function(x){return x;});
   }
   function kfscanf(ic, ef, fmt){
    return kscanf(memo_from_channel(ic), ef, fmt);
   }
   function fscanf(ic, fmt){
    return kscanf(memo_from_channel(ic), scanf_bad_input, fmt);
   }
   var
    Stdlib_Scanf =
      [0,
       [0,
        stdin,
        open_in,
        open_in_bin,
        close_in,
        open_in,
        open_in_bin,
        from_string,
        from_function,
        from_channel,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdin],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
   runtime.caml_register_global(65, Stdlib_Scanf, "Stdlib__Scanf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Callback
//# unitInfo: Requires: Stdlib, Stdlib__Obj
//# shape: Stdlib__Callback:[F(2),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_register_named_value = runtime.caml_register_named_value,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    register = caml_register_named_value;
   function register_exception(name, exn){
    var
     a = Stdlib_Obj[8],
     slot = runtime.caml_obj_tag(exn) === a ? exn : exn[1];
    return caml_register_named_value(name, slot);
   }
   var Stdlib_Callback = [0, register, register_exception];
   runtime.caml_register_global(1, Stdlib_Callback, "Stdlib__Callback");
   return;
  }
  (globalThis));

//# unitInfo: Provides: CamlinternalOO
//# unitInfo: Requires: Assert_failure, Stdlib, Stdlib__Array, Stdlib__List, Stdlib__Map, Stdlib__Obj, Stdlib__Sys
//# shape: CamlinternalOO:[F(1),F(1),F(2),F(3),F(2),F(2),F(2),F(2),F(2),F(3),F(2),F(4),F(1),F(2),N,F(1),F(1),F(6),F(2),F(3),F(1)*,F(1),F(1),F(2),F(2),F(3),F(2),F(2),N,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_camlinternalOO_ml = "camlinternalOO.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_get_public_method = runtime.caml_get_public_method,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_block = runtime.caml_obj_block,
    caml_set_oo_id = runtime.caml_set_oo_id,
    caml_string_compare = runtime.caml_string_compare,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Map = global_data.Stdlib__Map;
   function copy(o){
    var o$0 = runtime.caml_obj_dup(o);
    return caml_set_oo_id(o$0);
   }
   var params = [0, 1, 1, 1, 3, 16];
   function public_method_label(s){
    var accu = [0, 0], a = runtime.caml_ml_string_length(s) - 1 | 0, b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var c = runtime.caml_string_get(s, i);
      accu[1] = (223 * accu[1] | 0) + c | 0;
      var d = i + 1 | 0;
      if(a === i) break;
      i = d;
     }
    }
    accu[1] = accu[1] & 2147483647;
    var tag = 1073741823 < accu[1] ? accu[1] + 2147483648 | 0 : accu[1];
    return tag;
   }
   var
    compare = caml_string_compare,
    Vars = Stdlib_Map[1].call(null, [0, compare]),
    compare$0 = caml_string_compare,
    Meths = Stdlib_Map[1].call(null, [0, compare$0]),
    compare$1 = runtime.caml_int_compare,
    Labs = Stdlib_Map[1].call(null, [0, compare$1]),
    dummy_table = [0, 0, [0, 0], Meths[1], Labs[1], 0, 0, Vars[1], 0],
    table_count = [0, 0],
    dummy_met = caml_obj_block(0, 0),
    initial_object_size = 2;
   function fit_size(n){
    return 2 < n ? fit_size((n + 1 | 0) / 2 | 0) * 2 | 0 : n;
   }
   function new_table(pub_labels){
    table_count[1]++;
    var
     len = pub_labels.length - 1,
     methods = caml_make_vect((len * 2 | 0) + 2 | 0, dummy_met);
    caml_check_bound(methods, 0)[1] = len;
    var
     c = Stdlib_Sys[9],
     d = (runtime.caml_mul(fit_size(len), c) / 8 | 0) - 1 | 0;
    caml_check_bound(methods, 1)[2] = d;
    var a = len - 1 | 0, e = 0;
    if(a >= 0){
     var i = e;
     for(;;){
      var b = (i * 2 | 0) + 3 | 0, f = caml_check_bound(pub_labels, i)[i + 1];
      caml_check_bound(methods, b)[b + 1] = f;
      var g = i + 1 | 0;
      if(a === i) break;
      i = g;
     }
    }
    return [0,
            initial_object_size,
            methods,
            Meths[1],
            Labs[1],
            0,
            0,
            Vars[1],
            0];
   }
   function resize(array, new_size){
    var old_size = array[2].length - 1, a = old_size < new_size ? 1 : 0;
    if(a){
     var new_buck = caml_make_vect(new_size, dummy_met);
     Stdlib_Array[10].call(null, array[2], 0, new_buck, 0, old_size);
     array[2] = new_buck;
     var b = 0;
    }
    else
     var b = a;
    return b;
   }
   var
    method_count = [0, 0],
    inst_var_count = [0, 0],
    a = [0, cst_camlinternalOO_ml, 281, 50],
    b = [0, cst_camlinternalOO_ml, 409, 13],
    c = [0, cst_camlinternalOO_ml, 412, 13],
    d = [0, cst_camlinternalOO_ml, 415, 13],
    e = [0, cst_camlinternalOO_ml, 418, 13],
    f = [0, cst_camlinternalOO_ml, 421, 13],
    g = [0, cst_camlinternalOO_ml, 439, 17];
   function new_method(table){
    var index = table[2].length - 1;
    resize(table, index + 1 | 0);
    return index;
   }
   function get_method_label(table, name){
    try{var a = caml_call2(Meths[28], name, table[3]); return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn, 0);
     var label = new_method(table);
     table[3] = caml_call3(Meths[4], name, label, table[3]);
     table[4] = caml_call3(Labs[4], label, 1, table[4]);
     return label;
    }
   }
   function get_method_labels(table, names){
    return Stdlib_Array[15].call
            (null, function(a){return get_method_label(table, a);}, names);
   }
   function set_method(table, label, element){
    method_count[1]++;
    return caml_call2(Labs[28], label, table[4])
            ? (resize
               (table, label + 1 | 0),
              caml_check_bound(table[2], label)[label + 1] = element,
              0)
            : (table[6] = [0, [0, label, element], table[6]], 0);
   }
   function get_method(table, label){
    try{var a = Stdlib_List[46].call(null, label, table[6]); return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Stdlib[8])
      return caml_check_bound(table[2], label)[label + 1];
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function to_list(arr){
    return 0 === arr ? 0 : Stdlib_Array[11].call(null, arr);
   }
   function narrow(table, vars, virt_meths, concr_meths){
    var
     vars$0 = to_list(vars),
     virt_meths$0 = to_list(virt_meths),
     concr_meths$0 = to_list(concr_meths),
     virt_meth_labs =
       Stdlib_List[19].call
        (null, function(a){return get_method_label(table, a);}, virt_meths$0),
     concr_meth_labs =
       Stdlib_List[19].call
        (null, function(a){return get_method_label(table, a);}, concr_meths$0);
    table[5] =
     [0,
      [0, table[3], table[4], table[6], table[7], virt_meth_labs, vars$0],
      table[5]];
    table[7] =
     caml_call3
      (Vars[13],
       function(lab, info, tvars){
        return Stdlib_List[36].call(null, lab, vars$0)
                ? caml_call3(Vars[4], lab, info, tvars)
                : tvars;
       },
       table[7],
       Vars[1]);
    var by_name = [0, Meths[1]], by_label = [0, Labs[1]];
    Stdlib_List[27].call
     (null,
      function(met, label){
       by_name[1] = caml_call3(Meths[4], met, label, by_name[1]);
       var b = by_label[1];
       try{var c = caml_call2(Labs[28], label, table[4]), a = c;}
       catch(exn$0){
        var exn = caml_wrap_exception(exn$0);
        if(exn !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn, 0);
        var a = 1;
       }
       by_label[1] = caml_call3(Labs[4], label, a, b);
       return 0;
      },
      concr_meths$0,
      concr_meth_labs);
    Stdlib_List[27].call
     (null,
      function(met, label){
       by_name[1] = caml_call3(Meths[4], met, label, by_name[1]);
       by_label[1] = caml_call3(Labs[4], label, 0, by_label[1]);
       return 0;
      },
      virt_meths$0,
      virt_meth_labs);
    table[3] = by_name[1];
    table[4] = by_label[1];
    table[6] =
     Stdlib_List[26].call
      (null,
       function(met, hm){
        var lab = met[1];
        return Stdlib_List[36].call(null, lab, virt_meth_labs)
                ? hm
                : [0, met, hm];
       },
       table[6],
       0);
    return 0;
   }
   function widen(table){
    var
     match = Stdlib_List[5].call(null, table[5]),
     vars = match[6],
     virt_meths = match[5],
     saved_vars = match[4],
     saved_hidden_meths = match[3],
     by_label = match[2],
     by_name = match[1];
    table[5] = Stdlib_List[6].call(null, table[5]);
    table[7] =
     Stdlib_List[25].call
      (null,
       function(s, v){
        var a = caml_call2(Vars[28], v, table[7]);
        return caml_call3(Vars[4], v, a, s);
       },
       saved_vars,
       vars);
    table[3] = by_name;
    table[4] = by_label;
    table[6] =
     Stdlib_List[26].call
      (null,
       function(met, hm){
        var lab = met[1];
        return Stdlib_List[36].call(null, lab, virt_meths) ? hm : [0, met, hm];
       },
       table[6],
       saved_hidden_meths);
    return 0;
   }
   function new_variable(table, name){
    try{var a = caml_call2(Vars[28], name, table[7]); return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn, 0);
     var index = table[1];
     table[1] = index + 1 | 0;
     if(name !== "") table[7] = caml_call3(Vars[4], name, index, table[7]);
     return index;
    }
   }
   function to_array(arr){return runtime.caml_equal(arr, 0) ? [0] : arr;}
   function new_methods_variables(table, meths, vals){
    var
     meths$0 = to_array(meths),
     nmeths = meths$0.length - 1,
     nvals = vals.length - 1,
     res = caml_make_vect(nmeths + nvals | 0, 0),
     a = nmeths - 1 | 0,
     d = 0;
    if(a >= 0){
     var i$0 = d;
     for(;;){
      var
       h = get_method_label(table, caml_check_bound(meths$0, i$0)[i$0 + 1]);
      caml_check_bound(res, i$0)[i$0 + 1] = h;
      var j = i$0 + 1 | 0;
      if(a === i$0) break;
      i$0 = j;
     }
    }
    var b = nvals - 1 | 0, e = 0;
    if(b >= 0){
     var i = e;
     for(;;){
      var
       c = i + nmeths | 0,
       f = new_variable(table, caml_check_bound(vals, i)[i + 1]);
      caml_check_bound(res, c)[c + 1] = f;
      var g = i + 1 | 0;
      if(b === i) break;
      i = g;
     }
    }
    return res;
   }
   function get_variable(table, name){
    try{var b = caml_call2(Vars[28], name, table[7]); return b;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Stdlib[8])
      throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function get_variables(table, names){
    return Stdlib_Array[15].call
            (null, function(a){return get_variable(table, a);}, names);
   }
   function add_initializer(table, f){table[8] = [0, f, table[8]]; return 0;}
   function create_table(public_methods){
    if(0 === public_methods) return new_table([0]);
    var
     tags = Stdlib_Array[15].call(null, public_method_label, public_methods),
     table = new_table(tags);
    Stdlib_Array[14].call
     (null,
      function(i, met){
       var lab = (i * 2 | 0) + 2 | 0;
       table[3] = caml_call3(Meths[4], met, lab, table[3]);
       table[4] = caml_call3(Labs[4], lab, 1, table[4]);
       return 0;
      },
      public_methods);
    return table;
   }
   function init_class(table){
    inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
    table[8] = Stdlib_List[9].call(null, table[8]);
    var a = Stdlib_Sys[9];
    return resize
            (table,
             3 + caml_div(caml_check_bound(table[2], 1)[2] * 16 | 0, a) | 0);
   }
   function inherits(cla, vals, virt_meths, concr_meths, param, top){
    var env = param[4], super$ = param[2];
    narrow(cla, vals, virt_meths, concr_meths);
    var init = top ? caml_call2(super$, cla, env) : caml_call1(super$, cla);
    widen(cla);
    var
     a = to_array(concr_meths),
     b =
       [0,
        Stdlib_Array[15].call
         (null,
          function(nm){return get_method(cla, get_method_label(cla, nm));},
          a),
        0],
     c = to_array(vals),
     d =
       [0,
        [0, init],
        [0,
         Stdlib_Array[15].call
          (null, function(a){return get_variable(cla, a);}, c),
         b]];
    return Stdlib_Array[6].call(null, d);
   }
   function make_class(pub_meths, class_init){
    var
     table = create_table(pub_meths),
     env_init = caml_call1(class_init, table);
    init_class(table);
    return [0, caml_call1(env_init, 0), class_init, env_init, 0];
   }
   function make_class_store(pub_meths, class_init, init_table){
    var
     table = create_table(pub_meths),
     env_init = caml_call1(class_init, table);
    init_class(table);
    init_table[2] = class_init;
    init_table[1] = env_init;
    return 0;
   }
   function dummy_class(loc){
    function undef(param){
     throw caml_maybe_attach_backtrace([0, Stdlib[15], loc], 1);
    }
    return [0, undef, undef, undef, 0];
   }
   function create_object(table){
    var obj = caml_obj_block(Stdlib_Obj[8], table[1]);
    obj[1] = table[2];
    return caml_set_oo_id(obj);
   }
   function create_object_opt(obj_0, table){
    if(obj_0) return obj_0;
    var obj = caml_obj_block(Stdlib_Obj[8], table[1]);
    obj[1] = table[2];
    return caml_set_oo_id(obj);
   }
   function iter_f(obj, param$0){
    var param = param$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], f = param[1];
     caml_call1(f, obj);
     param = l;
    }
   }
   function run_initializers(obj, table){
    var inits = table[8], a = 0 !== inits ? 1 : 0;
    return a ? iter_f(obj, inits) : a;
   }
   function run_initializers_opt(obj_0, obj, table){
    if(obj_0) return obj;
    var inits = table[8];
    if(0 !== inits) iter_f(obj, inits);
    return obj;
   }
   function create_object_and_run_initiali(obj_0, table){
    if(obj_0) return obj_0;
    var obj = create_object(table);
    run_initializers(obj, table);
    return obj;
   }
   function get_data(param){
    if(param) return param[2];
    throw caml_maybe_attach_backtrace([0, Assert_failure, e], 1);
   }
   function build_path(n, keys, tables){
    var res = [0, 0, 0, 0], r = [0, res], a = 0;
    if(n >= 0){
     var i = a;
     for(;;){
      var c = r[1];
      r[1] = [0, caml_check_bound(keys, i)[i + 1], c, 0];
      var d = i + 1 | 0;
      if(n === i) break;
      i = d;
     }
    }
    var v = r[1];
    if(! tables) throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
    tables[2] = v;
    return res;
   }
   function lookup_tables(root, keys){
    var root_data = get_data(root);
    if(! root_data) return build_path(keys.length - 2 | 0, keys, root);
    var i$1 = keys.length - 2 | 0, i = i$1, tables$0 = root_data;
    for(;;){
     if(0 > i) return tables$0;
     var key = caml_check_bound(keys, i)[i + 1], tables$1 = tables$0;
     for(;;){
      if(! tables$1)
       throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
      if(tables$1[1] === key){
       var tables_data = get_data(tables$1);
       if(! tables_data)
        throw caml_maybe_attach_backtrace([0, Assert_failure, g], 1);
       var i$0 = i - 1 | 0;
       i = i$0;
       tables$0 = tables_data;
       break;
      }
      if(! tables$1)
       throw caml_maybe_attach_backtrace([0, Assert_failure, f], 1);
      var tables = tables$1[3];
      if(! tables){
       var next = [0, key, 0, 0];
       if(! tables$1)
        throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
       tables$1[3] = next;
       return build_path(i - 1 | 0, keys, next);
      }
      tables$1 = tables;
     }
    }
   }
   function new_cache(table){
    var n = new_method(table);
    if(0 === (n % 2 | 0))
     var n$0 = n;
    else
     var
      a = Stdlib_Sys[9],
      n$0 =
        (2 + caml_div(caml_check_bound(table[2], 1)[2] * 16 | 0, a) | 0) < n
         ? n
         : new_method(table);
    caml_check_bound(table[2], n$0)[n$0 + 1] = 0;
    return n$0;
   }
   function method_impl(table, i, arr){
    function next(param){
     i[1]++;
     var a = i[1];
     return caml_check_bound(arr, a)[a + 1];
    }
    var clo = next(0);
    if(typeof clo === "number")
     switch(clo){
       case 0:
        var x = next(0); return function(obj){return x;};
       case 1:
        var n = next(0); return function(obj){return obj[n + 1];};
       case 2:
        var e = next(0), n$0 = next(0);
        return function(obj){return obj[e + 1][n$0 + 1];};
       case 3:
        var n$1 = next(0);
        return function(obj){return caml_call1(obj[1][n$1 + 1], obj);};
       case 4:
        var n$2 = next(0);
        return function(obj, x){obj[n$2 + 1] = x; return 0;};
       case 5:
        var f = next(0), x$0 = next(0);
        return function(obj){return caml_call1(f, x$0);};
       case 6:
        var f$0 = next(0), n$3 = next(0);
        return function(obj){return caml_call1(f$0, obj[n$3 + 1]);};
       case 7:
        var f$1 = next(0), e$0 = next(0), n$4 = next(0);
        return function(obj){return caml_call1(f$1, obj[e$0 + 1][n$4 + 1]);};
       case 8:
        var f$2 = next(0), n$5 = next(0);
        return function(obj){
         return caml_call1(f$2, caml_call1(obj[1][n$5 + 1], obj));};
       case 9:
        var f$3 = next(0), x$1 = next(0), y = next(0);
        return function(obj){return caml_call2(f$3, x$1, y);};
       case 10:
        var f$4 = next(0), x$2 = next(0), n$6 = next(0);
        return function(obj){return caml_call2(f$4, x$2, obj[n$6 + 1]);};
       case 11:
        var f$5 = next(0), x$3 = next(0), e$1 = next(0), n$7 = next(0);
        return function(obj){
         return caml_call2(f$5, x$3, obj[e$1 + 1][n$7 + 1]);};
       case 12:
        var f$6 = next(0), x$4 = next(0), n$8 = next(0);
        return function(obj){
         return caml_call2(f$6, x$4, caml_call1(obj[1][n$8 + 1], obj));};
       case 13:
        var f$7 = next(0), n$9 = next(0), x$5 = next(0);
        return function(obj){return caml_call2(f$7, obj[n$9 + 1], x$5);};
       case 14:
        var f$8 = next(0), e$2 = next(0), n$10 = next(0), x$6 = next(0);
        return function(obj){
         return caml_call2(f$8, obj[e$2 + 1][n$10 + 1], x$6);};
       case 15:
        var f$9 = next(0), n$11 = next(0), x$7 = next(0);
        return function(obj){
         return caml_call2(f$9, caml_call1(obj[1][n$11 + 1], obj), x$7);};
       case 16:
        var n$12 = next(0), x$8 = next(0);
        return function(obj){return caml_call2(obj[1][n$12 + 1], obj, x$8);};
       case 17:
        var n$13 = next(0), m = next(0);
        return function(obj){
         return caml_call2(obj[1][n$13 + 1], obj, obj[m + 1]);};
       case 18:
        var n$14 = next(0), e$3 = next(0), m$0 = next(0);
        return function(obj){
         return caml_call2(obj[1][n$14 + 1], obj, obj[e$3 + 1][m$0 + 1]);};
       case 19:
        var n$15 = next(0), m$1 = next(0);
        return function(obj){
         var a = caml_call1(obj[1][m$1 + 1], obj);
         return caml_call2(obj[1][n$15 + 1], obj, a);};
       case 20:
        var m$2 = next(0), x$9 = next(0);
        new_cache(table);
        return function(obj){
         return caml_call1(caml_get_public_method(x$9, m$2), x$9);};
       case 21:
        var m$3 = next(0), n$16 = next(0);
        new_cache(table);
        return function(obj){
         var a = obj[n$16 + 1];
         return caml_call1(caml_get_public_method(a, m$3), a);};
       case 22:
        var m$4 = next(0), e$4 = next(0), n$17 = next(0);
        new_cache(table);
        return function(obj){
         var a = obj[e$4 + 1][n$17 + 1];
         return caml_call1(caml_get_public_method(a, m$4), a);};
       default:
        var m$5 = next(0), n$18 = next(0);
        new_cache(table);
        return function(obj){
         var a = caml_call1(obj[1][n$18 + 1], obj);
         return caml_call1(caml_get_public_method(a, m$5), a);};
     }
    return clo;
   }
   function set_methods(table, methods){
    var len = methods.length - 1, i = [0, 0];
    for(;;){
     if(i[1] >= len) return 0;
     var
      a = i[1],
      label = caml_check_bound(methods, a)[a + 1],
      clo = method_impl(table, i, methods);
     set_method(table, label, clo);
     i[1]++;
    }
   }
   function stats(param){
    return [0, table_count[1], method_count[1], inst_var_count[1]];
   }
   var
    CamlinternalOO =
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initiali,
       lookup_tables,
       params,
       stats];
   runtime.caml_register_global(17, CamlinternalOO, "CamlinternalOO");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Oo
//# unitInfo: Requires: CamlinternalOO
//# shape: Stdlib__Oo:[F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    CamlinternalOO = global_data.CamlinternalOO,
    copy = CamlinternalOO[22],
    new_method = CamlinternalOO[1],
    public_method_label = CamlinternalOO[1],
    Stdlib_Oo = [0, copy, new_method, public_method_label];
   runtime.caml_register_global(1, Stdlib_Oo, "Stdlib__Oo");
   return;
  }
  (globalThis));

//# unitInfo: Provides: CamlinternalMod
//# unitInfo: Requires: Assert_failure, CamlinternalLazy, CamlinternalOO, Stdlib, Stdlib__Obj
//# shape: CamlinternalMod:[F(2),F(3)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_camlinternalMod_ml = "camlinternalMod.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    CamlinternalLazy = global_data.CamlinternalLazy,
    CamlinternalOO = global_data.CamlinternalOO,
    Assert_failure = global_data.Assert_failure,
    cst_CamlinternalMod_init_mod_n = "CamlinternalMod.init_mod: not a module",
    a = [0, cst_camlinternalMod_ml, 72, 5],
    b = [0, cst_camlinternalMod_ml, 81, 2],
    cst_CamlinternalMod_update_mod =
      "CamlinternalMod.update_mod: not a module";
   function init_mod_block(loc, comps$0){
    var
     length = comps$0.length - 1,
     modu = runtime.caml_obj_block(0, length),
     a = length - 1 | 0,
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var shape = caml_check_bound(comps$0, i)[i + 1];
      if(typeof shape === "number")
       switch(shape){
         case 0:
          let i$1 = i;
          var
           fn =
             function(x){
              var fn = modu[i$1 + 1];
              if(fn$0 === fn)
               throw caml_maybe_attach_backtrace([0, Stdlib[15], loc], 1);
              return caml_call1(fn, x);
             };
          let fn$0 = fn;
          var init = fn;
          break;
         case 1:
          var l = [];
          let l$0 = l, i$0 = i;
          runtime.caml_update_dummy
           (l,
            [246,
             function(param){
              var l = modu[i$0 + 1];
              if(l$0 === l)
               throw caml_maybe_attach_backtrace([0, Stdlib[15], loc], 1);
              var a = caml_obj_tag(l);
              return 250 === a
                      ? l[1]
                      : 246 === a ? CamlinternalLazy[2].call(null, l) : l;
             }]);
          var init = l;
          break;
         default: var init = CamlinternalOO[21].call(null, loc);
       }
      else if(0 === shape[0])
       var comps = shape[1], init = init_mod_block(loc, comps);
      else
       var v = shape[1], init = v;
      modu[i + 1] = init;
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return modu;
   }
   function init_mod(loc, shape){
    if(typeof shape !== "number" && 0 === shape[0]){
     var comps = shape[1];
     return init_mod_block(loc, comps);
    }
    return Stdlib[2].call(null, cst_CamlinternalMod_init_mod_n);
   }
   function update_mod_block(comps$0, modu, n){
    if(0 === caml_obj_tag(n) && comps$0.length - 1 <= n.length - 1){
     var c = comps$0.length - 2 | 0, e = 0;
     if(c >= 0){
      var i = e;
      for(;;){
       var n$0 = n[i + 1], shape = caml_check_bound(comps$0, i)[i + 1];
       a:
       if(typeof shape === "number"){
        if(2 === shape){
         if(0 === caml_obj_tag(n$0) && 4 === n$0.length - 1){
          var cl = modu[i + 1], j = 0;
          for(;;){
           cl[j + 1] = n$0[j + 1];
           var d = j + 1 | 0;
           if(3 === j) break a;
           j = d;
          }
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
        }
        modu[i + 1] = n$0;
       }
       else if(0 === shape[0]){
        var comps = shape[1];
        update_mod_block(comps, modu[i + 1], n$0);
       }
       var f = i + 1 | 0;
       if(c === i) break;
       i = f;
      }
     }
     return 0;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
   }
   function update_mod(shape, o, n){
    if(typeof shape !== "number" && 0 === shape[0]){
     var comps = shape[1];
     return update_mod_block(comps, o, n);
    }
    return Stdlib[2].call(null, cst_CamlinternalMod_update_mod);
   }
   var CamlinternalMod = [0, init_mod, update_mod];
   runtime.caml_register_global(8, CamlinternalMod, "CamlinternalMod");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Genlex
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Char, Stdlib__Hashtbl, Stdlib__List, Stdlib__Stream, Stdlib__String
//# shape: Stdlib__Genlex:[F(1)->F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = "",
    caml_create_bytes = runtime.caml_create_bytes,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    cst = cst$5,
    cst$0 = cst$5,
    cst$1 = cst$5,
    cst$2 = cst$5,
    cst$4 = cst$5,
    cst$3 = cst$5,
    Stdlib_Stream = global_data.Stdlib__Stream,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    initial_buffer = caml_create_bytes(32),
    buffer = [0, initial_buffer],
    bufpos = [0, 0],
    cst_Illegal_character = "Illegal character ";
   function reset_buffer(param){buffer[1] = initial_buffer; bufpos[1] = 0;}
   function store(c){
    if(runtime.caml_ml_bytes_length(buffer[1]) <= bufpos[1]){
     var newbuffer = caml_create_bytes(2 * bufpos[1] | 0);
     Stdlib_Bytes[11].call(null, buffer[1], 0, newbuffer, 0, bufpos[1]);
     buffer[1] = newbuffer;
    }
    runtime.caml_bytes_set(buffer[1], bufpos[1], c);
    bufpos[1]++;
   }
   function get_string(param){
    var s = Stdlib_Bytes[8].call(null, buffer[1], 0, bufpos[1]);
    buffer[1] = initial_buffer;
    return s;
   }
   function make_lexer(keywords){
    var kwd_table = Stdlib_Hashtbl[1].call(null, 0, 17);
    Stdlib_List[17].call
     (null,
      function(s){return Stdlib_Hashtbl[5].call(null, kwd_table, s, [0, s]);},
      keywords);
    function ident_or_keyword(id){
     try{var a = Stdlib_Hashtbl[6].call(null, kwd_table, id); return a;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn === Stdlib[8]) return [1, id];
      throw caml_maybe_attach_backtrace(exn, 0);
     }
    }
    function keyword_or_error(c){
     var s = Stdlib_String[1].call(null, 1, c);
     try{var b = Stdlib_Hashtbl[6].call(null, kwd_table, s); return b;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn, 0);
      var a = Stdlib[28].call(null, cst_Illegal_character, s);
      throw caml_maybe_attach_backtrace([0, Stdlib_Stream[2], a], 1);
     }
    }
    function next_token(strm){
     a:
     {
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          f:
          {
           g:
           {
            for(;;){
             var match = Stdlib_Stream[11].call(null, strm);
             if(! match) return 0;
             var c = match[1];
             if(124 <= c) break;
             var a = c - 65 | 0;
             if(57 >= a >>> 0) break d;
             if(58 <= a) break a;
             switch(a + 65 | 0){
               case 34:
                break e;
               case 39:
                break f;
               case 40:
                Stdlib_Stream[12].call(null, strm);
                var match$5 = Stdlib_Stream[11].call(null, strm);
                if(match$5 && 42 === match$5[1]){
                 Stdlib_Stream[12].call(null, strm);
                 comment(strm);
                 break;
                }
                return [0, keyword_or_error(40)];
               case 45:
                break g;
               case 9:
               case 10:
               case 12:
               case 13:
               case 26:
               case 32:
                Stdlib_Stream[12].call(null, strm); break;
               case 48:
               case 49:
               case 50:
               case 51:
               case 52:
               case 53:
               case 54:
               case 55:
               case 56:
               case 57:
                Stdlib_Stream[12].call(null, strm);
                reset_buffer(0);
                store(c);
                return number(strm);
               case 33:
               case 35:
               case 36:
               case 37:
               case 38:
               case 42:
               case 43:
               case 47:
               case 58:
               case 60:
               case 61:
               case 62:
               case 63:
               case 64:
                break c;
               default: break a;
             }
            }
            if(127 <= c){if(192 <= c) break b; break a;}
            if(125 === c) break a;
            break c;
           }
           Stdlib_Stream[12].call(null, strm);
           var match$2 = Stdlib_Stream[11].call(null, strm);
           if(match$2){
            var c$2 = match$2[1];
            if(9 >= c$2 - 48 >>> 0){
             Stdlib_Stream[12].call(null, strm);
             reset_buffer(0);
             store(45);
             store(c$2);
             return number(strm);
            }
           }
           reset_buffer(0);
           store(45);
           return ident2(strm);
          }
          Stdlib_Stream[12].call(null, strm);
          try{
           var match$4 = Stdlib_Stream[11].call(null, strm);
           if(! match$4)
            throw caml_maybe_attach_backtrace(Stdlib_Stream[1], 1);
           var c$5 = match$4[1];
           if(92 === c$5){
            Stdlib_Stream[12].call(null, strm);
            try{var e = escape(strm), c$0 = e;}
            catch(exn){
             var exn$1 = caml_wrap_exception(exn);
             if(exn$1 === Stdlib_Stream[1])
              throw caml_maybe_attach_backtrace
                     ([0, Stdlib_Stream[2], cst$2], 1);
             throw caml_maybe_attach_backtrace(exn$1, 0);
            }
           }
           else{Stdlib_Stream[12].call(null, strm); var c$0 = c$5;}
          }
          catch(exn$0){
           var exn = caml_wrap_exception(exn$0);
           if(exn === Stdlib_Stream[1])
            throw caml_maybe_attach_backtrace([0, Stdlib_Stream[2], cst], 1);
           throw caml_maybe_attach_backtrace(exn, 0);
          }
          var match$0 = Stdlib_Stream[11].call(null, strm);
          if(match$0 && 39 === match$0[1]){
           Stdlib_Stream[12].call(null, strm);
           return [0, [5, c$0]];
          }
          throw caml_maybe_attach_backtrace([0, Stdlib_Stream[2], cst$0], 1);
         }
         Stdlib_Stream[12].call(null, strm);
         reset_buffer(0);
         for(;;){
          var match$3 = Stdlib_Stream[11].call(null, strm);
          if(! match$3)
           throw caml_maybe_attach_backtrace(Stdlib_Stream[1], 1);
          var c$3 = match$3[1];
          if(34 === c$3){
           Stdlib_Stream[12].call(null, strm);
           return [0, [4, get_string(0)]];
          }
          if(92 === c$3){
           Stdlib_Stream[12].call(null, strm);
           try{var c$4 = escape(strm);}
           catch(exn){
            var exn$0 = caml_wrap_exception(exn);
            if(exn$0 === Stdlib_Stream[1])
             throw caml_maybe_attach_backtrace
                    ([0, Stdlib_Stream[2], cst$1], 1);
            throw caml_maybe_attach_backtrace(exn$0, 0);
           }
           store(c$4);
          }
          else{Stdlib_Stream[12].call(null, strm); store(c$3);}
         }
        }
        var d = a - 26 | 0;
        if(5 < d >>> 0) break b;
        switch(d){case 4: break b;case 1:case 3: break;default: break a;
        }
       }
       Stdlib_Stream[12].call(null, strm);
       reset_buffer(0);
       store(c);
       return ident2(strm);
      }
      Stdlib_Stream[12].call(null, strm);
      reset_buffer(0);
      store(c);
      for(;;){
       var match$1 = Stdlib_Stream[11].call(null, strm);
       b:
       if(match$1){
        var c$1 = match$1[1];
        if(91 <= c$1){
         var b = c$1 - 95 | 0;
         if(27 < b >>> 0){if(97 > b) break b;} else if(1 === b) break b;
        }
        else
         if(48 <= c$1){
          if(6 >= c$1 - 58 >>> 0) break b;
         }
         else if(39 !== c$1) break b;
        Stdlib_Stream[12].call(null, strm);
        store(c$1);
        continue;
       }
       return [0, ident_or_keyword(get_string(0))];
      }
     }
     Stdlib_Stream[12].call(null, strm);
     return [0, keyword_or_error(c)];
    }
    function ident2(strm){
     for(;;){
      var match = Stdlib_Stream[11].call(null, strm);
      a:
      if(match){
       var c = match[1];
       if(94 <= c){
        var a = c - 95 | 0;
        if(30 < a >>> 0){if(32 <= a) break a;} else if(29 !== a) break a;
       }
       else
        if(65 <= c){
         if(92 !== c) break a;
        }
        else{
         if(33 > c) break a;
         switch(c - 33 | 0){
           case 0:
           case 2:
           case 3:
           case 4:
           case 5:
           case 9:
           case 10:
           case 12:
           case 14:
           case 25:
           case 27:
           case 28:
           case 29:
           case 30:
           case 31: break;
           default: break a;
         }
        }
       Stdlib_Stream[12].call(null, strm);
       store(c);
       continue;
      }
      return [0, ident_or_keyword(get_string(0))];
     }
    }
    function number(strm){
     for(;;){
      var match = Stdlib_Stream[11].call(null, strm);
      a:
      if(match){
       var c = match[1];
       if(58 <= c){
        if(69 !== c && 101 !== c) break a;
        Stdlib_Stream[12].call(null, strm);
        store(69);
        return exponent_part(strm);
       }
       if(46 === c) break;
       if(48 <= c){Stdlib_Stream[12].call(null, strm); store(c); continue;}
      }
      return [0, [2, runtime.caml_int_of_string(get_string(0))]];
     }
     Stdlib_Stream[12].call(null, strm);
     store(46);
     for(;;){
      var match$0 = Stdlib_Stream[11].call(null, strm);
      if(match$0){
       var c$0 = match$0[1], a = c$0 - 69 | 0;
       if(32 < a >>> 0){
        if(9 >= a + 21 >>> 0){
         Stdlib_Stream[12].call(null, strm);
         store(c$0);
         continue;
        }
       }
       else if(30 < a - 1 >>> 0){
        Stdlib_Stream[12].call(null, strm);
        store(69);
        return exponent_part(strm);
       }
      }
      return [0, [3, caml_float_of_string(get_string(0))]];
     }
    }
    function exponent_part(strm){
     var match = Stdlib_Stream[11].call(null, strm);
     a:
     if(match){
      var c = match[1];
      if(43 !== c && 45 !== c) break a;
      Stdlib_Stream[12].call(null, strm);
      store(c);
      return end_exponent_part(strm);
     }
     return end_exponent_part(strm);
    }
    function end_exponent_part(strm){
     for(;;){
      var match = Stdlib_Stream[11].call(null, strm);
      if(match){
       var c = match[1];
       if(9 >= c - 48 >>> 0){
        Stdlib_Stream[12].call(null, strm);
        store(c);
        continue;
       }
      }
      return [0, [3, caml_float_of_string(get_string(0))]];
     }
    }
    function escape(strm){
     var match = Stdlib_Stream[11].call(null, strm);
     if(! match) throw caml_maybe_attach_backtrace(Stdlib_Stream[1], 1);
     var c1 = match[1];
     if(58 <= c1){
      var switcher = c1 - 110 | 0;
      if(6 >= switcher >>> 0)
       switch(switcher){
         case 0:
          Stdlib_Stream[12].call(null, strm); return 10;
         case 4:
          Stdlib_Stream[12].call(null, strm); return 13;
         case 6:
          Stdlib_Stream[12].call(null, strm); return 9;
       }
     }
     else if(48 <= c1){
      Stdlib_Stream[12].call(null, strm);
      var match$0 = Stdlib_Stream[11].call(null, strm);
      if(match$0){
       var c2 = match$0[1];
       if(9 >= c2 - 48 >>> 0){
        Stdlib_Stream[12].call(null, strm);
        var match$1 = Stdlib_Stream[11].call(null, strm);
        if(match$1){
         var c3 = match$1[1];
         if(9 >= c3 - 48 >>> 0){
          Stdlib_Stream[12].call(null, strm);
          return Stdlib_Char[1].call
                  (null,
                   (((c1 - 48 | 0) * 100 | 0) + ((c2 - 48 | 0) * 10 | 0) | 0)
                   + (c3 - 48 | 0)
                   | 0);
         }
        }
        throw caml_maybe_attach_backtrace([0, Stdlib_Stream[2], cst$4], 1);
       }
      }
      throw caml_maybe_attach_backtrace([0, Stdlib_Stream[2], cst$3], 1);
     }
     Stdlib_Stream[12].call(null, strm);
     return c1;
    }
    function comment(strm){
     a:
     for(;;){
      var match = Stdlib_Stream[11].call(null, strm);
      if(! match) throw caml_maybe_attach_backtrace(Stdlib_Stream[1], 1);
      var switcher = match[1] - 40 | 0;
      if(2 >= switcher >>> 0)
       switch(switcher){
         case 0:
          Stdlib_Stream[12].call(null, strm);
          var match$0 = Stdlib_Stream[11].call(null, strm);
          if(! match$0)
           throw caml_maybe_attach_backtrace(Stdlib_Stream[1], 1);
          if(42 === match$0[1]){
           Stdlib_Stream[12].call(null, strm);
           comment(strm);
           continue;
          }
          Stdlib_Stream[12].call(null, strm);
          continue;
         case 2:
          Stdlib_Stream[12].call(null, strm);
          for(;;){
           var match$1 = Stdlib_Stream[11].call(null, strm);
           if(! match$1)
            throw caml_maybe_attach_backtrace(Stdlib_Stream[1], 1);
           var match$2 = match$1[1];
           if(41 === match$2){Stdlib_Stream[12].call(null, strm); return;}
           if(42 !== match$2){Stdlib_Stream[12].call(null, strm); continue a;}
           Stdlib_Stream[12].call(null, strm);
          }
          break;
       }
      Stdlib_Stream[12].call(null, strm);
     }
    }
    return function(input){
     return Stdlib_Stream[3].call
             (null, function(count){return next_token(input);});};
   }
   var Stdlib_Genlex = [0, make_lexer];
   runtime.caml_register_global(14, Stdlib_Genlex, "Stdlib__Genlex");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Ephemeron
//# unitInfo: Requires: CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Hashtbl, Stdlib__Int, Stdlib__List, Stdlib__Obj, Stdlib__Random, Stdlib__Seq, Stdlib__Sys
//# shape: Stdlib__Ephemeron:[N,N,N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    c = [0, 0],
    b = [0, 0],
    a = [0, 0],
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random;
   function MakeSeeded(H){
    var
     prng = [246, function(a){return caml_call1(Stdlib_Random[15][2], 0);}];
    function create(opt, initial_size){
     if(opt)
      var sth = opt[1], random = sth;
     else
      var random = Stdlib_Hashtbl[17].call(null, 0);
     var x = 16;
     for(;;){
      if(initial_size <= x) break;
      if(Stdlib_Sys[13] < (x * 2 | 0)) break;
      var x$0 = x * 2 | 0;
      x = x$0;
     }
     if(random)
      var
       a = runtime.caml_obj_tag(prng),
       b =
         250 === a
          ? prng[1]
          : 246 === a ? CamlinternalLazy[2].call(null, prng) : prng,
       seed = caml_call1(Stdlib_Random[15][4], b);
     else
      var seed = 0;
     return [0, 0, caml_make_vect(x, 0), seed, x];
    }
    function clear(h){
     h[1] = 0;
     var len = h[2].length - 1, a = len - 1 | 0, b = 0;
     if(a >= 0){
      var i = b;
      for(;;){
       caml_check_bound(h[2], i)[i + 1] = 0;
       var c = i + 1 | 0;
       if(a === i) break;
       i = c;
      }
     }
     return 0;
    }
    function reset(h){
     var len = h[2].length - 1;
     return len === h[4]
             ? clear(h)
             : (h[1] = 0, h[2] = caml_make_vect(h[4], 0), 0);
    }
    function copy(h){
     var a = h[4], b = h[3], c = Stdlib_Array[8].call(null, h[2]);
     return [0, h[1], c, b, a];
    }
    function key_index(h, hkey){return hkey & (h[2].length - 2 | 0);}
    function clean(h){
     function do_bucket(param$0){
      var param = param$0;
      for(;;){
       if(! param) return 0;
       var hkey = param[1], rest = param[3], c = param[2];
       if(caml_call1(H[7], c)){
        var rest$0 = param[3], c$0 = param[2];
        return [0, hkey, c$0, do_bucket(rest$0)];
       }
       h[1] = h[1] - 1 | 0;
       param = rest;
      }
     }
     var d = h[2], a = d.length - 2 | 0, b = 0;
     if(a >= 0){
      var i = b;
      for(;;){
       d[i + 1] = do_bucket(caml_check_bound(d, i)[i + 1]);
       var c = i + 1 | 0;
       if(a === i) break;
       i = c;
      }
     }
     return 0;
    }
    function resize(h){
     var odata = h[2], osize = odata.length - 1, nsize = osize * 2 | 0;
     clean(h);
     var
      a = nsize < Stdlib_Sys[13] ? 1 : 0,
      b = a ? (osize >>> 1 | 0) <= h[1] ? 1 : 0 : a;
     if(b){
      var ndata = caml_make_vect(nsize, 0);
      h[2] = ndata;
      var
       insert_bucket =
         function(param){
          if(! param) return;
          var rest = param[3], data = param[2], hkey = param[1];
          insert_bucket(rest);
          var nidx = key_index(h, hkey);
          ndata[nidx + 1] =
           [0, hkey, data, caml_check_bound(ndata, nidx)[nidx + 1]];
         },
       c = osize - 1 | 0,
       e = 0;
      if(c >= 0){
       var i = e;
       for(;;){
        insert_bucket(caml_check_bound(odata, i)[i + 1]);
        var f = i + 1 | 0;
        if(c === i) break;
        i = f;
       }
      }
      var d = 0;
     }
     else
      var d = b;
     return d;
    }
    function add(h, key, info){
     var
      hkey = caml_call2(H[2], h[3], key),
      i = key_index(h, hkey),
      container = caml_call2(H[1], key, info),
      bucket = [0, hkey, container, caml_check_bound(h[2], i)[i + 1]];
     caml_check_bound(h[2], i)[i + 1] = bucket;
     h[1] = h[1] + 1 | 0;
     var a = h[2].length - 1 << 1 < h[1] ? 1 : 0;
     return a ? resize(h) : a;
    }
    function remove(h, key){
     var hkey = caml_call2(H[2], h[3], key);
     function remove_bucket(param$0){
      var param = param$0;
      for(;;){
       if(! param) return 0;
       var hk = param[1], next = param[3], c = param[2];
       if(hkey !== hk){
        var next$0 = param[3], c$0 = param[2];
        return [0, hk, c$0, remove_bucket(next$0)];
       }
       switch(caml_call2(H[3], c, key)){
         case 0:
          h[1] = h[1] - 1 | 0; return next;
         case 1:
          return [0, hk, c, remove_bucket(next)];
         default: h[1] = h[1] - 1 | 0; param = next;
       }
      }
     }
     var
      i = key_index(h, hkey),
      a = remove_bucket(caml_check_bound(h[2], i)[i + 1]);
     caml_check_bound(h[2], i)[i + 1] = a;
     return 0;
    }
    function find(h, key){
     var
      hkey = caml_call2(H[2], h[3], key),
      a = key_index(h, hkey),
      param = caml_check_bound(h[2], a)[a + 1];
     for(;;){
      if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var hk = param[1], rest = param[3], c = param[2];
      if(hkey === hk)
       if(0 === caml_call2(H[3], c, key)){
        var match = caml_call1(H[4], c);
        if(match){var d = match[1]; return d;}
        param = rest;
       }
       else
        param = rest;
      else{var rest$0 = param[3]; param = rest$0;}
     }
    }
    function find_opt(h, key){
     var
      hkey = caml_call2(H[2], h[3], key),
      a = key_index(h, hkey),
      param = caml_check_bound(h[2], a)[a + 1];
     for(;;){
      if(! param) return 0;
      var hk = param[1], rest = param[3], c = param[2];
      if(hkey === hk)
       if(0 === caml_call2(H[3], c, key)){
        var d = caml_call1(H[4], c);
        if(d) return d;
        param = rest;
       }
       else
        param = rest;
      else{var rest$0 = param[3]; param = rest$0;}
     }
    }
    function find_all(h, key){
     var hkey = caml_call2(H[2], h[3], key);
     function find_in_bucket(param$0){
      var param = param$0;
      for(;;){
       if(! param) return 0;
       var hk = param[1], rest = param[3], c = param[2];
       if(hkey === hk)
        if(0 === caml_call2(H[3], c, key)){
         var match = caml_call1(H[4], c);
         if(match){var d = match[1]; return [0, d, find_in_bucket(rest)];}
         param = rest;
        }
        else
         param = rest;
       else{var rest$0 = param[3]; param = rest$0;}
      }
     }
     var a = key_index(h, hkey);
     return find_in_bucket(caml_check_bound(h[2], a)[a + 1]);
    }
    function replace(h, key, info){
     var
      hkey = caml_call2(H[2], h[3], key),
      i = key_index(h, hkey),
      l = caml_check_bound(h[2], i)[i + 1];
     try{
      var param = l;
      for(;;){
       if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
       var hk = param[1], next = param[3], c = param[2];
       if(hkey === hk){
        if(! caml_call2(H[3], c, key)){
         var b = caml_call3(H[6], c, key, info);
         return b;
        }
        param = next;
       }
       else{var next$0 = param[3]; param = next$0;}
      }
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn, 0);
      var container = caml_call2(H[1], key, info);
      caml_check_bound(h[2], i)[i + 1] = [0, hkey, container, l];
      h[1] = h[1] + 1 | 0;
      var a = h[2].length - 1 << 1 < h[1] ? 1 : 0;
      return a ? resize(h) : a;
     }
    }
    function mem(h, key){
     var
      hkey = caml_call2(H[2], h[3], key),
      a = key_index(h, hkey),
      param = caml_check_bound(h[2], a)[a + 1];
     for(;;){
      if(! param) return 0;
      var hk = param[1], rest = param[3], c = param[2];
      if(hk === hkey){
       if(! caml_call2(H[3], c, key)) return 1;
       param = rest;
      }
      else{var rest$0 = param[3]; param = rest$0;}
     }
    }
    function iter(f, h){
     var d$0 = h[2], a = d$0.length - 2 | 0, b = 0;
     if(a >= 0){
      var i = b;
      a:
      for(;;){
       var param = caml_check_bound(d$0, i)[i + 1];
       for(;;){
        if(! param){var e = i + 1 | 0; if(a === i) break a; i = e; break;}
        var
         rest = param[3],
         c = param[2],
         match = caml_call1(H[5], c),
         match$0 = caml_call1(H[4], c);
        if(match && match$0){
         var d = match$0[1], k = match[1];
         caml_call2(f, k, d);
         param = rest;
        }
        else
         param = rest;
       }
      }
     }
     return 0;
    }
    function fold(f, h, init){
     var d$0 = h[2], accu$0 = [0, init], a = d$0.length - 2 | 0, e = 0;
     if(a >= 0){
      var i = e;
      a:
      for(;;){
       var
        accu$1 = accu$0[1],
        b$0 = caml_check_bound(d$0, i)[i + 1],
        b = b$0,
        accu = accu$1;
       for(;;){
        if(! b){
         accu$0[1] = accu;
         var g = i + 1 | 0;
         if(a === i) break a;
         i = g;
         break;
        }
        var
         rest = b[3],
         c = b[2],
         match = caml_call1(H[5], c),
         match$0 = caml_call1(H[4], c);
        if(match && match$0){
         var d = match$0[1], k = match[1];
         b = rest;
         accu = caml_call3(f, k, d, accu);
        }
        else
         b = rest;
       }
      }
     }
     return accu$0[1];
    }
    function filter_map_inplace(f, h){
     function do_bucket(param$0){
      var param = param$0;
      for(;;){
       if(! param) return 0;
       var
        rest = param[3],
        c = param[2],
        hk = param[1],
        match = caml_call1(H[5], c),
        match$0 = caml_call1(H[4], c);
       if(match && match$0){
        var d = match$0[1], k = match[1], match$1 = caml_call2(f, k, d);
        if(match$1){
         var new_d = match$1[1];
         caml_call3(H[6], c, k, new_d);
         return [0, hk, c, do_bucket(rest)];
        }
        param = rest;
       }
       else
        param = rest;
      }
     }
     var d = h[2], a = d.length - 2 | 0, b = 0;
     if(a >= 0){
      var i = b;
      for(;;){
       d[i + 1] = do_bucket(caml_check_bound(d, i)[i + 1]);
       var c = i + 1 | 0;
       if(a === i) break;
       i = c;
      }
     }
     return 0;
    }
    function length(h){return h[1];}
    function bucket_length(accu$1, param$0){
     var accu = accu$1, param = param$0;
     for(;;){
      if(! param) return accu;
      var rest = param[3], accu$0 = accu + 1 | 0;
      accu = accu$0;
      param = rest;
     }
    }
    function stats(h){
     var
      mbl =
        Stdlib_Array[17].call
         (null,
          function(m, b){
           var a = bucket_length(0, b);
           return Stdlib_Int[11].call(null, m, a);
          },
          0,
          h[2]),
      histo = caml_make_vect(mbl + 1 | 0, 0);
     Stdlib_Array[13].call
      (null,
       function(b){
        var l = bucket_length(0, b);
        histo[l + 1] = caml_check_bound(histo, l)[l + 1] + 1 | 0;
        return 0;
       },
       h[2]);
     return [0, h[1], h[2].length - 1, mbl, histo];
    }
    function bucket_length_alive(accu$1, param$0){
     var accu = accu$1, param = param$0;
     for(;;){
      if(! param) return accu;
      var rest = param[3], c = param[2];
      if(caml_call1(H[7], c)){
       var accu$0 = accu + 1 | 0;
       accu = accu$0;
       param = rest;
      }
      else{var rest$0 = param[3]; param = rest$0;}
     }
    }
    function stats_alive(h){
     var
      size = [0, 0],
      mbl =
        Stdlib_Array[17].call
         (null,
          function(m, b){
           var a = bucket_length_alive(0, b);
           return Stdlib_Int[11].call(null, m, a);
          },
          0,
          h[2]),
      histo = caml_make_vect(mbl + 1 | 0, 0);
     Stdlib_Array[13].call
      (null,
       function(b){
        var l = bucket_length_alive(0, b);
        size[1] = size[1] + l | 0;
        histo[l + 1] = caml_check_bound(histo, l)[l + 1] + 1 | 0;
        return 0;
       },
       h[2]);
     return [0, size[1], h[2].length - 1, mbl, histo];
    }
    function to_seq(tbl){
     var tbl_data = tbl[2];
     function aux(i$1, buck$1, param){
      var i = i$1, buck = buck$1;
      for(;;)
       if(buck){
        var
         next = buck[3],
         c = buck[2],
         match = caml_call1(H[5], c),
         match$0 = caml_call1(H[4], c);
        if(match){if(match$0) break; buck = next;} else buck = next;
       }
       else{
        if(i === tbl_data.length - 1) return 0;
        var buck$0 = caml_check_bound(tbl_data, i)[i + 1], i$0 = i + 1 | 0;
        i = i$0;
        buck = buck$0;
       }
      var data = match$0[1], key = match[1];
      return [0, [0, key, data], function(a){return aux(i, next, a);}];
     }
     var a = 0, b = 0;
     return function(c){return aux(b, a, c);};
    }
    function to_seq_keys(m){
     var a = to_seq(m);
     function b(a){return a[1];}
     var c = Stdlib_Seq[27];
     return function(d){return c(b, a, d);};
    }
    function to_seq_values(m){
     var a = to_seq(m);
     function b(a){return a[2];}
     var c = Stdlib_Seq[27];
     return function(d){return c(b, a, d);};
    }
    function add_seq(tbl, i){
     return Stdlib_Seq[4].call
             (null,
              function(param){
               var v = param[2], k = param[1];
               return add(tbl, k, v);
              },
              i);
    }
    function replace_seq(tbl, i){
     return Stdlib_Seq[4].call
             (null,
              function(param){
               var v = param[2], k = param[1];
               return replace(tbl, k, v);
              },
              i);
    }
    function of_seq(i){
     var tbl = create(0, 16);
     replace_seq(tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq,
            clean,
            stats_alive];
   }
   function create(param){return caml_call1(Stdlib_Obj[26][1], 1);}
   function get_key(t){var x = caml_call2(Stdlib_Obj[26][3], t, 0); return x;}
   function get_key_copy(t){
    var x = caml_call2(Stdlib_Obj[26][4], t, 0);
    return x;
   }
   function set_key(t, k){return caml_call3(Stdlib_Obj[26][5], t, 0, k);}
   function unset_key(t){return caml_call2(Stdlib_Obj[26][6], t, 0);}
   function check_key(t){return caml_call2(Stdlib_Obj[26][7], t, 0);}
   function blit_key(t1, t2){
    return caml_call5(Stdlib_Obj[26][8], t1, 0, t2, 0, 1);
   }
   function get_data(t){var x = caml_call1(Stdlib_Obj[26][9], t); return x;}
   function get_data_copy(t){
    var x = caml_call1(Stdlib_Obj[26][10], t);
    return x;
   }
   function set_data(t, d){return caml_call2(Stdlib_Obj[26][11], t, d);}
   function unset_data(t){return caml_call1(Stdlib_Obj[26][12], t);}
   function check_data(t){return caml_call1(Stdlib_Obj[26][13], t);}
   function blit_data(t1, t2){return caml_call2(Stdlib_Obj[26][14], t1, t2);}
   function make(key, data){
    var eph = create(0);
    set_data(eph, data);
    set_key(eph, key);
    return eph;
   }
   function query(eph, key){
    var match = get_key(eph);
    if(! match) return 0;
    var k = match[1];
    return k === key ? get_data(eph) : 0;
   }
   function MakeSeeded$0(H){
    function create$0(k, d){
     var c = create(0);
     set_data(c, d);
     set_key(c, k);
     return c;
    }
    var hash = H[2];
    function equal(c, k){
     var match = get_key(c);
     if(! match) return 2;
     var k$0 = match[1];
     return caml_call2(H[1], k, k$0) ? 0 : 1;
    }
    function set_key_data(c, k, d){
     unset_data(c);
     set_key(c, k);
     return set_data(c, d);
    }
    return MakeSeeded
            ([0,
              create$0,
              hash,
              equal,
              get_data,
              get_key,
              set_key_data,
              check_key]);
   }
   function Make(H){
    var equal = H[1];
    function hash(seed, x){return caml_call1(H[2], x);}
    var
     include = MakeSeeded$0([0, equal, hash]),
     b = include[1],
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     iter = include[12],
     filter_map_inplace = include[13],
     fold = include[14],
     length = include[15],
     stats = include[16],
     to_seq = include[17],
     to_seq_keys = include[18],
     to_seq_values = include[19],
     add_seq = include[20],
     replace_seq = include[21],
     clean = include[23],
     stats_alive = include[24];
    function create(sz){return caml_call2(b, a, sz);}
    function of_seq(i){
     var tbl = caml_call2(b, a, 16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq,
            clean,
            stats_alive];
   }
   function make$0(param){return [0, 0];}
   function add(b, k, d){var a = b[1]; b[1] = [0, make(k, d), a]; return 0;}
   function test_key(k, e){
    var match = get_key(e);
    if(match){var x = match[1]; if(x === k) return 1;}
    return 0;
   }
   function remove(b, k){
    var l$0 = b[1], l = l$0, acc = 0;
    for(;;){
     if(! l) return 0;
     var h = l[1], t = l[2];
     if(test_key(k, h)){b[1] = Stdlib_List[12].call(null, acc, t); return 0;}
     var t$0 = l[2], acc$0 = [0, h, acc];
     l = t$0;
     acc = acc$0;
    }
   }
   function find(b, k){
    var
     match =
       Stdlib_List[39].call(null, function(a){return test_key(k, a);}, b[1]);
    if(! match) return 0;
    var e = match[1];
    return get_data(e);
   }
   function length(b){return Stdlib_List[1].call(null, b[1]);}
   function clear(b){b[1] = 0; return 0;}
   function create$0(param){return caml_call1(Stdlib_Obj[26][1], 2);}
   function get_key1(t){
    var x = caml_call2(Stdlib_Obj[26][3], t, 0);
    return x;
   }
   function get_key1_copy(t){
    var x = caml_call2(Stdlib_Obj[26][4], t, 0);
    return x;
   }
   function set_key1(t, k){return caml_call3(Stdlib_Obj[26][5], t, 0, k);}
   function unset_key1(t){return caml_call2(Stdlib_Obj[26][6], t, 0);}
   function check_key1(t){return caml_call2(Stdlib_Obj[26][7], t, 0);}
   function get_key2(t){
    var x = caml_call2(Stdlib_Obj[26][3], t, 1);
    return x;
   }
   function get_key2_copy(t){
    var x = caml_call2(Stdlib_Obj[26][4], t, 1);
    return x;
   }
   function set_key2(t, k){return caml_call3(Stdlib_Obj[26][5], t, 1, k);}
   function unset_key2(t){return caml_call2(Stdlib_Obj[26][6], t, 1);}
   function check_key2(t){return caml_call2(Stdlib_Obj[26][7], t, 1);}
   function blit_key1(t1, t2){
    return caml_call5(Stdlib_Obj[26][8], t1, 0, t2, 0, 1);
   }
   function blit_key2(t1, t2){
    return caml_call5(Stdlib_Obj[26][8], t1, 1, t2, 1, 1);
   }
   function blit_key12(t1, t2){
    return caml_call5(Stdlib_Obj[26][8], t1, 0, t2, 0, 2);
   }
   function get_data$0(t){var x = caml_call1(Stdlib_Obj[26][9], t); return x;}
   function get_data_copy$0(t){
    var x = caml_call1(Stdlib_Obj[26][10], t);
    return x;
   }
   function set_data$0(t, d){return caml_call2(Stdlib_Obj[26][11], t, d);}
   function unset_data$0(t){return caml_call1(Stdlib_Obj[26][12], t);}
   function check_data$0(t){return caml_call1(Stdlib_Obj[26][13], t);}
   function blit_data$0(t1, t2){
    return caml_call2(Stdlib_Obj[26][14], t1, t2);
   }
   function make$1(key1, key2, data){
    var eph = create$0(0);
    set_data$0(eph, data);
    set_key1(eph, key1);
    set_key2(eph, key2);
    return eph;
   }
   function query$0(eph, key1, key2){
    var match = get_key1(eph);
    if(! match) return 0;
    var k = match[1];
    if(k !== key1) return 0;
    var match$0 = get_key2(eph);
    if(! match$0) return 0;
    var k$0 = match$0[1];
    return k$0 === key2 ? get_data$0(eph) : 0;
   }
   function MakeSeeded$1(H1, H2){
    function create(param, d){
     var k2 = param[2], k1 = param[1], c = create$0(0);
     set_data$0(c, d);
     set_key1(c, k1);
     set_key2(c, k2);
     return c;
    }
    function hash(seed, param){
     var
      k2 = param[2],
      k1 = param[1],
      a = caml_call2(H2[2], seed, k2) * 65599 | 0;
     return caml_call2(H1[2], seed, k1) + a | 0;
    }
    function equal(c, param){
     var
      k2 = param[2],
      k1 = param[1],
      match = get_key1(c),
      match$0 = get_key2(c);
     if(match && match$0){
      var k2$0 = match$0[1], k1$0 = match[1];
      if(caml_call2(H1[1], k1, k1$0) && caml_call2(H2[1], k2, k2$0)) return 0;
      return 1;
     }
     return 2;
    }
    function get_key(c){
     var match = get_key1(c), match$0 = get_key2(c);
     if(match && match$0){
      var k2 = match$0[1], k1 = match[1];
      return [0, [0, k1, k2]];
     }
     return 0;
    }
    function set_key_data(c, param, d){
     var k2 = param[2], k1 = param[1];
     unset_data$0(c);
     set_key1(c, k1);
     set_key2(c, k2);
     return set_data$0(c, d);
    }
    function check_key(c){
     var a = check_key1(c);
     return a ? check_key2(c) : a;
    }
    return MakeSeeded
            ([0,
              create,
              hash,
              equal,
              get_data$0,
              get_key,
              set_key_data,
              check_key]);
   }
   function Make$0(H1, H2){
    var equal = H2[1];
    function hash(seed, x){return caml_call1(H2[2], x);}
    var equal$0 = H1[1];
    function hash$0(seed, x){return caml_call1(H1[2], x);}
    var
     include = MakeSeeded$1([0, equal$0, hash$0], [0, equal, hash]),
     a = include[1],
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     iter = include[12],
     filter_map_inplace = include[13],
     fold = include[14],
     length = include[15],
     stats = include[16],
     to_seq = include[17],
     to_seq_keys = include[18],
     to_seq_values = include[19],
     add_seq = include[20],
     replace_seq = include[21],
     clean = include[23],
     stats_alive = include[24];
    function create(sz){return caml_call2(a, b, sz);}
    function of_seq(i){
     var tbl = caml_call2(a, b, 16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq,
            clean,
            stats_alive];
   }
   function make$2(param){return [0, 0];}
   function add$0(b, k1, k2, d){
    var a = b[1];
    b[1] = [0, make$1(k1, k2, d), a];
    return 0;
   }
   function test_keys(k1, k2, e){
    var match = get_key1(e), match$0 = get_key2(e);
    if(match && match$0){
     var x2 = match$0[1], x1 = match[1];
     if(x1 === k1 && x2 === k2) return 1;
    }
    return 0;
   }
   function remove$0(b, k1, k2){
    var l$0 = b[1], l = l$0, acc = 0;
    for(;;){
     if(! l) return 0;
     var h = l[1], t = l[2];
     if(test_keys(k1, k2, h)){
      b[1] = Stdlib_List[12].call(null, acc, t);
      return 0;
     }
     var t$0 = l[2], acc$0 = [0, h, acc];
     l = t$0;
     acc = acc$0;
    }
   }
   function find$0(b, k1, k2){
    var
     match =
       Stdlib_List[39].call
        (null, function(a){return test_keys(k1, k2, a);}, b[1]);
    if(! match) return 0;
    var e = match[1];
    return get_data$0(e);
   }
   function length$0(b){return Stdlib_List[1].call(null, b[1]);}
   function clear$0(b){b[1] = 0; return 0;}
   function create$1(n){return caml_call1(Stdlib_Obj[26][1], n);}
   function length$1(k){return caml_call1(Stdlib_Obj[26][2], k);}
   function get_key$0(t, n){
    var x = caml_call2(Stdlib_Obj[26][3], t, n);
    return x;
   }
   function get_key_copy$0(t, n){
    var x = caml_call2(Stdlib_Obj[26][4], t, n);
    return x;
   }
   function set_key$0(t, n, k){return caml_call3(Stdlib_Obj[26][5], t, n, k);}
   function unset_key$0(t, n){return caml_call2(Stdlib_Obj[26][6], t, n);}
   function check_key$0(t, n){return caml_call2(Stdlib_Obj[26][7], t, n);}
   function blit_key$0(t1, o1, t2, o2, l){
    return caml_call5(Stdlib_Obj[26][8], t1, o1, t2, o2, l);
   }
   function get_data$1(t){var x = caml_call1(Stdlib_Obj[26][9], t); return x;}
   function get_data_copy$1(t){
    var x = caml_call1(Stdlib_Obj[26][10], t);
    return x;
   }
   function set_data$1(t, d){return caml_call2(Stdlib_Obj[26][11], t, d);}
   function unset_data$1(t){return caml_call1(Stdlib_Obj[26][12], t);}
   function check_data$1(t){return caml_call1(Stdlib_Obj[26][13], t);}
   function blit_data$1(t1, t2){
    return caml_call2(Stdlib_Obj[26][14], t1, t2);
   }
   function make$3(keys, data){
    var l = keys.length - 1, eph = create$1(l);
    set_data$1(eph, data);
    var a = l - 1 | 0, b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      set_key$0(eph, i, caml_check_bound(keys, i)[i + 1]);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return eph;
   }
   function query$1(eph, keys){
    var l = length$1(eph);
    try{
     if(l !== keys.length - 1)
      throw caml_maybe_attach_backtrace(Stdlib[3], 1);
     var a = l - 1 | 0, b = 0;
     if(a >= 0){
      var i = b;
      for(;;){
       var match = get_key$0(eph, i);
       if(! match) throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       var k = match[1];
       if(k !== caml_check_bound(keys, i)[i + 1])
        throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       var d = i + 1 | 0;
       if(a === i) break;
       i = d;
      }
     }
     var c = get_data$1(eph);
     return c;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function MakeSeeded$2(H){
    function create(k, d){
     var c = create$1(k.length - 1);
     set_data$1(c, d);
     var a = k.length - 2 | 0, b = 0;
     if(a >= 0){
      var i = b;
      for(;;){
       set_key$0(c, i, caml_check_bound(k, i)[i + 1]);
       var e = i + 1 | 0;
       if(a === i) break;
       i = e;
      }
     }
     return c;
    }
    function hash(seed, k){
     var h = [0, 0], a = k.length - 2 | 0, b = 0;
     if(a >= 0){
      var i = b;
      for(;;){
       var c = h[1], d = caml_check_bound(k, i)[i + 1];
       h[1] = (caml_call2(H[2], seed, d) * 65599 | 0) + c | 0;
       var e = i + 1 | 0;
       if(a === i) break;
       i = e;
      }
     }
     return h[1];
    }
    function equal(c, k){
     var len = k.length - 1, len$0 = length$1(c);
     if(len !== len$0) return 1;
     var i$1 = len - 1 | 0, i = i$1;
     for(;;){
      if(0 > i) return 0;
      var match = get_key$0(c, i);
      if(! match) return 2;
      var ki = match[1], a = caml_check_bound(k, i)[i + 1];
      if(! caml_call2(H[1], a, ki)) return 1;
      var i$0 = i - 1 | 0;
      i = i$0;
     }
    }
    function get_key(c){
     var len = length$1(c);
     if(0 === len) return [0, [0]];
     var match = get_key$0(c, 0);
     if(! match) return 0;
     var
      k0 = match[1],
      a = caml_make_vect(len, k0),
      i$1 = len - 1 | 0,
      i = i$1;
     for(;;){
      if(1 > i) return [0, a];
      var match$0 = get_key$0(c, i);
      if(! match$0) return 0;
      var ki = match$0[1];
      caml_check_bound(a, i)[i + 1] = ki;
      var i$0 = i - 1 | 0;
      i = i$0;
     }
    }
    function set_key_data(c, k, d){
     unset_data$1(c);
     var a = k.length - 2 | 0, b = 0;
     if(a >= 0){
      var i = b;
      for(;;){
       set_key$0(c, i, caml_check_bound(k, i)[i + 1]);
       var e = i + 1 | 0;
       if(a === i) break;
       i = e;
      }
     }
     return set_data$1(c, d);
    }
    function check_key(c){
     var i$1 = length$1(c) - 1 | 0, i = i$1;
     for(;;){
      var a = i < 0 ? 1 : 0;
      if(a)
       var b = a;
      else{
       var d = check_key$0(c, i);
       if(d){var i$0 = i - 1 | 0; i = i$0; continue;}
       var b = d;
      }
      return b;
     }
    }
    return MakeSeeded
            ([0,
              create,
              hash,
              equal,
              get_data$1,
              get_key,
              set_key_data,
              check_key]);
   }
   function Make$1(H){
    var equal = H[1];
    function hash(seed, x){return caml_call1(H[2], x);}
    var
     include = MakeSeeded$2([0, equal, hash]),
     a = include[1],
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     iter = include[12],
     filter_map_inplace = include[13],
     fold = include[14],
     length = include[15],
     stats = include[16],
     to_seq = include[17],
     to_seq_keys = include[18],
     to_seq_values = include[19],
     add_seq = include[20],
     replace_seq = include[21],
     clean = include[23],
     stats_alive = include[24];
    function create(sz){return caml_call2(a, c, sz);}
    function of_seq(i){
     var tbl = caml_call2(a, c, 16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq,
            clean,
            stats_alive];
   }
   function make$4(param){return [0, 0];}
   function add$1(b, k, d){
    var a = b[1];
    b[1] = [0, make$3(k, d), a];
    return 0;
   }
   function test_keys$0(k, e){
    try{
     if(length$1(e) !== k.length - 1)
      throw caml_maybe_attach_backtrace(Stdlib[3], 1);
     var a = k.length - 2 | 0, b = 0;
     if(a >= 0){
      var i = b;
      for(;;){
       var match = get_key$0(e, i);
       if(match){
        var x = match[1];
        if(x === caml_check_bound(k, i)[i + 1]){
         var d = i + 1 | 0;
         if(a === i) break;
         i = d;
         continue;
        }
       }
       throw caml_maybe_attach_backtrace(Stdlib[3], 1);
      }
     }
     var c = 1;
     return c;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function remove$1(b, k){
    var l$0 = b[1], l = l$0, acc = 0;
    for(;;){
     if(! l) return 0;
     var h = l[1], t = l[2];
     if(test_keys$0(k, h)){
      b[1] = Stdlib_List[12].call(null, acc, t);
      return 0;
     }
     var t$0 = l[2], acc$0 = [0, h, acc];
     l = t$0;
     acc = acc$0;
    }
   }
   function find$1(b, k){
    var
     match =
       Stdlib_List[39].call
        (null, function(a){return test_keys$0(k, a);}, b[1]);
    if(! match) return 0;
    var e = match[1];
    return get_data$1(e);
   }
   function length$2(b){return Stdlib_List[1].call(null, b[1]);}
   function clear$1(b){b[1] = 0; return 0;}
   var
    Stdlib_Ephemeron =
      [0,
       [0,
        create,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        get_data,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        make,
        query,
        Make,
        MakeSeeded$0,
        [0, make$0, add, remove, find, length, clear]],
       [0,
        create$0,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$0,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        make$1,
        query$0,
        Make$0,
        MakeSeeded$1,
        [0, make$2, add$0, remove$0, find$0, length$0, clear$0]],
       [0,
        create$1,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$1,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        make$3,
        query$1,
        Make$1,
        MakeSeeded$2,
        [0, make$4, add$1, remove$1, find$1, length$2, clear$1]],
       [0,
        function(a){
         return MakeSeeded([0, a[3], a[1], a[2], a[5], a[4], a[6], a[7]]);
        }]];
   runtime.caml_register_global(13, Stdlib_Ephemeron, "Stdlib__Ephemeron");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Filename
//# unitInfo: Requires: CamlinternalLazy, Stdlib, Stdlib__Buffer, Stdlib__List, Stdlib__Printf, Stdlib__Random, Stdlib__String, Stdlib__Sys
//# shape: Stdlib__Filename:[N,N,N,F(2),F(1),F(1),F(2),F(2),F(2),F(1),F(1),F(1),F(1),F(1),N,F(3),F(5),F(1)*,F(1),N,F(1),F(5)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$19 = "",
    cst$23 = " ",
    cst_2$1 = " 2>",
    cst_2_1$1 = " 2>&1",
    cst$22 = " <",
    cst$21 = " >",
    cst$20 = '"',
    cst$24 = ".",
    cst$25 = "..",
    cst$28 = "../",
    cst$27 = "./",
    cst$26 = "/",
    cst_dev_null = "/dev/null",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$18 = cst$19,
    cst$17 = cst$19,
    cst$16 = cst$19,
    cst$8 = cst$21,
    cst$15 = cst$19,
    cst$9 = cst$22,
    cst$14 = cst$19,
    cst$10 = cst$23,
    cst$11 = cst$23,
    cst$12 = cst$20,
    cst$13 = cst$19,
    cst$6 = cst$20,
    cst$7 = cst$20,
    cst$4 = cst$19,
    cst = cst$21,
    cst$3 = cst$19,
    cst$0 = cst$22,
    cst$2 = cst$19,
    cst$1 = cst$23,
    null$ = cst_dev_null,
    current_dir_name = cst$24,
    parent_dir_name = cst$25,
    dir_sep = cst$26,
    quotequote = "'\\''",
    null$0 = "NUL",
    current_dir_name$0 = cst$24,
    parent_dir_name$0 = cst$25,
    dir_sep$0 = "\\",
    cst$5 = cst$24,
    null$1 = cst_dev_null,
    current_dir_name$1 = cst$24,
    parent_dir_name$1 = cst$25,
    dir_sep$1 = cst$26,
    Stdlib = global_data.Stdlib,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Sys = global_data.Stdlib__Sys;
   function generic_basename(is_dir_sep, current_dir_name, name){
    if(name === cst$19) return current_dir_name;
    var n$3 = caml_ml_string_length(name) - 1 | 0, n = n$3;
    for(;;){
     if(0 > n) return Stdlib_String[15].call(null, name, 0, 1);
     if(! caml_call2(is_dir_sep, name, n)) break;
     var n$0 = n - 1 | 0;
     n = n$0;
    }
    var p = n + 1 | 0, n$1 = n;
    for(;;){
     if(0 > n$1) return Stdlib_String[15].call(null, name, 0, p);
     if(caml_call2(is_dir_sep, name, n$1))
      return Stdlib_String[15].call
              (null, name, n$1 + 1 | 0, (p - n$1 | 0) - 1 | 0);
     var n$2 = n$1 - 1 | 0;
     n$1 = n$2;
    }
   }
   function generic_dirname(is_dir_sep, current_dir_name, name){
    if(name === cst$19) return current_dir_name;
    var n$5 = caml_ml_string_length(name) - 1 | 0, n = n$5;
    for(;;){
     if(0 > n) return Stdlib_String[15].call(null, name, 0, 1);
     if(! caml_call2(is_dir_sep, name, n)){var n$1 = n; break;}
     var n$0 = n - 1 | 0;
     n = n$0;
    }
    for(;;){
     if(0 > n$1) return current_dir_name;
     if(caml_call2(is_dir_sep, name, n$1)){var n$3 = n$1; break;}
     var n$2 = n$1 - 1 | 0;
     n$1 = n$2;
    }
    for(;;){
     if(0 > n$3) return Stdlib_String[15].call(null, name, 0, 1);
     if(! caml_call2(is_dir_sep, name, n$3))
      return Stdlib_String[15].call(null, name, 0, n$3 + 1 | 0);
     var n$4 = n$3 - 1 | 0;
     n$3 = n$4;
    }
   }
   function is_dir_sep(s, i){return 47 === caml_string_get(s, i) ? 1 : 0;}
   function is_relative(n){
    var
     a = caml_ml_string_length(n) < 1 ? 1 : 0,
     b = a || (47 !== caml_string_get(n, 0) ? 1 : 0);
    return b;
   }
   function is_implicit(n){
    var b = is_relative(n);
    if(b){
     var
      d = caml_ml_string_length(n) < 2 ? 1 : 0,
      c = d || (Stdlib_String[15].call(null, n, 0, 2) !== cst$27 ? 1 : 0);
     if(c)
      var
       e = caml_ml_string_length(n) < 3 ? 1 : 0,
       a = e || (Stdlib_String[15].call(null, n, 0, 3) !== cst$28 ? 1 : 0);
     else
      var a = c;
    }
    else
     var a = b;
    return a;
   }
   function check_suffix(name, suff){
    return Stdlib_String[11].call(null, suff, name);
   }
   function chop_suffix_opt(suffix, filename){
    var
     len_s = caml_ml_string_length(suffix),
     len_f = caml_ml_string_length(filename);
    if(len_s > len_f) return 0;
    var r = Stdlib_String[15].call(null, filename, len_f - len_s | 0, len_s);
    return r === suffix
            ? [0,
              Stdlib_String[15].call(null, filename, 0, len_f - len_s | 0)]
            : 0;
   }
   var
    dummy = 0,
    d = [0, 7, 0],
    c = [0, 1, [0, 3, [0, 5, 0]]],
    b = [0, [2, 0, [4, 6, [0, 2, 6], 0, [2, 0, 0]]], "%s%06x%s"],
    cst_Filename_chop_extension = "Filename.chop_extension",
    cst_Filename_chop_suffix = "Filename.chop_suffix",
    a = [0, cst$20, 0],
    cst_2_1$0 = cst_2_1$1,
    cst_2$0 = cst_2$1,
    cst_Filename_quote_command_bad = "Filename.quote_command: bad file name ",
    cst_2_1 = cst_2_1$1,
    cst_2 = cst_2$1,
    cst_tmp = "/tmp";
   try{var f = caml_sys_getenv("TMPDIR"), temp_dir_name = f;}
   catch(exn$0){
    var exn = caml_wrap_exception(exn$0);
    if(exn !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn, 0);
    var temp_dir_name = cst_tmp;
   }
   function quote(s){
    var
     l = caml_ml_string_length(s),
     b = Stdlib_Buffer[1].call(null, l + 20 | 0);
    Stdlib_Buffer[12].call(null, b, 39);
    var a = l - 1 | 0, c = 0;
    if(a >= 0){
     var i = c;
     for(;;){
      if(39 === caml_string_get(s, i))
       Stdlib_Buffer[16].call(null, b, quotequote);
      else{var e = caml_string_get(s, i); Stdlib_Buffer[12].call(null, b, e);}
      var d = i + 1 | 0;
      if(a === i) break;
      i = d;
     }
    }
    Stdlib_Buffer[12].call(null, b, 39);
    return Stdlib_Buffer[2].call(null, b);
   }
   function quote_command(cmd, stdin, stdout, stderr, args){
    if(stderr){
     var f = stderr[1];
     if(caml_equal(stderr, stdout))
      var a = cst_2_1;
     else
      var k = quote(f), a = Stdlib[28].call(null, cst_2, k);
    }
    else
     var a = cst$4;
    if(stdout)
     var f$0 = stdout[1], d = quote(f$0), b = Stdlib[28].call(null, cst, d);
    else
     var b = cst$3;
    var e = Stdlib[28].call(null, b, a);
    if(stdin)
     var f$1 = stdin[1], g = quote(f$1), c = Stdlib[28].call(null, cst$0, g);
    else
     var c = cst$2;
    var
     h = Stdlib[28].call(null, c, e),
     i = Stdlib_List[19].call(null, quote, [0, cmd, args]),
     j = Stdlib_String[6].call(null, cst$1, i);
    return Stdlib[28].call(null, j, h);
   }
   function basename(a){
    return generic_basename(is_dir_sep, current_dir_name, a);
   }
   function dirname(a){
    return generic_dirname(is_dir_sep, current_dir_name, a);
   }
   var
    Unix =
      [0,
       null$,
       current_dir_name,
       parent_dir_name,
       dir_sep,
       is_dir_sep,
       is_relative,
       is_implicit,
       check_suffix,
       chop_suffix_opt,
       temp_dir_name,
       quote,
       quote_command,
       basename,
       dirname];
   function is_dir_sep$0(s, i){
    var c = caml_string_get(s, i), a = 47 === c ? 1 : 0;
    if(a)
     var b = a;
    else
     var d = 92 === c ? 1 : 0, b = d || (58 === c ? 1 : 0);
    return b;
   }
   function is_relative$0(n){
    var
     d = caml_ml_string_length(n) < 1 ? 1 : 0,
     b = d || (47 !== caml_string_get(n, 0) ? 1 : 0);
    if(b){
     var
      e = caml_ml_string_length(n) < 1 ? 1 : 0,
      c = e || (92 !== caml_string_get(n, 0) ? 1 : 0);
     if(c)
      var
       f = caml_ml_string_length(n) < 2 ? 1 : 0,
       a = f || (58 !== caml_string_get(n, 1) ? 1 : 0);
     else
      var a = c;
    }
    else
     var a = b;
    return a;
   }
   function is_implicit$0(n){
    var b = is_relative$0(n);
    if(b){
     var
      f = caml_ml_string_length(n) < 2 ? 1 : 0,
      c = f || (Stdlib_String[15].call(null, n, 0, 2) !== cst$27 ? 1 : 0);
     if(c){
      var
       g = caml_ml_string_length(n) < 2 ? 1 : 0,
       d = g || (Stdlib_String[15].call(null, n, 0, 2) !== ".\\" ? 1 : 0);
      if(d){
       var
        h = caml_ml_string_length(n) < 3 ? 1 : 0,
        e = h || (Stdlib_String[15].call(null, n, 0, 3) !== cst$28 ? 1 : 0);
       if(e)
        var
         i = caml_ml_string_length(n) < 3 ? 1 : 0,
         a = i || (Stdlib_String[15].call(null, n, 0, 3) !== "..\\" ? 1 : 0);
       else
        var a = e;
      }
      else
       var a = d;
     }
     else
      var a = c;
    }
    else
     var a = b;
    return a;
   }
   function check_suffix$0(name, suff){
    var
     a = caml_ml_string_length(suff) <= caml_ml_string_length(name) ? 1 : 0;
    if(a)
     var
      s =
        Stdlib_String[15].call
         (null,
          name,
          caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
          caml_ml_string_length(suff)),
      c = Stdlib_String[26].call(null, suff),
      b = Stdlib_String[26].call(null, s) === c ? 1 : 0;
    else
     var b = a;
    return b;
   }
   function chop_suffix_opt$0(suffix, filename){
    var
     len_s = caml_ml_string_length(suffix),
     len_f = caml_ml_string_length(filename);
    if(len_s > len_f) return 0;
    var
     r = Stdlib_String[15].call(null, filename, len_f - len_s | 0, len_s),
     a = Stdlib_String[26].call(null, suffix);
    return Stdlib_String[26].call(null, r) === a
            ? [0,
              Stdlib_String[15].call(null, filename, 0, len_f - len_s | 0)]
            : 0;
   }
   try{var e = caml_sys_getenv("TEMP"), temp_dir_name$0 = e;}
   catch(exn){
    var exn$0 = caml_wrap_exception(exn);
    if(exn$0 !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn$0, 0);
    var temp_dir_name$0 = cst$5;
   }
   function quote$0(s){
    var
     l = caml_ml_string_length(s),
     b = Stdlib_Buffer[1].call(null, l + 20 | 0);
    Stdlib_Buffer[12].call(null, b, 34);
    function loop$0(counter, i$1){
     var i = i$1;
     for(;;){
      if(i === l) return Stdlib_Buffer[12].call(null, b, 34);
      var c = caml_string_get(s, i);
      if(34 === c){
       var a = 0;
       if(counter >= 50) return caml_trampoline_return(loop_bs, [0, a, i]);
       var counter$1 = counter + 1 | 0;
       return loop_bs(counter$1, a, i);
      }
      if(92 === c){
       var d = 0;
       if(counter >= 50) return caml_trampoline_return(loop_bs, [0, d, i]);
       var counter$0 = counter + 1 | 0;
       return loop_bs(counter$0, d, i);
      }
      Stdlib_Buffer[12].call(null, b, c);
      var i$0 = i + 1 | 0;
      i = i$0;
     }
    }
    function loop(i){return caml_trampoline(loop$0(0, i));}
    function loop_bs(counter, n$1, i$1){
     var n = n$1, i = i$1;
     for(;;){
      if(i === l){Stdlib_Buffer[12].call(null, b, 34); return add_bs(n);}
      var match = caml_string_get(s, i);
      if(34 === match){
       add_bs((2 * n | 0) + 1 | 0);
       Stdlib_Buffer[12].call(null, b, 34);
       var a = i + 1 | 0;
       if(counter >= 50) return caml_trampoline_return(loop$0, [0, a]);
       var counter$1 = counter + 1 | 0;
       return loop$0(counter$1, a);
      }
      if(92 !== match){
       add_bs(n);
       if(counter >= 50) return caml_trampoline_return(loop$0, [0, i]);
       var counter$0 = counter + 1 | 0;
       return loop$0(counter$0, i);
      }
      var i$0 = i + 1 | 0, n$0 = n + 1 | 0;
      n = n$0;
      i = i$0;
     }
    }
    function add_bs(n){
     var a = 1;
     if(n >= 1){
      var j = a;
      for(;;){
       Stdlib_Buffer[12].call(null, b, 92);
       var c = j + 1 | 0;
       if(n === j) break;
       j = c;
      }
     }
    }
    loop(0);
    return Stdlib_Buffer[2].call(null, b);
   }
   function quote_cmd_filename(f){
    if
     (!
      Stdlib_String[14].call(null, f, 34)
      && ! Stdlib_String[14].call(null, f, 37)){
     if(! Stdlib_String[14].call(null, f, 32)) return f;
     var b = Stdlib[28].call(null, f, cst$6);
     return Stdlib[28].call(null, cst$7, b);
    }
    var a = Stdlib[28].call(null, cst_Filename_quote_command_bad, f);
    return Stdlib[2].call(null, a);
   }
   function quote_command$0(cmd, stdin, stdout, stderr, args){
    if(stderr){
     var f = stderr[1];
     if(caml_equal(stderr, stdout))
      var c = cst_2_1$0;
     else
      var n = quote_cmd_filename(f), c = Stdlib[28].call(null, cst_2$0, n);
    }
    else
     var c = cst$16;
    var g = [0, c, a];
    if(stdout)
     var
      f$0 = stdout[1],
      h = quote_cmd_filename(f$0),
      d = Stdlib[28].call(null, cst$8, h);
    else
     var d = cst$15;
    var i = [0, d, g];
    if(stdin)
     var
      f$1 = stdin[1],
      j = quote_cmd_filename(f$1),
      e = Stdlib[28].call(null, cst$9, j);
    else
     var e = cst$14;
    var
     k = Stdlib_List[19].call(null, quote$0, args),
     s = Stdlib_String[6].call(null, cst$10, k),
     b = Stdlib_Buffer[1].call(null, caml_ml_string_length(s) + 20 | 0);
    Stdlib_String[29].call
     (null,
      function(c){
       a:
       {
        if(62 <= c){
         var a = c - 63 | 0;
         if(60 < a >>> 0){if(62 <= a) break a;} else if(31 !== a) break a;
        }
        else
         if(42 <= c){
          if(60 !== c) break a;
         }
         else{
          if(33 > c) break a;
          switch(c - 33 | 0){case 2:case 3:case 6: break a;
          }
         }
        Stdlib_Buffer[12].call(null, b, 94);
        return Stdlib_Buffer[12].call(null, b, c);
       }
       return Stdlib_Buffer[12].call(null, b, c);
      },
      s);
    var
     l = [0, cst$11, [0, Stdlib_Buffer[2].call(null, b), [0, e, i]]],
     m = [0, cst$12, [0, quote_cmd_filename(cmd), l]];
    return Stdlib_String[6].call(null, cst$13, m);
   }
   function drive_and_path(s){
    var b = 2 <= caml_ml_string_length(s) ? 1 : 0;
    if(b){
     var param = caml_string_get(s, 0);
     a:
     {
      b:
      {
       if(91 <= param){
        if(25 < param - 97 >>> 0) break b;
       }
       else if(65 > param) break b;
       var a = 1;
       break a;
      }
      var a = 0;
     }
     var c = a ? 58 === caml_string_get(s, 1) ? 1 : 0 : a;
    }
    else
     var c = b;
    if(! c) return [0, cst$17, s];
    var
     d = Stdlib_String[15].call(null, s, 2, caml_ml_string_length(s) - 2 | 0);
    return [0, Stdlib_String[15].call(null, s, 0, 2), d];
   }
   function dirname$0(s){
    var
     match = drive_and_path(s),
     path = match[2],
     drive = match[1],
     dir = generic_dirname(is_dir_sep$0, current_dir_name$0, path);
    return Stdlib[28].call(null, drive, dir);
   }
   function basename$0(s){
    var path = drive_and_path(s)[2];
    return generic_basename(is_dir_sep$0, current_dir_name$0, path);
   }
   var
    Win32 =
      [0,
       null$0,
       current_dir_name$0,
       parent_dir_name$0,
       dir_sep$0,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name$0,
       quote$0,
       quote_command$0,
       basename$0,
       dirname$0];
   function basename$1(a){
    return generic_basename(is_dir_sep$0, current_dir_name$1, a);
   }
   function dirname$1(a){
    return generic_dirname(is_dir_sep$0, current_dir_name$1, a);
   }
   var
    Cygwin =
      [0,
       null$1,
       current_dir_name$1,
       parent_dir_name$1,
       dir_sep$1,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name,
       quote,
       quote_command,
       basename$1,
       dirname$1],
    match = Stdlib_Sys[4],
    Sysdeps = match !== "Cygwin" ? match !== "Win32" ? Unix : Win32 : Cygwin,
    null$2 = Sysdeps[1],
    current_dir_name$2 = Sysdeps[2],
    parent_dir_name$2 = Sysdeps[3],
    dir_sep$2 = Sysdeps[4],
    is_dir_sep$1 = Sysdeps[5],
    is_relative$1 = Sysdeps[6],
    is_implicit$1 = Sysdeps[7],
    check_suffix$1 = Sysdeps[8],
    chop_suffix_opt$1 = Sysdeps[9],
    temp_dir_name$1 = Sysdeps[10],
    quote$1 = Sysdeps[11],
    quote_command$1 = Sysdeps[12],
    basename$2 = Sysdeps[13],
    dirname$2 = Sysdeps[14];
   function concat(dirname, filename){
    var l = caml_ml_string_length(dirname);
    if(0 !== l && ! is_dir_sep$1(dirname, l - 1 | 0)){
     var a = Stdlib[28].call(null, dir_sep$2, filename);
     return Stdlib[28].call(null, dirname, a);
    }
    return Stdlib[28].call(null, dirname, filename);
   }
   function chop_suffix(name, suff){
    return check_suffix$1(name, suff)
            ? Stdlib_String
               [15].call
              (null,
               name,
               0,
               caml_ml_string_length(name) - caml_ml_string_length(suff) | 0)
            : Stdlib[1].call(null, cst_Filename_chop_suffix);
   }
   function extension_len(name){
    var i$3 = caml_ml_string_length(name) - 1 | 0, i0 = i$3;
    for(;;){
     if(0 <= i0 && ! is_dir_sep$1(name, i0)){
      if(46 === caml_string_get(name, i0)) break;
      var i$2 = i0 - 1 | 0;
      i0 = i$2;
      continue;
     }
     return 0;
    }
    var i$1 = i0 - 1 | 0, i = i$1;
    for(;;){
     if(0 <= i && ! is_dir_sep$1(name, i)){
      if(46 !== caml_string_get(name, i))
       return caml_ml_string_length(name) - i0 | 0;
      var i$0 = i - 1 | 0;
      i = i$0;
      continue;
     }
     return 0;
    }
   }
   function extension(name){
    var l = extension_len(name);
    return 0 === l
            ? cst$18
            : Stdlib_String
               [15].call
              (null, name, caml_ml_string_length(name) - l | 0, l);
   }
   function chop_extension(name){
    var l = extension_len(name);
    return 0 === l
            ? Stdlib[1].call(null, cst_Filename_chop_extension)
            : Stdlib_String
               [15].call
              (null, name, 0, caml_ml_string_length(name) - l | 0);
   }
   function remove_extension(name){
    var l = extension_len(name);
    return 0 === l
            ? name
            : Stdlib_String
               [15].call
              (null, name, 0, caml_ml_string_length(name) - l | 0);
   }
   var prng = [246, function(a){return caml_call1(Stdlib_Random[15][2], 0);}];
   function temp_file_name(temp_dir, prefix, suffix){
    var
     a = runtime.caml_obj_tag(prng),
     c =
       250 === a
        ? prng[1]
        : 246 === a ? CamlinternalLazy[2].call(null, prng) : prng,
     rnd = caml_call1(Stdlib_Random[15][4], c) & 16777215;
    return concat
            (temp_dir,
             caml_call3(Stdlib_Printf[4].call(null, b), prefix, rnd, suffix));
   }
   var current_temp_dir_name = [0, temp_dir_name$1];
   function set_temp_dir_name(s){current_temp_dir_name[1] = s; return 0;}
   function get_temp_dir_name(param){return current_temp_dir_name[1];}
   function temp_file(opt, prefix, suffix){
    if(opt)
     var sth = opt[1], temp_dir = sth;
    else
     var temp_dir = current_temp_dir_name[1];
    var counter = 0;
    for(;;){
     var name = temp_file_name(temp_dir, prefix, suffix);
     try{
      runtime.caml_sys_close(runtime.caml_sys_open(name, c, 384));
      return name;
     }
     catch(e$0){
      var e = caml_wrap_exception(e$0), tag = e[1];
      if(tag !== Stdlib[11]) throw caml_maybe_attach_backtrace(e, 0);
      if(1000 <= counter) throw caml_maybe_attach_backtrace(e, 0);
      var counter$0 = counter + 1 | 0;
      counter = counter$0;
     }
    }
   }
   function open_temp_file(opt, b, a, prefix, suffix){
    if(opt) var sth = opt[1], mode = sth; else var mode = d;
    if(b) var sth$0 = b[1], perms = sth$0; else var perms = 384;
    if(a)
     var sth$1 = a[1], temp_dir = sth$1;
    else
     var temp_dir = current_temp_dir_name[1];
    var counter = 0;
    for(;;){
     var name = temp_file_name(temp_dir, prefix, suffix);
     try{
      var
       c =
         [0,
          name,
          Stdlib[62].call(null, [0, 1, [0, 3, [0, 5, mode]]], perms, name)];
      return c;
     }
     catch(e$0){
      var e = caml_wrap_exception(e$0), tag = e[1];
      if(tag !== Stdlib[11]) throw caml_maybe_attach_backtrace(e, 0);
      if(1000 <= counter) throw caml_maybe_attach_backtrace(e, 0);
      var counter$0 = counter + 1 | 0;
      counter = counter$0;
     }
    }
   }
   var
    Stdlib_Filename =
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       chop_suffix_opt$1,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       null$2,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$1,
       quote$1,
       quote_command$1];
   runtime.caml_register_global(65, Stdlib_Filename, "Stdlib__Filename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Complex
//# unitInfo: Requires: Stdlib
//# shape: Stdlib__Complex:[N,N,N,F(1)*,F(1)*,F(2)*,F(2)*,F(2)*,F(1)*,F(2)*,F(1)*,F(1)*,F(1)*,F(1)*,F(2)*,F(1)*,F(1)*,F(2)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    zero = [254, 0., 0.],
    one = [254, 1., 0.],
    i = [254, 0., 1.],
    a = [254, 0., 0.];
   function add(x, y){return [254, x[1] + y[1], x[2] + y[2]];}
   function sub(x, y){return [254, x[1] - y[1], x[2] - y[2]];}
   function neg(x){return [254, - x[1], - x[2]];}
   function conj(x){return [254, x[1], - x[2]];}
   function mul(x, y){
    return [254, x[1] * y[1] - x[2] * y[2], x[1] * y[2] + x[2] * y[1]];
   }
   function div(x, y){
    if(Math.abs(y[2]) <= Math.abs(y[1])){
     var r = y[2] / y[1], d = y[1] + r * y[2];
     return [254, (x[1] + r * x[2]) / d, (x[2] - r * x[1]) / d];
    }
    var r$0 = y[1] / y[2], d$0 = y[2] + r$0 * y[1];
    return [254, (r$0 * x[1] + x[2]) / d$0, (r$0 * x[2] - x[1]) / d$0];
   }
   function inv(x){return div(one, x);}
   function norm2(x){return x[1] * x[1] + x[2] * x[2];}
   function norm(x){
    var r = Math.abs(x[1]), i = Math.abs(x[2]);
    if(r === 0.) return i;
    if(i === 0.) return r;
    if(i <= r){var q = i / r; return r * Math.sqrt(1. + q * q);}
    var q$0 = r / i;
    return i * Math.sqrt(1. + q$0 * q$0);
   }
   function arg(x){return Math.atan2(x[2], x[1]);}
   function polar(n, a){return [254, Math.cos(a) * n, Math.sin(a) * n];}
   function sqrt(x){
    if(x[1] === 0. && x[2] === 0.) return a;
    var r = Math.abs(x[1]), i = Math.abs(x[2]);
    if(i <= r)
     var
      q = i / r,
      w = Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
    else
     var
      q$0 = r / i,
      w = Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
    if(0. <= x[1]) return [254, w, 0.5 * x[2] / w];
    var w$0 = 0. <= x[2] ? w : - w;
    return [254, 0.5 * i / w, w$0];
   }
   function exp(x){
    var e = Math.exp(x[1]);
    return [254, e * Math.cos(x[2]), e * Math.sin(x[2])];
   }
   function log(x){
    var a = Math.atan2(x[2], x[1]);
    return [254, Math.log(norm(x)), a];
   }
   function pow(x, y){return exp(mul(y, log(x)));}
   var
    Stdlib_Complex =
      [0,
       zero,
       one,
       i,
       neg,
       conj,
       add,
       sub,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
   runtime.caml_register_global(19, Stdlib_Complex, "Stdlib__Complex");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__ArrayLabels
//# unitInfo: Requires: Stdlib__Array
//# shape: Stdlib__ArrayLabels:[F(1)*,F(2),F(3),F(3),F(2)*,F(1)*,F(3),F(1)*,F(4),F(5),F(1),F(1),F(2),F(2),F(2),F(2),F(3),F(3),F(3),F(3),F(3),F(2),F(2),F(3),F(3),F(2),F(2),F(2),F(2),F(1),F(2),F(2),F(2),F(2),F(1)*->F(1)*,F(1)*->F(1)*,F(1),[]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Array = global_data.Stdlib__Array,
    make_float = Stdlib_Array[1],
    init = Stdlib_Array[2],
    make_matrix = Stdlib_Array[3],
    create_matrix = Stdlib_Array[4],
    append = Stdlib_Array[5],
    concat = Stdlib_Array[6],
    sub = Stdlib_Array[7],
    copy = Stdlib_Array[8],
    fill = Stdlib_Array[9],
    blit = Stdlib_Array[10],
    to_list = Stdlib_Array[11],
    of_list = Stdlib_Array[12],
    iter = Stdlib_Array[13],
    iteri = Stdlib_Array[14],
    map = Stdlib_Array[15],
    mapi = Stdlib_Array[16],
    fold_left = Stdlib_Array[17],
    fold_left_map = Stdlib_Array[18],
    fold_right = Stdlib_Array[19],
    iter2 = Stdlib_Array[20],
    map2 = Stdlib_Array[21],
    for_all = Stdlib_Array[22],
    exists = Stdlib_Array[23],
    for_all2 = Stdlib_Array[24],
    exists2 = Stdlib_Array[25],
    mem = Stdlib_Array[26],
    memq = Stdlib_Array[27],
    find_opt = Stdlib_Array[28],
    find_map = Stdlib_Array[29],
    split = Stdlib_Array[30],
    combine = Stdlib_Array[31],
    sort = Stdlib_Array[32],
    stable_sort = Stdlib_Array[33],
    fast_sort = Stdlib_Array[34],
    to_seq = Stdlib_Array[35],
    to_seqi = Stdlib_Array[36],
    of_seq = Stdlib_Array[37],
    Floatarray = Stdlib_Array[38],
    Stdlib_ArrayLabels =
      [0,
       make_float,
       init,
       make_matrix,
       create_matrix,
       append,
       concat,
       sub,
       copy,
       fill,
       blit,
       to_list,
       of_list,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_left_map,
       fold_right,
       iter2,
       map2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find_opt,
       find_map,
       split,
       combine,
       sort,
       stable_sort,
       fast_sort,
       to_seq,
       to_seqi,
       of_seq,
       Floatarray];
   runtime.caml_register_global(1, Stdlib_ArrayLabels, "Stdlib__ArrayLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__ListLabels
//# unitInfo: Requires: Stdlib__List
//# shape: Stdlib__ListLabels:[F(1),F(2),F(2),F(2)*,F(1),F(1),F(2),F(2),F(1),F(2),F(2),F(2),F(1),F(1),F(3),F(3),F(2),F(2),F(2),F(2),F(2),F(1)*->F(1),F(2),F(3),F(3),F(3),F(3),F(3),F(3),F(4),F(4),F(2),F(2),F(3),F(3),F(2),F(2),F(2),F(2),F(2),F(1)*->F(1),F(1)*->F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(1),F(2),F(2),F(2),F(2),F(2),F(3),F(1)*->F(1)*,F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    length = Stdlib_List[1],
    compare_lengths = Stdlib_List[2],
    compare_length_with = Stdlib_List[3],
    cons = Stdlib_List[4],
    hd = Stdlib_List[5],
    tl = Stdlib_List[6],
    nth = Stdlib_List[7],
    nth_opt = Stdlib_List[8],
    rev = Stdlib_List[9],
    init = Stdlib_List[10],
    append = Stdlib_List[11],
    rev_append = Stdlib_List[12],
    concat = Stdlib_List[13],
    flatten = Stdlib_List[14],
    equal = Stdlib_List[15],
    compare = Stdlib_List[16],
    iter = Stdlib_List[17],
    iteri = Stdlib_List[18],
    map = Stdlib_List[19],
    mapi = Stdlib_List[20],
    rev_map = Stdlib_List[21],
    filter_map = Stdlib_List[22],
    concat_map = Stdlib_List[23],
    fold_left_map = Stdlib_List[24],
    fold_left = Stdlib_List[25],
    fold_right = Stdlib_List[26],
    iter2 = Stdlib_List[27],
    map2 = Stdlib_List[28],
    rev_map2 = Stdlib_List[29],
    fold_left2 = Stdlib_List[30],
    fold_right2 = Stdlib_List[31],
    for_all = Stdlib_List[32],
    exists = Stdlib_List[33],
    for_all2 = Stdlib_List[34],
    exists2 = Stdlib_List[35],
    mem = Stdlib_List[36],
    memq = Stdlib_List[37],
    find = Stdlib_List[38],
    find_opt = Stdlib_List[39],
    find_map = Stdlib_List[40],
    filter = Stdlib_List[41],
    find_all = Stdlib_List[42],
    filteri = Stdlib_List[43],
    partition = Stdlib_List[44],
    partition_map = Stdlib_List[45],
    assoc = Stdlib_List[46],
    assoc_opt = Stdlib_List[47],
    assq = Stdlib_List[48],
    assq_opt = Stdlib_List[49],
    mem_assoc = Stdlib_List[50],
    mem_assq = Stdlib_List[51],
    remove_assoc = Stdlib_List[52],
    remove_assq = Stdlib_List[53],
    split = Stdlib_List[54],
    combine = Stdlib_List[55],
    sort = Stdlib_List[56],
    stable_sort = Stdlib_List[57],
    fast_sort = Stdlib_List[58],
    sort_uniq = Stdlib_List[59],
    merge = Stdlib_List[60],
    to_seq = Stdlib_List[61],
    of_seq = Stdlib_List[62],
    Stdlib_ListLabels =
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       concat,
       flatten,
       equal,
       compare,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       filter_map,
       concat_map,
       fold_left_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       filter,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       sort,
       stable_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
   runtime.caml_register_global(1, Stdlib_ListLabels, "Stdlib__ListLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__BytesLabels
//# unitInfo: Requires: Stdlib__Bytes
//# shape: Stdlib__BytesLabels:[F(2),F(2),N,F(1),F(1),F(1),F(3),F(3),F(3),F(4),F(5),F(5),F(2),F(2),F(2),F(2),F(2),F(2),F(3),F(3),F(2),F(2),F(1),F(1),F(2),F(2),F(2),F(2),F(3),F(3),F(3),F(3),F(2),F(3),F(3),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(2)*,F(2)*,F(2),F(2),F(1),F(1)*,F(2),F(1)*->F(1),F(1)*->F(1),F(1),F(2),F(3),F(1),F(2),F(3),F(1),F(2),F(3),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    make = Stdlib_Bytes[1],
    init = Stdlib_Bytes[2],
    empty = Stdlib_Bytes[3],
    copy = Stdlib_Bytes[4],
    of_string = Stdlib_Bytes[5],
    to_string = Stdlib_Bytes[6],
    sub = Stdlib_Bytes[7],
    sub_string = Stdlib_Bytes[8],
    extend = Stdlib_Bytes[9],
    fill = Stdlib_Bytes[10],
    blit = Stdlib_Bytes[11],
    blit_string = Stdlib_Bytes[12],
    concat = Stdlib_Bytes[13],
    cat = Stdlib_Bytes[14],
    iter = Stdlib_Bytes[15],
    iteri = Stdlib_Bytes[16],
    map = Stdlib_Bytes[17],
    mapi = Stdlib_Bytes[18],
    fold_left = Stdlib_Bytes[19],
    fold_right = Stdlib_Bytes[20],
    for_all = Stdlib_Bytes[21],
    exists = Stdlib_Bytes[22],
    trim = Stdlib_Bytes[23],
    escaped = Stdlib_Bytes[24],
    index = Stdlib_Bytes[25],
    index_opt = Stdlib_Bytes[26],
    rindex = Stdlib_Bytes[27],
    rindex_opt = Stdlib_Bytes[28],
    index_from = Stdlib_Bytes[29],
    index_from_opt = Stdlib_Bytes[30],
    rindex_from = Stdlib_Bytes[31],
    rindex_from_opt = Stdlib_Bytes[32],
    contains = Stdlib_Bytes[33],
    contains_from = Stdlib_Bytes[34],
    rcontains_from = Stdlib_Bytes[35],
    uppercase = Stdlib_Bytes[36],
    lowercase = Stdlib_Bytes[37],
    capitalize = Stdlib_Bytes[38],
    uncapitalize = Stdlib_Bytes[39],
    uppercase_ascii = Stdlib_Bytes[40],
    lowercase_ascii = Stdlib_Bytes[41],
    capitalize_ascii = Stdlib_Bytes[42],
    uncapitalize_ascii = Stdlib_Bytes[43],
    compare = Stdlib_Bytes[44],
    equal = Stdlib_Bytes[45],
    starts_with = Stdlib_Bytes[46],
    ends_with = Stdlib_Bytes[47],
    unsafe_to_string = Stdlib_Bytes[48],
    unsafe_of_string = Stdlib_Bytes[49],
    split_on_char = Stdlib_Bytes[50],
    to_seq = Stdlib_Bytes[51],
    to_seqi = Stdlib_Bytes[52],
    of_seq = Stdlib_Bytes[53],
    get_utf_8_uchar = Stdlib_Bytes[54],
    set_utf_8_uchar = Stdlib_Bytes[55],
    is_valid_utf_8 = Stdlib_Bytes[56],
    get_utf_16be_uchar = Stdlib_Bytes[57],
    set_utf_16be_uchar = Stdlib_Bytes[58],
    is_valid_utf_16be = Stdlib_Bytes[59],
    get_utf_16le_uchar = Stdlib_Bytes[60],
    set_utf_16le_uchar = Stdlib_Bytes[61],
    is_valid_utf_16le = Stdlib_Bytes[62],
    get_uint8 = Stdlib_Bytes[63],
    get_int8 = Stdlib_Bytes[64],
    get_uint16_ne = Stdlib_Bytes[65],
    get_uint16_be = Stdlib_Bytes[66],
    get_uint16_le = Stdlib_Bytes[67],
    get_int16_ne = Stdlib_Bytes[68],
    get_int16_be = Stdlib_Bytes[69],
    get_int16_le = Stdlib_Bytes[70],
    get_int32_ne = Stdlib_Bytes[71],
    get_int32_be = Stdlib_Bytes[72],
    get_int32_le = Stdlib_Bytes[73],
    get_int64_ne = Stdlib_Bytes[74],
    get_int64_be = Stdlib_Bytes[75],
    get_int64_le = Stdlib_Bytes[76],
    set_uint8 = Stdlib_Bytes[77],
    set_int8 = Stdlib_Bytes[78],
    set_uint16_ne = Stdlib_Bytes[79],
    set_uint16_be = Stdlib_Bytes[80],
    set_uint16_le = Stdlib_Bytes[81],
    set_int16_ne = Stdlib_Bytes[82],
    set_int16_be = Stdlib_Bytes[83],
    set_int16_le = Stdlib_Bytes[84],
    set_int32_ne = Stdlib_Bytes[85],
    set_int32_be = Stdlib_Bytes[86],
    set_int32_le = Stdlib_Bytes[87],
    set_int64_ne = Stdlib_Bytes[88],
    set_int64_be = Stdlib_Bytes[89],
    set_int64_le = Stdlib_Bytes[90],
    Stdlib_BytesLabels =
      [0,
       make,
       init,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit_string,
       concat,
       cat,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare,
       equal,
       starts_with,
       ends_with,
       unsafe_to_string,
       unsafe_of_string,
       split_on_char,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       set_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       set_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       set_utf_16le_uchar,
       is_valid_utf_16le,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_uint16_be,
       set_uint16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
   runtime.caml_register_global(1, Stdlib_BytesLabels, "Stdlib__BytesLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__StringLabels
//# unitInfo: Requires: Stdlib__String
//# shape: Stdlib__StringLabels:[F(2),F(2),N,F(1),F(1),F(2),F(2)*,F(2)*,F(2)*,F(2),F(2),F(3),F(3),F(2),F(3),F(2),F(2),F(2),F(3),F(3),F(2),F(2),F(1),F(1),F(1),F(1),F(1),F(1),F(2),F(2),F(3),F(3),F(3),F(3),F(2),F(2),F(2),F(2),F(1)*,F(1)*,F(1),F(2),F(1),F(2),F(1),F(2),F(1),F(5),F(1),F(4),F(1),F(1),F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_String = global_data.Stdlib__String,
    make = Stdlib_String[1],
    init = Stdlib_String[2],
    empty = Stdlib_String[3],
    of_bytes = Stdlib_String[4],
    to_bytes = Stdlib_String[5],
    concat = Stdlib_String[6],
    cat = Stdlib_String[7],
    equal = Stdlib_String[8],
    compare = Stdlib_String[9],
    starts_with = Stdlib_String[10],
    ends_with = Stdlib_String[11],
    contains_from = Stdlib_String[12],
    rcontains_from = Stdlib_String[13],
    contains = Stdlib_String[14],
    sub = Stdlib_String[15],
    split_on_char = Stdlib_String[16],
    map = Stdlib_String[17],
    mapi = Stdlib_String[18],
    fold_left = Stdlib_String[19],
    fold_right = Stdlib_String[20],
    for_all = Stdlib_String[21],
    exists = Stdlib_String[22],
    trim = Stdlib_String[23],
    escaped = Stdlib_String[24],
    uppercase_ascii = Stdlib_String[25],
    lowercase_ascii = Stdlib_String[26],
    capitalize_ascii = Stdlib_String[27],
    uncapitalize_ascii = Stdlib_String[28],
    iter = Stdlib_String[29],
    iteri = Stdlib_String[30],
    index_from = Stdlib_String[31],
    index_from_opt = Stdlib_String[32],
    rindex_from = Stdlib_String[33],
    rindex_from_opt = Stdlib_String[34],
    index = Stdlib_String[35],
    index_opt = Stdlib_String[36],
    rindex = Stdlib_String[37],
    rindex_opt = Stdlib_String[38],
    to_seq = Stdlib_String[39],
    to_seqi = Stdlib_String[40],
    of_seq = Stdlib_String[41],
    get_utf_8_uchar = Stdlib_String[42],
    is_valid_utf_8 = Stdlib_String[43],
    get_utf_16be_uchar = Stdlib_String[44],
    is_valid_utf_16be = Stdlib_String[45],
    get_utf_16le_uchar = Stdlib_String[46],
    is_valid_utf_16le = Stdlib_String[47],
    blit = Stdlib_String[48],
    copy = Stdlib_String[49],
    fill = Stdlib_String[50],
    uppercase = Stdlib_String[51],
    lowercase = Stdlib_String[52],
    capitalize = Stdlib_String[53],
    uncapitalize = Stdlib_String[54],
    get_uint8 = Stdlib_String[55],
    get_int8 = Stdlib_String[56],
    get_uint16_ne = Stdlib_String[57],
    get_uint16_be = Stdlib_String[58],
    get_uint16_le = Stdlib_String[59],
    get_int16_ne = Stdlib_String[60],
    get_int16_be = Stdlib_String[61],
    get_int16_le = Stdlib_String[62],
    get_int32_ne = Stdlib_String[63],
    get_int32_be = Stdlib_String[64],
    get_int32_le = Stdlib_String[65],
    get_int64_ne = Stdlib_String[66],
    get_int64_be = Stdlib_String[67],
    get_int64_le = Stdlib_String[68],
    Stdlib_StringLabels =
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       concat,
       cat,
       equal,
       compare,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       blit,
       copy,
       fill,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le];
   runtime.caml_register_global
    (1, Stdlib_StringLabels, "Stdlib__StringLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__MoreLabels
//# unitInfo: Requires: Stdlib__Hashtbl, Stdlib__Map, Stdlib__Set
//# shape: Stdlib__MoreLabels:[[F(2),F(1),F(1),F(1),F(3),F(2),F(2),F(2),F(2),F(2),F(3),F(2),F(2),F(3),F(1)*,F(1),F(1)*,F(2),F(1),F(1)*->F(1),F(1)*->F(1),F(1)*->F(1),F(2),F(2),F(1),F(1)*,F(1)*,F(1)*,F(2)*,F(3)*,F(4)*],[F(1)*],[F(1)*]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Set = global_data.Stdlib__Set,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_MoreLabels = [0, Stdlib_Hashtbl, Stdlib_Map, Stdlib_Set];
   runtime.caml_register_global(3, Stdlib_MoreLabels, "Stdlib__MoreLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__StdLabels
//# shape: Stdlib__StdLabels:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Stdlib_StdLabels = [0];
   runtime.caml_register_global(0, Stdlib_StdLabels, "Stdlib__StdLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Bigarray
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Sys
//# shape: Stdlib__Bigarray:[N,N,N,N,N,N,N,N,N,N,N,N,N,F(1)*,N,N,N,N,N,N,N,F(1),F(1),F(1),F(1),F(2),F(1),F(2),F(3),F(4)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Bigarray_Array3_of_array_n$1 =
      "Bigarray.Array3.of_array: non-cubic data",
    caml_ba_change_layout = runtime.caml_ba_change_layout,
    caml_ba_create = runtime.caml_ba_create,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_num_dims = runtime.caml_ba_num_dims,
    caml_ba_reshape = runtime.caml_ba_reshape,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_ba_set_2 = runtime.caml_ba_set_2,
    caml_ba_set_3 = runtime.caml_ba_set_3,
    caml_ba_set_generic = runtime.caml_ba_set_generic,
    caml_ba_slice = runtime.caml_ba_slice,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Sys = global_data.Stdlib__Sys;
   function kind_size_in_bytes(param){
    switch(param){
      case 11:
       return 16;
      case 0:
      case 6:
       return 4;
      case 4:
      case 5:
       return 2;
      case 8:
      case 9:
       return Stdlib_Sys[9] / 8 | 0;
      case 1:
      case 7:
      case 10:
       return 8;
      default: return 1;
    }
   }
   var
    cst_Bigarray_Array2_of_array_n =
      "Bigarray.Array2.of_array: non-rectangular data",
    cst_Bigarray_Array3_of_array_n = cst_Bigarray_Array3_of_array_n$1,
    cst_Bigarray_Array3_of_array_n$0 = cst_Bigarray_Array3_of_array_n$1,
    cst_Bigarray_array0_of_genarra = "Bigarray.array0_of_genarray",
    cst_Bigarray_array1_of_genarra = "Bigarray.array1_of_genarray",
    cst_Bigarray_array2_of_genarra = "Bigarray.array2_of_genarray",
    cst_Bigarray_array3_of_genarra = "Bigarray.array3_of_genarray";
   function cloop(arr, idx, f, col, max){
    if(col === idx.length - 1){
     caml_ba_set_generic(arr, idx, caml_call1(f, idx));
     return;
    }
    var a = caml_check_bound(max, col)[col + 1] - 1 | 0, b = 0;
    if(a >= 0){
     var j = b;
     for(;;){
      caml_check_bound(idx, col)[col + 1] = j;
      cloop(arr, idx, f, col + 1 | 0, max);
      var c = j + 1 | 0;
      if(a === j) break;
      j = c;
     }
    }
   }
   function floop(arr, idx, f, col, max){
    if(0 > col){caml_ba_set_generic(arr, idx, caml_call1(f, idx)); return;}
    var a = caml_check_bound(max, col)[col + 1], b = 1;
    if(a >= 1){
     var j = b;
     for(;;){
      caml_check_bound(idx, col)[col + 1] = j;
      floop(arr, idx, f, col - 1 | 0, max);
      var c = j + 1 | 0;
      if(a === j) break;
      j = c;
     }
    }
   }
   function init(kind, layout, dims, f){
    var arr = caml_ba_create(kind, layout, dims), match = dims.length - 1;
    return 0 === match
            ? arr
            : layout
              ? (floop
                 (arr, caml_make_vect(match, 1), f, match - 1 | 0, dims),
                arr)
              : (cloop(arr, caml_make_vect(match, 0), f, 0, dims), arr);
   }
   function dims(a){
    var
     n = caml_ba_num_dims(a),
     d = caml_make_vect(n, 0),
     b = n - 1 | 0,
     c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      var e = runtime.caml_ba_dim(a, i);
      caml_check_bound(d, i)[i + 1] = e;
      var f = i + 1 | 0;
      if(b === i) break;
      i = f;
     }
    }
    return d;
   }
   function size_in_bytes(arr){
    var a = dims(arr), b = Stdlib_Array[17].call(null, caml_mul, 1, a);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), b);
   }
   function create(kind, layout){return caml_ba_create(kind, layout, [0]);}
   function get(arr){return runtime.caml_ba_get_generic(arr, [0]);}
   function set(arr){
    var a = [0];
    return function(b){return caml_ba_set_generic(arr, a, b);};
   }
   function size_in_bytes$0(arr){
    return kind_size_in_bytes(caml_ba_kind(arr));
   }
   function of_value(kind, layout, v){
    var a = create(kind, layout);
    set(a)(v);
    return a;
   }
   function create$0(kind, layout, dim){
    return caml_ba_create(kind, layout, [0, dim]);
   }
   function size_in_bytes$1(arr){
    var a = caml_ba_dim_1(arr);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), a);
   }
   function slice(a, n){
    return runtime.caml_ba_layout(a)
            ? caml_ba_slice(a, [0, n])
            : caml_ba_slice(a, [0, n]);
   }
   function init$0(kind, layout, dim, f){
    var arr = create$0(kind, layout, dim);
    if(layout){
     var d = 1;
     if(dim >= 1){
      var i$0 = d;
      for(;;){
       caml_ba_set_1(arr, i$0, caml_call1(f, i$0));
       var e = i$0 + 1 | 0;
       if(dim === i$0) break;
       i$0 = e;
      }
     }
     return arr;
    }
    var a = dim - 1 | 0, b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_ba_set_1(arr, i, caml_call1(f, i));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return arr;
   }
   function of_array(kind, layout, data){
    var
     ba = create$0(kind, layout, data.length - 1),
     ofs = layout ? 1 : 0,
     a = data.length - 2 | 0,
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_ba_set_1(ba, i + ofs | 0, caml_check_bound(data, i)[i + 1]);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return ba;
   }
   function create$1(kind, layout, dim1, dim2){
    return caml_ba_create(kind, layout, [0, dim1, dim2]);
   }
   function size_in_bytes$2(arr){
    var a = caml_ba_dim_2(arr), b = caml_ba_dim_1(arr);
    return caml_mul(caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), b), a);
   }
   function slice_left(a, n){return caml_ba_slice(a, [0, n]);}
   function slice_right(a, n){return caml_ba_slice(a, [0, n]);}
   function init$1(kind, layout, dim1, dim2, f){
    var arr = create$1(kind, layout, dim1, dim2);
    if(layout){
     var h = 1;
     if(dim2 >= 1){
      var j$0 = h;
      for(;;){
       var k = 1;
       if(dim1 >= 1){
        var i$0 = k;
        for(;;){
         caml_ba_set_2(arr, i$0, j$0, caml_call2(f, i$0, j$0));
         var m = i$0 + 1 | 0;
         if(dim1 === i$0) break;
         i$0 = m;
        }
       }
       var l = j$0 + 1 | 0;
       if(dim2 === j$0) break;
       j$0 = l;
      }
     }
     return arr;
    }
    var a = dim1 - 1 | 0, c = 0;
    if(a >= 0){
     var i = c;
     for(;;){
      var b = dim2 - 1 | 0, d = 0;
      if(b >= 0){
       var j = d;
       for(;;){
        caml_ba_set_2(arr, i, j, caml_call2(f, i, j));
        var g = j + 1 | 0;
        if(b === j) break;
        j = g;
       }
      }
      var e = i + 1 | 0;
      if(a === i) break;
      i = e;
     }
    }
    return arr;
   }
   function of_array$0(kind, layout, data){
    var
     dim1 = data.length - 1,
     dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
     ba = create$1(kind, layout, dim1, dim2),
     ofs = layout ? 1 : 0,
     a = dim1 - 1 | 0,
     c = 0;
    if(a >= 0){
     var i = c;
     for(;;){
      var row = caml_check_bound(data, i)[i + 1];
      if(row.length - 1 !== dim2)
       Stdlib[1].call(null, cst_Bigarray_Array2_of_array_n);
      var b = dim2 - 1 | 0, d = 0;
      if(b >= 0){
       var j = d;
       for(;;){
        caml_ba_set_2
         (ba, i + ofs | 0, j + ofs | 0, caml_check_bound(row, j)[j + 1]);
        var f = j + 1 | 0;
        if(b === j) break;
        j = f;
       }
      }
      var e = i + 1 | 0;
      if(a === i) break;
      i = e;
     }
    }
    return ba;
   }
   function create$2(kind, layout, dim1, dim2, dim3){
    return caml_ba_create(kind, layout, [0, dim1, dim2, dim3]);
   }
   function size_in_bytes$3(arr){
    var
     a = runtime.caml_ba_dim_3(arr),
     b = caml_ba_dim_2(arr),
     c = caml_ba_dim_1(arr);
    return caml_mul
            (caml_mul(caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), c), b),
             a);
   }
   function slice_left_1(a, n, m){return caml_ba_slice(a, [0, n, m]);}
   function slice_right_1(a, n, m){return caml_ba_slice(a, [0, n, m]);}
   function slice_left_2(a, n){return caml_ba_slice(a, [0, n]);}
   function slice_right_2(a, n){return caml_ba_slice(a, [0, n]);}
   function init$2(kind, layout, dim1, dim2, dim3, f){
    var arr = create$2(kind, layout, dim1, dim2, dim3);
    if(layout){
     var n = 1;
     if(dim3 >= 1){
      var k$0 = n;
      for(;;){
       var o = 1;
       if(dim2 >= 1){
        var j$0 = o;
        for(;;){
         var q = 1;
         if(dim1 >= 1){
          var i$0 = q;
          for(;;){
           caml_ba_set_3(arr, i$0, j$0, k$0, caml_call3(f, i$0, j$0, k$0));
           var s = i$0 + 1 | 0;
           if(dim1 === i$0) break;
           i$0 = s;
          }
         }
         var r = j$0 + 1 | 0;
         if(dim2 === j$0) break;
         j$0 = r;
        }
       }
       var p = k$0 + 1 | 0;
       if(dim3 === k$0) break;
       k$0 = p;
      }
     }
     return arr;
    }
    var a = dim1 - 1 | 0, d = 0;
    if(a >= 0){
     var i = d;
     for(;;){
      var b = dim2 - 1 | 0, e = 0;
      if(b >= 0){
       var j = e;
       for(;;){
        var c = dim3 - 1 | 0, h = 0;
        if(c >= 0){
         var k = h;
         for(;;){
          caml_ba_set_3(arr, i, j, k, caml_call3(f, i, j, k));
          var m = k + 1 | 0;
          if(c === k) break;
          k = m;
         }
        }
        var l = j + 1 | 0;
        if(b === j) break;
        j = l;
       }
      }
      var g = i + 1 | 0;
      if(a === i) break;
      i = g;
     }
    }
    return arr;
   }
   function of_array$1(kind, layout, data){
    var
     dim1 = data.length - 1,
     dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
     dim3 =
       0 === dim2
        ? 0
        : caml_check_bound(caml_check_bound(data, 0)[1], 0)[1].length - 1,
     ba = create$2(kind, layout, dim1, dim2, dim3),
     ofs = layout ? 1 : 0,
     a = dim1 - 1 | 0,
     d = 0;
    if(a >= 0){
     var i = d;
     for(;;){
      var row = caml_check_bound(data, i)[i + 1];
      if(row.length - 1 !== dim2)
       Stdlib[1].call(null, cst_Bigarray_Array3_of_array_n);
      var b = dim2 - 1 | 0, e = 0;
      if(b >= 0){
       var j = e;
       for(;;){
        var col = caml_check_bound(row, j)[j + 1];
        if(col.length - 1 !== dim3)
         Stdlib[1].call(null, cst_Bigarray_Array3_of_array_n$0);
        var c = dim3 - 1 | 0, g = 0;
        if(c >= 0){
         var k = g;
         for(;;){
          caml_ba_set_3
           (ba,
            i + ofs | 0,
            j + ofs | 0,
            k + ofs | 0,
            caml_check_bound(col, k)[k + 1]);
          var l = k + 1 | 0;
          if(c === k) break;
          k = l;
         }
        }
        var h = j + 1 | 0;
        if(b === j) break;
        j = h;
       }
      }
      var f = i + 1 | 0;
      if(a === i) break;
      i = f;
     }
    }
    return ba;
   }
   function array0_of_genarray(a){
    return 0 === caml_ba_num_dims(a)
            ? a
            : Stdlib[1].call(null, cst_Bigarray_array0_of_genarra);
   }
   function array1_of_genarray(a){
    return 1 === caml_ba_num_dims(a)
            ? a
            : Stdlib[1].call(null, cst_Bigarray_array1_of_genarra);
   }
   function array2_of_genarray(a){
    return 2 === caml_ba_num_dims(a)
            ? a
            : Stdlib[1].call(null, cst_Bigarray_array2_of_genarra);
   }
   function array3_of_genarray(a){
    return 3 === caml_ba_num_dims(a)
            ? a
            : Stdlib[1].call(null, cst_Bigarray_array3_of_genarra);
   }
   function reshape_0(a){return caml_ba_reshape(a, [0]);}
   function reshape_1(a, dim1){return caml_ba_reshape(a, [0, dim1]);}
   function reshape_2(a, dim1, dim2){
    return caml_ba_reshape(a, [0, dim1, dim2]);
   }
   function reshape_3(a, dim1, dim2, dim3){
    return caml_ba_reshape(a, [0, dim1, dim2, dim3]);
   }
   var
    Stdlib_Bigarray =
      [0,
       0,
       1,
       10,
       11,
       2,
       3,
       4,
       5,
       8,
       6,
       7,
       9,
       12,
       kind_size_in_bytes,
       0,
       1,
       [0, init, dims, size_in_bytes],
       [0,
        create,
        of_value,
        caml_ba_change_layout,
        size_in_bytes$0,
        get,
        set,
        of_value],
       [0,
        create$0,
        init$0,
        caml_ba_change_layout,
        size_in_bytes$1,
        slice,
        of_array],
       [0,
        create$1,
        init$1,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$2,
        init$2,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
   runtime.caml_register_global(10, Stdlib_Bigarray, "Stdlib__Bigarray");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__In_channel
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Fun, Stdlib__Sys
//# shape: Stdlib__In_channel:[N,F(1),F(1),F(3),F(2),F(2),F(4),N,N,N,F(1),F(1),F(1),F(1),F(1),F(4),F(4),F(2),F(1),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Fun = global_data.Stdlib__Fun,
    stdin = Stdlib[38],
    open_bin = Stdlib[80],
    open_text = Stdlib[79],
    open_gen = Stdlib[81];
   function with_open(openfun, s, f){
    var ic = caml_call1(openfun, s);
    return Stdlib_Fun[4].call
            (null,
             function(param){return Stdlib[94].call(null, ic);},
             function(param){return caml_call1(f, ic);});
   }
   function with_open_bin(s, f){return with_open(Stdlib[80], s, f);}
   function with_open_text(s, f){return with_open(Stdlib[79], s, f);}
   function with_open_gen(flags, perm, s, f){
    var a = Stdlib[81];
    return with_open(function(b){return a(flags, perm, b);}, s, f);
   }
   var
    seek = Stdlib[96][4],
    pos = Stdlib[96][5],
    length = Stdlib[96][6],
    close = Stdlib[93],
    close_noerr = Stdlib[94];
   function input_char(ic){
    try{var c = Stdlib[82].call(null, ic);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    return [0, c];
   }
   function input_byte(ic){
    try{var n = Stdlib[87].call(null, ic);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    return [0, n];
   }
   function input_line(ic){
    try{var s = Stdlib[83].call(null, ic);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    return [0, s];
   }
   var
    input = Stdlib[84],
    a = [0, 0],
    cst_In_channel_input_all_chann =
      "In_channel.input_all: channel content is larger than maximum string length";
   function really_input(ic, buf, pos, len){
    try{Stdlib[85].call(null, ic, buf, pos, len); return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function really_input_string(ic, len){
    try{var s = Stdlib[86].call(null, ic, len);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    return [0, s];
   }
   function read_upto(ic, buf, ofs, len){
    var ofs$0 = ofs, len$0 = len;
    for(;;){
     if(0 !== len$0){
      var r = Stdlib[84].call(null, ic, buf, ofs$0, len$0);
      if(0 !== r){
       var len$1 = len$0 - r | 0, ofs$1 = ofs$0 + r | 0;
       ofs$0 = ofs$1;
       len$0 = len$1;
       continue;
      }
     }
     return ofs$0 - ofs | 0;
    }
   }
   function ensure(buf, ofs, n){
    var len = caml_ml_bytes_length(buf);
    if((ofs + n | 0) <= len) return buf;
    var new_len = [0, len];
    for(;;){
     if(new_len[1] >= (ofs + n | 0)) break;
     new_len[1] = (2 * new_len[1] | 0) + 1 | 0;
    }
    var
     new_len$0 = new_len[1],
     new_len$1 =
       new_len$0 <= Stdlib_Sys[12]
        ? new_len$0
        : ofs
          < Stdlib_Sys[12]
          ? Stdlib_Sys[12]
          : Stdlib[2].call(null, cst_In_channel_input_all_chann),
     new_buf = caml_create_bytes(new_len$1);
    Stdlib_Bytes[11].call(null, buf, 0, new_buf, 0, ofs);
    return new_buf;
   }
   function input_all(ic){
    var chunk_size = 65536;
    try{
     var
      a = Stdlib[91].call(null, ic),
      b = Stdlib[92].call(null, ic) - a | 0,
      initial_size = b;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag !== Stdlib[11]) throw caml_maybe_attach_backtrace(exn, 0);
     var initial_size = -1;
    }
    var
     initial_size$0 = 0 <= initial_size ? initial_size : chunk_size,
     initial_size$1 =
       initial_size$0 <= Stdlib_Sys[12] ? initial_size$0 : Stdlib_Sys[12],
     buf = caml_create_bytes(initial_size$1),
     nread = read_upto(ic, buf, 0, initial_size$1);
    if(nread < initial_size$1)
     return Stdlib_Bytes[8].call(null, buf, 0, nread);
    try{var c = Stdlib[82].call(null, ic);}
    catch(exn){
     var exn$0 = caml_wrap_exception(exn);
     if(exn$0 === Stdlib[12]) return Stdlib_Bytes[48].call(null, buf);
     throw caml_maybe_attach_backtrace(exn$0, 0);
    }
    var buf$2 = ensure(buf, nread, 65537);
    runtime.caml_bytes_set(buf$2, nread, c);
    var ofs$1 = nread + 1 | 0, buf$0 = buf$2, ofs = ofs$1;
    for(;;){
     var
      buf$1 = ensure(buf$0, ofs, chunk_size),
      rem = caml_ml_bytes_length(buf$1) - ofs | 0,
      r = read_upto(ic, buf$1, ofs, rem);
     if(r < rem) return Stdlib_Bytes[8].call(null, buf$1, 0, ofs + r | 0);
     var ofs$0 = ofs + rem | 0;
     buf$0 = buf$1;
     ofs = ofs$0;
    }
   }
   var
    set_binary_mode = Stdlib[95],
    Stdlib_In_channel =
      [0,
       stdin,
       open_bin,
       open_text,
       open_gen,
       with_open_bin,
       with_open_text,
       with_open_gen,
       seek,
       pos,
       length,
       close,
       close_noerr,
       input_char,
       input_byte,
       input_line,
       input,
       really_input,
       really_input_string,
       input_all,
       set_binary_mode];
   runtime.caml_register_global(6, Stdlib_In_channel, "Stdlib__In_channel");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Out_channel
//# unitInfo: Requires: Stdlib, Stdlib__Fun
//# shape: Stdlib__Out_channel:[N,N,F(1),F(1),F(3),F(2),F(2),F(4),N,N,N,F(1),F(1),F(1),F(1),F(2),F(2),F(2),F(2),F(4),F(4),F(2),F(2),F(1)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Fun = global_data.Stdlib__Fun,
    stdout = Stdlib[39],
    stderr = Stdlib[40],
    open_bin = Stdlib[61],
    open_text = Stdlib[60],
    open_gen = Stdlib[62];
   function with_open(openfun, s, f){
    var oc = caml_call1(openfun, s);
    return Stdlib_Fun[4].call
            (null,
             function(param){return Stdlib[77].call(null, oc);},
             function(param){return caml_call1(f, oc);});
   }
   function with_open_bin(s, f){return with_open(Stdlib[61], s, f);}
   function with_open_text(s, f){return with_open(Stdlib[60], s, f);}
   function with_open_gen(flags, perm, s, f){
    var a = Stdlib[62];
    return with_open(function(b){return a(flags, perm, b);}, s, f);
   }
   var
    seek = Stdlib[96][1],
    pos = Stdlib[96][2],
    length = Stdlib[96][3],
    close = Stdlib[76],
    close_noerr = Stdlib[77],
    flush = Stdlib[63],
    flush_all = Stdlib[64],
    output_char = Stdlib[65],
    output_byte = Stdlib[70],
    output_string = Stdlib[66],
    output_bytes = Stdlib[67],
    output = Stdlib[68],
    output_substring = Stdlib[69],
    set_binary_mode = Stdlib[78],
    Stdlib_Out_channel =
      [0,
       stdout,
       stderr,
       open_bin,
       open_text,
       open_gen,
       with_open_bin,
       with_open_text,
       with_open_gen,
       seek,
       pos,
       length,
       close,
       close_noerr,
       flush,
       flush_all,
       output_char,
       output_byte,
       output_string,
       output_bytes,
       output,
       output_substring,
       set_binary_mode,
       runtime.caml_ml_set_buffered,
       runtime.caml_ml_is_buffered];
   runtime.caml_register_global(2, Stdlib_Out_channel, "Stdlib__Out_channel");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUGFkZGluZyBwb3NpdGlvbi4gKilcbnR5cGUgcGFkdHkgPVxuICB8IExlZnQgICAoKiBUZXh0IGlzIGxlZnQganVzdGlmaWVkICgnLScgb3B0aW9uKS4gICAgICAgICAgICAgICAqKVxuICB8IFJpZ2h0ICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCAobm8gJy0nIG9wdGlvbikuICAgICAgICAgICAqKVxuICB8IFplcm9zICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCBieSB6ZXJvcyAoc2VlICcwJyBvcHRpb24pLiAqKVxuXG4oKioqKVxuXG4oKiBJbnRlZ2VyIGNvbnZlcnNpb24uICopXG50eXBlIGludF9jb252ID1cbiAgfCBJbnRfZCB8IEludF9wZCB8IEludF9zZCAgICAgICAgKCogICVkIHwgJStkIHwgJSBkICAqKVxuICB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpICAgICAgICAoKiAgJWkgfCAlK2kgfCAlIGkgICopXG4gIHwgSW50X3ggfCBJbnRfQ3ggICAgICAgICAgICAgICAgICgqICAleCB8ICUjeCAgICAgICAgKilcbiAgfCBJbnRfWCB8IEludF9DWCAgICAgICAgICAgICAgICAgKCogICVYIHwgJSNYICAgICAgICAqKVxuICB8IEludF9vIHwgSW50X0NvICAgICAgICAgICAgICAgICAoKiAgJW8gfCAlI28gICAgICAgICopXG4gIHwgSW50X3UgICAgICAgICAgICAgICAgICAgICAgICAgICgqICAldSAgICAgICAgICAgICAgKilcbiAgfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgICAgICAgKCogICUjZCB8ICUjaSB8ICUjdSAqKVxuXG4oKiBGbG9hdCBjb252ZXJzaW9uLiAqKVxudHlwZSBmbG9hdF9mbGFnX2NvbnYgPVxuICB8IEZsb2F0X2ZsYWdfICAgICAgICAgICAgICAgICAgICAoKiAlW2ZlRWdHRmhIXSAqKVxuICB8IEZsb2F0X2ZsYWdfcCAgICAgICAgICAgICAgICAgICAoKiAlK1tmZUVnR0ZoSF0gKilcbiAgfCBGbG9hdF9mbGFnX3MgICAgICAgICAgICAgICAgICAgKCogJSBbZmVFZ0dGaEhdICopXG50eXBlIGZsb2F0X2tpbmRfY29udiA9XG4gIHwgRmxvYXRfZiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZiB8ICUrZiB8ICUgZiAgKilcbiAgfCBGbG9hdF9lICAgICAgICAgICAgICAgICAgICAgICAgKCogICVlIHwgJStlIHwgJSBlICAqKVxuICB8IEZsb2F0X0UgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUUgfCAlK0UgfCAlIEUgICopXG4gIHwgRmxvYXRfZyAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZyB8ICUrZyB8ICUgZyAgKilcbiAgfCBGbG9hdF9HICAgICAgICAgICAgICAgICAgICAgICAgKCogICVHIHwgJStHIHwgJSBHICAqKVxuICB8IEZsb2F0X0YgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUYgfCAlK0YgfCAlIEYgICopXG4gIHwgRmxvYXRfaCAgICAgICAgICAgICAgICAgICAgICAgICgqICAlaCB8ICUraCB8ICUgaCAgKilcbiAgfCBGbG9hdF9IICAgICAgICAgICAgICAgICAgICAgICAgKCogICVIIHwgJStIIHwgJSBIICAqKVxuICB8IEZsb2F0X0NGICAgICAgICAgICAgICAgICAgICAgICAoKiAgJSNGfCAlKyNGfCAlICNGICopXG50eXBlIGZsb2F0X2NvbnYgPSBmbG9hdF9mbGFnX2NvbnYgKiBmbG9hdF9raW5kX2NvbnZcblxuKCoqKilcblxuKCogQ2hhciBzZXRzIChzZWUgJVsuLi5dKSBhcmUgYml0bWFwcyBpbXBsZW1lbnRlZCBhcyAzMi1jaGFyIHN0cmluZ3MuICopXG50eXBlIGNoYXJfc2V0ID0gc3RyaW5nXG5cbigqKiopXG5cbigqIENvdW50ZXIgdXNlZCBpbiBTY2FuZi4gKilcbnR5cGUgY291bnRlciA9XG4gIHwgTGluZV9jb3VudGVyICAgICAoKiAgJWwgICAgICAqKVxuICB8IENoYXJfY291bnRlciAgICAgKCogICVuICAgICAgKilcbiAgfCBUb2tlbl9jb3VudGVyICAgICgqICAlTiwgJUwgICopXG5cbigqKiopXG5cbigqIFBhZGRpbmcgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycy4gKilcbnR5cGUgKCdhLCAnYikgcGFkZGluZyA9XG4gICgqIE5vIHBhZGRpbmcgKGV4OiBcIiVkXCIpICopXG4gIHwgTm9fcGFkZGluZyAgOiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIExpdGVyYWwgcGFkZGluZyAoZXg6IFwiJThkXCIpICopXG4gIHwgTGl0X3BhZGRpbmcgOiBwYWR0eSAqIGludCAtPiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIFBhZGRpbmcgYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqZFwiKSAqKVxuICB8IEFyZ19wYWRkaW5nIDogcGFkdHkgLT4gKGludCAtPiAnYSwgJ2EpIHBhZGRpbmdcblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZCxcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwYWRkaW5nIG9wdGlvbiAobm8gZXh0cmEgYXJndW1lbnQpICopXG50eXBlIHBhZF9vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIFByZWNpc2lvbiBvZiBmbG9hdHMgYW5kICcwJy1wYWRkaW5nIG9mIGludGVnZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwcmVjaXNpb24gPVxuICAoKiBObyBwcmVjaXNpb24gKGV4OiBcIiVmXCIpICopXG4gIHwgTm9fcHJlY2lzaW9uIDogKCdhLCAnYSkgcHJlY2lzaW9uXG4gICgqIExpdGVyYWwgcHJlY2lzaW9uIChleDogXCIlLjNmXCIpICopXG4gIHwgTGl0X3ByZWNpc2lvbiA6IGludCAtPiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogUHJlY2lzaW9uIGFzIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpICopXG4gIHwgQXJnX3ByZWNpc2lvbiA6IChpbnQgLT4gJ2EsICdhKSBwcmVjaXNpb25cblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZixcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwcmVjaXNpb24gb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcHJlY19vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIHNlZSB0aGUgQ3VzdG9tIGZvcm1hdCBjb21iaW5hdG9yICopXG50eXBlICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgPVxuICB8IEN1c3RvbV96ZXJvIDogKCdhLCBzdHJpbmcsICdhKSBjdXN0b21fYXJpdHlcbiAgfCBDdXN0b21fc3VjYyA6ICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgLT5cbiAgICAoJ2EsICd4IC0+ICdiLCAneCAtPiAnYykgY3VzdG9tX2FyaXR5XG5cbigqKiopXG5cbigqICAgICAgICBSZWxhdGlvbmFsIGZvcm1hdCB0eXBlc1xuXG5JbiB0aGUgZmlyc3QgZm9ybWF0K2dhZHRzIGltcGxlbWVudGF0aW9uLCB0aGUgdHlwZSBmb3IgJSguLiUpIGluIHRoZVxuZm10IEdBRFQgd2FzIGFzIGZvbGxvd3M6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKiAoJ2QxLCAncTEsICdkMiwgJ3EyKSByZWFkZXJfbmJfdW5pZmllciAqXG4gICAgKCd4LCAnYiwgJ2MsICdkMSwgJ3ExLCAndSkgZm10dHkgKlxuICAgICgndSwgJ2IsICdjLCAncTEsICdlMSwgJ2YpIGZtdCAtPlxuICAgICAgKCgneCwgJ2IsICdjLCAnZDIsICdxMiwgJ3UpIGZvcm1hdDYgLT4gJ3gsICdiLCAnYywgJ2QxLCAnZTEsICdmKSBmbXRcblxuTm90aWNlIHRoYXQgdGhlICd1IHBhcmFtZXRlciBpbiAnZiBwb3NpdGlvbiBpbiB0aGUgZm9ybWF0IGFyZ3VtZW50XG4oKCd4LCAuLiwgJ3UpIGZvcm1hdDYgLT4gLi4pIGlzIGVxdWFsIHRvIHRoZSAndSBwYXJhbWV0ZXIgaW4gJ2FcbnBvc2l0aW9uIGluIHRoZSBmb3JtYXQgdGFpbCAoKCd1LCAuLiwgJ2YpIGZtdCkuIFRoaXMgbWVhbnMgdGhhdCB0aGVcbnR5cGUgb2YgdGhlIGV4cGVjdGVkIGZvcm1hdCBwYXJhbWV0ZXIgZGVwZW5kcyBvZiB3aGVyZSB0aGUgJSguLi4lKVxuYXJlIGluIHRoZSBmb3JtYXQgc3RyaW5nOlxuXG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSlcIlxuICAtIDogKHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgdW5pdClcbiAgICAgIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2IC0+IHVuaXRcbiAgPSA8ZnVuPlxuICAjIFByaW50Zi5wcmludGYgXCIlKCUpJWRcIlxuICAtIDogKGludCAtPiB1bml0LCBvdXRfY2hhbm5lbCwgdW5pdCwgJ19hLCAnX2EsIGludCAtPiB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gaW50IC0+IHVuaXRcbiAgPSA8ZnVuPlxuXG5PbiB0aGUgY29udHJhcnksIHRoZSBsZWdhY3kgdHlwZXIgZ2l2ZXMgYSBjbGV2ZXIgdHlwZSB0aGF0IGRvZXMgbm90XG5kZXBlbmQgb24gdGhlIHBvc2l0aW9uIG9mICUoLi4lKSBpbiB0aGUgZm9ybWF0IHN0cmluZy4gRm9yIGV4YW1wbGUsXG4lKCUpIHdpbGwgaGF2ZSB0aGUgcG9seW1vcnBoaWMgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSk6IGl0IGNhblxuYmUgY29uY2F0ZW5hdGVkIHRvIGFueSBmb3JtYXQgdHlwZSwgYW5kIG9ubHkgZW5mb3JjZXMgdGhlIGNvbnN0cmFpbnRcbnRoYXQgaXRzICdhIGFuZCAnZiBwYXJhbWV0ZXJzIGFyZSBlcXVhbCAobm8gZm9ybWF0IGFyZ3VtZW50cykgYW5kICdkXG5hbmQgJ2UgYXJlIGVxdWFsIChubyByZWFkZXIgYXJndW1lbnQpLlxuXG5UaGUgd2Vha2VuaW5nIG9mIHRoaXMgcGFyYW1ldGVyIHR5cGUgaW4gdGhlIEdBRFQgdmVyc2lvbiBicm9rZSB1c2VyXG5jb2RlIChpbiBmYWN0IGl0IGVzc2VudGlhbGx5IG1hZGUgJSguLi4lKSB1bnVzYWJsZSBleGNlcHQgYXQgdGhlIGxhc3RcbnBvc2l0aW9uIG9mIGEgZm9ybWF0KS4gSW4gcGFydGljdWxhciwgdGhlIGZvbGxvd2luZyB3b3VsZCBub3Qgd29ya1xuYW55bW9yZTpcblxuICBmdW4gc2VwIC0+XG4gICAgRm9ybWF0LnByaW50ZiBcImZvbyUoJSliYXIlKCUpYmF6XCIgc2VwIHNlcFxuXG5BcyB0aGUgdHlwZS1jaGVja2VyIHdvdWxkIHJlcXVpcmUgdHdvICppbmNvbXBhdGlibGUqIHR5cGVzIGZvciB0aGUgJSglKVxuaW4gZGlmZmVyZW50IHBvc2l0aW9ucy5cblxuVGhlIHNvbHV0aW9uIHRvIHJlZ2FpbiBhIGdlbmVyYWwgdHlwZSBmb3IgJSguLiUpIGlzIHRvIGdlbmVyYWxpemUgdGhpc1xudGVjaG5pcXVlLCBub3Qgb25seSBvbiB0aGUgJ2QsICdlIHBhcmFtZXRlcnMsIGJ1dCBvbiBhbGwgc2l4XG5wYXJhbWV0ZXJzIG9mIGEgZm9ybWF0OiB3ZSBpbnRyb2R1Y2UgYSBcInJlbGF0aW9uYWxcIiB0eXBlXG4gICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG53aG9zZSB2YWx1ZXMgYXJlIHByb29mcyB0aGF0ICgnYTEsIC4uLCAnZjEpIGFuZCAoJ2EyLCAuLiwgJ2YyKSBtb3JhbGx5XG5jb3JyZXNwb25kIHRvIHRoZSBzYW1lIGZvcm1hdCB0eXBlOiAnYTEgaXMgb2J0YWluZWQgZnJvbSAnZjEsJ2IxLCdjMVxuaW4gdGhlIGV4YWN0IHNhbWUgd2F5IHRoYXQgJ2EyIGlzIG9idGFpbmVkIGZyb20gJ2YyLCdiMiwnYzIsIGV0Yy5cblxuRm9yIGV4YW1wbGUsIHRoZSByZWxhdGlvbiBiZXR3ZWVuIHR3byBmb3JtYXQgdHlwZXMgYmVnaW5uaW5nIHdpdGggYSBDaGFyXG5wYXJhbWV0ZXIgaXMgYXMgZm9sbG93czpcblxufCBDaGFyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgICopXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgIChjaGFyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbkluIHRoZSBnZW5lcmFsIGNhc2UsIHRoZSB0ZXJtIHN0cnVjdHVyZSBvZiBmbXR0eV9yZWwgaXMgKGFsbW9zdFsxXSlcbmlzb21vcnBoaWMgdG8gdGhlIGZtdHR5IG9mIHRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbjogZXZlcnlcbmNvbnN0cnVjdG9yIGlzIHJlLXJlYWQgd2l0aCBhIGJpbmFyeSwgcmVsYXRpb25hbCB0eXBlLCBpbnN0ZWFkIG9mIHRoZVxucHJldmlvdXMgdW5hcnkgdHlwaW5nLiBmbXR0eSBjYW4gdGhlbiBiZSByZS1kZWZpbmVkIGFzIHRoZSBkaWFnb25hbCBvZlxuZm10dHlfcmVsOlxuXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5ID1cbiAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5cbk9uY2Ugd2UgaGF2ZSB0aGlzIGZtdHR5X3JlbCB0eXBlIGluIHBsYWNlLCB3ZSBjYW4gZ2l2ZSB0aGUgbW9yZVxuZ2VuZXJhbCB0eXBlIHRvICUoLi4uJSk6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKlxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG5XZSBhY2NlcHQgYW55IGZvcm1hdCAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYpICh0aGlzIGlzXG5jb21wbGV0ZWx5IHVucmVsYXRlZCB0byB0aGUgdHlwZSBvZiB0aGUgY3VycmVudCBmb3JtYXQpLCBidXQgYWxzb1xucmVxdWlyZSBhIHByb29mIHRoYXQgdGhpcyBmb3JtYXQgaXMgaW4gcmVsYXRpb24gdG8gYW5vdGhlciBmb3JtYXQgdGhhdFxuaXMgY29uY2F0ZW5hYmxlIHRvIHRoZSBmb3JtYXQgdGFpbC4gV2hlbiBleGVjdXRpbmcgYSAlKC4uLiUpIGZvcm1hdFxuKGluIGNhbWxpbnRlcm5hbEZvcm1hdC5tbDptYWtlX3ByaW50ZiBvciBzY2FuZi5tbDptYWtlX3NjYW5mKSwgd2VcbnRyYW5zdHlwZSB0aGUgZm9ybWF0IGFsb25nIHRoaXMgcmVsYXRpb24gdXNpbmcgdGhlICdyZWNhc3QnIGZ1bmN0aW9uXG50byB0cmFuc3Bvc2UgYmV0d2VlbiByZWxhdGVkIGZvcm1hdCB0eXBlcy5cblxuICB2YWwgcmVjYXN0IDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEpIGZtdFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10XG5cbk5PVEUgWzFdOiB0aGUgdHlwaW5nIG9mIEZvcm1hdF9zdWJzdF90eSByZXF1aXJlcyBub3Qgb25lIGZvcm1hdCB0eXBlLCBidXRcbnR3bywgb25lIHRvIGVzdGFibGlzaCB0aGUgbGluayBiZXR3ZWVuIHRoZSBmb3JtYXQgYXJndW1lbnQgYW5kIHRoZVxuZmlyc3Qgc2l4IHBhcmFtZXRlcnMsIGFuZCB0aGUgb3RoZXIgZm9yIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdFxuYXJndW1lbnQgYW5kIHRoZSBsYXN0IHNpeCBwYXJhbWV0ZXJzLlxuXG58IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2QyLCAnYTIpIGZtdHR5X3JlbCAqXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzEsICdiMSwgJ2MxLCAnajEsICdlMSwgJ2YxLFxuICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuV2hlbiB3ZSBnZW5lcmF0ZSBhIGZvcm1hdCBBU1QsIHdlIGdlbmVyYXRlIGV4YWN0bHkgdGhlIHNhbWUgd2l0bmVzc1xuZm9yIGJvdGggcmVsYXRpb25zLCBhbmQgdGhlIHdpdG5lc3MtY29udmVyc2lvbiBmdW5jdGlvbnMgaW5cbmNhbWxpbnRlcm5hbEZvcm1hdCBkbyByZWx5IG9uIHRoaXMgaW52YXJpYW50LiBGb3IgZXhhbXBsZSwgdGhlXG5mdW5jdGlvbiB0aGF0IHByb3ZlcyB0aGF0IHRoZSByZWxhdGlvbiBpcyB0cmFuc2l0aXZlXG5cbiAgdmFsIHRyYW5zIDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgLT4gKCdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcbiAgLT4gKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcblxuZG9lcyBhc3N1bWUgdGhhdCB0aGUgdHdvIGlucHV0cyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgdGVybSBzdHJ1Y3R1cmVcbihhbmQgaXMgb25seSBldmVyeSB1c2VkIGZvciBhcmd1bWVudCB3aXRuZXNzZXMgb2YgdGhlXG5Gb3JtYXRfc3Vic3RfdHkgY29uc3RydWN0b3IpLlxuKilcblxuKCogVHlwZSBvZiBhIGJsb2NrIHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCAgICgqIEhvcml6b250YWwgYmxvY2sgbm8gbGluZSBicmVha2luZyAqKVxuICB8IFBwX3Zib3ggICAoKiBWZXJ0aWNhbCBibG9jayBlYWNoIGJyZWFrIGxlYWRzIHRvIGEgbmV3IGxpbmUgKilcbiAgfCBQcF9odmJveCAgKCogSG9yaXpvbnRhbC12ZXJ0aWNhbCBibG9jazogc2FtZSBhcyB2Ym94LCBleGNlcHQgaWYgdGhpcyBibG9ja1xuICAgICAgICAgICAgICAgICBpcyBzbWFsbCBlbm91Z2ggdG8gZml0IG9uIGEgc2luZ2xlIGxpbmUgKilcbiAgfCBQcF9ob3Zib3ggKCogSG9yaXpvbnRhbCBvciBWZXJ0aWNhbCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2sgKilcbiAgfCBQcF9ib3ggICAgKCogSG9yaXpvbnRhbCBvciBJbmRlbnQgYmxvY2s6IGJyZWFrcyBsZWFkIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgIG9ubHkgd2hlbiBuZWNlc3NhcnkgdG8gcHJpbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGJsb2NrLCBvclxuICAgICAgICAgICAgICAgICB3aGVuIGl0IGxlYWRzIHRvIGEgbmV3IGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50IGxpbmUgKilcbiAgfCBQcF9maXRzICAgKCogSW50ZXJuYWwgdXNhZ2U6IHdoZW4gYSBibG9jayBmaXRzIG9uIGEgc2luZ2xlIGxpbmUgKilcblxuKCogRm9ybWF0dGluZyBlbGVtZW50IHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgZm9ybWF0dGluZ19saXQgPVxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXSAgICopXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEB9ICAgKilcbiAgfCBCcmVhayBvZiBzdHJpbmcgKiBpbnQgKiBpbnQgICAgICAgICAgKCogQCwgfCBAICB8IEA7IHwgQDs8PiAqKVxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPyAgICopXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBcXG4gICopXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAuICAgKilcbiAgfCBNYWdpY19zaXplIG9mIHN0cmluZyAqIGludCAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQDxuPiAqKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAQCAgICopXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAlJSAgKilcbiAgfCBTY2FuX2luZGljIG9mIGNoYXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFggICAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW4gPVxuICB8IE9wZW5fdGFnIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gICAgICAoKiBAeyAgICopXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuXG4gIHwgT3Blbl9ib3ggOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEBbICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cblxuKCoqKilcblxuKCogTGlzdCBvZiBmb3JtYXQgdHlwZSBlbGVtZW50cy4gKilcbigqIEluIHBhcnRpY3VsYXIgdXNlZCB0byByZXByZXNlbnQgJSguLi4lKSBhbmQgJXsuLi4lfSBjb250ZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X3JlbFxuYW5kICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgPVxuICB8IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBjaGFyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFN0cmluZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKHN0cmluZyAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIHN0cmluZyAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50MzJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVsZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50MzIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQzMiAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBOYXRpdmVpbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5kICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChuYXRpdmVpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBuYXRpdmVpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50NjRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVMZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50NjQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQ2NCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBGbG9hdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWYgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChmbG9hdCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGZsb2F0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEJvb2xfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGJvb2wgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBib29sIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRm9ybWF0X2FyZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpXG4gICAgICAgICAgIGZtdHR5X3JlbFxuICB8IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzEsICdiMSwgJ2MxLCAnajEsICdkMSwgJ2ExKSBmbXR0eV9yZWwgKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzLiAqKVxuICB8IEFscGhhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ3ggLT4gJ2MxKSAtPiAneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ3ggLT4gJ2MyKSAtPiAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBUaGV0YV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2IxIC0+ICdjMSkgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2IyIC0+ICdjMikgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQW55X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBVc2VkIGZvciBjdXN0b20gZm9ybWF0cyAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ3ggLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBSZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRW5kX29mX2ZtdHR5IDpcbiAgICAgICgnZjEsICdiMSwgJ2MxLCAnZDEsICdkMSwgJ2YxLFxuICAgICAgICdmMiwgJ2IyLCAnYzIsICdkMiwgJ2QyLCAnZjIpIGZtdHR5X3JlbFxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCBlbGVtZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ID1cbiAgfCBDaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlUyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQzMiAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IE5hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVuW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgbmF0aXZlaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQ2NCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGaEhdICopXG4gICAgICBmbG9hdF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgZmxvYXQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBCb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2JCXSAqKVxuICAgICAgKCd4LCBib29sIC0+ICdhKSBwYWRkaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmx1c2ggOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogYWJjICopXG4gICAgICBzdHJpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDaGFyX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiB4ICopXG4gICAgICBjaGFyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBGb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAley4uLiV9ICopXG4gICAgICBwYWRfb3B0aW9uICogKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgIHBhZF9vcHRpb24gKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYiwgJ2MsICdqMiwgJ2QsICdhKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3IuICopXG4gIHwgQWxwaGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAneCAtPiAnYykgLT4gJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgVGhldGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAnYykgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICBmb3JtYXR0aW5nX2xpdCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdHRpbmdfZ2VuIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXyAqKVxuICAgICAgKCdhMSwgJ2IsICdjLCAnZDEsICdlMSwgJ2YxKSBmb3JtYXR0aW5nX2dlbiAqXG4gICAgICAoJ2YxLCAnYiwgJ2MsICdlMSwgJ2UyLCAnZjIpIGZtdCAtPiAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UyLCAnZjIpIGZtdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3ggLT4gJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKHN0cmluZyAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW25sTkxdICopXG4gICAgICBjb3VudGVyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoaW50IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUwYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKGNoYXIgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSWdub3JlZF9wYXJhbSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8gKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBpZ25vcmVkICogKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogQ3VzdG9tIHByaW50aW5nIGZvcm1hdCAoUFIjNjQ1MiwgR1BSIzE0MClcblxuICAgICBXZSBpbmNsdWRlIGEgdHlwZSBDdXN0b20gb2YgXCJjdXN0b20gY29udmVydGVyc1wiLCB3aGVyZSBhblxuICAgICBhcmJpdHJhcnkgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY29udmVydCBvbmUgb3IgbW9yZVxuICAgICBhcmd1bWVudHMuIFRoZXJlIGlzIG5vIHN5bnRheCBmb3IgY3VzdG9tIGNvbnZlcnRlcnMsIGl0IGlzIG9ubHlcbiAgICAgaW50ZW5kZWQgZm9yIGN1c3RvbSBwcm9jZXNzb3JzIHRoYXQgd2lzaCB0byByZWx5IG9uIHRoZVxuICAgICBzdGRsaWItZGVmaW5lZCBmb3JtYXQgR0FEVHMuXG5cbiAgICAgRm9yIGluc3RhbmNlIGEgcHJlLXByb2Nlc3NvciBjb3VsZCBjaG9vc2UgdG8gaW50ZXJwcmV0IHN0cmluZ3NcbiAgICAgcHJlZml4ZWQgd2l0aCBbXCIhXCJdIGFzIGZvcm1hdCBzdHJpbmdzIHdoZXJlIFsle3sgLi4uIH19XSBpc1xuICAgICBhIHNwZWNpYWwgZm9ybSB0byBwYXNzIGEgdG9fc3RyaW5nIGZ1bmN0aW9uLCBzbyB0aGF0IG9uZSBjb3VsZFxuICAgICB3cml0ZTpcblxuICAgICB7W1xuICAgICAgIHR5cGUgdCA9IHsgeCA6IGludDsgeSA6IGludCB9XG5cbiAgICAgICBsZXQgc3RyaW5nX29mX3QgdCA9IFByaW50Zi5zcHJpbnRmIFwieyB4ID0gJWQ7IHkgPSAlZCB9XCIgdC54IHQueVxuXG4gICAgICAgUHJpbnRmLnByaW50ZiAhXCJ0ID0gJXt7c3RyaW5nX29mX3R9fVwiIHsgeCA9IDQyOyB5ID0gNDIgfVxuICAgICBdfVxuICAqKVxuICB8IEN1c3RvbSA6XG4gICAgICAoJ2EsICd4LCAneSkgY3VzdG9tX2FyaXR5ICogKHVuaXQgLT4gJ3gpICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIGVuZCBvZiBhIGZvcm1hdCBzcGVjaWZpY2F0aW9uICopXG4gIHwgRW5kX29mX2Zvcm1hdCA6XG4gICAgICAgICgnZiwgJ2IsICdjLCAnZSwgJ2UsICdmKSBmbXRcblxuKCoqKilcblxuKCogVHlwZSBmb3IgaWdub3JlZCBwYXJhbWV0ZXJzIChzZWUgXCIlX1wiKS4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZCA9XG4gIHwgSWdub3JlZF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9jICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2QgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfbmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbmQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfTGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZiAqKVxuICAgICAgcGFkX29wdGlvbiAqIHByZWNfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9ib29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9CICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV97Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZFxuICB8IElnbm9yZWRfcmVhZGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICgnYiAtPiAneCkgLT4gJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfW25sTkxdICopXG4gICAgICBjb3VudGVyIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8wYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcblxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgKiBzdHJpbmdcblxubGV0IHJlYyBlcmFzZV9yZWwgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYsXG4gICBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5XG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludF90eSByZXN0IC0+XG4gICAgSW50X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBOYXRpdmVpbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGVyYXNlX3JlbCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCBfdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTEsIGVyYXNlX3JlbCByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIFRoZXRhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBlIGNvbmNhdGVuYXRpb24gKilcblxuKCogQ29uY2F0ZW5hdGUgdHdvIGZvcm1hdCB0eXBlcy4gKilcbigqIFVzZWQgYnk6XG4gICAqIHJlYWRlcl9uYl91bmlmaWVyX29mX2ZtdHR5IHRvIGNvdW50IHJlYWRlcnMgaW4gYW4gZm10dHksXG4gICAqIFNjYW5mLnRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgdG8gZXh0cmFjdCByZWFkZXJzIGluc2lkZSAlKC4uLiUpLFxuICAgKiBDYW1saW50ZXJuYWxGb3JtYXQuZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgdG8gZXh0cmFjdCBmb3JtYXQgdHlwZS4gKilcblxuKCpcbmxldCByZWMgY29uY2F0X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChmLCBiLCBjLCBlLCBnLCBoKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXR0eSA9XG4qKVxubGV0IHJlYyBjb25jYXRfZm10dHkgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgICAgICBnMSBqMSBnMiBqMlxuICAuXG4gICAgKGcxLCBiMSwgYzEsIGoxLCBkMSwgYTEsXG4gICAgIGcyLCBiMiwgYzIsIGoyLCBkMiwgYTIpIGZtdHR5X3JlbCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGUxLCBmMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGUyLCBmMikgZm10dHlfcmVsID1cbmZ1biBmbXR0eTEgZm10dHkyIC0+IG1hdGNoIGZtdHR5MSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgU3RyaW5nX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIEJvb2xfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgQWxwaGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgUmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBFbmRfb2ZfZm10dHkgLT4gZm10dHkyXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0cy4gKilcbmxldCByZWMgY29uY2F0X2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXQgPVxuZnVuIGZtdDEgZm10MiAtPiBtYXRjaCBmbXQxIHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBTdHJpbmcgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBDYW1sX3N0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDMyIChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgQ2hhciAocmVzdCkgLT5cbiAgICBDaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIENhbWxfY2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIEJvb2wgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIEFscGhhIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgVGhldGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgQ3VzdG9tIChhcml0eSwgZiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgUmVhZGVyIHJlc3QgLT5cbiAgICBSZWFkZXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBGbHVzaCAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZ19saXRlcmFsIChzdHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIENoYXJfbGl0ZXJhbCAgIChjaHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnICAgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3QgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgIFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fbmV4dF9jaGFyIChyZXN0KSAtPlxuICAgIFNjYW5fbmV4dF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgSWdub3JlZF9wYXJhbSAoaWduLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgZm10MlxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJlcmFzZV9yZWwiLCJwYXJhbSIsInJlc3QiLCJ0eSIsInR5MSIsImNvbmNhdF9mbXR0eSIsImZtdHR5MSIsImZtdHR5MiIsInR5MiIsImNvbmNhdF9mbXQiLCJmbXQxIiwiZm10MiIsInBhZCIsInByZWMiLCJpY29udiIsImZjb252Iiwic3RyIiwiY2hyIiwiZm10dHkiLCJmbXRpbmdfbGl0IiwiZm10aW5nX2dlbiIsImNoYXJfc2V0Iiwid2lkdGhfb3B0IiwiY291bnRlciIsImlnbiIsImYiLCJhcml0eSIsIkNhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcyJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxVQUFBQztBQUFBQSxJQytnQlEsOEJBa0NZO0FBQUEsSUFsQ1o7QUFBQTtBQUFBLFdBQUFDLE9BQUEsVUFLSSwyQkFBZ0I7QUFBQTtBQUFBLFdBQUFBLFNBTHBCLFVBT00sNkJBQWdCO0FBQUE7QUFBQSxXQUFBQSxTQVB0QixVQVNHLDZCQUFnQjtBQUFBO0FBQUEsV0FBQUEsU0FUbkIsVUFXSyw2QkFBZ0I7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QXRCbEIsU0FnQ1AscUNBQXNCO0FBQUE7QUFBQSxXQUFBQSxVQWhDZixTQUFBYyxNQUFBO0FBQUEsT0FtQ1EsMkNBQW9CO0FBQUE7QUFBQSxXQUFBZCxVQW5DNUIsU0FBQWUsTUFBQTtBQUFBLE9BcUNRLDJDQUFvQjtBQUFBO0FBQUEsV0FBQWYsVUFyQzVCLFNBQUFnQixRQUFBLFNBQUFOLFFBQUE7QUFBQSxPQXdDYSxvREFBb0I7QUFBQTtBQUFBLFdBQUFWLFVBeENqQyxTQUFBZ0IsVUFBQSxTQUFBTixRQUFBO0FBQUEsT0EwQ2Esc0RBQW9CO0FBQUE7QUFBQSxXQUFBVixVQTFDakMsU0F3QlAsc0NBQXNCO0FBQUE7QUFBQSxXQUFBQSxVQXhCZixTQTBCUCxzQ0FBc0I7QUFBQTtBQUFBLFdBQUFBLFVBMUJmLFNBQUFpQixhQUFBO0FBQUEsT0FzRGUsa0RBQW9CO0FBQUE7QUFBQSxXQUFBakIsVUF0RG5DLFNBQUFrQixhQUFBO0FBQUEsT0F3RGUsa0RBQW9CO0FBQUE7QUFBQSxXQUFBbEIsVUF4RG5DLFNBOEJOLHNDQUFzQjtBQUFBO0FBQUEsV0FBQUEsVUE5QmhCLFNBQUFtQixXQUFBLFNBQUFDLFlBQUE7QUFBQSxPQTZDdUIsMkRBQW9CO0FBQUE7QUFBQSxXQUFBcEIsVUE3QzNDLFNBQUFxQixVQUFBO0FBQUEsT0ErQ2MsK0NBQW9CO0FBQUE7QUFBQSxXQUFBckIsVUEvQ2xDLFNBaURFLHNDQUFzQjtBQUFBO0FBQUEsV0FBQUEsVUFqRHhCLFNBQUFzQixNQUFBO0FBQUEsT0FtRE8sMkNBQW9CO0FBQUE7QUFBQSxXQUFBdEIsVUFuRDNCLFNBQUF1QixJQUFBLFNBQUFDLFFBQUE7QUFBQSxPQTRCSyxnREFBb0I7QUFBQTtBQUFBLEdBK0JsQztBQUFBLE9BQUFDLDJCRGpyQlIiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxODMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxBdG9taWMubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBHYWJyaWVsIFNjaGVyZXIsIHByb2pldCBQYXJ0b3V0LCBJTlJJQSBQYXJpcy1TYWNsYXkgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIwIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENhbWxpbnRlcm5hbEF0b21pYyBpcyBhIGRlcGVuZGVuY3kgb2YgU3RkbGliLCBzbyBpdCBpcyBjb21waWxlZCB3aXRoXG4gICAtbm9wZXJ2YXNpdmVzLiAqKVxuZXh0ZXJuYWwgKCA9PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbigqIFdlIGFyZSBub3QgcmV1c2luZyAoJ2EgcmVmKSBkaXJlY3RseSB0byBtYWtlIGl0IGVhc2llciB0byByZWFzb25cbiAgIGFib3V0IGF0b21pY2l0eSBpZiB3ZSB3aXNoIHRvOiBldmVuIGluIGEgc2VxdWVudGlhbCBpbXBsZW1lbnRhdGlvbixcbiAgIHNpZ25hbHMgYW5kIG90aGVyIGFzeW5jaHJvbm91cyBjYWxsYmFja3MgbWlnaHQgYnJlYWsgYXRvbWljaXR5LiAqKVxudHlwZSAnYSB0ID0ge211dGFibGUgdjogJ2F9XG5cbmxldCBtYWtlIHYgPSB7dn1cbmxldCBnZXQgciA9IHIudlxubGV0IHNldCByIHYgPSByLnYgPC0gdlxuXG4oKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgc2V0IHRvIG5ldmVyIGJlIGlubGluZWQ6IEZsYW1iZGEgaXNcbiAgIGFsbG93ZWQgdG8gbW92ZSBzdXJyb3VuZGluZyBjb2RlIGluc2lkZSB0aGUgY3JpdGljYWwgc2VjdGlvbixcbiAgIGluY2x1ZGluZyBhbGxvY2F0aW9ucy4gKilcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGV4Y2hhbmdlIHIgdiA9XG4gICgqIEJFR0lOIEFUT01JQyAqKVxuICBsZXQgY3VyID0gci52IGluXG4gIHIudiA8LSB2O1xuICAoKiBFTkQgQVRPTUlDICopXG4gIGN1clxuXG5sZXRbQGlubGluZSBuZXZlcl0gY29tcGFyZV9hbmRfc2V0IHIgc2VlbiB2ID1cbiAgKCogQkVHSU4gQVRPTUlDICopXG4gIGxldCBjdXIgPSByLnYgaW5cbiAgaWYgY3VyID09IHNlZW4gdGhlbiAoXG4gICAgci52IDwtIHY7XG4gICAgKCogRU5EIEFUT01JQyAqKVxuICAgIHRydWVcbiAgKSBlbHNlXG4gICAgZmFsc2VcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGZldGNoX2FuZF9hZGQgciBuID1cbiAgKCogQkVHSU4gQVRPTUlDICopXG4gIGxldCBjdXIgPSByLnYgaW5cbiAgci52IDwtIChjdXIgKyBuKTtcbiAgKCogRU5EIEFUT01JQyAqKVxuICBjdXJcblxubGV0IGluY3IgciA9IGlnbm9yZSAoZmV0Y2hfYW5kX2FkZCByIDEpXG5sZXQgZGVjciByID0gaWdub3JlIChmZXRjaF9hbmRfYWRkIHIgKC0xKSlcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwibWFrZSIsInYiLCJnZXQiLCJyIiwic2V0IiwiZXhjaGFuZ2UiLCJjdXIiLCJjb21wYXJlX2FuZF9zZXQiLCJzZWVuIiwiZmV0Y2hfYW5kX2FkZCIsIm4iLCJpbmNyIiwiZGVjciIsIkNhbWxpbnRlcm5hbEF0b21pYyJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxLQUFBQyxHQzBCYSxjQUFHO0FBQUEsWUFBQUMsSUFBQUMsR0FDSixZQUFHO0FBQUEsWUFBQUMsSUFBQUQsR0FBQUYsR0FDRCxtQkFBUTtBQUFBLFlBQUFJLFNBQUFGLEdBQUFGLE9BQUFLLE1BUXBCLE1BQ0EsVUFFQSxXQUFHO0FBQUEsWUFBQUMsZ0JBQUFKLEdBQUFLLE1BQUFQO0FBQUFBLFFBQUFLLE1BSUg7QUFBQSxJQUNBLHVDQUtPO0FBQUE7QUFBQSxZQUFBRyxjQUFBTixHQUFBTztBQUFBQSxRQUFBSixNQUlQO0FBQUEsSUFDQTtBQUFBLElBRUE7QUFBQSxHQUFHO0FBQUEsWUFBQUssS0FBQVIsR0FFZSxxQkFBbUI7QUFBQSxZQUFBUyxLQUFBVCxHQUNuQixzQkFBc0I7QUFBQTtBQUFBLElBQUFVO0FBQUFBLE1EM0QxQyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyMiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL3N0ZGxpYi5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRXhjZXB0aW9ucyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gICgqIGZvciBydW50aW1lL2ZhaWxfbmF0LmMgKilcbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQZXJ2YXNpdmVzLmFycmF5X2JvdW5kX2Vycm9yXCJcbiAgICAoSW52YWxpZF9hcmd1bWVudCBcImluZGV4IG91dCBvZiBib3VuZHNcIilcblxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZVwiXG5leHRlcm5hbCByYWlzZV9ub3RyYWNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2Vfbm90cmFjZVwiXG5cbmxldCBmYWlsd2l0aCBzID0gcmFpc2UoRmFpbHVyZSBzKVxubGV0IGludmFsaWRfYXJnIHMgPSByYWlzZShJbnZhbGlkX2FyZ3VtZW50IHMpXG5cbmV4Y2VwdGlvbiBFeGl0XG5leGNlcHRpb24gTWF0Y2hfZmFpbHVyZSA9IE1hdGNoX2ZhaWx1cmVcbmV4Y2VwdGlvbiBBc3NlcnRfZmFpbHVyZSA9IEFzc2VydF9mYWlsdXJlXG5leGNlcHRpb24gSW52YWxpZF9hcmd1bWVudCA9IEludmFsaWRfYXJndW1lbnRcbmV4Y2VwdGlvbiBGYWlsdXJlID0gRmFpbHVyZVxuZXhjZXB0aW9uIE5vdF9mb3VuZCA9IE5vdF9mb3VuZFxuZXhjZXB0aW9uIE91dF9vZl9tZW1vcnkgPSBPdXRfb2ZfbWVtb3J5XG5leGNlcHRpb24gU3RhY2tfb3ZlcmZsb3cgPSBTdGFja19vdmVyZmxvd1xuZXhjZXB0aW9uIFN5c19lcnJvciA9IFN5c19lcnJvclxuZXhjZXB0aW9uIEVuZF9vZl9maWxlID0gRW5kX29mX2ZpbGVcbmV4Y2VwdGlvbiBEaXZpc2lvbl9ieV96ZXJvID0gRGl2aXNpb25fYnlfemVyb1xuZXhjZXB0aW9uIFN5c19ibG9ja2VkX2lvID0gU3lzX2Jsb2NrZWRfaW9cbmV4Y2VwdGlvbiBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSA9IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlXG5cbigqIENvbXBvc2l0aW9uIG9wZXJhdG9ycyAqKVxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcblxuKCogRGVidWdnaW5nICopXG5cbmV4dGVybmFsIF9fTE9DX18gOiBzdHJpbmcgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fRklMRV9fIDogc3RyaW5nID0gXCIlbG9jX0ZJTEVcIlxuZXh0ZXJuYWwgX19MSU5FX18gOiBpbnQgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5leHRlcm5hbCBfX1BPU19fIDogc3RyaW5nICogaW50ICogaW50ICogaW50ID0gXCIlbG9jX1BPU1wiXG5leHRlcm5hbCBfX0ZVTkNUSU9OX18gOiBzdHJpbmcgPSBcIiVsb2NfRlVOQ1RJT05cIlxuXG5leHRlcm5hbCBfX0xPQ19PRl9fIDogJ2EgLT4gc3RyaW5nICogJ2EgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fTElORV9PRl9fIDogJ2EgLT4gaW50ICogJ2EgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX1BPU19PRl9fIDogJ2EgLT4gKHN0cmluZyAqIGludCAqIGludCAqIGludCkgKiAnYSA9IFwiJWxvY19QT1NcIlxuXG4oKiBDb21wYXJpc29ucyAqKVxuXG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoID49ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcblxubGV0IG1pbiB4IHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCAhPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxXCJcblxuKCogQm9vbGVhbiBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggb3IgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcblxuKCogSW50ZWdlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgKCB+KyApIDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCAoIG1vZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcblxuZXh0ZXJuYWwgKCBsYW5kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCAoIGx4b3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcblxubGV0IGxub3QgeCA9IHggbHhvciAoLTEpXG5cbmV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcblxubGV0IG1heF9pbnQgPSAoLTEpIGxzciAxXG5sZXQgbWluX2ludCA9IG1heF9pbnQgKyAxXG5cbigqIEZsb2F0aW5nLXBvaW50IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LS4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgKCB+Ky4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCArLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCAoIC0uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsICggKi4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgKCAvLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCAoICoqICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9wb3dlcl9mbG9hdFwiIFwicG93XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zaF9mbG9hdFwiIFwiY2FtbF9hY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbmhfZmxvYXRcIiBcImNhbWxfYXNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuaF9mbG9hdFwiIFwiY2FtbF9hdGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnNfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG5leHRlcm5hbCBmbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgaW50X29mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxubGV0IGluZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5lZ19pbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHhGRl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuYW4gPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDFMXG5sZXQgbWF4X2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0VGX0ZGX0ZGX0ZGX0ZGX0ZGX0ZGTFxubGV0IG1pbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgwMF8xMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBlcHNpbG9uX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDNDX0IwXzAwXzAwXzAwXzAwXzAwXzAwTFxuXG50eXBlIGZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cblxuKCogU3RyaW5nIGFuZCBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGVzIFN0cmluZyBhbmQgQnl0ZXMgKilcblxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2xlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19jcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHN0cmluZ19ibGl0IDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgKCBeICkgczEgczIgPVxuICBsZXQgbDEgPSBzdHJpbmdfbGVuZ3RoIHMxIGFuZCBsMiA9IHN0cmluZ19sZW5ndGggczIgaW5cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgKGwxICsgbDIpIGluXG4gIHN0cmluZ19ibGl0IHMxIDAgcyAwIGwxO1xuICBzdHJpbmdfYmxpdCBzMiAwIHMgbDEgbDI7XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBDaGFyICopXG5cbmV4dGVybmFsIGludF9vZl9jaGFyIDogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB1bnNhZmVfY2hhcl9vZl9pbnQgOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcbmxldCBjaGFyX29mX2ludCBuID1cbiAgaWYgbiA8IDAgfHwgbiA+IDI1NSB0aGVuIGludmFsaWRfYXJnIFwiY2hhcl9vZl9pbnRcIiBlbHNlIHVuc2FmZV9jaGFyX29mX2ludCBuXG5cbigqIFVuaXQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogUGFpciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGZzdCA6ICdhICogJ2IgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgc25kIDogJ2EgKiAnYiAtPiAnYiA9IFwiJWZpZWxkMVwiXG5cbigqIFJlZmVyZW5jZXMgKilcblxudHlwZSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5leHRlcm5hbCBpbmNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlaW5jclwiXG5leHRlcm5hbCBkZWNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlZGVjclwiXG5cbigqIFJlc3VsdCB0eXBlICopXG5cbnR5cGUgKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiXG5cbigqIFN0cmluZyBjb252ZXJzaW9uIGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbmxldCBzdHJpbmdfb2ZfYm9vbCBiID1cbiAgaWYgYiB0aGVuIFwidHJ1ZVwiIGVsc2UgXCJmYWxzZVwiXG5sZXQgYm9vbF9vZl9zdHJpbmcgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBfIC0+IGludmFsaWRfYXJnIFwiYm9vbF9vZl9zdHJpbmdcIlxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0ID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiBTb21lIHRydWVcbiAgfCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxuICB8IF8gLT4gTm9uZVxuXG5sZXQgc3RyaW5nX29mX2ludCBuID1cbiAgZm9ybWF0X2ludCBcIiVkXCIgblxuXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuZXh0ZXJuYWwgc3RyaW5nX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5cbmxldCB2YWxpZF9mbG9hdF9sZXhlbSBzID1cbiAgbGV0IGwgPSBzdHJpbmdfbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPj0gbCB0aGVuIHMgXiBcIi5cIiBlbHNlXG4gICAgbWF0Y2ggc3RyaW5nX2dldCBzIGkgd2l0aFxuICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBsb29wIChpICsgMSlcbiAgICB8IF8gLT4gc1xuICBpblxuICBsb29wIDBcblxubGV0IHN0cmluZ19vZl9mbG9hdCBmID0gdmFsaWRfZmxvYXRfbGV4ZW0gKGZvcm1hdF9mbG9hdCBcIiUuMTJnXCIgZilcblxuZXh0ZXJuYWwgZmxvYXRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgTGlzdCAqKVxuXG5sZXQgcmVjICggQCApIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgaGQgOjogdGwgLT4gaGQgOjogKHRsIEAgbDIpXG5cbigqIEkvTyBvcGVyYXRpb25zICopXG5cbnR5cGUgaW5fY2hhbm5lbFxudHlwZSBvdXRfY2hhbm5lbFxuXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDogaW50IC0+IG91dF9jaGFubmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcIlxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX2luIDogaW50IC0+IGluX2NoYW5uZWwgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXCJcblxubGV0IHN0ZGluID0gb3Blbl9kZXNjcmlwdG9yX2luIDBcbmxldCBzdGRvdXQgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDFcbmxldCBzdGRlcnIgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDJcblxuKCogR2VuZXJhbCBvdXRwdXQgZnVuY3Rpb25zICopXG5cbnR5cGUgb3Blbl9mbGFnID1cbiAgICBPcGVuX3Jkb25seSB8IE9wZW5fd3Jvbmx5IHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0IHwgT3Blbl90cnVuYyB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5IHwgT3Blbl90ZXh0IHwgT3Blbl9ub25ibG9ja1xuXG5leHRlcm5hbCBvcGVuX2Rlc2MgOiBzdHJpbmcgLT4gb3Blbl9mbGFnIGxpc3QgLT4gaW50IC0+IGludCA9IFwiY2FtbF9zeXNfb3BlblwiXG5cbmV4dGVybmFsIHNldF9vdXRfY2hhbm5lbF9uYW1lOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5fb3V0X2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX291dChvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9vdXRfY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9vdXQgbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fdGV4dF0gMG82NjYgbmFtZVxuXG5sZXQgb3Blbl9vdXRfYmluIG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX2JpbmFyeV0gMG82NjYgbmFtZVxuXG5leHRlcm5hbCBmbHVzaCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfZmx1c2hcIlxuXG5leHRlcm5hbCBvdXRfY2hhbm5lbHNfbGlzdCA6IHVuaXQgLT4gb3V0X2NoYW5uZWwgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3RcIlxuXG5sZXQgZmx1c2hfYWxsICgpID1cbiAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIFtdIC0+ICgpXG4gICAgfCBhOjpsIC0+XG4gICAgICAgIGJlZ2luIHRyeVxuICAgICAgICAgICAgZmx1c2ggYVxuICAgICAgICB3aXRoIFN5c19lcnJvciBfIC0+XG4gICAgICAgICAgKCkgKCogaWdub3JlIGNoYW5uZWxzIGNsb3NlZCBkdXJpbmcgYSBwcmVjZWRpbmcgZmx1c2guICopXG4gICAgICAgIGVuZDtcbiAgICAgICAgaXRlciBsXG4gIGluIGl0ZXIgKG91dF9jaGFubmVsc19saXN0ICgpKVxuXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0IDogb3V0X2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dF9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0X3N0cmluZyA6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dFwiXG5cbmV4dGVybmFsIG91dHB1dF9jaGFyIDogb3V0X2NoYW5uZWwgLT4gY2hhciAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcblxubGV0IG91dHB1dF9ieXRlcyBvYyBzID1cbiAgdW5zYWZlX291dHB1dCBvYyBzIDAgKGJ5dGVzX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0X3N0cmluZyBvYyBzID1cbiAgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyAwIChzdHJpbmdfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXQgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXQgb2MgcyBvZnMgbGVuXG5cbmxldCBvdXRwdXRfc3Vic3RyaW5nIG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBzdHJpbmdfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dF9zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgb2ZzIGxlblxuXG5leHRlcm5hbCBvdXRwdXRfYnl0ZSA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcbmV4dGVybmFsIG91dHB1dF9iaW5hcnlfaW50IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2ludFwiXG5cbmV4dGVybmFsIG1hcnNoYWxfdG9fY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+ICdhIC0+IHVuaXQgbGlzdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5sZXQgb3V0cHV0X3ZhbHVlIGNoYW4gdiA9IG1hcnNoYWxfdG9fY2hhbm5lbCBjaGFuIHYgW11cblxuZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dFwiXG5leHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19vdXRcIlxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9vdXRfY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2Vfb3V0IG9jID0gZmx1c2ggb2M7IGNsb3NlX291dF9jaGFubmVsIG9jXG5sZXQgY2xvc2Vfb3V0X25vZXJyIG9jID1cbiAgKHRyeSBmbHVzaCBvYyB3aXRoIF8gLT4gKCkpO1xuICAodHJ5IGNsb3NlX291dF9jaGFubmVsIG9jIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9vdXQgOiBvdXRfY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogR2VuZXJhbCBpbnB1dCBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgc2V0X2luX2NoYW5uZWxfbmFtZTogaW5fY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5faW5fZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3JfaW4ob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfaW5fY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9pbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX3RleHRdIDAgbmFtZVxuXG5sZXQgb3Blbl9pbl9iaW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl9iaW5hcnldIDAgbmFtZVxuXG5leHRlcm5hbCBpbnB1dF9jaGFyIDogaW5fY2hhbm5lbCAtPiBjaGFyID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuXG5leHRlcm5hbCB1bnNhZmVfaW5wdXQgOiBpbl9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfaW5wdXRcIlxuXG5sZXQgaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJpbnB1dFwiXG4gIGVsc2UgdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVjIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgbGVuIDw9IDAgdGhlbiAoKSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuIGluXG4gICAgaWYgciA9IDBcbiAgICB0aGVuIHJhaXNlIEVuZF9vZl9maWxlXG4gICAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgKG9mcyArIHIpIChsZW4gLSByKVxuICBlbmRcblxubGV0IHJlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcInJlYWxseV9pbnB1dFwiXG4gIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYWxseV9pbnB1dF9zdHJpbmcgaWMgbGVuID1cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgbGVuIGluXG4gIHJlYWxseV9pbnB1dCBpYyBzIDAgbGVuO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuZXh0ZXJuYWwgaW5wdXRfc2Nhbl9saW5lIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXCJcblxubGV0IGlucHV0X2xpbmUgY2hhbiA9XG4gIGxldCByZWMgYnVpbGRfcmVzdWx0IGJ1ZiBwb3MgPSBmdW5jdGlvblxuICAgIFtdIC0+IGJ1ZlxuICB8IGhkIDo6IHRsIC0+XG4gICAgICBsZXQgbGVuID0gYnl0ZXNfbGVuZ3RoIGhkIGluXG4gICAgICBieXRlc19ibGl0IGhkIDAgYnVmIChwb3MgLSBsZW4pIGxlbjtcbiAgICAgIGJ1aWxkX3Jlc3VsdCBidWYgKHBvcyAtIGxlbikgdGwgaW5cbiAgbGV0IHJlYyBzY2FuIGFjY3UgbGVuID1cbiAgICBsZXQgbiA9IGlucHV0X3NjYW5fbGluZSBjaGFuIGluXG4gICAgaWYgbiA9IDAgdGhlbiBiZWdpbiAgICAgICAgICAgICAgICAgICAoKiBuID0gMDogd2UgYXJlIGF0IEVPRiAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJhaXNlIEVuZF9vZl9maWxlXG4gICAgICB8IF8gIC0+IGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIGFjY3VcbiAgICBlbmQgZWxzZSBpZiBuID4gMCB0aGVuIGJlZ2luICAgICAgICAgICgqIG4gPiAwOiBuZXdsaW5lIGZvdW5kIGluIGJ1ZmZlciAqKVxuICAgICAgbGV0IHJlcyA9IGJ5dGVzX2NyZWF0ZSAobiAtIDEpIGluXG4gICAgICBpZ25vcmUgKHVuc2FmZV9pbnB1dCBjaGFuIHJlcyAwIChuIC0gMSkpO1xuICAgICAgaWdub3JlIChpbnB1dF9jaGFyIGNoYW4pOyAgICAgICAgICAgKCogc2tpcCB0aGUgbmV3bGluZSAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJlc1xuICAgICAgfCAgXyAtPiBsZXQgbGVuID0gbGVuICsgbiAtIDEgaW5cbiAgICAgICAgICAgICAgYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gKHJlcyA6OiBhY2N1KVxuICAgIGVuZCBlbHNlIGJlZ2luICAgICAgICAgICAgICAgICAgICAgICAgKCogbiA8IDA6IG5ld2xpbmUgbm90IGZvdW5kICopXG4gICAgICBsZXQgYmVnID0gYnl0ZXNfY3JlYXRlICgtbikgaW5cbiAgICAgIGlnbm9yZSh1bnNhZmVfaW5wdXQgY2hhbiBiZWcgMCAoLW4pKTtcbiAgICAgIHNjYW4gKGJlZyA6OiBhY2N1KSAobGVuIC0gbilcbiAgICBlbmRcbiAgaW4gYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyAoc2NhbiBbXSAwKVxuXG5leHRlcm5hbCBpbnB1dF9ieXRlIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5leHRlcm5hbCBpbnB1dF9iaW5hcnlfaW50IDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfaW50XCJcbmV4dGVybmFsIGlucHV0X3ZhbHVlIDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXCJcbmV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19pblwiXG5leHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9pbl9ub2VyciBpYyA9ICh0cnkgY2xvc2VfaW4gaWMgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX2luIDogaW5fY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIG91dHB1dCAqKVxuXG5sZXQgcHJpbnRfY2hhciBjID0gb3V0cHV0X2NoYXIgc3Rkb3V0IGNcbmxldCBwcmludF9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IHNcbmxldCBwcmludF9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZG91dCBzXG5sZXQgcHJpbnRfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByaW50X2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJpbnRfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRvdXQgczsgb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcbmxldCBwcmludF9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBlcnJvciAqKVxuXG5sZXQgcHJlcnJfY2hhciBjID0gb3V0cHV0X2NoYXIgc3RkZXJyIGNcbmxldCBwcmVycl9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIHNcbmxldCBwcmVycl9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZGVyciBzXG5sZXQgcHJlcnJfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByZXJyX2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJlcnJfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRlcnIgczsgb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcbmxldCBwcmVycl9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcblxuKCogSW5wdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGlucHV0ICopXG5cbmxldCByZWFkX2xpbmUgKCkgPSBmbHVzaCBzdGRvdXQ7IGlucHV0X2xpbmUgc3RkaW5cbmxldCByZWFkX2ludCAoKSA9IGludF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9pbnRfb3B0ICgpID0gaW50X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdCAoKSA9IGZsb2F0X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0X29wdCAoKSA9IGZsb2F0X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5cbigqIE9wZXJhdGlvbnMgb24gbGFyZ2UgZmlsZXMgKilcblxubW9kdWxlIExhcmdlRmlsZSA9XG4gIHN0cnVjdFxuICAgIGV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dF82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19vdXRfNjRcIlxuICAgIGV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludDY0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gICAgZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXzY0XCJcbiAgICBleHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19pbl82NFwiXG4gICAgZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gIGVuZFxuXG4oKiBGb3JtYXRzICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgID0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG4gICA9IEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZtdFxuICAgICAgICAgICAgICAgKiBzdHJpbmdcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2MsICdjLCAnZCkgZm9ybWF0NlxuXG50eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYywgJ2MpIGZvcm1hdDRcblxubGV0IHN0cmluZ19vZl9mb3JtYXQgKEZvcm1hdCAoX2ZtdCwgc3RyKSkgPSBzdHJcblxuZXh0ZXJuYWwgZm9ybWF0X29mX3N0cmluZyA6XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9IFwiJWlkZW50aXR5XCJcblxubGV0ICggXl4gKSAoRm9ybWF0IChmbXQxLCBzdHIxKSkgKEZvcm1hdCAoZm10Miwgc3RyMikpID1cbiAgRm9ybWF0IChDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuY29uY2F0X2ZtdCBmbXQxIGZtdDIsXG4gICAgICAgICAgc3RyMSBeIFwiJSxcIiBeIHN0cjIpXG5cbigqIE1pc2NlbGxhbmVvdXMgKilcblxuZXh0ZXJuYWwgc3lzX2V4aXQgOiBpbnQgLT4gJ2EgPSBcImNhbWxfc3lzX2V4aXRcIlxuXG5sZXQgZXhpdF9mdW5jdGlvbiA9IENhbWxpbnRlcm5hbEF0b21pYy5tYWtlIGZsdXNoX2FsbFxuXG5sZXQgcmVjIGF0X2V4aXQgZiA9XG4gIGxldCBtb2R1bGUgQXRvbWljID0gQ2FtbGludGVybmFsQXRvbWljIGluXG4gICgqIE1QUiM3MjUzLCBNUFIjNzc5NjogbWFrZSBzdXJlIFwiZlwiIGlzIGV4ZWN1dGVkIG9ubHkgb25jZSAqKVxuICBsZXQgZl95ZXRfdG9fcnVuID0gQXRvbWljLm1ha2UgdHJ1ZSBpblxuICBsZXQgb2xkX2V4aXQgPSBBdG9taWMuZ2V0IGV4aXRfZnVuY3Rpb24gaW5cbiAgbGV0IG5ld19leGl0ICgpID1cbiAgICBpZiBBdG9taWMuY29tcGFyZV9hbmRfc2V0IGZfeWV0X3RvX3J1biB0cnVlIGZhbHNlIHRoZW4gZiAoKSA7XG4gICAgb2xkX2V4aXQgKClcbiAgaW5cbiAgbGV0IHN1Y2Nlc3MgPSBBdG9taWMuY29tcGFyZV9hbmRfc2V0IGV4aXRfZnVuY3Rpb24gb2xkX2V4aXQgbmV3X2V4aXQgaW5cbiAgaWYgbm90IHN1Y2Nlc3MgdGhlbiBhdF9leGl0IGZcblxubGV0IGRvX2F0X2V4aXQgKCkgPSAoQ2FtbGludGVybmFsQXRvbWljLmdldCBleGl0X2Z1bmN0aW9uKSAoKVxuXG5sZXQgZXhpdCByZXRjb2RlID1cbiAgZG9fYXRfZXhpdCAoKTtcbiAgc3lzX2V4aXQgcmV0Y29kZVxuXG5sZXQgXyA9IHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIgZG9fYXRfZXhpdFxuXG5leHRlcm5hbCBtYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19tYWpvclwiXG5leHRlcm5hbCBuYWtlZF9wb2ludGVyc19jaGVja2VkIDogdW5pdCAtPiBib29sXG4gID0gXCJjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkXCJcbmxldCAoKSA9IGlmIG5ha2VkX3BvaW50ZXJzX2NoZWNrZWQgKCkgdGhlbiBhdF9leGl0IG1ham9yXG5cbigqTU9EVUxFX0FMSUFTRVMqKVxubW9kdWxlIEFyZyAgICAgICAgICA9IEFyZ1xubW9kdWxlIEFycmF5ICAgICAgICA9IEFycmF5XG5tb2R1bGUgQXJyYXlMYWJlbHMgID0gQXJyYXlMYWJlbHNcbm1vZHVsZSBBdG9taWMgICAgICAgPSBBdG9taWNcbm1vZHVsZSBCaWdhcnJheSAgICAgPSBCaWdhcnJheVxubW9kdWxlIEJvb2wgICAgICAgICA9IEJvb2xcbm1vZHVsZSBCdWZmZXIgICAgICAgPSBCdWZmZXJcbm1vZHVsZSBCeXRlcyAgICAgICAgPSBCeXRlc1xubW9kdWxlIEJ5dGVzTGFiZWxzICA9IEJ5dGVzTGFiZWxzXG5tb2R1bGUgQ2FsbGJhY2sgICAgID0gQ2FsbGJhY2tcbm1vZHVsZSBDaGFyICAgICAgICAgPSBDaGFyXG5tb2R1bGUgQ29tcGxleCAgICAgID0gQ29tcGxleFxubW9kdWxlIERpZ2VzdCAgICAgICA9IERpZ2VzdFxubW9kdWxlIEVpdGhlciAgICAgICA9IEVpdGhlclxubW9kdWxlIEVwaGVtZXJvbiAgICA9IEVwaGVtZXJvblxubW9kdWxlIEZpbGVuYW1lICAgICA9IEZpbGVuYW1lXG5tb2R1bGUgRmxvYXQgICAgICAgID0gRmxvYXRcbm1vZHVsZSBGb3JtYXQgICAgICAgPSBGb3JtYXRcbm1vZHVsZSBGdW4gICAgICAgICAgPSBGdW5cbm1vZHVsZSBHYyAgICAgICAgICAgPSBHY1xubW9kdWxlIEdlbmxleCAgICAgICA9IEdlbmxleFxubW9kdWxlIEhhc2h0YmwgICAgICA9IEhhc2h0Ymxcbm1vZHVsZSBJbl9jaGFubmVsICAgPSBJbl9jaGFubmVsXG5tb2R1bGUgSW50ICAgICAgICAgID0gSW50XG5tb2R1bGUgSW50MzIgICAgICAgID0gSW50MzJcbm1vZHVsZSBJbnQ2NCAgICAgICAgPSBJbnQ2NFxubW9kdWxlIExhenkgICAgICAgICA9IExhenlcbm1vZHVsZSBMZXhpbmcgICAgICAgPSBMZXhpbmdcbm1vZHVsZSBMaXN0ICAgICAgICAgPSBMaXN0XG5tb2R1bGUgTGlzdExhYmVscyAgID0gTGlzdExhYmVsc1xubW9kdWxlIE1hcCAgICAgICAgICA9IE1hcFxubW9kdWxlIE1hcnNoYWwgICAgICA9IE1hcnNoYWxcbm1vZHVsZSBNb3JlTGFiZWxzICAgPSBNb3JlTGFiZWxzXG5tb2R1bGUgTmF0aXZlaW50ICAgID0gTmF0aXZlaW50XG5tb2R1bGUgT2JqICAgICAgICAgID0gT2JqXG5tb2R1bGUgT28gICAgICAgICAgID0gT29cbm1vZHVsZSBPcHRpb24gICAgICAgPSBPcHRpb25cbm1vZHVsZSBPdXRfY2hhbm5lbCAgPSBPdXRfY2hhbm5lbFxubW9kdWxlIFBhcnNpbmcgICAgICA9IFBhcnNpbmdcbm1vZHVsZSBQZXJ2YXNpdmVzICAgPSBQZXJ2YXNpdmVzXG5tb2R1bGUgUHJpbnRleGMgICAgID0gUHJpbnRleGNcbm1vZHVsZSBQcmludGYgICAgICAgPSBQcmludGZcbm1vZHVsZSBRdWV1ZSAgICAgICAgPSBRdWV1ZVxubW9kdWxlIFJhbmRvbSAgICAgICA9IFJhbmRvbVxubW9kdWxlIFJlc3VsdCAgICAgICA9IFJlc3VsdFxubW9kdWxlIFNjYW5mICAgICAgICA9IFNjYW5mXG5tb2R1bGUgU2VxICAgICAgICAgID0gU2VxXG5tb2R1bGUgU2V0ICAgICAgICAgID0gU2V0XG5tb2R1bGUgU3RhY2sgICAgICAgID0gU3RhY2tcbm1vZHVsZSBTdGRMYWJlbHMgICAgPSBTdGRMYWJlbHNcbm1vZHVsZSBTdHJlYW0gICAgICAgPSBTdHJlYW1cbm1vZHVsZSBTdHJpbmcgICAgICAgPSBTdHJpbmdcbm1vZHVsZSBTdHJpbmdMYWJlbHMgPSBTdHJpbmdMYWJlbHNcbm1vZHVsZSBTeXMgICAgICAgICAgPSBTeXNcbm1vZHVsZSBVY2hhciAgICAgICAgPSBVY2hhclxubW9kdWxlIFVuaXQgICAgICAgICA9IFVuaXRcbm1vZHVsZSBXZWFrICAgICAgICAgPSBXZWFrXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9mYWxzZSIsImNzdF90cnVlIiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX2Zsb2F0X29mX3N0cmluZyIsImNhbWxfaW50X29mX3N0cmluZyIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbWxfYnl0ZXNfbGVuZ3RoIiwiY2FtbF9tbF9jaGFubmVsX3NpemUiLCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NCIsImNhbWxfbWxfY2xvc2VfY2hhbm5lbCIsImNhbWxfbWxfZmx1c2giLCJjYW1sX21sX2lucHV0IiwiY2FtbF9tbF9pbnB1dF9jaGFyIiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4iLCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQiLCJjYW1sX21sX291dHB1dCIsImNhbWxfbWxfb3V0cHV0X2J5dGVzIiwiY2FtbF9tbF9vdXRwdXRfY2hhciIsImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlIiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfY29uY2F0IiwiY2FtbF9zdHJpbmdfb2ZfYnl0ZXMiLCJjYW1sX3N5c19vcGVuIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJnbG9iYWxfZGF0YSIsIkNhbWxpbnRlcm5hbEF0b21pYyIsIkNhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcyIsIkludmFsaWRfYXJndW1lbnQiLCJGYWlsdXJlIiwiTWF0Y2hfZmFpbHVyZSIsIkFzc2VydF9mYWlsdXJlIiwiTm90X2ZvdW5kIiwiT3V0X29mX21lbW9yeSIsIlN0YWNrX292ZXJmbG93IiwiU3lzX2Vycm9yIiwiRW5kX29mX2ZpbGUiLCJEaXZpc2lvbl9ieV96ZXJvIiwiU3lzX2Jsb2NrZWRfaW8iLCJVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSIsImZhaWx3aXRoIiwicyIsImludmFsaWRfYXJnIiwiRXhpdCIsIm1pbiIsIngiLCJ5IiwibWF4IiwiYWJzIiwibG5vdCIsInN5bWJvbF9jb25jYXQiLCJjc3RfY2hhcl9vZl9pbnQiLCJjc3RfYm9vbF9vZl9zdHJpbmciLCJjaGFyX29mX2ludCIsIm4iLCJzdHJpbmdfb2ZfYm9vbCIsImIiLCJib29sX29mX3N0cmluZyIsInBhcmFtIiwiYm9vbF9vZl9zdHJpbmdfb3B0Iiwic3RyaW5nX29mX2ludCIsImludF9vZl9zdHJpbmdfb3B0IiwiZXhuIiwidGFnIiwidmFsaWRfZmxvYXRfbGV4ZW0iLCJzMSIsImwiLCJpIiwibWF0Y2giLCJzdHJpbmdfb2ZfZmxvYXQiLCJmbG9hdF9vZl9zdHJpbmdfb3B0Iiwic3ltYm9sIiwibDEiLCJsMiIsInRsIiwiaGQiLCJzdGRpbiIsInN0ZG91dCIsInN0ZGVyciIsImNzdF9vdXRwdXQiLCJjc3Rfb3V0cHV0X3N1YnN0cmluZyIsImNzdF9pbnB1dCIsImNzdF9yZWFsbHlfaW5wdXQiLCJvcGVuX291dF9nZW4iLCJtb2RlIiwicGVybSIsIm5hbWUiLCJjIiwib3Blbl9vdXQiLCJvcGVuX291dF9iaW4iLCJmbHVzaF9hbGwiLCJhIiwib3V0cHV0X2J5dGVzIiwib2MiLCJvdXRwdXRfc3RyaW5nIiwib3V0cHV0Iiwib2ZzIiwibGVuIiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF92YWx1ZSIsImNoYW4iLCJ2IiwiY2xvc2Vfb3V0IiwiY2xvc2Vfb3V0X25vZXJyIiwib3Blbl9pbl9nZW4iLCJvcGVuX2luIiwib3Blbl9pbl9iaW4iLCJpbnB1dCIsImljIiwidW5zYWZlX3JlYWxseV9pbnB1dCIsInIiLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfc3RyaW5nIiwiaW5wdXRfbGluZSIsImJ1aWxkX3Jlc3VsdCIsImJ1ZiIsInBvcyIsImFjY3UiLCJiZWciLCJyZXMiLCJjbG9zZV9pbl9ub2VyciIsInByaW50X2NoYXIiLCJwcmludF9zdHJpbmciLCJwcmludF9ieXRlcyIsInByaW50X2ludCIsInByaW50X2Zsb2F0IiwicHJpbnRfZW5kbGluZSIsInByaW50X25ld2xpbmUiLCJwcmVycl9jaGFyIiwicHJlcnJfc3RyaW5nIiwicHJlcnJfYnl0ZXMiLCJwcmVycl9pbnQiLCJwcmVycl9mbG9hdCIsInByZXJyX2VuZGxpbmUiLCJwcmVycl9uZXdsaW5lIiwicmVhZF9saW5lIiwicmVhZF9pbnQiLCJyZWFkX2ludF9vcHQiLCJyZWFkX2Zsb2F0IiwicmVhZF9mbG9hdF9vcHQiLCJzdHJpbmdfb2ZfZm9ybWF0Iiwic3RyIiwic3RyMiIsImZtdDIiLCJzdHIxIiwiZm10MSIsInMyIiwiZXhpdF9mdW5jdGlvbiIsImF0X2V4aXQiLCJmX3lldF90b19ydW4iLCJvbGRfZXhpdCIsIm5ld19leGl0Iiwic3VjY2VzcyIsImRvX2F0X2V4aXQiLCJleGl0IiwicmV0Y29kZSIsIlN0ZGxpYiJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMs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NjcyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsImludmFsaWRfYXJnIiwiZmFpbHdpdGgiLCJFeGl0IiwibWluIiwibWF4IiwiYWJzIiwibWF4X2ludCIsIm1pbl9pbnQiLCJsbm90IiwiaW5maW5pdHkiLCJuZWdfaW5maW5pdHkiLCJuYW4iLCJtYXhfZmxvYXQiLCJtaW5fZmxvYXQiLCJlcHNpbG9uX2Zsb2F0Iiwic3ltYm9sX2NvbmNhdCIsImNoYXJfb2ZfaW50Iiwic3RyaW5nX29mX2Jvb2wiLCJib29sX29mX3N0cmluZyIsImJvb2xfb2Zfc3RyaW5nX29wdCIsInN0cmluZ19vZl9pbnQiLCJpbnRfb2Zfc3RyaW5nX29wdCIsInN0cmluZ19vZl9mbG9hdCIsImZsb2F0X29mX3N0cmluZ19vcHQiLCJzeW1ib2wiLCJzdGRpbiIsInN0ZG91dCIsInN0ZGVyciIsInByaW50X2NoYXIiLCJwcmludF9zdHJpbmciLCJwcmludF9ieXRlcyIsInByaW50X2ludCIsInByaW50X2Zsb2F0IiwicHJpbnRfZW5kbGluZSIsInByaW50X25ld2xpbmUiLCJwcmVycl9jaGFyIiwicHJlcnJfc3RyaW5nIiwicHJlcnJfYnl0ZXMiLCJwcmVycl9pbnQiLCJwcmVycl9mbG9hdCIsInByZXJyX2VuZGxpbmUiLCJwcmVycl9uZXdsaW5lIiwicmVhZF9saW5lIiwicmVhZF9pbnQiLCJyZWFkX2ludF9vcHQiLCJyZWFkX2Zsb2F0IiwicmVhZF9mbG9hdF9vcHQiLCJvcGVuX291dCIsIm9wZW5fb3V0X2JpbiIsIm9wZW5fb3V0X2dlbiIsImZsdXNoIiwiZmx1c2hfYWxsIiwib3V0cHV0X2NoYXIiLCJvdXRwdXRfc3RyaW5nIiwib3V0cHV0X2J5dGVzIiwib3V0cHV0Iiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF9ieXRlIiwib3V0cHV0X2JpbmFyeV9pbnQiLCJvdXRwdXRfdmFsdWUiLCJzZWVrX291dCIsInBvc19vdXQiLCJvdXRfY2hhbm5lbF9sZW5ndGgiLCJjbG9zZV9vdXQiLCJjbG9zZV9vdXRfbm9lcnIiLCJzZXRfYmluYXJ5X21vZGVfb3V0Iiwib3Blbl9pbiIsIm9wZW5faW5fYmluIiwib3Blbl9pbl9nZW4iLCJpbnB1dF9jaGFyIiwiaW5wdXRfbGluZSIsImlucHV0IiwicmVhbGx5X2lucHV0IiwicmVhbGx5X2lucHV0X3N0cmluZyIsImlucHV0X2J5dGUiLCJpbnB1dF9iaW5hcnlfaW50IiwiaW5wdXRfdmFsdWUiLCJzZWVrX2luIiwicG9zX2luIiwiaW5fY2hhbm5lbF9sZW5ndGgiLCJjbG9zZV9pbiIsImNsb3NlX2luX25vZXJyIiwic2V0X2JpbmFyeV9tb2RlX2luIiwic3RyaW5nX29mX2Zvcm1hdCIsImV4aXQiLCJhdF9leGl0IiwidmFsaWRfZmxvYXRfbGV4ZW0iLCJkb19hdF9leGl0IiwiU3RkbGliX1BlcnZhc2l2ZXMiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUEzRCxXQUFBO0FBQUEsSUFBQTRELE9BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjg2NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL2VpdGhlci5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgR2FicmllbCBTY2hlcmVyLCBwcm9qZXQgUGFyc2lmYWwsIElOUklBIFNhY2xheSAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTkgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAoJ2EsICdiKSB0ID0gTGVmdCBvZiAnYSB8IFJpZ2h0IG9mICdiXG5cbmxldCBsZWZ0IHYgPSBMZWZ0IHZcbmxldCByaWdodCB2ID0gUmlnaHQgdlxuXG5sZXQgaXNfbGVmdCA9IGZ1bmN0aW9uXG58IExlZnQgXyAtPiB0cnVlXG58IFJpZ2h0IF8gLT4gZmFsc2VcblxubGV0IGlzX3JpZ2h0ID0gZnVuY3Rpb25cbnwgTGVmdCBfIC0+IGZhbHNlXG58IFJpZ2h0IF8gLT4gdHJ1ZVxuXG5sZXQgZmluZF9sZWZ0ID0gZnVuY3Rpb25cbnwgTGVmdCB2IC0+IFNvbWUgdlxufCBSaWdodCBfIC0+IE5vbmVcblxubGV0IGZpbmRfcmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IF8gLT4gTm9uZVxufCBSaWdodCB2IC0+IFNvbWUgdlxuXG5sZXQgbWFwX2xlZnQgZiA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBMZWZ0IChmIHYpXG58IFJpZ2h0IF8gYXMgZSAtPiBlXG5cbmxldCBtYXBfcmlnaHQgZiA9IGZ1bmN0aW9uXG58IExlZnQgXyBhcyBlIC0+IGVcbnwgUmlnaHQgdiAtPiBSaWdodCAoZiB2KVxuXG5sZXQgbWFwIH5sZWZ0IH5yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBMZWZ0IChsZWZ0IHYpXG58IFJpZ2h0IHYgLT4gUmlnaHQgKHJpZ2h0IHYpXG5cbmxldCBmb2xkIH5sZWZ0IH5yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBsZWZ0IHZcbnwgUmlnaHQgdiAtPiByaWdodCB2XG5cbmxldCBpdGVyID0gZm9sZFxuXG5sZXQgZm9yX2FsbCA9IGZvbGRcblxubGV0IGVxdWFsIH5sZWZ0IH5yaWdodCBlMSBlMiA9IG1hdGNoIGUxLCBlMiB3aXRoXG58IExlZnQgdjEsIExlZnQgdjIgLT4gbGVmdCB2MSB2MlxufCBSaWdodCB2MSwgUmlnaHQgdjIgLT4gcmlnaHQgdjEgdjJcbnwgTGVmdCBfLCBSaWdodCBfIHwgUmlnaHQgXywgTGVmdCBfIC0+IGZhbHNlXG5cbmxldCBjb21wYXJlIH5sZWZ0IH5yaWdodCBlMSBlMiA9IG1hdGNoIGUxLCBlMiB3aXRoXG58IExlZnQgdjEsIExlZnQgdjIgLT4gbGVmdCB2MSB2MlxufCBSaWdodCB2MSwgUmlnaHQgdjIgLT4gcmlnaHQgdjEgdjJcbnwgTGVmdCBfLCBSaWdodCBfIC0+ICgtMSlcbnwgUmlnaHQgXywgTGVmdCBfIC0+IDFcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImxlZnQiLCJ2IiwicmlnaHQiLCJpc19sZWZ0IiwicGFyYW0iLCJpc19yaWdodCIsImZpbmRfbGVmdCIsImZpbmRfcmlnaHQiLCJtYXBfbGVmdCIsImUiLCJtYXBfcmlnaHQiLCJtYXAiLCJmb2xkIiwiZXF1YWwiLCJlMSIsImUyIiwidjEiLCJ2MiIsImNvbXBhcmUiLCJTdGRsaWJfRWl0aGVyIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsS0FBQUMsR0NpQmEsY0FBTTtBQUFBLFlBQUFDLE1BQUFELEdBQ0wsY0FBTztBQUFBLFlBQUFFLFFBQUFDLE9BRVAsNkJBRUk7QUFBQSxZQUFBQyxTQUFBRCxPQUVILDZCQUVFO0FBQUEsWUFBQUUsVUFBQUY7QUFBQUEsSUFFRCxtQkFFSDtBQUFBLFFBQUFILElBRkc7QUFBQSxJQUNKO0FBQUEsR0FDSztBQUFBLFlBQUFNLFdBQUFIO0FBQUFBLElBRUEsbUJBQ0w7QUFBQSxRQUFBSCxJQURLO0FBQUEsSUFFSjtBQUFBLEdBQU07QUFBQSxZQUFBTyxTQUFBWixHQUFBYTtBQUFBQSxJQUVOLGVBRUs7QUFBQSxRQUFBUixJQUZMO0FBQUEsSUFDSSw0QkFBSztBQUFBLEdBQ0g7QUFBQSxZQUFBUyxVQUFBZCxHQUFBYTtBQUFBQSxJQUVMLGVBQ0c7QUFBQSxRQUFBUixJQURIO0FBQUEsSUFFSyw0QkFBSztBQUFBO0FBQUEsWUFBQVUsSUFBQVgsTUFBQUUsT0FBQUU7QUFBQUEsSUFFaEIsdUJBQUFILElBQUEsVUFDUywrQkFBUTtBQUFBLFFBQUFBLE1BRGpCO0FBQUEsSUFFVyxrQ0FBUztBQUFBO0FBQUEsWUFBQVcsS0FBQVosTUFBQUUsT0FBQUU7QUFBQUEsSUFFbkIsdUJBQUFILElBQUEsVUFDRywwQkFDUTtBQUFBLFFBQUFBLE1BRlg7QUFBQSxJQUVJLDZCQUFPO0FBQUE7QUFBQSxZQUFBWSxNQUFBYixNQUFBRSxPQUFBWSxJQUFBQztBQUFBQSxJQU1XO0FBQUEsU0FBQUMsS0FBQTtBQUFBLHlCQUFBQyxLQUFBLE9BQ1QsK0JBRXNCO0FBQUE7QUFBQTtBQUFBLFNBQUFELE9BSGI7QUFBQSx5QkFBQUMsT0FBQSxPQUVQLG9DQUNvQjtBQUFBO0FBQUEsSUFBTDtBQUFBLEdBQUs7QUFBQSxZQUFBQyxRQUFBbEIsTUFBQUUsT0FBQVksSUFBQUM7QUFBQUEsSUFFWDtBQUFBLFNBQUFDLEtBQUE7QUFBQSxxQkFHWjtBQUFBLFNBQUFDLEtBSFk7QUFBQSxLQUNYLCtCQUdBO0FBQUE7QUFBQSxRQUFBRCxPQUpXO0FBQUEsb0JBSVo7QUFBQSxRQUFBQyxPQUpZO0FBQUEsSUFFVCxvQ0FFRjtBQUFBO0FBQUE7QUFBQSxJQUFBRTtBQUFBQSxNRGpFdEIiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo5NjIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJnbG9iYWxfZGF0YSIsIm9jYW1sX3ZlcnNpb24iLCJvY2FtbF9yZWxlYXNlIiwiU3RkbGliIiwiZXhlY3V0YWJsZV9uYW1lIiwib3NfdHlwZSIsImJhY2tlbmRfdHlwZSIsInVuaXgiLCJ3aW4zMiIsImN5Z3dpbiIsIm1heF9hcnJheV9sZW5ndGgiLCJtYXhfZmxvYXRhcnJheV9sZW5ndGgiLCJtYXhfc3RyaW5nX2xlbmd0aCIsImdldGVudl9vcHQiLCJzIiwiZXhuIiwiaW50ZXJhY3RpdmUiLCJzZXRfc2lnbmFsIiwic2lnX251bSIsInNpZ19iZWgiLCJCcmVhayIsImNhdGNoX2JyZWFrIiwib24iLCJNYWtlIiwiSW1tZWRpYXRlIiwiTm9uX2ltbWVkaWF0ZSIsIkltbWVkaWF0ZTY0IiwiU3RkbGliX1N5cyJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLFlBQUFDLFdBQUFDO0FBQUFBLElBQUEsWUFBQTtBQUFBLFVBQUFDO0FBQUFBLFNBQUFBLE1BQUE7QUFBQSwyQkFBQTtBQUFBLEtBQUE7QUFBQTtBQUFBLEdBQUE7QUFBQSxPQUFBQyxjQUFBO0FBQUEsWUFBQUMsV0FBQUMsU0FBQUMsU0FBQTtBQUFBLE9BQUFDLFFBQUE7QUFBQSxZQUFBQyxZQUFBQyxJQUFBLGlCQUFBO0FBQUEsWUFBQUMsS0FBQUMsV0FBQUMsZUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEwNTgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9vYmoubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE9wZXJhdGlvbnMgb24gaW50ZXJuYWwgcmVwcmVzZW50YXRpb25zIG9mIHZhbHVlcyAqKVxuXG50eXBlIHRcblxudHlwZSByYXdfZGF0YSA9IG5hdGl2ZWludFxuXG5leHRlcm5hbCByZXByIDogJ2EgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG9iaiA6IHQgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBtYWdpYyA6ICdhIC0+ICdiID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgaXNfaW50IDogdCAtPiBib29sID0gXCIlb2JqX2lzX2ludFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBpc19ibG9jayBhID0gbm90IChpc19pbnQgYSlcbmV4dGVybmFsIHRhZyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial90YWdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2V0X3RhZyA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3NldF90YWdcIlxuZXh0ZXJuYWwgc2l6ZSA6IHQgLT4gaW50ID0gXCIlb2JqX3NpemVcIlxuZXh0ZXJuYWwgcmVhY2hhYmxlX3dvcmRzIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1wiXG5leHRlcm5hbCBmaWVsZCA6IHQgLT4gaW50IC0+IHQgPSBcIiVvYmpfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X2ZpZWxkIDogdCAtPiBpbnQgLT4gdCAtPiB1bml0ID0gXCIlb2JqX3NldF9maWVsZFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfZ2V0XCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfc2V0IDpcbiAgICBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfc2V0XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGRvdWJsZV9maWVsZCB4IGkgPSBmbG9hdGFycmF5X2dldCAob2JqIHggOiBmbG9hdGFycmF5KSBpXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBzZXRfZG91YmxlX2ZpZWxkIHggaSB2ID1cbiAgZmxvYXRhcnJheV9zZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaSB2XG5leHRlcm5hbCByYXdfZmllbGQgOiB0IC0+IGludCAtPiByYXdfZGF0YSA9IFwiY2FtbF9vYmpfcmF3X2ZpZWxkXCJcbmV4dGVybmFsIHNldF9yYXdfZmllbGQgOiB0IC0+IGludCAtPiByYXdfZGF0YSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9vYmpfc2V0X3Jhd19maWVsZFwiXG5cbmV4dGVybmFsIG5ld19ibG9jayA6IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9vYmpfYmxvY2tcIlxuZXh0ZXJuYWwgZHVwIDogdCAtPiB0ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5leHRlcm5hbCBhZGRfb2Zmc2V0IDogdCAtPiBJbnQzMi50IC0+IHQgPSBcImNhbWxfb2JqX2FkZF9vZmZzZXRcIlxuZXh0ZXJuYWwgd2l0aF90YWcgOiBpbnQgLT4gdCAtPiB0ID0gXCJjYW1sX29ial93aXRoX3RhZ1wiXG5cbmxldCBmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMFxubGV0IGxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDI0NVxuXG5sZXQgbGF6eV90YWcgPSAyNDZcbmxldCBjbG9zdXJlX3RhZyA9IDI0N1xubGV0IG9iamVjdF90YWcgPSAyNDhcbmxldCBpbmZpeF90YWcgPSAyNDlcbmxldCBmb3J3YXJkX3RhZyA9IDI1MFxuXG5sZXQgbm9fc2Nhbl90YWcgPSAyNTFcblxubGV0IGFic3RyYWN0X3RhZyA9IDI1MVxubGV0IHN0cmluZ190YWcgPSAyNTJcbmxldCBkb3VibGVfdGFnID0gMjUzXG5sZXQgZG91YmxlX2FycmF5X3RhZyA9IDI1NFxubGV0IGN1c3RvbV90YWcgPSAyNTVcbmxldCBmaW5hbF90YWcgPSBjdXN0b21fdGFnXG5cblxubGV0IGludF90YWcgPSAxMDAwXG5sZXQgb3V0X29mX2hlYXBfdGFnID0gMTAwMVxubGV0IHVuYWxpZ25lZF90YWcgPSAxMDAyXG5cbm1vZHVsZSBDbG9zdXJlID0gc3RydWN0XG4gIHR5cGUgaW5mbyA9IHtcbiAgICBhcml0eTogaW50O1xuICAgIHN0YXJ0X2VudjogaW50O1xuICB9XG5cbiAgbGV0IGluZm9fb2ZfcmF3IChpbmZvIDogbmF0aXZlaW50KSA9XG4gICAgbGV0IG9wZW4gTmF0aXZlaW50IGluXG4gICAgbGV0IGFyaXR5ID1cbiAgICAgICgqIHNpZ25lZDogbmVnYXRpdmUgZm9yIHR1cGxlZCBmdW5jdGlvbnMgKilcbiAgICAgIGlmIFN5cy53b3JkX3NpemUgPSA2NCB0aGVuXG4gICAgICAgIHRvX2ludCAoc2hpZnRfcmlnaHQgaW5mbyA1NilcbiAgICAgIGVsc2VcbiAgICAgICAgdG9faW50IChzaGlmdF9yaWdodCBpbmZvIDI0KVxuICAgIGluXG4gICAgbGV0IHN0YXJ0X2VudiA9XG4gICAgICAoKiBzdGFydF9lbnYgaXMgdW5zaWduZWQsIGJ1dCB3ZSBrbm93IGl0IGNhbiBhbHdheXMgZml0IGFuIE9DYW1sXG4gICAgICAgICBpbnRlZ2VyIHNvIHdlIHVzZSBbdG9faW50XSBpbnN0ZWFkIG9mIFt1bnNpZ25lZF90b19pbnRdLiAqKVxuICAgICAgdG9faW50IChzaGlmdF9yaWdodF9sb2dpY2FsIChzaGlmdF9sZWZ0IGluZm8gOCkgOSkgaW5cbiAgICB7IGFyaXR5OyBzdGFydF9lbnYgfVxuXG4gICgqIG5vdGU6IHdlIGV4cGVjdCBhIGNsb3N1cmUsIG5vdCBhbiBpbmZpeCBwb2ludGVyICopXG4gIGxldCBpbmZvIChvYmogOiB0KSA9XG4gICAgYXNzZXJ0ICh0YWcgb2JqID0gY2xvc3VyZV90YWcpO1xuICAgIGluZm9fb2ZfcmF3IChyYXdfZmllbGQgb2JqIDEpXG5lbmRcblxubW9kdWxlIEV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9XG5zdHJ1Y3RcbiAgdHlwZSB0ID0gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXG4gIGxldCBvZl92YWwgeCA9XG4gICAgbGV0IHggPSByZXByIHggaW5cbiAgICBsZXQgc2xvdCA9XG4gICAgICBpZiAoaXNfYmxvY2sgeCkgJiYgKHRhZyB4KSA8PiBvYmplY3RfdGFnICYmIChzaXplIHgpID49IDEgdGhlbiBmaWVsZCB4IDBcbiAgICAgIGVsc2UgeFxuICAgIGluXG4gICAgbGV0IG5hbWUgPVxuICAgICAgaWYgKGlzX2Jsb2NrIHNsb3QpICYmICh0YWcgc2xvdCkgPSBvYmplY3RfdGFnIHRoZW4gZmllbGQgc2xvdCAwXG4gICAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG4gICAgaW5cbiAgICAgIGlmICh0YWcgbmFtZSkgPSBzdHJpbmdfdGFnIHRoZW4gKG9iaiBzbG90IDogdClcbiAgICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcblxuICBsZXQgW0BpbmxpbmUgYWx3YXlzXSBuYW1lIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDApIDogc3RyaW5nKVxuXG4gIGxldCBbQGlubGluZSBhbHdheXNdIGlkIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDEpIDogaW50KVxuZW5kXG5cbmxldCBleHRlbnNpb25fY29uc3RydWN0b3IgPSBFeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsXG5sZXQgZXh0ZW5zaW9uX25hbWUgPSBFeHRlbnNpb25fY29uc3RydWN0b3IubmFtZVxubGV0IGV4dGVuc2lvbl9pZCA9IEV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZFxuXG5tb2R1bGUgRXBoZW1lcm9uID0gc3RydWN0XG4gIHR5cGUgb2JqX3QgPSB0XG5cbiAgdHlwZSB0ICgqKiBlcGhlbWVyb24gKilcblxuICAgKCoqIFRvIGNoYW5nZSBpbiBzeW5jIHdpdGggd2Vhay5oICopXG4gIGxldCBhZGRpdGlvbmFsX3ZhbHVlcyA9IDJcbiAgbGV0IG1heF9lcGhlX2xlbmd0aCA9IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gdCA9IFwiY2FtbF9lcGhlX2NyZWF0ZVwiOztcbiAgbGV0IGNyZWF0ZSBsID1cbiAgICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IG1heF9lcGhlX2xlbmd0aCkgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJPYmouRXBoZW1lcm9uLmNyZWF0ZVwiO1xuICAgIGNyZWF0ZSBsXG5cbiAgbGV0IGxlbmd0aCB4ID0gc2l6ZShyZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBsZXQgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIG1zZyA9XG4gICAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBtc2dcblxuICBleHRlcm5hbCBnZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5XCJcbiAgbGV0IGdldF9rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmdldF9rZXlcIjtcbiAgICBnZXRfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGdldF9rZXlfY29weTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XCJcbiAgbGV0IGdldF9rZXlfY29weSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uZ2V0X2tleV9jb3B5XCI7XG4gICAgZ2V0X2tleV9jb3B5IGUgb1xuXG4gIGV4dGVybmFsIHNldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbiAgbGV0IHNldF9rZXkgZSBvIHggPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uc2V0X2tleVwiO1xuICAgIHNldF9rZXkgZSBvIHhcblxuICBleHRlcm5hbCB1bnNldF9rZXk6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxuICBsZXQgdW5zZXRfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi51bnNldF9rZXlcIjtcbiAgICB1bnNldF9rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgY2hlY2tfa2V5OiB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfa2V5XCJcbiAgbGV0IGNoZWNrX2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uY2hlY2tfa2V5XCI7XG4gICAgY2hlY2tfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGJsaXRfa2V5IDogdCAtPiBpbnQgLT4gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9lcGhlX2JsaXRfa2V5XCJcblxuICBsZXQgYmxpdF9rZXkgZTEgbzEgZTIgbzIgbCA9XG4gICAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiT2JqLkVwaGVtZXJvbi5ibGl0X2tleVwiXG4gICAgZWxzZSBpZiBsIDw+IDAgdGhlbiBibGl0X2tleSBlMSBvMSBlMiBvMiBsXG5cbiAgZXh0ZXJuYWwgZ2V0X2RhdGE6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFcIlxuICBleHRlcm5hbCBnZXRfZGF0YV9jb3B5OiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcIlxuICBleHRlcm5hbCBzZXRfZGF0YTogdCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2RhdGFcIlxuICBleHRlcm5hbCB1bnNldF9kYXRhOiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9kYXRhXCJcbiAgZXh0ZXJuYWwgY2hlY2tfZGF0YTogdCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfZGF0YVwiXG4gIGV4dGVybmFsIGJsaXRfZGF0YSA6IHQgLT4gdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfYmxpdF9kYXRhXCJcblxuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9PYmpfZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfb2JqX3RhZyIsImdsb2JhbF9kYXRhIiwiU3RkbGliIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfU3lzIiwiaXNfYmxvY2siLCJhIiwiZG91YmxlX2ZpZWxkIiwieCIsImkiLCJzZXRfZG91YmxlX2ZpZWxkIiwidiIsImN1c3RvbV90YWciLCJpbmZvIiwib2JqIiwiYXJpdHkiLCJzdGFydF9lbnYiLCJleHRlbnNpb25fY29uc3RydWN0b3IiLCJzbG90IiwibmFtZSIsImV4dGVuc2lvbl9uYW1lIiwiZXh0ZW5zaW9uX2lkIiwiRXh0ZW5zaW9uX2NvbnN0cnVjdG9yIiwibWF4X2VwaGVfbGVuZ3RoIiwiY3N0X09ial9FcGhlbWVyb25fY3JlYXRlIiwiY3N0X09ial9FcGhlbWVyb25fZ2V0X2tleSIsImNzdF9PYmpfRXBoZW1lcm9uX2dldF9rZXlfY29weSIsImNzdF9PYmpfRXBoZW1lcm9uX3NldF9rZXkiLCJjc3RfT2JqX0VwaGVtZXJvbl91bnNldF9rZXkiLCJjc3RfT2JqX0VwaGVtZXJvbl9jaGVja19rZXkiLCJjc3RfT2JqX0VwaGVtZXJvbl9ibGl0X2tleSIsImNyZWF0ZSIsImwiLCJsZW5ndGgiLCJyYWlzZV9pZl9pbnZhbGlkX29mZnNldCIsImUiLCJvIiwibXNnIiwiZ2V0X2tleSIsImdldF9rZXlfY29weSIsInNldF9rZXkiLCJ1bnNldF9rZXkiLCJjaGVja19rZXkiLCJibGl0X2tleSIsImUxIiwibzEiLCJlMiIsIm8yIiwiU3RkbGliX09iaiJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxrQ0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxZQUFBQyxTQUFBQyxHQ3lCa0MsMkNBQWM7QUFBQSxZQUFBQyxhQUFBQyxHQUFBQyxHQVVSLG9DQUFxQztBQUFBLFlBQUFDLGlCQUFBRixHQUFBQyxHQUFBRTtBQUFBQSxJQUUzRTtBQUFBLElBQXVDO0FBQUE7QUFBQTtBQUFBLElBQUFDLGFEckN6QztBQUFBO0FBQUEsSUFBQWYsZ0NBQUE7QUFBQSxJQUFBQSxrQ0FBQTtBQUFBLFlBQUFnQixLQUFBQztBQUFBQSxJQzhGWTtBQUFBLEtBQU87QUFBQTtBQUFBLEtBQUFELE9BQ0g7QUFBQSxLQUFBRSxRQWpCWjtBQUFBLEtBQUFDLFlBV29EO0FBQUEsSUFDcEQ7QUFBQSxHQUs2QjtBQUFBLFlBQUFDLHNCQUFBVDtBQUFBQTtBQUFBQSxLQUFBVTtBQUFBQSxPQVN4QjtBQUFBLFVBQWdCO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FJaEIscUJBQW1CLGdDQUFBQyxPQUF5QztBQUFBLFNBQUFBLE9BQzFEO0FBQUE7QUFBQSxJQUVGO0FBQUE7QUFBQSxjQUNFLG1EQUF1QztBQUFBO0FBQUEsWUFBQUMsZUFBQUYsTUFHcEI7QUFBQSxZQUFBRyxhQUFBSCxNQUdBO0FBQUE7QUFBQSxJQUFBSTtBQUFBQSxNRHRIOUI7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsWUFBQUMsT0FBQUM7QUFBQUEsUUFBQSxJQ3dJSTtBQUFBLGNBQ0U7QUFBQSxJQUNGLGtDQUFRO0FBQUE7QUFBQSxZQUFBQyxPQUFBekIsR0FFSyx3QkFBZ0M7QUFBQSxZQUFBMEIsd0JBQUFDLEdBQUFDLEdBQUFDO0FBQUFBLFFBQUEsSUFHN0MsNEJBQXNCLDJCQUF0QjtBQUFBLGVBQ0UsNkJBQWU7QUFBQTtBQUFBLFlBQUFDLFFBQUFILEdBQUFDO0FBQUFBLElBSWpCO0FBQUEsSUFDQSxzQ0FBVztBQUFBO0FBQUEsWUFBQUcsYUFBQUosR0FBQUM7QUFBQUEsSUFJWDtBQUFBLElBQ0EsMkNBQWdCO0FBQUE7QUFBQSxZQUFBSSxRQUFBTCxHQUFBQyxHQUFBNUI7QUFBQUEsSUFJaEI7QUFBQSxJQUNBLHlDQUFhO0FBQUE7QUFBQSxZQUFBaUMsVUFBQU4sR0FBQUM7QUFBQUEsSUFJYjtBQUFBLElBQ0Esd0NBQWE7QUFBQTtBQUFBLFlBQUFNLFVBQUFQLEdBQUFDO0FBQUFBLElBSWI7QUFBQSxJQUNBLHdDQUFhO0FBQUE7QUFBQSxZQUFBTyxTQUFBQyxJQUFBQyxJQUFBQyxJQUFBQyxJQUFBZjtBQUFBQSxJQU1iO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBMkIseUNBQ047QUFBQTtBQUFBLFVBRWhCO0FBQUEsY0FBZTtBQUFBLEtBQWY7QUFBQTtBQUFBLElBREEsdURBQ3FDO0FBQUE7QUFBQTtBQUFBLElBQUFnQjtBQUFBQSxNRGxMOUMiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMjE0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvY2FtbGludGVybmFsTGF6eS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSW50ZXJuYWxzIG9mIGZvcmNpbmcgbGF6eSB2YWx1ZXMuICopXG5cbnR5cGUgJ2EgdCA9ICdhIGxhenlfdFxuXG5leGNlcHRpb24gVW5kZWZpbmVkXG5cbmxldCByYWlzZV91bmRlZmluZWQgPSBPYmoucmVwciAoZnVuICgpIC0+IHJhaXNlIFVuZGVmaW5lZClcblxuZXh0ZXJuYWwgbWFrZV9mb3J3YXJkIDogT2JqLnQgLT4gT2JqLnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfbWFrZV9mb3J3YXJkXCJcblxuKCogQXNzdW1lIFtibGtdIGlzIGEgYmxvY2sgd2l0aCB0YWcgbGF6eSAqKVxubGV0IGZvcmNlX2xhenlfYmxvY2sgKGJsayA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCAoT2JqLnJlcHIgYmxrKSAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIHJhaXNlX3VuZGVmaW5lZDtcbiAgdHJ5XG4gICAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgICBtYWtlX2ZvcndhcmQgKE9iai5yZXByIGJsaykgKE9iai5yZXByIHJlc3VsdCk7XG4gICAgcmVzdWx0XG4gIHdpdGggZSAtPlxuICAgIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCAoT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBlKSk7XG4gICAgcmFpc2UgZVxuXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV92YWxfbGF6eV9ibG9jayAoYmxrIDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IGNsb3N1cmUgPSAoT2JqLm9iaiAoT2JqLmZpZWxkIChPYmoucmVwciBibGspIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgcmFpc2VfdW5kZWZpbmVkO1xuICBsZXQgcmVzdWx0ID0gY2xvc3VyZSAoKSBpblxuICBtYWtlX2ZvcndhcmQgKE9iai5yZXByIGJsaykgKE9iai5yZXByIHJlc3VsdCk7XG4gIHJlc3VsdFxuXG5cbigqIFtmb3JjZV0gaXMgbm90IHVzZWQsIHNpbmNlIFtMYXp5LmZvcmNlXSBpcyBkZWNsYXJlZCBhcyBhIHByaW1pdGl2ZVxuICAgd2hvc2UgY29kZSBpbmxpbmVzIHRoZSB0YWcgdGVzdHMgb2YgaXRzIGFyZ3VtZW50LCBleGNlcHQgd2hlbiBhZmxcbiAgIGluc3RydW1lbnRhdGlvbiBpcyB0dXJuZWQgb24uICopXG5cbmxldCBmb3JjZSAobHp2IDogJ2FyZyBsYXp5X3QpID1cbiAgKCogVXNpbmcgW1N5cy5vcGFxdWVfaWRlbnRpdHldIHByZXZlbnRzIHR3byBwb3RlbnRpYWwgcHJvYmxlbXM6XG4gICAgIC0gSWYgdGhlIHZhbHVlIGlzIGtub3duIHRvIGhhdmUgRm9yd2FyZF90YWcsIHRoZW4gaXRzIHRhZyBjb3VsZCBoYXZlXG4gICAgICAgY2hhbmdlZCBkdXJpbmcgR0MsIHNvIHRoYXQgaW5mb3JtYXRpb24gbXVzdCBiZSBmb3Jnb3R0ZW4gKHNlZSBHUFIjNzEzXG4gICAgICAgYW5kIGlzc3VlICM3MzAxKVxuICAgICAtIElmIHRoZSB2YWx1ZSBpcyBrbm93biB0byBiZSBpbW11dGFibGUsIHRoZW4gaWYgdGhlIGNvbXBpbGVyXG4gICAgICAgY2Fubm90IHByb3ZlIHRoYXQgdGhlIGxhc3QgYnJhbmNoIGlzIG5vdCB0YWtlbiBpdCB3aWxsIGlzc3VlIGFcbiAgICAgICB3YXJuaW5nIDU5IChtb2RpZmljYXRpb24gb2YgYW4gaW1tdXRhYmxlIHZhbHVlKSAqKVxuICBsZXQgbHp2ID0gU3lzLm9wYXF1ZV9pZGVudGl0eSBsenYgaW5cbiAgbGV0IHggPSBPYmoucmVwciBsenYgaW5cbiAgbGV0IHQgPSBPYmoudGFnIHggaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB0aGVuIChPYmoub2JqIChPYmouZmllbGQgeCAwKSA6ICdhcmcpIGVsc2VcbiAgaWYgdCA8PiBPYmoubGF6eV90YWcgdGhlbiAoT2JqLm9iaiB4IDogJ2FyZylcbiAgZWxzZSBmb3JjZV9sYXp5X2Jsb2NrIGx6dlxuXG5cbmxldCBmb3JjZV92YWwgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gIGxldCB0ID0gT2JqLnRhZyB4IGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgdGhlbiAoT2JqLm9iaiAoT2JqLmZpZWxkIHggMCkgOiAnYXJnKSBlbHNlXG4gIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfdmFsX2xhenlfYmxvY2sgbHp2XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfb2JqX21ha2VfZm9yd2FyZCIsImNhbWxfb2JqX3RhZyIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfT2JqIiwiVW5kZWZpbmVkIiwicmFpc2VfdW5kZWZpbmVkIiwicGFyYW0iLCJmb3JjZV9sYXp5X2Jsb2NrIiwiYmxrIiwiY2xvc3VyZSIsInJlc3VsdCIsImUiLCJmb3JjZV92YWxfbGF6eV9ibG9jayIsImZvcmNlIiwibHp2IiwidCIsImZvcmNlX3ZhbCIsIkNhbWxpbnRlcm5hbExhenkiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLFlBQUFDLGdCQUFBQztBQUFBQSxJQ3FCMEM7QUFBQSxHQUFlO0FBQUEsWUFBQUMsaUJBQUFDO0FBQUFBLFFBQUFDLFVBTWhDO0FBQUEsSUFDdkI7QUFBQSxJQUE4QztBQUFBLFNBQUFDLFNBRS9CO0FBQUEsS0FDYjtBQUFBO0FBQUE7QUFBQSxVQUFBQztBQUFBQSxTQUFBQSxJRC9CSjtBQUFBLEtDa0NJLGtCQUFBTCxPQUFvRCx3Q0FBTztBQUFBLEtBQUU7QUFBQTtBQUFBLEdBQ3REO0FBQUEsWUFBQU0scUJBQUFKO0FBQUFBLFFBQUFDLFVBS2M7QUFBQSxJQUN2QjtBQUFBLFFBQUFDLFNBQ2E7QUFBQSxJQUNiO0FBQUEsSUFBNkM7QUFBQSxHQUN2QztBQUFBLFlBQUFHLE1BQUFDO0FBQUFBLFFBQUFDLElBaUJFO0FBQUEsSUFDUjtBQUFBO0FBQUEsMENBRUsscUJBQW9CO0FBQUE7QUFBQSxZQUFBQyxVQUFBRjtBQUFBQSxRQUFBQyxJQUtqQjtBQUFBLElBQ1I7QUFBQTtBQUFBLDBDQUVLLHlCQUF3QjtBQUFBO0FBQUE7QUFBQSxJQUFBRTtBQUFBQSxNRHhFL0IiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMjc5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvbGF6eS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtMYXp5XTogZGVmZXJyZWQgY29tcHV0YXRpb25zICopXG5cblxuKCpcbiAgIFdBUk5JTkc6IHNvbWUgcHVycGxlIG1hZ2ljIGlzIGdvaW5nIG9uIGhlcmUuICBEbyBub3QgdGFrZSB0aGlzIGZpbGVcbiAgIGFzIGFuIGV4YW1wbGUgb2YgaG93IHRvIHByb2dyYW0gaW4gT0NhbWwuXG4qKVxuXG5cbigqIFdlIG1ha2UgdXNlIG9mIHR3byBzcGVjaWFsIHRhZ3MgcHJvdmlkZWQgYnkgdGhlIHJ1bnRpbWU6XG4gICBbbGF6eV90YWddIGFuZCBbZm9yd2FyZF90YWddLlxuXG4gICBBIHZhbHVlIG9mIHR5cGUgWydhIExhenkudF0gY2FuIGJlIG9uZSBvZiB0aHJlZSB0aGluZ3M6XG4gICAxLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbbGF6eV90YWddLiAgSXRzIGZpZWxkIGlzIGEgY2xvc3VyZSBvZlxuICAgICAgdHlwZSBbdW5pdCAtPiAnYV0gdGhhdCBjb21wdXRlcyB0aGUgdmFsdWUuXG4gICAyLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbZm9yd2FyZF90YWddLiAgSXRzIGZpZWxkIGlzIHRoZSB2YWx1ZVxuICAgICAgb2YgdHlwZSBbJ2FdIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgMy4gQW55dGhpbmcgZWxzZSBleGNlcHQgYSBmbG9hdC4gIFRoaXMgaGFzIHR5cGUgWydhXSBhbmQgaXMgdGhlIHZhbHVlXG4gICAgICB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIEV4Y2VwdGlvbnMgYXJlIHN0b3JlZCBpbiBmb3JtYXQgKDEpLlxuICAgVGhlIEdDIHdpbGwgbWFnaWNhbGx5IGNoYW5nZSB0aGluZ3MgZnJvbSAoMikgdG8gKDMpIGFjY29yZGluZyB0byBpdHNcbiAgIGZhbmN5LlxuXG4gICBJZiBPQ2FtbCB3YXMgY29uZmlndXJlZCB3aXRoIHRoZSAtZmxhdC1mbG9hdC1hcnJheSBvcHRpb24gKHdoaWNoIGlzXG4gICBjdXJyZW50bHkgdGhlIGRlZmF1bHQpLCB0aGUgZm9sbG93aW5nIGlzIGFsc28gdHJ1ZTpcbiAgIFdlIGNhbm5vdCB1c2UgcmVwcmVzZW50YXRpb24gKDMpIGZvciBhIFtmbG9hdCBMYXp5LnRdIGJlY2F1c2VcbiAgIFtjYW1sX21ha2VfYXJyYXldIGFzc3VtZXMgdGhhdCBvbmx5IGEgW2Zsb2F0XSB2YWx1ZSBjYW4gaGF2ZSB0YWdcbiAgIFtEb3VibGVfdGFnXS5cblxuICAgV2UgaGF2ZSB0byB1c2UgdGhlIGJ1aWx0LWluIHR5cGUgY29uc3RydWN0b3IgW2xhenlfdF0gdG9cbiAgIGxldCB0aGUgY29tcGlsZXIgaW1wbGVtZW50IHRoZSBzcGVjaWFsIHR5cGluZyBhbmQgY29tcGlsYXRpb25cbiAgIHJ1bGVzIGZvciB0aGUgW2xhenldIGtleXdvcmQuXG4qKVxuXG50eXBlICdhIHQgPSAnYSBDYW1saW50ZXJuYWxMYXp5LnRcblxuZXhjZXB0aW9uIFVuZGVmaW5lZCA9IENhbWxpbnRlcm5hbExhenkuVW5kZWZpbmVkXG5cbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6ICdhIC0+ICdhIGxhenlfdCA9IFwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZFwiXG5cbmV4dGVybmFsIGZvcmNlIDogJ2EgdCAtPiAnYSA9IFwiJWxhenlfZm9yY2VcIlxuXG5cbmxldCBmb3JjZV92YWwgPSBDYW1saW50ZXJuYWxMYXp5LmZvcmNlX3ZhbFxuXG5sZXQgZnJvbV9mdW4gKGYgOiB1bml0IC0+ICdhcmcpID1cbiAgbGV0IHggPSBPYmoubmV3X2Jsb2NrIE9iai5sYXp5X3RhZyAxIGluXG4gIE9iai5zZXRfZmllbGQgeCAwIChPYmoucmVwciBmKTtcbiAgKE9iai5vYmogeCA6ICdhcmcgdClcblxubGV0IGZyb21fdmFsICh2IDogJ2FyZykgPVxuICBsZXQgdCA9IE9iai50YWcgKE9iai5yZXByIHYpIGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgfHwgdCA9IE9iai5sYXp5X3RhZyB8fCB0ID0gT2JqLmRvdWJsZV90YWcgdGhlbiBiZWdpblxuICAgIG1ha2VfZm9yd2FyZCB2XG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgKE9iai5tYWdpYyB2IDogJ2FyZyB0KVxuICBlbmRcblxuXG5sZXQgaXNfdmFsIChsIDogJ2FyZyB0KSA9IE9iai50YWcgKE9iai5yZXByIGwpIDw+IE9iai5sYXp5X3RhZ1xuXG5sZXQgbGF6eV9mcm9tX2Z1biA9IGZyb21fZnVuXG5cbmxldCBsYXp5X2Zyb21fdmFsID0gZnJvbV92YWxcblxubGV0IGxhenlfaXNfdmFsID0gaXNfdmFsXG5cblxubGV0IG1hcCBmIHggPVxuICBsYXp5IChmIChmb3JjZSB4KSlcblxubGV0IG1hcF92YWwgZiB4ID1cbiAgaWYgaXNfdmFsIHhcbiAgdGhlbiBsYXp5X2Zyb21fdmFsIChmIChmb3JjZSB4KSlcbiAgZWxzZSBsYXp5IChmIChmb3JjZSB4KSlcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9vYmpfdGFnIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImdsb2JhbF9kYXRhIiwiQ2FtbGludGVybmFsTGF6eSIsIlN0ZGxpYl9PYmoiLCJVbmRlZmluZWQiLCJmb3JjZV92YWwiLCJmcm9tX2Z1biIsIngiLCJmcm9tX3ZhbCIsInYiLCJ0IiwiaXNfdmFsIiwibCIsIm1hcCIsInBhcmFtIiwibWFwX3ZhbCIsIlN0ZGxpYl9MYXp5Il0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsZUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLFlBQUFDLFNBQUFQO0FBQUFBLFFBQUFRLElDNkRVO0FBQUEsSUFDUjtBQUFBLElBQThCO0FBQUEsR0FDVjtBQUFBLFlBQUFDLFNBQUFDO0FBQUFBLFFBQUFDLElBR1o7QUFBQSxJQUNSO0FBQUEsS0FHRztBQUFBLElBSG1FLHdDQUluRTtBQUFBO0FBQUEsWUFBQUMsT0FBQUM7QUFBQUEsUUFBQSxJQUdxQjtBQUFBLHdDQUFvQjtBQUFBLEdBQWdCO0FBQUEsWUFBQUMsSUFBQWQsR0FBQVE7QUFBQUEsSUFVNUQ7QUFBQSxxQkFBQU87QUFBQUE7QUFBQUEsY0FBQSxJRHBGRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQ29GRTtBQUFBLEdBQWtCO0FBQUEsWUFBQUMsUUFBQWhCLEdBQUFRO0FBQUFBLElBR2Y7QUFBQSxLQUVFO0FBQUEsc0JBQUFPO0FBQUFBO0FBQUFBLGVBQUEsSUR6RlA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUN5Rk87QUFBQTtBQUFBLFNBREE7QUFBQTtBQUFBLElBQWMsT0FBYSxTQUFiLGlCQUNJO0FBQUE7QUFBQTtBQUFBLElBQUFFO0FBQUFBLE1EekZ6QiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEzNjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9zZXEubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgU2ltb24gQ3J1YW5lcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbU2VxXTogZnVuY3Rpb25hbCBpdGVyYXRvcnMgKilcblxudHlwZSArJ2Egbm9kZSA9XG4gIHwgTmlsXG4gIHwgQ29ucyBvZiAnYSAqICdhIHRcblxuYW5kICdhIHQgPSB1bml0IC0+ICdhIG5vZGVcblxubGV0IGVtcHR5ICgpID0gTmlsXG5cbmxldCByZXR1cm4geCAoKSA9IENvbnMgKHgsIGVtcHR5KVxuXG5sZXQgY29ucyB4IG5leHQgKCkgPSBDb25zICh4LCBuZXh0KVxuXG5sZXQgcmVjIGFwcGVuZCBzZXExIHNlcTIgKCkgPVxuICBtYXRjaCBzZXExKCkgd2l0aFxuICB8IE5pbCAtPiBzZXEyKClcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBDb25zICh4LCBhcHBlbmQgbmV4dCBzZXEyKVxuXG5sZXQgcmVjIG1hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gQ29ucyAoZiB4LCBtYXAgZiBuZXh0KVxuXG5sZXQgcmVjIGZpbHRlcl9tYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgICB8IE5vbmUgLT4gZmlsdGVyX21hcCBmIG5leHQgKClcbiAgICAgICAgfCBTb21lIHkgLT4gQ29ucyAoeSwgZmlsdGVyX21hcCBmIG5leHQpXG5cbmxldCByZWMgZmlsdGVyIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgaWYgZiB4XG4gICAgICB0aGVuIENvbnMgKHgsIGZpbHRlciBmIG5leHQpXG4gICAgICBlbHNlIGZpbHRlciBmIG5leHQgKClcblxubGV0IHJlYyBjb25jYXQgc2VxICgpID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgYXBwZW5kIHggKGNvbmNhdCBuZXh0KSAoKVxuXG5sZXQgcmVjIGZsYXRfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICBhcHBlbmQgKGYgeCkgKGZsYXRfbWFwIGYgbmV4dCkgKClcblxubGV0IGNvbmNhdF9tYXAgPSBmbGF0X21hcFxuXG5sZXQgcmVjIGZvbGRfbGVmdCBmIGFjYyBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+IGFjY1xuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0IGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgZm9sZF9sZWZ0IGYgYWNjIG5leHRcblxubGV0IHJlYyBpdGVyIGYgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiAoKVxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgZiB4O1xuICAgICAgICBpdGVyIGYgbmV4dFxuXG5sZXQgcmVjIHVuZm9sZCBmIHUgKCkgPVxuICBtYXRjaCBmIHUgd2l0aFxuICB8IE5vbmUgLT4gTmlsXG4gIHwgU29tZSAoeCwgdScpIC0+IENvbnMgKHgsIHVuZm9sZCBmIHUnKVxuXG5sZXQgaXNfZW1wdHkgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zIChfLCBfKSAtPlxuICAgICAgZmFsc2VcblxubGV0IHVuY29ucyB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgU29tZSAoeCwgeHMpXG4gIHwgTmlsIC0+XG4gICAgICBOb25lXG5cblxuXG5sZXQgcmVjIGxlbmd0aF9hdXggYWNjdSB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgYWNjdVxuICB8IENvbnMgKF8sIHhzKSAtPlxuICAgICAgbGVuZ3RoX2F1eCAoYWNjdSArIDEpIHhzXG5cbmxldFtAaW5saW5lXSBsZW5ndGggeHMgPVxuICBsZW5ndGhfYXV4IDAgeHNcblxubGV0IHJlYyBpdGVyaV9hdXggZiBpIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICAoKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgZiBpIHg7XG4gICAgICBpdGVyaV9hdXggZiAoaSsxKSB4c1xuXG5sZXRbQGlubGluZV0gaXRlcmkgZiB4cyA9XG4gIGl0ZXJpX2F1eCBmIDAgeHNcblxubGV0IHJlYyBmb2xkX2xlZnRpX2F1eCBmIGFjY3UgaSB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgYWNjdVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbGV0IGFjY3UgPSBmIGFjY3UgaSB4IGluXG4gICAgICBmb2xkX2xlZnRpX2F1eCBmIGFjY3UgKGkrMSkgeHNcblxubGV0W0BpbmxpbmVdIGZvbGRfbGVmdGkgZiBhY2N1IHhzID1cbiAgZm9sZF9sZWZ0aV9hdXggZiBhY2N1IDAgeHNcblxubGV0IHJlYyBmb3JfYWxsIHAgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIHAgeCAmJiBmb3JfYWxsIHAgeHNcblxubGV0IHJlYyBleGlzdHMgcCB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIHAgeCB8fCBleGlzdHMgcCB4c1xuXG5sZXQgcmVjIGZpbmQgcCB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTm9uZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgaWYgcCB4IHRoZW4gU29tZSB4IGVsc2UgZmluZCBwIHhzXG5cbmxldCByZWMgZmluZF9tYXAgZiB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTm9uZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGZpbmRfbWFwIGYgeHNcbiAgICAgIHwgU29tZSBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHJlc3VsdFxuXG4oKiBbaXRlcjJdLCBbZm9sZF9sZWZ0Ml0sIFtmb3JfYWxsMl0sIFtleGlzdHMyXSwgW21hcDJdLCBbemlwXSB3b3JrIGFsc28gaW5cbiAgIHRoZSBjYXNlIHdoZXJlIHRoZSB0d28gc2VxdWVuY2VzIGhhdmUgZGlmZmVyZW50IGxlbmd0aHMuIFRoZXkgc3RvcCBhcyBzb29uXG4gICBhcyBvbmUgc2VxdWVuY2UgaXMgZXhoYXVzdGVkLiBUaGVpciBiZWhhdmlvciBpcyBzbGlnaHRseSBhc3ltbWV0cmljOiB3aGVuXG4gICBbeHNdIGlzIGVtcHR5LCB0aGV5IGRvIG5vdCBmb3JjZSBbeXNdOyBob3dldmVyLCB3aGVuIFt5c10gaXMgZW1wdHksIFt4c10gaXNcbiAgIGZvcmNlZCwgZXZlbiB0aG91Z2ggdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gYXBwbGljYXRpb24gW3hzKCldIHR1cm5zIG91dFxuICAgdG8gYmUgdXNlbGVzcy4gKilcblxubGV0IHJlYyBpdGVyMiBmIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICAoKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgICgpXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIGYgeCB5O1xuICAgICAgICAgIGl0ZXIyIGYgeHMgeXNcblxubGV0IHJlYyBmb2xkX2xlZnQyIGYgYWNjdSB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgYWNjdVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIGFjY3VcbiAgICAgIHwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICAgICAgbGV0IGFjY3UgPSBmIGFjY3UgeCB5IGluXG4gICAgICAgICAgZm9sZF9sZWZ0MiBmIGFjY3UgeHMgeXNcblxubGV0IHJlYyBmb3JfYWxsMiBmIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCB5cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBmIHggeSAmJiBmb3JfYWxsMiBmIHhzIHlzXG5cbmxldCByZWMgZXhpc3RzMiBmIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBmYWxzZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIGYgeCB5IHx8IGV4aXN0czIgZiB4cyB5c1xuXG5sZXQgcmVjIGVxdWFsIGVxIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSwgeXMoKSB3aXRoXG4gIHwgTmlsLCBOaWwgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh4LCB4cyksIENvbnMgKHksIHlzKSAtPlxuICAgICAgZXEgeCB5ICYmIGVxdWFsIGVxIHhzIHlzXG4gIHwgTmlsLCBDb25zIChfLCBfKVxuICB8IENvbnMgKF8sIF8pLCBOaWwgLT5cbiAgICAgIGZhbHNlXG5cbmxldCByZWMgY29tcGFyZSBjbXAgeHMgeXMgPVxuICBtYXRjaCB4cygpLCB5cygpIHdpdGhcbiAgfCBOaWwsIE5pbCAtPlxuICAgICAgMFxuICB8IENvbnMgKHgsIHhzKSwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICBsZXQgYyA9IGNtcCB4IHkgaW5cbiAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZSBjb21wYXJlIGNtcCB4cyB5c1xuICB8IE5pbCwgQ29ucyAoXywgXykgLT5cbiAgICAgIC0xXG4gIHwgQ29ucyAoXywgXyksIE5pbCAtPlxuICAgICAgKzFcblxuXG5cbigqIFtpbml0X2F1eCBmIGkgal0gaXMgdGhlIHNlcXVlbmNlIFtmIGksIC4uLiwgZiAoai0xKV0uICopXG5cbmxldCByZWMgaW5pdF9hdXggZiBpIGogKCkgPVxuICBpZiBpIDwgaiB0aGVuIGJlZ2luXG4gICAgQ29ucyAoZiBpLCBpbml0X2F1eCBmIChpICsgMSkgailcbiAgZW5kXG4gIGVsc2VcbiAgICBOaWxcblxubGV0IGluaXQgbiBmID1cbiAgaWYgbiA8IDAgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU2VxLmluaXRcIlxuICBlbHNlXG4gICAgaW5pdF9hdXggZiAwIG5cblxubGV0IHJlYyByZXBlYXQgeCAoKSA9XG4gIENvbnMgKHgsIHJlcGVhdCB4KVxuXG5sZXQgcmVjIGZvcmV2ZXIgZiAoKSA9XG4gIENvbnMgKGYoKSwgZm9yZXZlciBmKVxuXG4oKiBUaGlzIHByZWxpbWluYXJ5IGRlZmluaXRpb24gb2YgW2N5Y2xlXSByZXF1aXJlcyB0aGUgc2VxdWVuY2UgW3hzXVxuICAgdG8gYmUgbm9uZW1wdHkuIEFwcGx5aW5nIGl0IHRvIGFuIGVtcHR5IHNlcXVlbmNlIHdvdWxkIHByb2R1Y2UgYVxuICAgc2VxdWVuY2UgdGhhdCBkaXZlcmdlcyB3aGVuIGl0IGlzIGZvcmNlZC4gKilcblxubGV0IHJlYyBjeWNsZV9ub25lbXB0eSB4cyAoKSA9XG4gIGFwcGVuZCB4cyAoY3ljbGVfbm9uZW1wdHkgeHMpICgpXG5cbigqIFtjeWNsZSB4c10gY2hlY2tzIHdoZXRoZXIgW3hzXSBpcyBlbXB0eSBhbmQsIGlmIHNvLCByZXR1cm5zIGFuIGVtcHR5XG4gICBzZXF1ZW5jZS4gT3RoZXJ3aXNlLCBbY3ljbGUgeHNdIHByb2R1Y2VzIG9uZSBjb3B5IG9mIFt4c10gZm9sbG93ZWRcbiAgIHdpdGggdGhlIGluZmluaXRlIHNlcXVlbmNlIFtjeWNsZV9ub25lbXB0eSB4c10uIFRodXMsIHRoZSBub25lbXB0aW5lc3NcbiAgIGNoZWNrIGlzIHBlcmZvcm1lZCBqdXN0IG9uY2UuICopXG5cbmxldCBjeWNsZSB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMnKSAtPlxuICAgICAgQ29ucyAoeCwgYXBwZW5kIHhzJyAoY3ljbGVfbm9uZW1wdHkgeHMpKVxuXG4oKiBbaXRlcmF0ZTEgZiB4XSBpcyB0aGUgc2VxdWVuY2UgW2YgeCwgZiAoZiB4KSwgLi4uXS5cbiAgIEl0IGlzIGVxdWl2YWxlbnQgdG8gW3RhaWwgKGl0ZXJhdGUgZiB4KV0uXG4gICBbaXRlcmF0ZTFdIGlzIHVzZWQgYXMgYSBidWlsZGluZyBibG9jayBpbiB0aGUgZGVmaW5pdGlvbiBvZiBbaXRlcmF0ZV0uICopXG5cbmxldCByZWMgaXRlcmF0ZTEgZiB4ICgpID1cbiAgbGV0IHkgPSBmIHggaW5cbiAgQ29ucyAoeSwgaXRlcmF0ZTEgZiB5KVxuXG4oKiBbaXRlcmF0ZSBmIHhdIGlzIHRoZSBzZXF1ZW5jZSBbeCwgZiB4LCAuLi5dLiAqKVxuXG4oKiBUaGUgcmVhc29uIHdoeSB3ZSBnaXZlIHRoaXMgc2xpZ2h0bHkgaW5kaXJlY3QgZGVmaW5pdGlvbiBvZiBbaXRlcmF0ZV0sXG4gICBhcyBvcHBvc2VkIHRvIHRoZSBtb3JlIG5haXZlIGRlZmluaXRpb24gdGhhdCBtYXkgY29tZSB0byBtaW5kLCBpcyB0aGF0XG4gICB3ZSBhcmUgY2FyZWZ1bCB0byBhdm9pZCBldmFsdWF0aW5nIFtmIHhdIHVudGlsIHRoaXMgZnVuY3Rpb24gY2FsbCBpc1xuICAgYWN0dWFsbHkgbmVjZXNzYXJ5LiBUaGUgbmFpdmUgZGVmaW5pdGlvbiAobm90IHNob3duIGhlcmUpIGNvbXB1dGVzIHRoZVxuICAgc2Vjb25kIGFyZ3VtZW50IG9mIHRoZSBzZXF1ZW5jZSwgW2YgeF0sIHdoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IGlzXG4gICByZXF1ZXN0ZWQgYnkgdGhlIHVzZXIuICopXG5cbmxldCBpdGVyYXRlIGYgeCA9XG4gIGNvbnMgeCAoaXRlcmF0ZTEgZiB4KVxuXG5cblxubGV0IHJlYyBtYXBpX2F1eCBmIGkgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgQ29ucyAoZiBpIHgsIG1hcGlfYXV4IGYgKGkrMSkgeHMpXG5cbmxldFtAaW5saW5lXSBtYXBpIGYgeHMgPVxuICBtYXBpX2F1eCBmIDAgeHNcblxuKCogW3RhaWxfc2NhbiBmIHMgeHNdIGlzIGVxdWl2YWxlbnQgdG8gW3RhaWwgKHNjYW4gZiBzIHhzKV0uXG4gICBbdGFpbF9zY2FuXSBpcyB1c2VkIGFzIGEgYnVpbGRpbmcgYmxvY2sgaW4gdGhlIGRlZmluaXRpb24gb2YgW3NjYW5dLiAqKVxuXG4oKiBUaGlzIHNsaWdodGx5IGluZGlyZWN0IGRlZmluaXRpb24gb2YgW3NjYW5dIGlzIG1lYW50IHRvIGF2b2lkIGNvbXB1dGluZ1xuICAgZWxlbWVudHMgdG9vIGVhcmx5OyBzZWUgdGhlIGFib3ZlIGNvbW1lbnQgYWJvdXQgW2l0ZXJhdGUxXSBhbmQgW2l0ZXJhdGVdLiAqKVxuXG5sZXQgcmVjIHRhaWxfc2NhbiBmIHMgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbGV0IHMgPSBmIHMgeCBpblxuICAgICAgQ29ucyAocywgdGFpbF9zY2FuIGYgcyB4cylcblxubGV0IHNjYW4gZiBzIHhzID1cbiAgY29ucyBzICh0YWlsX3NjYW4gZiBzIHhzKVxuXG4oKiBbdGFrZV0gaXMgZGVmaW5lZCBpbiBzdWNoIGEgd2F5IHRoYXQgW3Rha2UgMCB4c10gcmV0dXJucyBbZW1wdHldXG4gICBpbW1lZGlhdGVseSwgd2l0aG91dCBhbGxvY2F0aW5nIGFueSBtZW1vcnkuICopXG5cbmxldCByZWMgdGFrZV9hdXggbiB4cyA9XG4gIGlmIG4gPSAwIHRoZW5cbiAgICBlbXB0eVxuICBlbHNlXG4gICAgZnVuICgpIC0+XG4gICAgICBtYXRjaCB4cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgTmlsXG4gICAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICAgIENvbnMgKHgsIHRha2VfYXV4IChuLTEpIHhzKVxuXG5sZXQgdGFrZSBuIHhzID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcS50YWtlXCI7XG4gIHRha2VfYXV4IG4geHNcblxuKCogW2ZvcmNlX2Ryb3AgbiB4c10gaXMgZXF1aXZhbGVudCB0byBbZHJvcCBuIHhzICgpXS5cbiAgIFtmb3JjZV9kcm9wIG4geHNdIHJlcXVpcmVzIFtuID4gMF0uXG4gICBbZm9yY2VfZHJvcF0gaXMgdXNlZCBhcyBhIGJ1aWxkaW5nIGJsb2NrIGluIHRoZSBkZWZpbml0aW9uIG9mIFtkcm9wXS4gKilcblxubGV0IHJlYyBmb3JjZV9kcm9wIG4geHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKF8sIHhzKSAtPlxuICAgICAgbGV0IG4gPSBuIC0gMSBpblxuICAgICAgaWYgbiA9IDAgdGhlblxuICAgICAgICB4cygpXG4gICAgICBlbHNlXG4gICAgICAgIGZvcmNlX2Ryb3AgbiB4c1xuXG4oKiBbZHJvcF0gaXMgZGVmaW5lZCBpbiBzdWNoIGEgd2F5IHRoYXQgW2Ryb3AgMCB4c10gcmV0dXJucyBbeHNdIGltbWVkaWF0ZWx5LFxuICAgd2l0aG91dCBhbGxvY2F0aW5nIGFueSBtZW1vcnkuICopXG5cbmxldCBkcm9wIG4geHMgPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiU2VxLmRyb3BcIlxuICBlbHNlIGlmIG4gPSAwIHRoZW5cbiAgICB4c1xuICBlbHNlXG4gICAgZnVuICgpIC0+XG4gICAgICBmb3JjZV9kcm9wIG4geHNcblxubGV0IHJlYyB0YWtlX3doaWxlIHAgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgaWYgcCB4IHRoZW4gQ29ucyAoeCwgdGFrZV93aGlsZSBwIHhzKSBlbHNlIE5pbFxuXG5sZXQgcmVjIGRyb3Bfd2hpbGUgcCB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIGFzIG5vZGUgLT5cbiAgICAgIGlmIHAgeCB0aGVuIGRyb3Bfd2hpbGUgcCB4cyAoKSBlbHNlIG5vZGVcblxubGV0IHJlYyBncm91cCBlcSB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBDb25zIChjb25zIHggKHRha2Vfd2hpbGUgKGVxIHgpIHhzKSwgZ3JvdXAgZXEgKGRyb3Bfd2hpbGUgKGVxIHgpIHhzKSlcblxuZXhjZXB0aW9uIEZvcmNlZF90d2ljZVxuXG5tb2R1bGUgU3VzcGVuc2lvbiA9IHN0cnVjdFxuXG4gIHR5cGUgJ2Egc3VzcGVuc2lvbiA9XG4gICAgdW5pdCAtPiAnYVxuXG4gICgqIENvbnZlcnNpb25zLiAqKVxuXG4gIGxldCB0b19sYXp5IDogJ2Egc3VzcGVuc2lvbiAtPiAnYSBMYXp5LnQgPVxuICAgIExhenkuZnJvbV9mdW5cbiAgICAoKiBmdW4gcyAtPiBsYXp5IChzKCkpICopXG5cbiAgbGV0IGZyb21fbGF6eSAocyA6ICdhIExhenkudCkgOiAnYSBzdXNwZW5zaW9uID1cbiAgICBmdW4gKCkgLT4gTGF6eS5mb3JjZSBzXG5cbiAgKCogW21lbW9pemVdIHR1cm5zIGFuIGFyYml0cmFyeSBzdXNwZW5zaW9uIGludG8gYSBwZXJzaXN0ZW50IHN1c3BlbnNpb24uICopXG5cbiAgbGV0IG1lbW9pemUgKHMgOiAnYSBzdXNwZW5zaW9uKSA6ICdhIHN1c3BlbnNpb24gPVxuICAgIGZyb21fbGF6eSAodG9fbGF6eSBzKVxuXG4gICgqIFtmYWlsdXJlXSBpcyBhIHN1c3BlbnNpb24gdGhhdCBmYWlscyB3aGVuIGZvcmNlZC4gKilcblxuICBsZXQgZmFpbHVyZSA6IF8gc3VzcGVuc2lvbiA9XG4gICAgZnVuICgpIC0+XG4gICAgICAoKiBBIHN1c3BlbnNpb24gY3JlYXRlZCBieSBbb25jZV0gaGFzIGJlZW4gZm9yY2VkIHR3aWNlLiAqKVxuICAgICAgcmFpc2UgRm9yY2VkX3R3aWNlXG5cbiAgKCogSWYgW2ZdIGlzIGEgc3VzcGVuc2lvbiwgdGhlbiBbb25jZSBmXSBpcyBhIHN1c3BlbnNpb24gdGhhdCBjYW4gYmUgZm9yY2VkXG4gICAgIGF0IG1vc3Qgb25jZS4gSWYgaXQgaXMgZm9yY2VkIG1vcmUgdGhhbiBvbmNlLCB0aGVuIFtGb3JjZWRfdHdpY2VdIGlzXG4gICAgIHJhaXNlZC4gKilcblxuICBsZXQgb25jZSAoZiA6ICdhIHN1c3BlbnNpb24pIDogJ2Egc3VzcGVuc2lvbiA9XG4gICAgbGV0IGFjdGlvbiA9IENhbWxpbnRlcm5hbEF0b21pYy5tYWtlIGYgaW5cbiAgICBmdW4gKCkgLT5cbiAgICAgICgqIEdldCB0aGUgZnVuY3Rpb24gY3VycmVudGx5IHN0b3JlZCBpbiBbYWN0aW9uXSwgYW5kIHdyaXRlIHRoZVxuICAgICAgICAgZnVuY3Rpb24gW2ZhaWx1cmVdIGluIGl0cyBwbGFjZSwgc28gdGhlIG5leHQgYWNjZXNzIHdpbGwgcmVzdWx0XG4gICAgICAgICBpbiBhIGNhbGwgdG8gW2ZhaWx1cmUoKV0uICopXG4gICAgICBsZXQgZiA9IENhbWxpbnRlcm5hbEF0b21pYy5leGNoYW5nZSBhY3Rpb24gZmFpbHVyZSBpblxuICAgICAgZigpXG5cbmVuZCAoKiBTdXNwZW5zaW9uICopXG5cbmxldCByZWMgbWVtb2l6ZSB4cyA9XG4gIFN1c3BlbnNpb24ubWVtb2l6ZSAoZnVuICgpIC0+XG4gICAgbWF0Y2ggeHMoKSB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgICAgTmlsXG4gICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgQ29ucyAoeCwgbWVtb2l6ZSB4cylcbiAgKVxuXG5sZXQgcmVjIG9uY2UgeHMgPVxuICBTdXNwZW5zaW9uLm9uY2UgKGZ1biAoKSAtPlxuICAgIG1hdGNoIHhzKCkgd2l0aFxuICAgIHwgTmlsIC0+XG4gICAgICAgIE5pbFxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIENvbnMgKHgsIG9uY2UgeHMpXG4gIClcblxuXG5sZXQgcmVjIHppcCB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCB5cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgTmlsXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIENvbnMgKCh4LCB5KSwgemlwIHhzIHlzKVxuXG5sZXQgcmVjIG1hcDIgZiB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCB5cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgTmlsXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIENvbnMgKGYgeCB5LCBtYXAyIGYgeHMgeXMpXG5cbmxldCByZWMgaW50ZXJsZWF2ZSB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgeXMoKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgQ29ucyAoeCwgaW50ZXJsZWF2ZSB5cyB4cylcblxuKCogW3NvcnRlZF9tZXJnZTFsIGNtcCB4IHhzIHlzXSBpcyBlcXVpdmFsZW50IHRvXG4gICAgIFtzb3J0ZWRfbWVyZ2UgY21wIChjb25zIHggeHMpIHlzXS5cblxuICAgW3NvcnRlZF9tZXJnZTFyIGNtcCB4cyB5IHlzXSBpcyBlcXVpdmFsZW50IHRvXG4gICAgIFtzb3J0ZWRfbWVyZ2UgY21wIHhzIChjb25zIHkgeXMpXS5cblxuICAgW3NvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c10gaXMgZXF1aXZhbGVudCB0b1xuICAgICBbc29ydGVkX21lcmdlIGNtcCAoY29ucyB4IHhzKSAoY29ucyB5IHlzKV0uXG5cbiAgIFRoZXNlIHRocmVlIGZ1bmN0aW9ucyBhcmUgdXNlZCBhcyBidWlsZGluZyBibG9ja3MgaW4gdGhlIGRlZmluaXRpb25cbiAgIG9mIFtzb3J0ZWRfbWVyZ2VdLiAqKVxuXG5sZXQgcmVjIHNvcnRlZF9tZXJnZTFsIGNtcCB4IHhzIHlzICgpID1cbiAgbWF0Y2ggeXMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBDb25zICh4LCB4cylcbiAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgIHNvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c1xuXG5hbmQgc29ydGVkX21lcmdlMXIgY21wIHhzIHkgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIENvbnMgKHksIHlzKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgc29ydGVkX21lcmdlMSBjbXAgeCB4cyB5IHlzXG5cbmFuZCBzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXMgPVxuICBpZiBjbXAgeCB5IDw9IDAgdGhlblxuICAgIENvbnMgKHgsIHNvcnRlZF9tZXJnZTFyIGNtcCB4cyB5IHlzKVxuICBlbHNlXG4gICAgQ29ucyAoeSwgc29ydGVkX21lcmdlMWwgY21wIHggeHMgeXMpXG5cbmxldCBzb3J0ZWRfbWVyZ2UgY21wIHhzIHlzICgpID1cbiAgbWF0Y2ggeHMoKSwgeXMoKSB3aXRoXG4gICAgfCBOaWwsIE5pbCAtPlxuICAgICAgICBOaWxcbiAgICB8IE5pbCwgY1xuICAgIHwgYywgTmlsIC0+XG4gICAgICAgIGNcbiAgICB8IENvbnMgKHgsIHhzKSwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICAgIHNvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c1xuXG5cbmxldCByZWMgbWFwX2ZzdCB4eXMgKCkgPVxuICBtYXRjaCB4eXMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICgoeCwgXyksIHh5cykgLT5cbiAgICAgIENvbnMgKHgsIG1hcF9mc3QgeHlzKVxuXG5sZXQgcmVjIG1hcF9zbmQgeHlzICgpID1cbiAgbWF0Y2ggeHlzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoKF8sIHkpLCB4eXMpIC0+XG4gICAgICBDb25zICh5LCBtYXBfc25kIHh5cylcblxubGV0IHVuemlwIHh5cyA9XG4gIG1hcF9mc3QgeHlzLCBtYXBfc25kIHh5c1xuXG5sZXQgc3BsaXQgPVxuICB1bnppcFxuXG4oKiBbZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIGYgeHNdIGlzIGVxdWl2YWxlbnQgdG9cbiAgIFtmaWx0ZXJfbWFwIEVpdGhlci5maW5kX2xlZnQgKG1hcCBmIHhzKV0uICopXG5cbmxldCByZWMgZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIGYgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgIHwgRWl0aGVyLkxlZnQgeSAtPlxuICAgICAgICAgIENvbnMgKHksIGZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzKVxuICAgICAgfCBFaXRoZXIuUmlnaHQgXyAtPlxuICAgICAgICAgIGZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzICgpXG5cbmxldCByZWMgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IEVpdGhlci5MZWZ0IF8gLT5cbiAgICAgICAgICBmaWx0ZXJfbWFwX2ZpbmRfcmlnaHRfbWFwIGYgeHMgKClcbiAgICAgIHwgRWl0aGVyLlJpZ2h0IHogLT5cbiAgICAgICAgICBDb25zICh6LCBmaWx0ZXJfbWFwX2ZpbmRfcmlnaHRfbWFwIGYgeHMpXG5cbmxldCBwYXJ0aXRpb25fbWFwIGYgeHMgPVxuICBmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAgZiB4cyxcbiAgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzXG5cbmxldCBwYXJ0aXRpb24gcCB4cyA9XG4gIGZpbHRlciBwIHhzLCBmaWx0ZXIgKGZ1biB4IC0+IG5vdCAocCB4KSkgeHNcblxuKCogSWYgW3hzc10gaXMgYSBtYXRyaXggKGEgc2VxdWVuY2Ugb2Ygcm93cyksIHRoZW4gW3BlZWwgeHNzXSBpcyBhIHBhaXIgb2ZcbiAgIHRoZSBmaXJzdCBjb2x1bW4gKGEgc2VxdWVuY2Ugb2YgZWxlbWVudHMpIGFuZCBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZVxuICAgbWF0cml4IChhIHNlcXVlbmNlIG9mIHNob3J0ZXIgcm93cykuIFRoZXNlIHR3byBzZXF1ZW5jZXMgaGF2ZSB0aGUgc2FtZVxuICAgbGVuZ3RoLiBUaGUgcm93cyBvZiB0aGUgbWF0cml4IFt4c3NdIGFyZSBub3QgcmVxdWlyZWQgdG8gaGF2ZSB0aGUgc2FtZVxuICAgbGVuZ3RoLiBBbiBlbXB0eSByb3cgaXMgaWdub3JlZC4gKilcblxuKCogQmVjYXVzZSBbcGVlbF0gdXNlcyBbdW56aXBdLCBpdHMgYXJndW1lbnQgbXVzdCBiZSBwZXJzaXN0ZW50LiBUaGUgc2FtZVxuICAgcmVtYXJrIGFwcGxpZXMgdG8gW3RyYW5zcG9zZV0sIFtkaWFnb25hbHNdLCBbcHJvZHVjdF0sIGV0Yy4gKilcblxubGV0IHBlZWwgeHNzID1cbiAgdW56aXAgKGZpbHRlcl9tYXAgdW5jb25zIHhzcylcblxubGV0IHJlYyB0cmFuc3Bvc2UgeHNzICgpID1cbiAgbGV0IGhlYWRzLCB0YWlscyA9IHBlZWwgeHNzIGluXG4gIGlmIGlzX2VtcHR5IGhlYWRzIHRoZW4gYmVnaW5cbiAgICBhc3NlcnQgKGlzX2VtcHR5IHRhaWxzKTtcbiAgICBOaWxcbiAgZW5kXG4gIGVsc2VcbiAgICBDb25zIChoZWFkcywgdHJhbnNwb3NlIHRhaWxzKVxuXG4oKiBUaGUgaW50ZXJuYWwgZnVuY3Rpb24gW2RpYWdvbmFsc10gdGFrZXMgYW4gZXh0cmEgYXJndW1lbnQsIFtyZW1haW5kZXJzXSxcbiAgIHdoaWNoIGNvbnRhaW5zIHRoZSByZW1haW5kZXJzIG9mIHRoZSByb3dzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW5cbiAgIGRpc2NvdmVyZWQuICopXG5cbmxldCByZWMgZGlhZ29uYWxzIHJlbWFpbmRlcnMgeHNzICgpID1cbiAgbWF0Y2ggeHNzKCkgd2l0aFxuICB8IENvbnMgKHhzLCB4c3MpIC0+XG4gICAgICBiZWdpbiBtYXRjaCB4cygpIHdpdGhcbiAgICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgICAgKCogV2UgZGlzY292ZXIgYSBuZXcgbm9uZW1wdHkgcm93IFt4IDo6IHhzXS4gVGh1cywgdGhlIG5leHQgZGlhZ29uYWxcbiAgICAgICAgICAgICBpcyBbeCA6OiBoZWFkc106IHRoaXMgZGlhZ29uYWwgYmVnaW5zIHdpdGggW3hdIGFuZCBjb250aW51ZXMgd2l0aFxuICAgICAgICAgICAgIHRoZSBmaXJzdCBlbGVtZW50IG9mIGV2ZXJ5IHJvdyBpbiBbcmVtYWluZGVyc10uIEluIHRoZSByZWN1cnNpdmVcbiAgICAgICAgICAgICBjYWxsLCB0aGUgYXJndW1lbnQgW3JlbWFpbmRlcnNdIGlzIGluc3RhbnRpYXRlZCB3aXRoIFt4cyA6OlxuICAgICAgICAgICAgIHRhaWxzXSwgd2hpY2ggbWVhbnMgdGhhdCB3ZSBoYXZlIG9uZSBtb3JlIHJlbWFpbmluZyByb3csIFt4c10sXG4gICAgICAgICAgICAgYW5kIHRoYXQgd2Uga2VlcCB0aGUgdGFpbHMgb2YgdGhlIHByZS1leGlzdGluZyByZW1haW5pbmcgcm93cy4gKilcbiAgICAgICAgICBsZXQgaGVhZHMsIHRhaWxzID0gcGVlbCByZW1haW5kZXJzIGluXG4gICAgICAgICAgQ29ucyAoY29ucyB4IGhlYWRzLCBkaWFnb25hbHMgKGNvbnMgeHMgdGFpbHMpIHhzcylcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgKCogV2UgZGlzY292ZXIgYSBuZXcgZW1wdHkgcm93LiBJbiB0aGlzIGNhc2UsIHRoZSBuZXcgZGlhZ29uYWwgaXNcbiAgICAgICAgICAgICBqdXN0IFtoZWFkc10sIGFuZCBbcmVtYWluZGVyc10gaXMgaW5zdGFudGlhdGVkIHdpdGgganVzdCBbdGFpbHNdLFxuICAgICAgICAgICAgIGFzIHdlIGRvIG5vdCBoYXZlIG9uZSBtb3JlIHJlbWFpbmluZyByb3cuICopXG4gICAgICAgICAgbGV0IGhlYWRzLCB0YWlscyA9IHBlZWwgcmVtYWluZGVycyBpblxuICAgICAgICAgIENvbnMgKGhlYWRzLCBkaWFnb25hbHMgdGFpbHMgeHNzKVxuICAgICAgZW5kXG4gIHwgTmlsIC0+XG4gICAgICAoKiBUaGVyZSBhcmUgbm8gbW9yZSByb3dzIHRvIGJlIGRpc2NvdmVyZWQuIFRoZXJlIHJlbWFpbnMgdG8gZXhoYXVzdFxuICAgICAgICAgdGhlIHJlbWFpbmluZyByb3dzLiAqKVxuICAgICAgdHJhbnNwb3NlIHJlbWFpbmRlcnMgKClcblxuKCogSWYgW3hzc10gaXMgYSBtYXRyaXggKGEgc2VxdWVuY2Ugb2Ygcm93cyksIHRoZW4gW2RpYWdvbmFscyB4c3NdIGlzXG4gICB0aGUgc2VxdWVuY2Ugb2YgaXRzIGRpYWdvbmFscy5cblxuICAgVGhlIGZpcnN0IGRpYWdvbmFsIGNvbnRhaW5zIGp1c3QgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlXG4gICBmaXJzdCByb3cuIFRoZSBzZWNvbmQgZGlhZ29uYWwgY29udGFpbnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlXG4gICBzZWNvbmQgcm93IGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgdGhlIGZpcnN0IHJvdzsgYW5kIHNvIG9uLlxuICAgVGhpcyBraW5kIG9mIGRpYWdvbmFsIGlzIGluIGZhY3Qgc29tZXRpbWVzIGtub3duIGFzIGFuIGFudGlkaWFnb25hbC5cblxuICAgLSBFdmVyeSBkaWFnb25hbCBpcyBhIGZpbml0ZSBzZXF1ZW5jZS5cbiAgIC0gVGhlIHJvd3Mgb2YgdGhlIG1hdHJpeCBbeHNzXSBhcmUgbm90IHJlcXVpcmVkIHRvIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlxuICAgLSBUaGUgbWF0cml4IFt4c3NdIGlzIG5vdCByZXF1aXJlZCB0byBiZSBmaW5pdGUgKGluIGVpdGhlciBkaXJlY3Rpb24pLlxuICAgLSBUaGUgbWF0cml4IFt4c3NdIG11c3QgYmUgcGVyc2lzdGVudC4gKilcblxubGV0IGRpYWdvbmFscyB4c3MgPVxuICBkaWFnb25hbHMgZW1wdHkgeHNzXG5cbmxldCBtYXBfcHJvZHVjdCBmIHhzIHlzID1cbiAgY29uY2F0IChkaWFnb25hbHMgKFxuICAgIG1hcCAoZnVuIHggLT5cbiAgICAgIG1hcCAoZnVuIHkgLT5cbiAgICAgICAgZiB4IHlcbiAgICAgICkgeXNcbiAgICApIHhzXG4gICkpXG5cbmxldCBwcm9kdWN0IHhzIHlzID1cbiAgbWFwX3Byb2R1Y3QgKGZ1biB4IHkgLT4gKHgsIHkpKSB4cyB5c1xuXG5sZXQgb2ZfZGlzcGVuc2VyIGl0ID1cbiAgbGV0IHJlYyBjICgpID1cbiAgICBtYXRjaCBpdCgpIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgICAgTmlsXG4gICAgfCBTb21lIHggLT5cbiAgICAgICAgQ29ucyAoeCwgYylcbiAgaW5cbiAgY1xuXG5sZXQgdG9fZGlzcGVuc2VyIHhzID1cbiAgbGV0IHMgPSByZWYgeHMgaW5cbiAgZnVuICgpIC0+XG4gICAgbWF0Y2ggKCFzKSgpIHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgICBOb25lXG4gICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgcyA6PSB4cztcbiAgICAgICAgU29tZSB4XG5cblxuXG5sZXQgcmVjIGludHMgaSAoKSA9XG4gIENvbnMgKGksIGludHMgKGkgKyAxKSlcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiQXNzZXJ0X2ZhaWx1cmUiLCJDYW1saW50ZXJuYWxBdG9taWMiLCJDYW1saW50ZXJuYWxMYXp5IiwiU3RkbGliIiwiU3RkbGliX0xhenkiLCJjc3RfU2VxX2luaXQiLCJjc3RfU2VxX3Rha2UiLCJjc3RfU2VxX2Ryb3AiLCJlbXB0eSIsInBhcmFtIiwicmV0dXJuJCIsIngiLCJjb25zIiwibmV4dCIsImFwcGVuZCIsInNlcTEiLCJzZXEyIiwibWF0Y2giLCJtYXAiLCJzZXEiLCJmaWx0ZXJfbWFwIiwieSIsImZpbHRlciIsImNvbmNhdCIsImZsYXRfbWFwIiwiZm9sZF9sZWZ0IiwiYWNjIiwiaXRlciIsInVuZm9sZCIsInUiLCJpc19lbXB0eSIsInhzIiwidW5jb25zIiwibGVuZ3RoIiwiYWNjdSIsIml0ZXJpIiwiaSIsImZvbGRfbGVmdGkiLCJmb3JfYWxsIiwicCIsImV4aXN0cyIsImZpbmQiLCJmaW5kX21hcCIsInJlc3VsdCIsIml0ZXIyIiwieXMiLCJmb2xkX2xlZnQyIiwiZm9yX2FsbDIiLCJleGlzdHMyIiwiZXF1YWwiLCJlcSIsImNvbXBhcmUiLCJjbXAiLCJjIiwiaW5pdF9hdXgiLCJqIiwiaW5pdCIsIm4iLCJyZXBlYXQiLCJmb3JldmVyIiwiY3ljbGVfbm9uZW1wdHkiLCJjeWNsZSIsIml0ZXJhdGUxIiwiaXRlcmF0ZSIsIm1hcGlfYXV4IiwibWFwaSIsInRhaWxfc2NhbiIsInMiLCJzY2FuIiwidGFrZV9hdXgiLCJ0YWtlIiwiZHJvcCIsInRha2Vfd2hpbGUiLCJkcm9wX3doaWxlIiwibm9kZSIsImdyb3VwIiwiRm9yY2VkX3R3aWNlIiwidG9fbGF6eSIsImZhaWx1cmUiLCJtZW1vaXplIiwib25jZSIsImFjdGlvbiIsInppcCIsIm1hcDIiLCJpbnRlcmxlYXZlIiwic29ydGVkX21lcmdlMSIsInNvcnRlZF9tZXJnZSIsIm1hcF9mc3QiLCJ4eXMiLCJtYXBfc25kIiwidW56aXAiLCJmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAiLCJmaWx0ZXJfbWFwX2ZpbmRfcmlnaHRfbWFwIiwieiIsInBhcnRpdGlvbl9tYXAiLCJwYXJ0aXRpb24iLCJwZWVsIiwieHNzIiwidHJhbnNwb3NlIiwidGFpbHMiLCJoZWFkcyIsInJlbWFpbmRlcnMiLCJtYXBfcHJvZHVjdCIsInByb2R1Y3QiLCJvZl9kaXNwZW5zZXIiLCJpdCIsInRvX2Rpc3BlbnNlciIsImludHMiLCJTdGRsaWJfU2VxIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxNQUFBQyxPQ3VCZSxTQUFHO0FBQUEsWUFBQUMsUUFBQUMsR0FBQUYsT0FFQSxxQkFBZTtBQUFBLFlBQUFHLEtBQUFELEdBQUFFLE1BQUFKLE9BRVosb0JBQWM7QUFBQSxZQUFBSyxPQUFBQyxNQUFBQyxNQUFBUDtBQUFBQSxRQUFBUSxRQUczQjtBQUFBLElBQU0sWUFDSCwwQkFDcUM7QUFBQSxRQUFBSixPQUZsQyxVQUFBRixJQUFBO0FBQUEsSUFFaUMsMEJBQWhCLCtCQUFnQjtBQUFBLEdBQUM7QUFBQSxZQUFBTyxJQUFBekIsR0FBQTBCLEtBQUFWO0FBQUFBLFFBQUFRLFFBRW5CO0FBQUEsSUFBSyxZQUN2QjtBQUFBLFFBQUFKLE9BRHVCLFVBQUFGLElBQUE7QUFBQSxJQUVOLHlDQUFLLHlCQUFGO0FBQUEsR0FBYTtBQUFBLFlBQUFTLFdBQUEzQixHQUFBMEIsT0FBQVY7QUFBQUEsUUFBQVUsTUFFZDtBQUFBO0FBQUEsU0FBQUYsUUFBTTtBQUFBLEtBQUssWUFDOUI7QUFBQSxTQUFBSixPQUQ4QixVQUFBRixJQUFBLFVBQUFNLFVBRzdCO0FBQUEsS0FBRztBQUFBO0FBQUE7QUFBQSxRQUFBSSxJQUhlO0FBQUEsSUFLZ0IsMEJBQWpCLGdDQUFpQjtBQUFBLEdBQUM7QUFBQSxZQUFBQyxPQUFBN0IsR0FBQTBCLE9BQUFWO0FBQUFBLFFBQUFVLE1BRXJCO0FBQUE7QUFBQSxTQUFBRixRQUFNO0FBQUEsS0FBSyxZQUMxQjtBQUFBLFNBQUFKLE9BRDBCLFVBQUFGLElBQUE7QUFBQSxLQUc1QjtBQUFBLEtBQUc7QUFBQTtBQUFBLElBQ3FCLDBCQUFiLDRCQUFhO0FBQUEsR0FDTjtBQUFBLFlBQUFZLE9BQUFKLEtBQUFWO0FBQUFBLFFBQUFRLFFBRUc7QUFBQSxJQUFNLFlBQ3pCO0FBQUEsUUFBQUosT0FEeUIsVUFBQUYsSUFBQTtBQUFBLElBR1QsNkJBQWIsNEJBQWdCO0FBQUE7QUFBQSxZQUFBYSxTQUFBL0IsR0FBQTBCLEtBQUFWO0FBQUFBLFFBQUFRLFFBRUk7QUFBQSxJQUFNLFlBQzdCO0FBQUEsUUFBQUosT0FENkIsVUFBQUYsSUFBQTtBQUFBLElBRzdCLE9BQUs7QUFBQSxhQUFMLDhCQUFNLGlDQUFvQjtBQUFBO0FBQUEsWUFBQWMsVUFBQWhDLEdBQUFpQyxPQUFBUDtBQUFBQSxRQUFBTyxNQUtuQyxPQUFBUCxNQUFBO0FBQUE7QUFBQSxTQUFBRixRQUFNO0FBQUEsS0FBTSxZQUNEO0FBQUEsU0FBQUosT0FEQyxVQUFBRixJQUFBLFVBQUFlLFFBR0k7QUFBQSxLQUNWO0FBQUE7QUFBQTtBQUFBLEdBQW9CO0FBQUEsWUFBQUMsS0FBQWxDLEdBQUEwQjtBQUFBQSxRQUFBQSxNQUcxQjtBQUFBO0FBQUEsU0FBQUYsUUFBTTtBQUFBLEtBQU0sWUFDRDtBQUFBLFNBQUFKLE9BREMsVUFBQUYsSUFBQTtBQUFBLEtBR047QUFBQSxLQUFHO0FBQUE7QUFBQSxHQUNRO0FBQUEsWUFBQWlCLE9BQUFuQyxHQUFBb0MsR0FBQXBCO0FBQUFBLFFBQUFRLFFBR1g7QUFBQSxJQUFHLFlBQ0M7QUFBQSxRQUFBQSxVQURELFVBQUFZLE1BQUEsWUFBQWxCLElBQUE7QUFBQSxJQUU2QiwwQkFBWCwyQkFBVztBQUFBLEdBQUM7QUFBQSxZQUFBbUIsU0FBQUMsSUFHakMsZ0NBSUc7QUFBQSxZQUFBQyxPQUFBRDtBQUFBQSxRQUFBZCxRQUdIO0FBQUEsSUFBSSxZQUlOO0FBQUEsUUFBQWMsT0FKTSxVQUFBcEIsSUFBQTtBQUFBLElBRU47QUFBQSxHQUVJO0FBQUEsWUFBQXNCLE9BQUFGO0FBQUFBLFFBQUFHLE9BWVIsR0FBQUgsS0FBQTtBQUFBO0FBQUEsU0FBQWQsUUFQTTtBQUFBLEtBQUksWUFFTjtBQUFBLFNBQUFjLE9BRk0sVUFBQUcsU0FJTjtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBR1c7QUFBQSxZQUFBQyxNQUFBMUMsR0FBQXNDO0FBQUFBLFFBQUFLLElBV2YsR0FBQUwsS0FBQTtBQUFBO0FBQUEsU0FBQWQsUUFSTTtBQUFBLEtBQUksWUFFTjtBQUFBLFNBQUFjLE9BRk0sVUFBQXBCLElBQUE7QUFBQSxLQUlOO0FBQUEsU0FBQXlCLE1BQUs7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUlPO0FBQUEsWUFBQUMsV0FBQTVDLEdBQUF5QyxRQUFBSDtBQUFBQSxRQUFBRyxPQVdoQixRQUFBRSxJQUFBLEdBQUFMLEtBQUE7QUFBQTtBQUFBLFNBQUFkLFFBUk07QUFBQSxLQUFJLFlBRU47QUFBQTtBQUFBLE1BQUFjLE9BRk07QUFBQSxNQUFBcEIsSUFBQTtBQUFBLE1BQUF1QixTQUlLO0FBQUEsTUFBQUUsTUFDWDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FHc0I7QUFBQSxZQUFBRSxRQUFBQyxHQUFBUjtBQUFBQSxRQUFBQSxLQUcxQjtBQUFBO0FBQUEsU0FBQWQsUUFBTTtBQUFBLEtBQUksWUFFTjtBQUFBLFNBQUFjLE9BRk0sVUFBQXBCLElBQUEsY0FJTjtBQUFBLEtBQUc7QUFBQTtBQUFBO0FBQUEsR0FBZ0I7QUFBQSxZQUFBNkIsT0FBQUQsR0FBQVI7QUFBQUEsUUFBQUEsS0FHdkI7QUFBQTtBQUFBLFNBQUFkLFFBQU07QUFBQSxLQUFJLFlBRU47QUFBQSxTQUFBYyxPQUZNLFVBQUFwQixJQUFBLGNBSU47QUFBQSxLQUFHO0FBQUE7QUFBQTtBQUFBLEdBQWU7QUFBQSxZQUFBOEIsS0FBQUYsR0FBQVI7QUFBQUEsUUFBQUEsS0FHdEI7QUFBQTtBQUFBLFNBQUFkLFFBQU07QUFBQSxLQUFJLFlBRU47QUFBQSxTQUFBYyxPQUZNLFVBQUFwQixJQUFBO0FBQUEsS0FJSCxxQkFBUztBQUFBLEtBQU47QUFBQTtBQUFBLEdBQTJCO0FBQUEsWUFBQStCLFNBQUFqRCxHQUFBc0M7QUFBQUEsUUFBQUEsS0FHckM7QUFBQTtBQUFBLFNBQUFkLFFBQU07QUFBQSxLQUFJLFlBRU47QUFBQSxTQUFBYyxPQUZNLFVBQUFwQixJQUFBLFVBQUFnQyxTQUlBO0FBQUEsS0FBRyxXQUlMO0FBQUEsS0FKSztBQUFBO0FBQUEsR0FJQztBQUFBLFlBQUFDLE1BQUFuRCxHQUFBc0MsTUFBQWM7QUFBQUEsUUFBQWQsS0FVZCxNQUFBYyxLQUFBO0FBQUE7QUFBQSxTQUFBNUIsUUFBTTtBQUFBLEtBQUksWUFFTjtBQUFBLFNBQUFjLE9BRk0sVUFBQXBCLElBQUEsVUFBQU0sVUFJQTtBQUFBLEtBQUksY0FFTjtBQUFBLFNBQUE0QixPQUZNLFlBQUF4QixJQUFBO0FBQUEsS0FJTjtBQUFBLEtBQUs7QUFBQTtBQUFBO0FBQUEsR0FDUTtBQUFBLFlBQUF5QixXQUFBckQsR0FBQXlDLFFBQUFILE1BQUFjO0FBQUFBLFFBQUFYLE9BR3JCLFFBQUFILEtBQUEsTUFBQWMsS0FBQTtBQUFBO0FBQUEsU0FBQTVCLFFBQU07QUFBQSxLQUFJLFlBRU47QUFBQSxTQUFBYyxPQUZNLFVBQUFwQixJQUFBLFVBQUFNLFVBSUE7QUFBQSxLQUFJLGNBRU47QUFBQTtBQUFBLE1BQUE0QixPQUZNO0FBQUEsTUFBQXhCLElBQUE7QUFBQSxNQUFBYSxTQUlLO0FBQUEsS0FDWDtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQXVCO0FBQUEsWUFBQWEsU0FBQXRELEdBQUFzQyxNQUFBYztBQUFBQSxRQUFBZCxLQUcvQixNQUFBYyxLQUFBO0FBQUE7QUFBQSxTQUFBNUIsUUFBTTtBQUFBLEtBQUksWUFFTjtBQUFBLFNBQUFjLE9BRk0sVUFBQXBCLElBQUEsVUFBQU0sVUFJQTtBQUFBLEtBQUksY0FFTjtBQUFBLFNBQUE0QixPQUZNLFlBQUF4QixJQUFBLGdCQUlOO0FBQUEsS0FBSztBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQW9CO0FBQUEsWUFBQTJCLFFBQUF2RCxHQUFBc0MsTUFBQWM7QUFBQUEsUUFBQWQsS0FHakMsTUFBQWMsS0FBQTtBQUFBO0FBQUEsU0FBQTVCLFFBQU07QUFBQSxLQUFJLFlBRU47QUFBQSxTQUFBYyxPQUZNLFVBQUFwQixJQUFBLFVBQUFNLFVBSUE7QUFBQSxLQUFJLGNBRU47QUFBQSxTQUFBNEIsT0FGTSxZQUFBeEIsSUFBQSxnQkFJTjtBQUFBLEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUFtQjtBQUFBLFlBQUE0QixNQUFBQyxJQUFBbkIsTUFBQWM7QUFBQUEsUUFBQWQsS0FHaEMsTUFBQWMsS0FBQTtBQUFBO0FBQUEsU0FBQTVCLFFBQU0sbUJBQUFBLFVBQU07QUFBQSxLQUFJO0FBQUE7QUFBQTtBQUFBLFFBQUE0QixPQUFBO0FBQUEsUUFBQXhCLElBQUE7QUFBQSxRQUFBVSxPQUFBO0FBQUEsUUFBQXBCLElBQUE7QUFBQSxZQUlaO0FBQUEsT0FBTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx3QkFGTjtBQUFBLEtBS0E7QUFBQTtBQUFBLEdBQUs7QUFBQSxZQUFBd0MsUUFBQUMsS0FBQXJCLE1BQUFjO0FBQUFBLFFBQUFkLEtBR1QsTUFBQWMsS0FBQTtBQUFBO0FBQUEsU0FBQTVCLFFBQU0sbUJBQUFBLFVBQU07QUFBQSxLQUFJLG1DQVNWO0FBQUEsU0FBQWMsT0FUVSxVQUFBcEIsSUFBQTtBQUFBLG1CQVNaO0FBQUEsU0FBQWtDLE9BVFksWUFBQXhCLElBQUEsWUFBQWdDLElBSUo7QUFBQSxLQUNSLFlBQWU7QUFBQSxLQUFmO0FBQUE7QUFBQTtBQUFBLEdBSUU7QUFBQSxZQUFBQyxTQUFBN0QsR0FBQTJDLEdBQUFtQixHQUFBOUM7QUFBQUEsSUFPTixXQUlFO0FBQUEsWUFIVztBQUFBLElBQUwseUNBQUssOEJBQUY7QUFBQSxHQUdOO0FBQUEsWUFBQStDLEtBQUFDLEdBQUFoRTtBQUFBQSxJQUdMLFVBQ0UseUNBRWM7QUFBQSxZQUFkO0FBQUEsdUJEN1BKLDZCQzZQSTtBQUFBLEdBQWM7QUFBQSxZQUFBaUUsT0FBQS9DLEdBQUFGO0FBQUFBLElBR0MsMEJBQVIsc0JBQVE7QUFBQSxHQUFDO0FBQUEsWUFBQWtELFFBQUFsRSxHQUFBZ0I7QUFBQUEsSUFHWix5Q0FBSyx1QkFBRjtBQUFBLEdBQVk7QUFBQSxZQUFBbUQsZUFBQTdCLElBQUF0QjtBQUFBQSxJQU9RLDhCQUFuQixrQ0FBc0I7QUFBQTtBQUFBLFlBQUFvRCxNQUFBOUIsSUFBQXRCO0FBQUFBLFFBQUFRLFFBUTFCO0FBQUEsSUFBSSxZQUVOO0FBQUEsUUFBQWMsT0FGTSxVQUFBcEIsSUFBQTtBQUFBLGtCQUljO0FBQUEsSUFBbUIsMEJBQTlCLDRCQUE4QjtBQUFBLEdBQUM7QUFBQSxZQUFBbUQsU0FBQXJFLEdBQUFrQixHQUFBRjtBQUFBQSxRQUFBWSxJQU9wQztBQUFBLElBQ2EsMEJBQVosMkJBQVk7QUFBQSxHQUFDO0FBQUEsWUFBQTBDLFFBQUF0RSxHQUFBa0I7QUFBQUEsYUFBQUUsS0FBQSxHQVlmO0FBQUEsSUFBYyxnQkFBQUosT0EvUUYscUJBK1FFO0FBQUE7QUFBQSxZQUFBdUQsU0FBQXZFLEdBQUEyQyxHQUFBTCxJQUFBdEI7QUFBQUEsUUFBQVEsUUFLZjtBQUFBLElBQUksWUFFTjtBQUFBLFFBQUFjLE9BRk0sVUFBQXBCLElBQUEsY0FJTztBQUFBLElBQVA7QUFBQTtBQUFBLHdCQUFPLGlDQUFGO0FBQUEsR0FBc0I7QUFBQSxZQUFBc0QsS0FBQXhFLEdBQUFzQztBQUFBQSxRQUFBLElBR3JDO0FBQUEsdUJEdFRGLDhCQ3NURTtBQUFBLEdBQWU7QUFBQSxZQUFBbUMsVUFBQXpFLEdBQUEwRSxHQUFBcEMsSUFBQXRCO0FBQUFBLFFBQUFRLFFBU1Q7QUFBQSxJQUFJLFlBRU47QUFBQSxRQUFBYyxPQUZNLFVBQUFwQixJQUFBLFVBQUF3RCxNQUlFO0FBQUEsSUFDaUIsNEJBQWhCLG9DQUFnQjtBQUFBLEdBQUM7QUFBQSxZQUFBQyxLQUFBM0UsR0FBQTBFLEdBQUFwQztBQUFBQSxhQUFBbEIsS0FBQSxHQUd2QjtBQUFBLElBQWtCLGdCQUFBSixPQTVTTixxQkE0U007QUFBQTtBQUFBLFlBQUE0RCxTQUFBWixHQUFBMUI7QUFBQUEsSUFNekI7QUFBQTtBQUFBO0FBQUEsY0FBQXRCO0FBQUFBLGtCQUFBUSxRQUlVO0FBQUEsY0FBSSxZQUVOO0FBQUEsa0JBQUFjLE9BRk0sVUFBQXBCLElBQUE7QUFBQSxjQUlHLHdDQUFpQjtBQUFBLGFBQUM7QUFBQTtBQUFBLFlBQUEyRCxLQUFBYixHQUFBMUI7QUFBQUEsSUFHbkMsVUFBYztBQUFBLElBQ2Qsc0JBQWE7QUFBQTtBQUFBLFlBQUF3QyxLQUFBZCxHQUFBMUI7QUFBQUEsSUFxQmI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBdEI7QUFBQUEsb0JBQUFnRCxNQUtJLEdBQUExQixPQUFBO0FBQUE7QUFBQSxxQkFBQWQsUUFuQkU7QUFBQSxpQkFBSSxZQUVOO0FBQUEscUJBQUFjLE9BRk0sVUFBQTBCLE1BSU47QUFBQSxpQkFDQSxjQUNFLDBCQWFhO0FBQUEsaUJBZGY7QUFBQTtBQUFBO0FBQUEsZUFjZTtBQUFBLGNBTEwsa0NBS0s7QUFBQTtBQUFBLFlBQUFlLFdBQUFqQyxHQUFBUixJQUFBdEI7QUFBQUEsUUFBQVEsUUFHYjtBQUFBLElBQUksWUFFTjtBQUFBLFFBQUFjLE9BRk0sVUFBQXBCLElBQUE7QUFBQSxJQUlIO0FBQUEsaUNBQWtCO0FBQUEsZUFBeUI7QUFBQTtBQUFBLFlBQUE4RCxXQUFBbEMsR0FBQVIsTUFBQXRCO0FBQUFBLFFBQUFzQixLQUdsRDtBQUFBO0FBQUEsU0FBQTJDLE9BQU07QUFBQSxLQUFJLFdBRU47QUFBQSxTQUFBM0MsT0FGTSxTQUFBcEIsSUFBQTtBQUFBLEtBSUgsdUJBQWlDO0FBQUEsS0FBOUI7QUFBQTtBQUFBLEdBQWtDO0FBQUEsWUFBQWdFLE1BQUF6QixJQUFBbkIsSUFBQXRCO0FBQUFBLFFBQUFRLFFBR3RDO0FBQUEsSUFBSSxZQUVOO0FBQUEsUUFBQWMsT0FGTSxVQUFBcEIsSUFBQSxjQUlvRDtBQUFBLGtCQUFaO0FBQUEsWUFBckI7QUFBQSxhQUFBRSxLQUFBLEdBQVo7QUFBQSxJQUFzQjtBQUFBLHFCQUFBSixPQTdXcEI7QUFBQSx3QkE2V3NCLHlCQUFGO0FBQUEsR0FBa0M7QUFBQTtBQUFBLElBQUFtRTtBQUFBQSxNRHhZM0U7QUFBQSxJQUFBQyxVQUFBO0FBQUE7QUFBQSxZQUFBQyxRQUFBckU7QUFBQUEsSUNvYU07QUFBQSxHQUFrQjtBQUFBLFlBQUFzRSxRQUFBaEQ7QUFBQUEsYUFBQW9DLElBQUExRDtBQUFBQSxTQUFBUSxRQW1CZDtBQUFBLEtBQUksWUFFTjtBQUFBLFNBQUFjLE9BRk0sVUFBQXBCLElBQUE7QUFBQSxLQUlHLDRCQUFVO0FBQUEsSUFBQztBQUFBLFFBQUF3RCxJQTlCZDtBQUFBLElBQVcsZ0JBQUExRDtBQUFBQSxTQUFBLElBTFg7QUFBQTtBQUFBO0FBQUEsa0VBS1c7QUFBQSxHQStCdEI7QUFBQSxZQUFBdUUsS0FBQWpEO0FBQUFBLGFBQUF0QyxFQUFBZ0I7QUFBQUEsU0FBQVEsUUFJTztBQUFBLEtBQUksWUFFTjtBQUFBLFNBQUFjLE9BRk0sVUFBQXBCLElBQUE7QUFBQSxLQUlHLHlCQUFPO0FBQUEsSUFBQztBQUFBLFFBQUFzRSxTQXpCUjtBQUFBLElBQ2IsZ0JBQUF4RTtBQUFBQSxTQUFBaEIsSUFJVTtBQUFBLEtBQ1IsdUJBQUcsRUFMTDtBQUFBLEdBeUJEO0FBQUEsWUFBQXlGLElBQUFuRCxJQUFBYyxJQUFBcEM7QUFBQUEsUUFBQVEsUUFJSztBQUFBLElBQUksWUFFTjtBQUFBLFFBQUFjLE9BRk0sVUFBQXBCLElBQUEsVUFBQU0sVUFJQTtBQUFBLElBQUksY0FFTjtBQUFBLFFBQUE0QixPQUZNLFlBQUF4QixJQUFBO0FBQUEsSUFJaUIsa0NBQVQsNEJBQVM7QUFBQSxHQUFDO0FBQUEsWUFBQThELEtBQUExRixHQUFBc0MsSUFBQWMsSUFBQXBDO0FBQUFBLFFBQUFRLFFBRzFCO0FBQUEsSUFBSSxZQUVOO0FBQUEsUUFBQWMsT0FGTSxVQUFBcEIsSUFBQSxVQUFBTSxVQUlBO0FBQUEsSUFBSSxjQUVOO0FBQUEsUUFBQTRCLE9BRk0sWUFBQXhCLElBQUE7QUFBQSxJQUlBO0FBQUE7QUFBQSx3QkFBTyxnQ0FBRjtBQUFBLEdBQWU7QUFBQSxZQUFBK0QsV0FBQXJELElBQUFjLElBQUFwQztBQUFBQSxRQUFBUSxRQUc1QjtBQUFBLElBQUksWUFFTix3QkFFMEI7QUFBQSxRQUFBYyxPQUpwQixVQUFBcEIsSUFBQTtBQUFBLElBSW1CLDBCQUFoQixpQ0FBZ0I7QUFBQSxHQUFDO0FBQUEsWUFBQTBFLGNBQUFqQyxLQUFBekMsR0FBQW9CLElBQUFWLEdBQUF3QjtBQUFBQSxJQTZCM0I7QUFBQTtBQUFBO0FBQUEsdUJBQUFwQztBQUFBQSxtQkFBQVEsUUFkRztBQUFBLGVBQUksWUFFTjtBQUFBLG1CQUFBNEIsT0FGTSxVQUFBeEIsSUFBQTtBQUFBLGVBSU47QUFBQTtBQUFBO0FBQUE7QUFBQSx1QkFBQVo7QUFBQUEsbUJBQUFRLFFBR0U7QUFBQSxlQUFJLFlBRU47QUFBQSxtQkFBQWMsT0FGTSxVQUFBcEIsSUFBQTtBQUFBLGVBSU47QUFBQSxnQkFNa0M7QUFBQTtBQUFBLFlBQUEyRSxhQUFBbEMsS0FBQXJCLElBQUFjLElBQUFwQztBQUFBQSxRQUFBUSxRQUdoQyxtQkFBQUEsVUFBTTtBQUFBLElBQUk7QUFBQTtBQUFBLFVBQUE0QixPQUFBLFlBQUF4QixJQUFBLFlBQUFVLE9BQUEsVUFBQXBCLElBQUE7QUFBQSxNQU9WLDJDQUEyQjtBQUFBO0FBQUEsU0FBQTBDLElBUGpCO0FBQUE7QUFBQSx1QkFFVixjQUFBQSxJQUZVO0FBQUEsSUFLVjtBQUFBLEdBRTJCO0FBQUEsWUFBQWtDLFFBQUFDLEtBQUEvRTtBQUFBQSxRQUFBUSxRQUkzQjtBQUFBLElBQUssWUFFUDtBQUFBLFFBQUF1RSxRQUZPLFVBQUE3RSxJQUFBO0FBQUEsSUFJYSwwQkFBWCwyQkFBVztBQUFBLEdBQUM7QUFBQSxZQUFBOEUsUUFBQUQsS0FBQS9FO0FBQUFBLFFBQUFRLFFBR25CO0FBQUEsSUFBSyxZQUVQO0FBQUEsUUFBQXVFLFFBRk8sVUFBQW5FLElBQUE7QUFBQSxJQUlhLDBCQUFYLDJCQUFXO0FBQUEsR0FBQztBQUFBLFlBQUFxRSxNQUFBRjtBQUFBQSxJQUdkO0FBQUEsd0JBQVg7QUFBQSx3QkFBYSx5QkFBRjtBQUFBLEdBQWE7QUFBQSxZQUFBRyx5QkFBQWxHLEdBQUFzQyxNQUFBdEI7QUFBQUEsUUFBQXNCLEtBU3hCO0FBQUE7QUFBQSxTQUFBZCxRQUFNO0FBQUEsS0FBSSxZQUVOO0FBQUEsU0FBQWMsT0FGTSxVQUFBcEIsSUFBQSxVQUFBTSxVQUlBO0FBQUEsS0FBRztBQUFBO0FBQUE7QUFBQSxRQUFBSSxJQUpiO0FBQUEsSUFNOEMsMEJBQTdCLDhDQUE2QjtBQUFBLEdBRU47QUFBQSxZQUFBdUUsMEJBQUFuRyxHQUFBc0MsTUFBQXRCO0FBQUFBLFFBQUFzQixLQUd4QztBQUFBO0FBQUEsU0FBQWQsUUFBTTtBQUFBLEtBQUksWUFFTjtBQUFBLFNBQUFjLE9BRk0sVUFBQXBCLElBQUEsVUFBQU0sVUFJQTtBQUFBLEtBQUc7QUFBQTtBQUFBO0FBQUEsUUFBQTRFLElBSmI7QUFBQSxJQVErQywwQkFBOUIsK0NBQThCO0FBQUEsR0FBQztBQUFBLFlBQUFDLGNBQUFyRyxHQUFBc0M7QUFBQUEsSUFHbkI7QUFBQSx3QkFBN0I7QUFBQSx3QkFDQSw2Q0FENkI7QUFBQSxHQUNDO0FBQUEsWUFBQWdFLFVBQUF4RCxHQUFBUjtBQUFBQSxhQUFBLEVBQUFwQixHQUdJLDJCQUFLO0FBQUEsSUFBNUI7QUFBQSx3QkFBWDtBQUFBLHdCQUFhLDBCQUFGO0FBQUEsR0FBZ0M7QUFBQSxZQUFBcUYsS0FBQUM7QUFBQUEsSUFZZCx5QkFBdkIsb0NBQXVCO0FBQUE7QUFBQSxZQUFBQyxVQUFBRCxLQUFBeEY7QUFBQUEsUUFBQVEsUUFHVixXQUFBa0YsUUFBUSxVQUFBQyxRQUFBO0FBQUEsSUFDeEI7QUFBQSxLQUsyQiw4QkFBZiw2QkFBZTtBQUFBLElBSnJCLG9CQUNQO0FBQUEsSUFEdUI7QUFBQSxHQUlNO0FBQUEsY0FBQUMsWUFBQUosS0FBQXhGO0FBQUFBLFFBQUFRLFFBT3pCO0FBQUEsSUFBSyxZQXNCUCwrQkFBdUI7QUFBQSxRQUFBZ0YsUUF0QmhCLFVBQUFsRSxLQUFBLFVBQUFkLFVBRUs7QUFBQSxJQUFJO0FBQUE7QUFBQSxNQUFBYyxPQUFBO0FBQUEsTUFBQXBCLElBQUE7QUFBQSxNQUFBTSxVQVFPO0FBQUEsTUFBQWtGLFFBQWU7QUFBQSxNQUFBQyxRQUFBO0FBQUEsVUFDSixTQUFBM0YsT0E5a0JuQjtBQUFBLEtBOGtCTztBQUFBLHNCQUFBQSxPQTlrQlA7QUFBQSx5QkE4a0JTLHdCQUFGO0FBQUE7QUFBQTtBQUFBLEtBQUFRLFVBS0M7QUFBQSxLQUFBa0YsVUFBZTtBQUFBLEtBQUFDLFVBQUE7QUFBQSxJQUNGLGdDQUFuQiw4QkFBbUI7QUFBQSxHQUtiO0FBQUEsWUFBQUUsWUFBQTdHLEdBQUFzQyxJQUFBYztBQUFBQSxhQUFBLEVBQUFsQztBQUFBQSxjQUFBLEVBQUFVLEdBc0JyQiwwQkFBSztBQUFBLEtBRFAsbUJEem9CTixzQkN5b0JNO0FBQUEsSUFFSTtBQUFBLGFBQUE0RSxJQUFBLEdBSlU7QUFBQSxrQkFIbEI7QUFBQSxJQVNFO0FBQUE7QUFBQSxZQUFBTSxRQUFBeEUsSUFBQWM7QUFBQUEsSUFHRiw0QkFBQWxDLEdBQUFVLEdBQXdCLGlCQUFNLFVBQU87QUFBQTtBQUFBLFlBQUFtRixhQUFBQztBQUFBQSxhQUFBcEQsRUFBQTVDO0FBQUFBLFNBQUFRLFFBSTdCO0FBQUEsS0FBSSxZQUVOO0FBQUEsU0FBQU4sSUFGTTtBQUFBLEtBSU47QUFBQSxJQUFXO0FBQUEsSUFFakI7QUFBQSxHQUFDO0FBQUEsWUFBQStGLGFBQUEzRTtBQUFBQSxRQUFBb0MsSUFHRDtBQUFBLElBQ0EsZ0JBQUExRDtBQUFBQSxTQUFBUSxRQUNRO0FBQUEsS0FBTSxZQUVSO0FBQUEsU0FBQWMsS0FGUSxVQUFBcEIsSUFBQTtBQUFBLEtBSVI7QUFBQSxLQUNBLGNBQU0sQ0FOWjtBQUFBLEdBTVk7QUFBQSxZQUFBZ0csS0FBQXZFLEdBQUEzQjtBQUFBQSxRQUFBLElBS0g7QUFBQSxJQUFZLDBCQUFaLG9CQUFZO0FBQUEsR0FBQztBQUFBO0FBQUEsSUFBQW1HO0FBQUFBLE1EenFCeEIiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMDM1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvb3B0aW9uLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSAnYSBvcHRpb24gPSBOb25lIHwgU29tZSBvZiAnYVxuXG5sZXQgbm9uZSA9IE5vbmVcbmxldCBzb21lIHYgPSBTb21lIHZcbmxldCB2YWx1ZSBvIH5kZWZhdWx0ID0gbWF0Y2ggbyB3aXRoIFNvbWUgdiAtPiB2IHwgTm9uZSAtPiBkZWZhdWx0XG5sZXQgZ2V0ID0gZnVuY3Rpb24gU29tZSB2IC0+IHYgfCBOb25lIC0+IGludmFsaWRfYXJnIFwib3B0aW9uIGlzIE5vbmVcIlxubGV0IGJpbmQgbyBmID0gbWF0Y2ggbyB3aXRoIE5vbmUgLT4gTm9uZSB8IFNvbWUgdiAtPiBmIHZcbmxldCBqb2luID0gZnVuY3Rpb24gU29tZSBvIC0+IG8gfCBOb25lIC0+IE5vbmVcbmxldCBtYXAgZiBvID0gbWF0Y2ggbyB3aXRoIE5vbmUgLT4gTm9uZSB8IFNvbWUgdiAtPiBTb21lIChmIHYpXG5sZXQgZm9sZCB+bm9uZSB+c29tZSA9IGZ1bmN0aW9uIFNvbWUgdiAtPiBzb21lIHYgfCBOb25lIC0+IG5vbmVcbmxldCBpdGVyIGYgPSBmdW5jdGlvbiBTb21lIHYgLT4gZiB2IHwgTm9uZSAtPiAoKVxubGV0IGlzX25vbmUgPSBmdW5jdGlvbiBOb25lIC0+IHRydWUgfCBTb21lIF8gLT4gZmFsc2VcbmxldCBpc19zb21lID0gZnVuY3Rpb24gTm9uZSAtPiBmYWxzZSB8IFNvbWUgXyAtPiB0cnVlXG5cbmxldCBlcXVhbCBlcSBvMCBvMSA9IG1hdGNoIG8wLCBvMSB3aXRoXG58IFNvbWUgdjAsIFNvbWUgdjEgLT4gZXEgdjAgdjFcbnwgTm9uZSwgTm9uZSAtPiB0cnVlXG58IF8gLT4gZmFsc2VcblxubGV0IGNvbXBhcmUgY21wIG8wIG8xID0gbWF0Y2ggbzAsIG8xIHdpdGhcbnwgU29tZSB2MCwgU29tZSB2MSAtPiBjbXAgdjAgdjFcbnwgTm9uZSwgTm9uZSAtPiAwXG58IE5vbmUsIFNvbWUgXyAtPiAtMVxufCBTb21lIF8sIE5vbmUgLT4gMVxuXG5sZXQgdG9fcmVzdWx0IH5ub25lID0gZnVuY3Rpb24gTm9uZSAtPiBFcnJvciBub25lIHwgU29tZSB2IC0+IE9rIHZcbmxldCB0b19saXN0ID0gZnVuY3Rpb24gTm9uZSAtPiBbXSB8IFNvbWUgdiAtPiBbdl1cbmxldCB0b19zZXEgPSBmdW5jdGlvbiBOb25lIC0+IFNlcS5lbXB0eSB8IFNvbWUgdiAtPiBTZXEucmV0dXJuIHZcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiU3RkbGliX1NlcSIsIlN0ZGxpYiIsImNzdF9vcHRpb25faXNfTm9uZSIsInNvbWUiLCJ2IiwidmFsdWUiLCJvIiwiZGVmYXVsdCQiLCJnZXQiLCJwYXJhbSIsImJpbmQiLCJqb2luIiwibWFwIiwiZm9sZCIsIm5vbmUiLCJpdGVyIiwiaXNfbm9uZSIsImlzX3NvbWUiLCJlcXVhbCIsImVxIiwibzAiLCJvMSIsInYxIiwidjAiLCJjb21wYXJlIiwiY21wIiwidG9fcmVzdWx0IiwidG9fbGlzdCIsInRvX3NlcSIsIlN0ZGxpYl9PcHRpb24iXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsWUFBQUMsS0FBQUMsR0NrQmEsY0FBTTtBQUFBLFlBQUFDLE1BQUFDLEdBQUFDO0FBQUFBLElBQ0ksUUFBbUM7QUFBQSxRQUFBSCxJQUFuQztBQUFBLElBQXVCO0FBQUEsR0FBbUI7QUFBQSxZQUFBSSxJQUFBQztBQUFBQSxJQUN2RCxZQUErQiwrQ0FBNEI7QUFBQSxRQUFBTCxJQUEzRDtBQUFBLElBQW1CO0FBQUEsR0FBd0M7QUFBQSxZQUFBTSxLQUFBSixHQUFBWDtBQUFBQSxJQUN0RCxRQUFxQjtBQUFBLFFBQUFTLElBQXJCO0FBQUEsSUFBc0MsdUJBQUc7QUFBQTtBQUFBLFlBQUFPLEtBQUFGLE9BQzdDLFlBQStCLGNBQUFILElBQS9CLFVBQW1CLFNBQWdCO0FBQUEsWUFBQU0sSUFBQWpCLEdBQUFXO0FBQUFBLElBQ2hDLFFBQXFCO0FBQUEsUUFBQUYsSUFBckI7QUFBQSxJQUEyQyw0QkFBSztBQUFBO0FBQUEsWUFBQVMsS0FBQUMsTUFBQVgsTUFBQU07QUFBQUEsSUFDckQsWUFBa0Q7QUFBQSxRQUFBTCxJQUFsRDtBQUFBLElBQWlDLDBCQUFxQjtBQUFBO0FBQUEsWUFBQVcsS0FBQXBCLEdBQUFjO0FBQUFBLElBQ3RELFlBQXFDO0FBQUEsUUFBQUwsSUFBckM7QUFBQSxJQUF1Qix1QkFBZ0I7QUFBQTtBQUFBLFlBQUFZLFFBQUFQLE9BQ2xDLG9CQUF1QztBQUFBLFlBQUFRLFFBQUFSLE9BQ3ZDLG9CQUF1QztBQUFBLFlBQUFTLE1BQUFDLElBQUFDLElBQUFDO0FBQUFBLElBRWhDO0FBQUEsZ0JBQUFDLEtBQUEsT0FBQUMsS0FBQSxPQUNDLDZCQUVWO0FBQUE7QUFBQSxrQkFESTtBQUFBLElBQ1Q7QUFBQSxHQUFLO0FBQUEsWUFBQUMsUUFBQUMsS0FBQUwsSUFBQUM7QUFBQUEsSUFFWSwyQkFJTDtBQUFBLFFBQUFFLEtBSks7QUFBQSxhQUlOO0FBQUEsUUFBQUQsS0FKTTtBQUFBLElBQ0YsOEJBR0g7QUFBQTtBQUFBLFlBQUFJLFVBQUFaLE1BQUFMO0FBQUFBLElBRUwsWUFBeUI7QUFBQSxRQUFBTCxJQUF6QjtBQUFBLElBQWdEO0FBQUEsR0FBSTtBQUFBLFlBQUF1QixRQUFBbEI7QUFBQUEsSUFDcEQsWUFBaUI7QUFBQSxRQUFBTCxJQUFqQjtBQUFBLElBQWdDO0FBQUEsR0FBRztBQUFBLFlBQUF3QixPQUFBbkI7QUFBQUEsSUFDcEMsWUFBaUI7QUFBQSxRQUFBTCxJQUFqQixjQUF1QztBQUFBLHVCRDFDcEQsZ0JDMENvRDtBQUFBLEdBQVk7QUFBQTtBQUFBLElBQUF5QjtBQUFBQSxNRDFDaEUiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMTQ0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvcmVzdWx0Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdlXG5cbmxldCBvayB2ID0gT2sgdlxubGV0IGVycm9yIGUgPSBFcnJvciBlXG5sZXQgdmFsdWUgciB+ZGVmYXVsdCA9IG1hdGNoIHIgd2l0aCBPayB2IC0+IHYgfCBFcnJvciBfIC0+IGRlZmF1bHRcbmxldCBnZXRfb2sgPSBmdW5jdGlvbiBPayB2IC0+IHYgfCBFcnJvciBfIC0+IGludmFsaWRfYXJnIFwicmVzdWx0IGlzIEVycm9yIF9cIlxubGV0IGdldF9lcnJvciA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gZSB8IE9rIF8gLT4gaW52YWxpZF9hcmcgXCJyZXN1bHQgaXMgT2sgX1wiXG5sZXQgYmluZCByIGYgPSBtYXRjaCByIHdpdGggT2sgdiAtPiBmIHYgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IGpvaW4gPSBmdW5jdGlvbiBPayByIC0+IHIgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IG1hcCBmID0gZnVuY3Rpb24gT2sgdiAtPiBPayAoZiB2KSB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgbWFwX2Vycm9yIGYgPSBmdW5jdGlvbiBFcnJvciBlIC0+IEVycm9yIChmIGUpIHwgT2sgXyBhcyB2IC0+IHZcbmxldCBmb2xkIH5vayB+ZXJyb3IgPSBmdW5jdGlvbiBPayB2IC0+IG9rIHYgfCBFcnJvciBlIC0+IGVycm9yIGVcbmxldCBpdGVyIGYgPSBmdW5jdGlvbiBPayB2IC0+IGYgdiB8IEVycm9yIF8gLT4gKClcbmxldCBpdGVyX2Vycm9yIGYgPSBmdW5jdGlvbiBFcnJvciBlIC0+IGYgZSB8IE9rIF8gLT4gKClcbmxldCBpc19vayA9IGZ1bmN0aW9uIE9rIF8gLT4gdHJ1ZSB8IEVycm9yIF8gLT4gZmFsc2VcbmxldCBpc19lcnJvciA9IGZ1bmN0aW9uIEVycm9yIF8gLT4gdHJ1ZSB8IE9rIF8gLT4gZmFsc2VcblxubGV0IGVxdWFsIH5vayB+ZXJyb3IgcjAgcjEgPSBtYXRjaCByMCwgcjEgd2l0aFxufCBPayB2MCwgT2sgdjEgLT4gb2sgdjAgdjFcbnwgRXJyb3IgZTAsIEVycm9yIGUxIC0+IGVycm9yIGUwIGUxXG58IF8sIF8gLT4gZmFsc2VcblxubGV0IGNvbXBhcmUgfm9rIH5lcnJvciByMCByMSA9IG1hdGNoIHIwLCByMSB3aXRoXG58IE9rIHYwLCBPayB2MSAtPiBvayB2MCB2MVxufCBFcnJvciBlMCwgRXJyb3IgZTEgLT4gZXJyb3IgZTAgZTFcbnwgT2sgXywgRXJyb3IgXyAtPiAtMVxufCBFcnJvciBfLCBPayBfIC0+IDFcblxubGV0IHRvX29wdGlvbiA9IGZ1bmN0aW9uIE9rIHYgLT4gU29tZSB2IHwgRXJyb3IgXyAtPiBOb25lXG5sZXQgdG9fbGlzdCA9IGZ1bmN0aW9uIE9rIHYgLT4gW3ZdIHwgRXJyb3IgXyAtPiBbXVxubGV0IHRvX3NlcSA9IGZ1bmN0aW9uIE9rIHYgLT4gU2VxLnJldHVybiB2IHwgRXJyb3IgXyAtPiBTZXEuZW1wdHlcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiU3RkbGliX1NlcSIsIlN0ZGxpYiIsImNzdF9yZXN1bHRfaXNfRXJyb3IiLCJjc3RfcmVzdWx0X2lzX09rIiwib2siLCJ2IiwiZXJyb3IiLCJlIiwidmFsdWUiLCJyIiwiZGVmYXVsdCQiLCJnZXRfb2siLCJwYXJhbSIsImdldF9lcnJvciIsImJpbmQiLCJqb2luIiwibWFwIiwibWFwX2Vycm9yIiwiZm9sZCIsIml0ZXIiLCJpdGVyX2Vycm9yIiwiaXNfb2siLCJpc19lcnJvciIsImVxdWFsIiwicjAiLCJyMSIsInYwIiwidjEiLCJlMCIsImUxIiwiY29tcGFyZSIsInRvX29wdGlvbiIsInRvX2xpc3QiLCJ0b19zZXEiLCJTdGRsaWJfUmVzdWx0Il0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsWUFBQUMsR0FBQUMsR0NpQlcsY0FBSTtBQUFBLFlBQUFDLE1BQUFDLEdBQ0QsY0FBTztBQUFBLFlBQUFDLE1BQUFDLEdBQUFDO0FBQUFBLElBQ0UsZUFBb0M7QUFBQSxRQUFBTCxJQUFwQztBQUFBLElBQXFCO0FBQUEsR0FBc0I7QUFBQSxZQUFBTSxPQUFBQztBQUFBQSxJQUNyRCxtQkFBZ0MsZ0RBQStCO0FBQUEsUUFBQVAsSUFBL0Q7QUFBQSxJQUFpQjtBQUFBLEdBQThDO0FBQUEsWUFBQVEsVUFBQUQ7QUFBQUEsSUFDNUQsbUJBQWdDLDZDQUE0QjtBQUFBLFFBQUFMLElBQTVEO0FBQUEsSUFBb0I7QUFBQSxHQUF3QztBQUFBLFlBQUFPLEtBQUFMLEdBQUFkO0FBQUFBLElBQzdELGVBQTJDO0FBQUEsUUFBQVUsSUFBM0M7QUFBQSxJQUFxQix1QkFBdUI7QUFBQTtBQUFBLFlBQUFVLEtBQUFSLEdBQ2hELGVBQXFDLGNBQUFFLElBQXJDLE1BQWlCLFNBQXFCO0FBQUEsWUFBQU8sSUFBQXJCLEdBQUFZO0FBQUFBLElBQ3pDLGVBQWdEO0FBQUEsUUFBQUYsSUFBaEQ7QUFBQSxJQUF3Qiw0QkFBSztBQUFBLEdBQW9CO0FBQUEsWUFBQVksVUFBQXRCLEdBQUFVO0FBQUFBLElBQzNDLGVBQW1EO0FBQUEsUUFBQUUsSUFBbkQ7QUFBQSxJQUE4Qiw0QkFBSztBQUFBLEdBQWlCO0FBQUEsWUFBQVcsS0FBQWQsSUFBQUUsT0FBQU07QUFBQUEsSUFDekQsdUJBQUFQLElBQUEsVUFBOEIsd0JBQXlCO0FBQUEsUUFBQUUsSUFBdkQ7QUFBQSxJQUFnRCwyQkFBTztBQUFBO0FBQUEsWUFBQVksS0FBQXhCLEdBQUFpQjtBQUFBQSxJQUN2RCxtQkFBc0M7QUFBQSxRQUFBUCxJQUF0QztBQUFBLElBQXFCLHVCQUFtQjtBQUFBO0FBQUEsWUFBQWUsV0FBQXpCLEdBQUFpQjtBQUFBQSxJQUNsQyxtQkFBc0M7QUFBQSxRQUFBTCxJQUF0QztBQUFBLElBQXdCLHVCQUFnQjtBQUFBO0FBQUEsWUFBQWMsTUFBQVQsT0FDM0MsNkJBQXdDO0FBQUEsWUFBQVUsU0FBQVYsT0FDckMsNkJBQXdDO0FBQUEsWUFBQVcsTUFBQW5CLElBQUFFLE9BQUFrQixJQUFBQztBQUFBQSxJQUUxQjtBQUFBLFNBQUFDLEtBQUE7QUFBQSx5QkFBQUMsS0FBQSxPQUNYLDZCQUVIO0FBQUE7QUFBQTtBQUFBLFNBQUFDLEtBSGM7QUFBQSx5QkFBQUMsS0FBQSxPQUVMLGdDQUNUO0FBQUE7QUFBQSxJQUFMO0FBQUEsR0FBSztBQUFBLFlBQUFDLFFBQUExQixJQUFBRSxPQUFBa0IsSUFBQUM7QUFBQUEsSUFFZ0I7QUFBQSxTQUFBQyxLQUFBO0FBQUEscUJBR1o7QUFBQSxTQUFBQyxLQUhZO0FBQUEsS0FDYiw2QkFHRTtBQUFBO0FBQUEsUUFBQUMsS0FKVztBQUFBLG9CQUlaO0FBQUEsUUFBQUMsS0FKWTtBQUFBLElBRVAsZ0NBRUo7QUFBQTtBQUFBLFlBQUFFLFVBQUFuQjtBQUFBQSxJQUVKLG1CQUFxQztBQUFBLFFBQUFQLElBQXJDO0FBQUEsSUFBaUI7QUFBQSxHQUF3QjtBQUFBLFlBQUEyQixRQUFBcEI7QUFBQUEsSUFDM0MsbUJBQWtDO0FBQUEsUUFBQVAsSUFBbEM7QUFBQSxJQUFpQjtBQUFBLEdBQW1CO0FBQUEsWUFBQTRCLE9BQUFyQjtBQUFBQSxJQUNyQyxtQkFBMkM7QUFBQSxRQUFBUCxJQUEzQyxjQUFpQjtBQUFBLHVCRDdDOUIsZ0JDNkM4QjtBQUFBLEdBQW1DO0FBQUE7QUFBQSxJQUFBNkI7QUFBQUEsTUQ3Q2pFIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjI4MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL2Jvb2wubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGJvb2wgPSBmYWxzZSB8IHRydWVcblxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxubGV0IGVxdWFsIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBib29sIC0+IGJvb2wgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmV4dGVybmFsIHRvX2ludCA6IGJvb2wgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxubGV0IHRvX2Zsb2F0ID0gZnVuY3Rpb24gZmFsc2UgLT4gMC4gfCB0cnVlIC0+IDEuXG5cbigqXG5sZXQgb2Zfc3RyaW5nID0gZnVuY3Rpb25cbnwgXCJmYWxzZVwiIC0+IFNvbWUgZmFsc2VcbnwgXCJ0cnVlXCIgLT4gU29tZSB0cnVlXG58IF8gLT4gTm9uZVxuKilcblxubGV0IHRvX3N0cmluZyA9IGZ1bmN0aW9uIGZhbHNlIC0+IFwiZmFsc2VcIiB8IHRydWUgLT4gXCJ0cnVlXCJcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiZXF1YWwiLCJjb21wYXJlIiwiY3N0X3RydWUiLCJjc3RfZmFsc2UiLCJ0b19mbG9hdCIsInBhcmFtIiwidG9fc3RyaW5nIiwiU3RkbGliX0Jvb2wiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsTUFBQTtBQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsWUFBQUMsU0FBQUMsT0N1QmUsc0JBQWlDO0FBQUEsWUFBQUMsVUFBQUQsT0FTaEMsbUNBQTBDO0FBQUE7QUFBQSxJQUFBRTtBQUFBQSxNRGhDMUQiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMzEwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvY2hhci5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQ2hhcmFjdGVyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgY29kZTogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB1bnNhZmVfY2hyOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcblxubGV0IGNociBuID1cbiAgaWYgbiA8IDAgfHwgbiA+IDI1NSB0aGVuIGludmFsaWRfYXJnIFwiQ2hhci5jaHJcIiBlbHNlIHVuc2FmZV9jaHIgblxuXG5leHRlcm5hbCBieXRlc19jcmVhdGU6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgYnl0ZXNfdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcblxubGV0IGVzY2FwZWQgPSBmdW5jdGlvblxuICB8ICdcXCcnIC0+IFwiXFxcXCdcIlxuICB8ICdcXFxcJyAtPiBcIlxcXFxcXFxcXCJcbiAgfCAnXFxuJyAtPiBcIlxcXFxuXCJcbiAgfCAnXFx0JyAtPiBcIlxcXFx0XCJcbiAgfCAnXFxyJyAtPiBcIlxcXFxyXCJcbiAgfCAnXFxiJyAtPiBcIlxcXFxiXCJcbiAgfCAnICcgLi4gJ34nIGFzIGMgLT5cbiAgICAgIGxldCBzID0gYnl0ZXNfY3JlYXRlIDEgaW5cbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAwIGM7XG4gICAgICB1bnNhZmVfdG9fc3RyaW5nIHNcbiAgfCBjIC0+XG4gICAgICBsZXQgbiA9IGNvZGUgYyBpblxuICAgICAgbGV0IHMgPSBieXRlc19jcmVhdGUgNCBpblxuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDAgJ1xcXFwnO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDEgKHVuc2FmZV9jaHIgKDQ4ICsgbiAvIDEwMCkpO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDIgKHVuc2FmZV9jaHIgKDQ4ICsgKG4gLyAxMCkgbW9kIDEwKSk7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMyAodW5zYWZlX2NociAoNDggKyBuIG1vZCAxMCkpO1xuICAgICAgdW5zYWZlX3RvX3N0cmluZyBzXG5cbmxldCBsb3dlcmNhc2UgPSBmdW5jdGlvblxuICB8ICdBJyAuLiAnWidcbiAgfCAnXFwxOTInIC4uICdcXDIxNCdcbiAgfCAnXFwyMTYnIC4uICdcXDIyMicgYXMgYyAtPlxuICAgIHVuc2FmZV9jaHIoY29kZSBjICsgMzIpXG4gIHwgYyAtPiBjXG5cbmxldCB1cHBlcmNhc2UgPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneidcbiAgfCAnXFwyMjQnIC4uICdcXDI0NidcbiAgfCAnXFwyNDgnIC4uICdcXDI1NCcgYXMgYyAtPlxuICAgIHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIHwgYyAtPiBjXG5cbmxldCBsb3dlcmNhc2VfYXNjaWkgPSBmdW5jdGlvblxuICB8ICdBJyAuLiAnWicgYXMgYyAtPiB1bnNhZmVfY2hyKGNvZGUgYyArIDMyKVxuICB8IGMgLT4gY1xuXG5sZXQgdXBwZXJjYXNlX2FzY2lpID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onIGFzIGMgLT4gdW5zYWZlX2Nocihjb2RlIGMgLSAzMilcbiAgfCBjIC0+IGNcblxudHlwZSB0ID0gY2hhclxuXG5sZXQgY29tcGFyZSBjMSBjMiA9IGNvZGUgYzEgLSBjb2RlIGMyXG5sZXQgZXF1YWwgKGMxOiB0KSAoYzI6IHQpID0gY29tcGFyZSBjMSBjMiA9IDBcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImdsb2JhbF9kYXRhIiwiY3N0IiwiU3RkbGliIiwiY3N0X0NoYXJfY2hyIiwiY3N0X2IiLCJjc3RfdCIsImNzdF9uIiwiY3N0X3IiLCJjaHIiLCJuIiwiZXNjYXBlZCIsImMiLCJzIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibG93ZXJjYXNlX2FzY2lpIiwidXBwZXJjYXNlX2FzY2lpIiwiY29tcGFyZSIsImMxIiwiYzIiLCJlcXVhbCIsIlN0ZGxpYl9DaGFyIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLFlBQUFDLElBQUFDO0FBQUFBLElDcUJFLHVCQUFxRDtBQUFBLElBQTVCLHlDQUF3QztBQUFBO0FBQUEsWUFBQUMsUUFBQUM7QUFBQUE7QUFBQUE7QUFBQUEsS0FPckQ7QUFBQSxtQkFFRjtBQUFBLE1BRkU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQU1GO0FBQUE7QUFBQSxVQUZBO0FBQUE7QUFBQSxVQURBO0FBQUE7QUFBQSxVQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFMRSxZQUNGO0FBQUE7QUFBQSxTQUFBQyxNQU9FO0FBQUEsS0FDUjtBQUFBLEtBQ0EsZ0NBUWtCO0FBQUE7QUFBQSxRQUFBQSxJQUxWO0FBQUEsSUFDUjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0EsOEJBQWtCO0FBQUE7QUFBQSxZQUFBQyxVQUFBRjtBQUFBQSxRQUFBLElBRVI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUlaO0FBQUE7QUFBQSxJQUNLO0FBQUEsR0FBQztBQUFBLFlBQUFHLFVBQUFIO0FBQUFBLFFBQUEsSUFFTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBSVo7QUFBQTtBQUFBLElBQ0s7QUFBQSxHQUFDO0FBQUEsWUFBQUksZ0JBQUFKLEdBRVkseUNBRVo7QUFBQSxZQUFBSyxnQkFBQUwsR0FFWSx5Q0FFWjtBQUFBLFlBQUFNLFFBQUFDLElBQUFDLElBSVUsbUJBQWlCO0FBQUEsWUFBQUMsTUFBQUYsSUFBQUMsSUFDSSxtQ0FBSTtBQUFBO0FBQUEsSUFBQUU7QUFBQUEsTUR6RTdDIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjQxMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL3VjaGFyLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBEYW5pZWwgQy4gQnVlbnpsaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5cbmxldCBlcnJfbm9fcHJlZCA9IFwiVSswMDAwIGhhcyBubyBwcmVkZWNlc3NvclwiXG5sZXQgZXJyX25vX3N1Y2MgPSBcIlUrMTBGRkZGIGhhcyBubyBzdWNjZXNzb3JcIlxubGV0IGVycl9ub3Rfc3YgaSA9IGZvcm1hdF9pbnQgXCIlWFwiIGkgXiBcIiBpcyBub3QgYW4gVW5pY29kZSBzY2FsYXIgdmFsdWVcIlxubGV0IGVycl9ub3RfbGF0aW4xIHUgPSBcIlUrXCIgXiBmb3JtYXRfaW50IFwiJTA0WFwiIHUgXiBcIiBpcyBub3QgYSBsYXRpbjEgY2hhcmFjdGVyXCJcblxudHlwZSB0ID0gaW50XG5cbmxldCBtaW4gPSAweDAwMDBcbmxldCBtYXggPSAweDEwRkZGRlxubGV0IGxvX2JvdW5kID0gMHhEN0ZGXG5sZXQgaGlfYm91bmQgPSAweEUwMDBcblxubGV0IGJvbSA9IDB4RkVGRlxubGV0IHJlcCA9IDB4RkZGRFxuXG5sZXQgc3VjYyB1ID1cbiAgaWYgdSA9IGxvX2JvdW5kIHRoZW4gaGlfYm91bmQgZWxzZVxuICBpZiB1ID0gbWF4IHRoZW4gaW52YWxpZF9hcmcgZXJyX25vX3N1Y2MgZWxzZVxuICB1ICsgMVxuXG5sZXQgcHJlZCB1ID1cbiAgaWYgdSA9IGhpX2JvdW5kIHRoZW4gbG9fYm91bmQgZWxzZVxuICBpZiB1ID0gbWluIHRoZW4gaW52YWxpZF9hcmcgZXJyX25vX3ByZWQgZWxzZVxuICB1IC0gMVxuXG5sZXQgaXNfdmFsaWQgaSA9IChtaW4gPD0gaSAmJiBpIDw9IGxvX2JvdW5kKSB8fCAoaGlfYm91bmQgPD0gaSAmJiBpIDw9IG1heClcbmxldCBvZl9pbnQgaSA9IGlmIGlzX3ZhbGlkIGkgdGhlbiBpIGVsc2UgaW52YWxpZF9hcmcgKGVycl9ub3Rfc3YgaSlcbmV4dGVybmFsIHVuc2FmZV9vZl9pbnQgOiBpbnQgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHRvX2ludCA6IHQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgaXNfY2hhciB1ID0gdSA8IDI1NlxubGV0IG9mX2NoYXIgYyA9IENoYXIuY29kZSBjXG5sZXQgdG9fY2hhciB1ID1cbiAgaWYgdSA+IDI1NSB0aGVuIGludmFsaWRfYXJnIChlcnJfbm90X2xhdGluMSB1KSBlbHNlXG4gIENoYXIudW5zYWZlX2NociB1XG5cbmxldCB1bnNhZmVfdG9fY2hhciA9IENoYXIudW5zYWZlX2NoclxuXG5sZXQgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5sZXQgaGFzaCA9IHRvX2ludFxuXG4oKiBVVEYgY29kZWNzIHRvb2xzICopXG5cbnR5cGUgdXRmX2RlY29kZSA9IGludFxuKCogVGhpcyBpcyBhbiBpbnQgWzB4RFVVVVVVVV0gZGVjb21wb3NlZCBhcyBmb2xsb3dzOlxuICAgLSBbRF0gaXMgZm91ciBiaXRzIGZvciBkZWNvZGUgaW5mb3JtYXRpb24sIHRoZSBoaWdoZXN0IGJpdCBpcyBzZXQgaWYgdGhlXG4gICAgIGRlY29kZSBpcyB2YWxpZC4gVGhlIHRocmVlIGxvd2VyIGJpdHMgaW5kaWNhdGUgdGhlIG51bWJlciBvZiBlbGVtZW50c1xuICAgICBmcm9tIHRoZSBzb3VyY2UgdGhhdCB3ZXJlIGNvbnN1bWVkIGJ5IHRoZSBkZWNvZGUuXG4gICAtIFtVVVVVVVVdIGlzIHRoZSBkZWNvZGVkIFVuaWNvZGUgY2hhcmFjdGVyIG9yIHRoZSBVbmljb2RlIHJlcGxhY2VtZW50XG4gICAgIGNoYXJhY3RlciBVK0ZGRkQgaWYgZm9yIGludmFsaWQgZGVjb2Rlcy4gKilcblxubGV0IHZhbGlkX2JpdCA9IDI3XG5sZXQgZGVjb2RlX2JpdHMgPSAyNFxuXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZV9pc192YWxpZCBkID0gKGQgbHNyIHZhbGlkX2JpdCkgPSAxXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZV9sZW5ndGggZCA9IChkIGxzciBkZWNvZGVfYml0cykgbGFuZCAwYjExMVxubGV0W0BpbmxpbmVdIHV0Zl9kZWNvZGVfdWNoYXIgZCA9IHVuc2FmZV9vZl9pbnQgKGQgbGFuZCAweEZGRkZGRilcbmxldFtAaW5saW5lXSB1dGZfZGVjb2RlIG4gdSA9ICgoOCBsb3IgbikgbHNsIGRlY29kZV9iaXRzKSBsb3IgKHRvX2ludCB1KVxubGV0W0BpbmxpbmVdIHV0Zl9kZWNvZGVfaW52YWxpZCBuID0gKG4gbHNsIGRlY29kZV9iaXRzKSBsb3IgcmVwXG5cbmxldCB1dGZfOF9ieXRlX2xlbmd0aCB1ID0gbWF0Y2ggdG9faW50IHUgd2l0aFxufCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG58IHUgd2hlbiB1IDw9IDB4MDA3RiAtPiAxXG58IHUgd2hlbiB1IDw9IDB4MDdGRiAtPiAyXG58IHUgd2hlbiB1IDw9IDB4RkZGRiAtPiAzXG58IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+IDRcbnwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHV0Zl8xNl9ieXRlX2xlbmd0aCB1ID0gbWF0Y2ggdG9faW50IHUgd2l0aFxufCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG58IHUgd2hlbiB1IDw9IDB4RkZGRiAtPiAyXG58IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+IDRcbnwgXyAtPiBhc3NlcnQgZmFsc2VcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X3VjaGFyX21sIiwiY2FtbF9mb3JtYXRfaW50IiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiZ2xvYmFsX2RhdGEiLCJlcnJfbm9fcHJlZCIsImVycl9ub19zdWNjIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWIiLCJjc3RfaXNfbm90X2FuX1VuaWNvZGVfc2NhbGFyX3YiLCJjc3RfaXNfbm90X2FfbGF0aW4xX2NoYXJhY3RlciIsImNzdF9VIiwibG9fYm91bmQiLCJoaV9ib3VuZCIsInN1Y2MiLCJ1IiwicHJlZCIsImlzX3ZhbGlkIiwiaSIsIm9mX2ludCIsImlzX2NoYXIiLCJvZl9jaGFyIiwiYyIsInRvX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsImVxdWFsIiwiY29tcGFyZSIsImhhc2giLCJ1dGZfZGVjb2RlX2lzX3ZhbGlkIiwiZCIsInV0Zl9kZWNvZGVfbGVuZ3RoIiwidXRmX2RlY29kZV91Y2hhciIsInV0Zl9kZWNvZGUiLCJuIiwidXRmX2RlY29kZV9pbnZhbGlkIiwidXRmXzhfYnl0ZV9sZW5ndGgiLCJ1dGZfMTZfYnl0ZV9sZW5ndGgiLCJTdGRsaWJfVWNoYXIiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLGdDQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsWUFBQUMsS0FBQUM7QUFBQUEsSUNpQ0U7QUFBQTtBQUFBLDhCQUNnQiw2Q0FDWDtBQUFBO0FBQUEsWUFBQUMsS0FBQUQ7QUFBQUEsSUFHTDtBQUFBO0FBQUEsd0JBQ2dCLDZDQUNYO0FBQUE7QUFBQSxZQUFBRSxTQUFBQztBQUFBQSxRQUFBLElBRVU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FBMEQ7QUFBQSxZQUFBQyxPQUFBRDtBQUFBQSxJQUN6RCxnQkFBZ0I7QUFBQTtBQUFBO0FBQUEsT0F4QkU7QUFBQSxlQUFqQjtBQUFBLElBd0JnRDtBQUFBO0FBQUEsWUFBQUUsUUFBQUwsR0FJbkQsdUJBQU87QUFBQSxZQUFBTSxRQUFBQyxHQUNQLFNBQVc7QUFBQSxZQUFBQyxRQUFBUjtBQUFBQSxJQUV6QixhQUNBO0FBQUE7QUFBQTtBQUFBLE9BL0I0QjtBQUFBO0FBQUEsU0FBa0Q7QUFBQSxJQThCaEMsOEJBQzdCO0FBQUE7QUFBQSxZQUFBUyxlQUFBLEdEbkRuQjtBQUFBLFlBQUFDLE1BQUE7QUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLEtBQUE7QUFBQSxZQUFBQyxvQkFBQUMsR0N3RXFDLG9DQUFxQjtBQUFBLFlBQUFDLGtCQUFBRCxHQUN2QiwwQkFBOEI7QUFBQSxZQUFBRSxpQkFBQUYsR0FDL0Isb0JBQStCO0FBQUEsWUFBQUcsV0FBQUMsR0FBQWxCLEdBQ25DLHlCQUEwQztBQUFBLFlBQUFtQixtQkFBQUQsR0FDcEMsdUJBQTJCO0FBQUEsWUFBQUUsa0JBQUFwQjtBQUFBQSxJQUd0RCxVQUFTO0FBQUEsSUFDVCxhQUFlO0FBQUEsSUFDZixjQUFlO0FBQUEsSUFDZixlQUFlO0FBQUEsSUFDZjtBQUFBLEtBQ0Y7QUFBQSxJQURtQjtBQUFBLEdBQ1A7QUFBQSxZQUFBcUIsbUJBQUFyQjtBQUFBQSxJQUdWLFVBQVM7QUFBQSxJQUNULGVBQWU7QUFBQSxJQUNmO0FBQUEsS0FDRjtBQUFBLElBRG1CO0FBQUEsR0FDUDtBQUFBO0FBQUEsSUFBQXNCO0FBQUFBLE1EMUZuQiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MzMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9saXN0Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgbGlzdHMuICopXG50eXBlICdhIHQgPSAnYSBsaXN0ID0gW10gfCAoOjopIG9mICdhICogJ2EgbGlzdFxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgKilcblxubGV0IHJlYyBsZW5ndGhfYXV4IGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gbGVuXG4gIHwgXzo6bCAtPiBsZW5ndGhfYXV4IChsZW4gKyAxKSBsXG5cbmxldCBsZW5ndGggbCA9IGxlbmd0aF9hdXggMCBsXG5cbmxldCBjb25zIGEgbCA9IGE6OmxcblxubGV0IGhkID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWlsd2l0aCBcImhkXCJcbiAgfCBhOjpfIC0+IGFcblxubGV0IHRsID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWlsd2l0aCBcInRsXCJcbiAgfCBfOjpsIC0+IGxcblxubGV0IG50aCBsIG4gPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5udGhcIiBlbHNlXG4gIGxldCByZWMgbnRoX2F1eCBsIG4gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gZmFpbHdpdGggXCJudGhcIlxuICAgIHwgYTo6bCAtPiBpZiBuID0gMCB0aGVuIGEgZWxzZSBudGhfYXV4IGwgKG4tMSlcbiAgaW4gbnRoX2F1eCBsIG5cblxubGV0IG50aF9vcHQgbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBTb21lIGEgZWxzZSBudGhfYXV4IGwgKG4tMSlcbiAgaW4gbnRoX2F1eCBsIG5cblxubGV0IGFwcGVuZCA9IChAKVxuXG5sZXQgcmVjIHJldl9hcHBlbmQgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBhIDo6IGwgLT4gcmV2X2FwcGVuZCBsIChhIDo6IGwyKVxuXG5sZXQgcmV2IGwgPSByZXZfYXBwZW5kIGwgW11cblxubGV0IHJlYyBpbml0X3RhaWxyZWNfYXV4IGFjYyBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIGFjY1xuICBlbHNlIGluaXRfdGFpbHJlY19hdXggKGYgaSA6OiBhY2MpIChpKzEpIG4gZlxuXG5sZXQgcmVjIGluaXRfYXV4IGkgbiBmID1cbiAgaWYgaSA+PSBuIHRoZW4gW11cbiAgZWxzZVxuICAgIGxldCByID0gZiBpIGluXG4gICAgciA6OiBpbml0X2F1eCAoaSsxKSBuIGZcblxubGV0IHJldl9pbml0X3RocmVzaG9sZCA9XG4gIG1hdGNoIFN5cy5iYWNrZW5kX3R5cGUgd2l0aFxuICB8IFN5cy5OYXRpdmUgfCBTeXMuQnl0ZWNvZGUgLT4gMTBfMDAwXG4gICgqIFdlIGRvbid0IGtub3cgdGhlIHNpemUgb2YgdGhlIHN0YWNrLCBiZXR0ZXIgYmUgc2FmZSBhbmQgYXNzdW1lIGl0J3NcbiAgICAgc21hbGwuICopXG4gIHwgU3lzLk90aGVyIF8gLT4gNTBcblxubGV0IGluaXQgbGVuIGYgPVxuICBpZiBsZW4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LmluaXRcIiBlbHNlXG4gIGlmIGxlbiA+IHJldl9pbml0X3RocmVzaG9sZCB0aGVuIHJldiAoaW5pdF90YWlscmVjX2F1eCBbXSAwIGxlbiBmKVxuICBlbHNlIGluaXRfYXV4IDAgbGVuIGZcblxubGV0IHJlYyBmbGF0dGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGw6OnIgLT4gbCBAIGZsYXR0ZW4gclxuXG5sZXQgY29uY2F0ID0gZmxhdHRlblxuXG5sZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGE6OmwgLT4gbGV0IHIgPSBmIGEgaW4gciA6OiBtYXAgZiBsXG5cbmxldCByZWMgbWFwaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgYTo6bCAtPiBsZXQgciA9IGYgaSBhIGluIHIgOjogbWFwaSAoaSArIDEpIGYgbFxuXG5sZXQgbWFwaSBmIGwgPSBtYXBpIDAgZiBsXG5cbmxldCByZXZfbWFwIGYgbCA9XG4gIGxldCByZWMgcm1hcF9mIGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdVxuICAgIHwgYTo6bCAtPiBybWFwX2YgKGYgYSA6OiBhY2N1KSBsXG4gIGluXG4gIHJtYXBfZiBbXSBsXG5cblxubGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGE7IGl0ZXIgZiBsXG5cbmxldCByZWMgaXRlcmkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBpIGE7IGl0ZXJpIChpICsgMSkgZiBsXG5cbmxldCBpdGVyaSBmIGwgPSBpdGVyaSAwIGYgbFxuXG5sZXQgcmVjIGZvbGRfbGVmdCBmIGFjY3UgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGZvbGRfbGVmdCBmIChmIGFjY3UgYSkgbFxuXG5sZXQgcmVjIGZvbGRfcmlnaHQgZiBsIGFjY3UgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmIGEgKGZvbGRfcmlnaHQgZiBsIGFjY3UpXG5cbmxldCByZWMgbWFwMiBmIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBsZXQgciA9IGYgYTEgYTIgaW4gciA6OiBtYXAyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lm1hcDJcIlxuXG5sZXQgcmV2X21hcDIgZiBsMSBsMiA9XG4gIGxldCByZWMgcm1hcDJfZiBhY2N1IGwxIGwyID1cbiAgICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgfCAoW10sIFtdKSAtPiBhY2N1XG4gICAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHJtYXAyX2YgKGYgYTEgYTIgOjogYWNjdSkgbDEgbDJcbiAgICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmV2X21hcDJcIlxuICBpblxuICBybWFwMl9mIFtdIGwxIGwyXG5cblxubGV0IHJlYyBpdGVyMiBmIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+ICgpXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyOyBpdGVyMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5pdGVyMlwiXG5cbmxldCByZWMgZm9sZF9sZWZ0MiBmIGFjY3UgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gYWNjdVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZm9sZF9sZWZ0MiBmIChmIGFjY3UgYTEgYTIpIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX2xlZnQyXCJcblxubGV0IHJlYyBmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gYWNjdVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMiAoZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1KVxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9yaWdodDJcIlxuXG5sZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gdHJ1ZVxuICB8IGE6OmwgLT4gcCBhICYmIGZvcl9hbGwgcCBsXG5cbmxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBwIGEgfHwgZXhpc3RzIHAgbFxuXG5sZXQgcmVjIGZvcl9hbGwyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gdHJ1ZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiAmJiBmb3JfYWxsMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb3JfYWxsMlwiXG5cbmxldCByZWMgZXhpc3RzMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGZhbHNlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyIHx8IGV4aXN0czIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZXhpc3RzMlwiXG5cbmxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBjb21wYXJlIGEgeCA9IDAgfHwgbWVtIHggbFxuXG5sZXQgcmVjIG1lbXEgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGEgPT0geCB8fCBtZW1xIHggbFxuXG5sZXQgcmVjIGFzc29jIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IChhLGIpOjpsIC0+IGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIGIgZWxzZSBhc3NvYyB4IGxcblxubGV0IHJlYyBhc3NvY19vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIFNvbWUgYiBlbHNlIGFzc29jX29wdCB4IGxcblxubGV0IHJlYyBhc3NxIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIGIgZWxzZSBhc3NxIHggbFxuXG5sZXQgcmVjIGFzc3Ffb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBTb21lIGIgZWxzZSBhc3NxX29wdCB4IGxcblxubGV0IHJlYyBtZW1fYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBjb21wYXJlIGEgeCA9IDAgfHwgbWVtX2Fzc29jIHggbFxuXG5sZXQgcmVjIG1lbV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gYSA9PSB4IHx8IG1lbV9hc3NxIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChhLCBfIGFzIHBhaXIpIDo6IGwgLT5cbiAgICAgIGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NvYyB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChhLCBfIGFzIHBhaXIpIDo6IGwgLT4gaWYgYSA9PSB4IHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc3EgeCBsXG5cbmxldCByZWMgZmluZCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4geCBlbHNlIGZpbmQgcCBsXG5cbmxldCByZWMgZmluZF9vcHQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBTb21lIHggZWxzZSBmaW5kX29wdCBwIGxcblxubGV0IHJlYyBmaW5kX21hcCBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+XG4gICAgIGJlZ2luIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgcmVzdWx0IC0+IHJlc3VsdFxuICAgICAgIHwgTm9uZSAtPiBmaW5kX21hcCBmIGxcbiAgICAgZW5kXG5cbmxldCBmaW5kX2FsbCBwID1cbiAgbGV0IHJlYyBmaW5kIGFjY3UgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJldiBhY2N1XG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIGZpbmQgKHggOjogYWNjdSkgbCBlbHNlIGZpbmQgYWNjdSBsIGluXG4gIGZpbmQgW11cblxubGV0IGZpbHRlciA9IGZpbmRfYWxsXG5cbmxldCBmaWx0ZXJpIHAgbCA9XG4gIGxldCByZWMgYXV4IGkgYWNjID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByZXYgYWNjXG4gIHwgeDo6bCAtPiBhdXggKGkgKyAxKSAoaWYgcCBpIHggdGhlbiB4OjphY2MgZWxzZSBhY2MpIGxcbiAgaW5cbiAgYXV4IDAgW10gbFxuXG5sZXQgZmlsdGVyX21hcCBmID1cbiAgbGV0IHJlYyBhdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjdVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBhdXggYWNjdSBsXG4gICAgICAgIHwgU29tZSB2IC0+IGF1eCAodiA6OiBhY2N1KSBsXG4gIGluXG4gIGF1eCBbXVxuXG5sZXQgY29uY2F0X21hcCBmIGwgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgICBsZXQgeHMgPSBmIHggaW5cbiAgICAgICBhdXggZiAocmV2X2FwcGVuZCB4cyBhY2MpIGxcbiAgaW4gYXV4IGYgW10gbFxuXG5sZXQgZm9sZF9sZWZ0X21hcCBmIGFjY3UgbCA9XG4gIGxldCByZWMgYXV4IGFjY3UgbF9hY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3UsIHJldiBsX2FjY3VcbiAgICB8IHggOjogbCAtPlxuICAgICAgICBsZXQgYWNjdSwgeCA9IGYgYWNjdSB4IGluXG4gICAgICAgIGF1eCBhY2N1ICh4IDo6IGxfYWNjdSkgbCBpblxuICBhdXggYWNjdSBbXSBsXG5cbmxldCBwYXJ0aXRpb24gcCBsID1cbiAgbGV0IHJlYyBwYXJ0IHllcyBubyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKHJldiB5ZXMsIHJldiBubylcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gcGFydCAoeCA6OiB5ZXMpIG5vIGwgZWxzZSBwYXJ0IHllcyAoeCA6OiBubykgbCBpblxuICBwYXJ0IFtdIFtdIGxcblxubGV0IHBhcnRpdGlvbl9tYXAgcCBsID1cbiAgbGV0IHJlYyBwYXJ0IGxlZnQgcmlnaHQgPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgbGVmdCwgcmV2IHJpZ2h0KVxuICB8IHggOjogbCAtPlxuICAgICBiZWdpbiBtYXRjaCBwIHggd2l0aFxuICAgICAgIHwgRWl0aGVyLkxlZnQgdiAtPiBwYXJ0ICh2IDo6IGxlZnQpIHJpZ2h0IGxcbiAgICAgICB8IEVpdGhlci5SaWdodCB2IC0+IHBhcnQgbGVmdCAodiA6OiByaWdodCkgbFxuICAgICBlbmRcbiAgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCByZWMgc3BsaXQgPSBmdW5jdGlvblxuICAgIFtdIC0+IChbXSwgW10pXG4gIHwgKHgseSk6OmwgLT5cbiAgICAgIGxldCAocngsIHJ5KSA9IHNwbGl0IGwgaW4gKHg6OnJ4LCB5OjpyeSlcblxubGV0IHJlYyBjb21iaW5lIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiAoYTEsIGEyKSA6OiBjb21iaW5lIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5jb21iaW5lXCJcblxuKCoqIHNvcnRpbmcgKilcblxubGV0IHJlYyBtZXJnZSBjbXAgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsMiAtPiBsMlxuICB8IGwxLCBbXSAtPiBsMVxuICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgIHRoZW4gaDEgOjogbWVyZ2UgY21wIHQxIGwyXG4gICAgICBlbHNlIGgyIDo6IG1lcmdlIGNtcCBsMSB0MlxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPSBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV0gaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW5cbiAgICAgICAgICAgIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzIDw9IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZV9yZXYgczEgczIgW10sIHRsKVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV0gaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGlmIGNtcCB4MSB4MiA+IDAgdGhlblxuICAgICAgICAgICAgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHNvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlIHMxIHMyIFtdLCB0bClcbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2UgZnN0IChzb3J0IGxlbiBsKVxuXG5cbmxldCBzb3J0ID0gc3RhYmxlX3NvcnRcbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiBOb3RlOiBvbiBhIGxpc3Qgb2YgbGVuZ3RoIGJldHdlZW4gYWJvdXQgMTAwMDAwIChkZXBlbmRpbmcgb24gdGhlIG1pbm9yXG4gICBoZWFwIHNpemUgYW5kIHRoZSB0eXBlIG9mIHRoZSBsaXN0KSBhbmQgU3lzLm1heF9hcnJheV9zaXplLCBpdCBpc1xuICAgYWN0dWFsbHkgZmFzdGVyIHRvIHVzZSB0aGUgZm9sbG93aW5nLCBidXQgaXQgbWlnaHQgYWxzbyB1c2UgbW9yZSBtZW1vcnlcbiAgIGJlY2F1c2UgdGhlIGFyZ3VtZW50IGxpc3QgY2Fubm90IGJlIGRlYWxsb2NhdGVkIGluY3JlbWVudGFsbHkuXG5cbiAgIEFsc28sIHRoZXJlIHNlZW1zIHRvIGJlIGEgYnVnIGluIHRoaXMgY29kZSBvciBpbiB0aGVcbiAgIGltcGxlbWVudGF0aW9uIG9mIG9ial90cnVuY2F0ZS5cblxuZXh0ZXJuYWwgb2JqX3RydW5jYXRlIDogJ2EgYXJyYXkgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcblxubGV0IGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYSA9XG4gIGxldCBsID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGFjY3UgbiBwID1cbiAgICBpZiBwIDw9IDAgdGhlbiBhY2N1IGVsc2UgYmVnaW5cbiAgICAgIGlmIHAgPSBuIHRoZW4gYmVnaW5cbiAgICAgICAgb2JqX3RydW5jYXRlIGEgcDtcbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSAobi0xMDAwKSAocC0xKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSBuIChwLTEpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBbXSAobC0xMDAwKSBsXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IGEgPSBBcnJheS5vZl9saXN0IGwgaW5cbiAgQXJyYXkuc3RhYmxlX3NvcnQgY21wIGE7XG4gIGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYVxuXG4qKVxuXG5cbigqKiBzb3J0aW5nICsgcmVtb3ZpbmcgZHVwbGljYXRlcyAqKVxuXG5sZXQgc29ydF91bmlxIGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlIHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZV9yZXYgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml0gZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlX3JldiBzMSBzMiBbXSwgdGwpXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml0gZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZSBzMSBzMiBbXSwgdGwpXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcblxuXG5sZXQgcmVjIGNvbXBhcmVfbGVuZ3RocyBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCBfIDo6IGwxLCBfIDo6IGwyIC0+IGNvbXBhcmVfbGVuZ3RocyBsMSBsMlxuOztcblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aF93aXRoIGwgbiA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgaWYgbiA9IDAgdGhlbiAwIGVsc2VcbiAgICAgIGlmIG4gPiAwIHRoZW4gLTEgZWxzZSAxXG4gIHwgXyA6OiBsIC0+XG4gICAgaWYgbiA8PSAwIHRoZW4gMSBlbHNlXG4gICAgICBjb21wYXJlX2xlbmd0aF93aXRoIGwgKG4tMSlcbjs7XG5cbigqKiB7MSBDb21wYXJpc29ufSAqKVxuXG4oKiBOb3RlOiB3ZSBhcmUgKm5vdCogc2hvcnRjdXR0aW5nIHRoZSBsaXN0IGJ5IHVzaW5nXG4gICBbTGlzdC5jb21wYXJlX2xlbmd0aHNdIGZpcnN0OyB0aGlzIG1heSBiZSBzbG93ZXIgb24gbG9uZyBsaXN0c1xuICAgaW1tZWRpYXRlbHkgc3RhcnQgd2l0aCBkaXN0aW5jdCBlbGVtZW50cy4gSXQgaXMgYWxzbyBpbmNvcnJlY3QgZm9yXG4gICBbY29tcGFyZV0gYmVsb3csIGFuZCBpdCBpcyBiZXR0ZXIgKHByaW5jaXBsZSBvZiBsZWFzdCBzdXJwcmlzZSkgdG9cbiAgIHVzZSB0aGUgc2FtZSBhcHByb2FjaCBmb3IgYm90aCBmdW5jdGlvbnMuICopXG5sZXQgcmVjIGVxdWFsIGVxIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gdHJ1ZVxuICB8IFtdLCBfOjpfIHwgXzo6XywgW10gLT4gZmFsc2VcbiAgfCBhMTo6bDEsIGEyOjpsMiAtPiBlcSBhMSBhMiAmJiBlcXVhbCBlcSBsMSBsMlxuXG5sZXQgcmVjIGNvbXBhcmUgY21wIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfOjpfIC0+IC0xXG4gIHwgXzo6XywgW10gLT4gMVxuICB8IGExOjpsMSwgYTI6OmwyIC0+XG4gICAgbGV0IGMgPSBjbXAgYTEgYTIgaW5cbiAgICBpZiBjIDw+IDAgdGhlbiBjXG4gICAgZWxzZSBjb21wYXJlIGNtcCBsMSBsMlxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGwgPVxuICBsZXQgcmVjIGF1eCBsICgpID0gbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBTZXEuTmlsXG4gICAgfCB4IDo6IHRhaWwgLT4gU2VxLkNvbnMgKHgsIGF1eCB0YWlsKVxuICBpblxuICBhdXggbFxuXG5sZXQgb2Zfc2VxIHNlcSA9XG4gIGxldCByZWMgZGlyZWN0IGRlcHRoIHNlcSA6IF8gbGlzdCA9XG4gICAgaWYgZGVwdGg9MFxuICAgIHRoZW5cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIHNlcVxuICAgICAgfD4gcmV2ICgqIHRhaWxyZWMgKilcbiAgICBlbHNlIG1hdGNoIHNlcSgpIHdpdGhcbiAgICAgIHwgU2VxLk5pbCAtPiBbXVxuICAgICAgfCBTZXEuQ29ucyAoeCwgbmV4dCkgLT4geCA6OiBkaXJlY3QgKGRlcHRoLTEpIG5leHRcbiAgaW5cbiAgZGlyZWN0IDUwMCBzZXFcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X0xpc3RfbnRoIiwiY2FtbF9jb21wYXJlIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiU3RkbGliIiwiU3RkbGliX1NlcSIsIlN0ZGxpYl9TeXMiLCJjc3RfaGQiLCJjc3RfdGwiLCJjc3RfbnRoIiwibGVuZ3RoIiwibCIsImxlbiIsInBhcmFtIiwiY29ucyIsImEiLCJoZCIsInRsIiwibnRoIiwibiIsIm50aF9vcHQiLCJhcHBlbmQiLCJyZXZfYXBwZW5kIiwibDEiLCJsMiIsInJldiIsImluaXRfYXV4IiwiaSIsInIiLCJjc3RfTGlzdF9tYXAyIiwiY3N0X0xpc3RfaXRlcjIiLCJjc3RfTGlzdF9mb2xkX2xlZnQyIiwiY3N0X0xpc3RfZm9sZF9yaWdodDIiLCJjc3RfTGlzdF9mb3JfYWxsMiIsImNzdF9MaXN0X2V4aXN0czIiLCJjc3RfTGlzdF9jb21iaW5lIiwiY3N0X0xpc3RfcmV2X21hcDIiLCJjc3RfTGlzdF9pbml0IiwicmV2X2luaXRfdGhyZXNob2xkIiwiaW5pdCIsImFjYyIsImZsYXR0ZW4iLCJtYXAiLCJtYXBpIiwicmV2X21hcCIsImFjY3UiLCJpdGVyIiwiaXRlcmkiLCJmb2xkX2xlZnQiLCJmb2xkX3JpZ2h0IiwibWFwMiIsInJldl9tYXAyIiwiaXRlcjIiLCJmb2xkX2xlZnQyIiwiZm9sZF9yaWdodDIiLCJmb3JfYWxsIiwicCIsImV4aXN0cyIsImZvcl9hbGwyIiwiZXhpc3RzMiIsIm1lbSIsIngiLCJtZW1xIiwiYXNzb2MiLCJtYXRjaCIsImIiLCJhc3NvY19vcHQiLCJhc3NxIiwiYXNzcV9vcHQiLCJtZW1fYXNzb2MiLCJtZW1fYXNzcSIsInJlbW92ZV9hc3NvYyIsInBhaXIiLCJyZW1vdmVfYXNzcSIsImZpbmQiLCJmaW5kX29wdCIsImZpbmRfbWFwIiwicmVzdWx0IiwiZmluZF9hbGwiLCJmaWx0ZXJpIiwiZmlsdGVyX21hcCIsInYiLCJjb25jYXRfbWFwIiwieHMiLCJmb2xkX2xlZnRfbWFwIiwibF9hY2N1IiwicGFydGl0aW9uIiwieWVzIiwibm8iLCJwYXJ0aXRpb25fbWFwIiwibGVmdCIsInJpZ2h0Iiwic3BsaXQiLCJ5IiwicnkiLCJyeCIsImNvbWJpbmUiLCJtZXJnZSIsImNtcCIsInQyIiwiaDIiLCJ0MSIsImgxIiwic3RhYmxlX3NvcnQiLCJzb3J0IiwieDIiLCJ4MSIsInMiLCJ4MyIsIm4xIiwibjIiLCJzMSIsInMyIiwicmV2X3NvcnQiLCJzb3J0X3VuaXEiLCJjIiwiY29tcGFyZV9sZW5ndGhzIiwiY29tcGFyZV9sZW5ndGhfd2l0aCIsImVxdWFsIiwiZXEiLCJjb21wYXJlIiwidG9fc2VxIiwiYXV4IiwidGFpbCIsIm9mX3NlcSIsInNlcSIsImRpcmVjdCIsImRlcHRoIiwibmV4dCIsIlN0ZGxpYl9MaXN0Il0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQWhCLGVBQUE7QUFBQSxJQUFBQSxpQkFBQTtBQUFBLFlBQUFpQixPQUFBQztBQUFBQSxRQUFBQyxNQ3dCZSxHQUFBQyxRQUFBO0FBQUE7QUFBQSxLQUpJLFlBQ1Q7QUFBQSxTQUFBRixJ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QUNSLFlBQWU7QUFBQSxLQUFmO0FBQUE7QUFBQTtBQUFBLEdBQ3NCO0FBQUEsWUFBQU0sT0FBQTlHO0FBQUFBLGFBQUErRyxJQUFBL0csR0FBQUU7QUFBQUEsS0FLTCxRQUNUO0FBQUEsU0FBQThHLE9BRFMsTUFBQTlELElBQUE7QUFBQSxLQUVtQiwwQkFBUixzQkFBUTtBQUFBLElBQUM7QUFBQSxJQUV2QztBQUFBLEdBQUs7QUFBQSxZQUFBK0QsT0FBQUM7QUFBQUEsYUFBQUMsT0FBQUMsT0FBQUY7QUFBQUEsS0FJSDtBQUFBLE1BRUUsT0FBMEM7QUFBQSxlQUExQztBQUFBLGdDQUFBckYsS0FBQXFCLEdBQTRCLG1CQUFNLFdBSWdCO0FBQUEsU0FBQUcsUUFGekM7QUFBQSxLQUFLLFlBQ0Q7QUFBQSxTQUFBZ0UsT0FEQyxVQUFBbkUsSUFBQTtBQUFBLEtBRWUsMENBQXFCO0FBQUE7QUFBQSxJQUV0RCx1QkFBYztBQUFBO0FBQUE7QUFBQSxJQUFBb0U7QUFBQUEsTURqbEJoQiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2NTEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9pbnQubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGludFxuXG5sZXQgemVybyA9IDBcbmxldCBvbmUgPSAxXG5sZXQgbWludXNfb25lID0gLTFcbmV4dGVybmFsIG5lZyA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgYWRkIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgc3ViIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgbXVsIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgZGl2IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgcmVtIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcbmxldCBtYXhfaW50ID0gKC0xKSBsc3IgMVxubGV0IG1pbl9pbnQgPSBtYXhfaW50ICsgMVxuZXh0ZXJuYWwgbG9nYW5kIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsIGxvZ3hvciA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcbmxldCBsb2dub3QgeCA9IGxvZ3hvciB4ICgtMSlcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5sZXQgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5sZXQgbWluIHggeSA6IHQgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgOiB0ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuXG4oKlxuZXh0ZXJuYWwgaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfaW50X29mX3N0cmluZ1wiXG5sZXQgb2Zfc3RyaW5nIHMgPSB0cnkgU29tZSAoaW50X29mX3N0cmluZyBzKSB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG4qKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5sZXQgdG9fc3RyaW5nIHggPSBmb3JtYXRfaW50IFwiJWRcIiB4XG4iXSwibmFtZXMiOlsicnVudGltZSIsImFicyIsIngiLCJsb2dub3QiLCJlcXVhbCIsImNvbXBhcmUiLCJtaW4iLCJ5IiwibWF4IiwidG9fc3RyaW5nIiwiU3RkbGliX0ludCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxJQUFBQyxHQzRCWSwyQkFBd0I7QUFBQSxZQUFBQyxPQUFBRCxHQU1yQixjQUFhO0FBQUEsWUFBQUUsTUFBQSxNRGxDNUI7QUFBQSxPQUFBQyxVQUFBO0FBQUEsWUFBQUMsSUFBQUosR0FBQUssR0N3Q2tCLHFCQUF1QjtBQUFBLFlBQUFDLElBQUFOLEdBQUFLLEdBQ3ZCLHFCQUF1QjtBQUFBLFlBQUFFLFVBQUFQLEdBVU47QUFBQTtBQUFBLElBQUFRO0FBQUFBLE1EbkRuQyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2ODYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9ieXRlcy5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zICopXG5cbigqIFdBUk5JTkc6IFNvbWUgZnVuY3Rpb25zIGluIHRoaXMgZmlsZSBhcmUgZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gc3RyaW5nLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHVuc2FmZV9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gYnl0ZXMgPSBcIiVieXRlc19vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2JsaXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cblxubGV0IG1ha2UgbiBjID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICB1bnNhZmVfZmlsbCBzIDAgbiBjO1xuICBzXG5cbmxldCBpbml0IG4gZiA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgdW5zYWZlX3NldCBzIGkgKGYgaSlcbiAgZG9uZTtcbiAgc1xuXG5sZXQgZW1wdHkgPSBjcmVhdGUgMFxuXG5sZXQgY29weSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICB1bnNhZmVfYmxpdCBzIDAgciAwIGxlbjtcbiAgclxuXG5sZXQgdG9fc3RyaW5nIGIgPSB1bnNhZmVfdG9fc3RyaW5nIChjb3B5IGIpXG5sZXQgb2Zfc3RyaW5nIHMgPSBjb3B5ICh1bnNhZmVfb2Zfc3RyaW5nIHMpXG5cbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuc3ViIC8gQnl0ZXMuc3ViXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGxlbiBpblxuICAgIHVuc2FmZV9ibGl0IHMgb2ZzIHIgMCBsZW47XG4gICAgclxuICBlbmRcblxubGV0IHN1Yl9zdHJpbmcgYiBvZnMgbGVuID0gdW5zYWZlX3RvX3N0cmluZyAoc3ViIGIgb2ZzIGxlbilcblxuKCogYWRkaXRpb24gd2l0aCBhbiBvdmVyZmxvdyBjaGVjayAqKVxubGV0ICgrKykgYSBiID1cbiAgbGV0IGMgPSBhICsgYiBpblxuICBtYXRjaCBhIDwgMCwgYiA8IDAsIGMgPCAwIHdpdGhcbiAgfCB0cnVlICwgdHJ1ZSAsIGZhbHNlXG4gIHwgZmFsc2UsIGZhbHNlLCB0cnVlICAtPiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmV4dGVuZFwiICgqIG92ZXJmbG93ICopXG4gIHwgXyAtPiBjXG5cbmxldCBleHRlbmQgcyBsZWZ0IHJpZ2h0ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzICsrIGxlZnQgKysgcmlnaHQgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIGxldCAoc3Jjb2ZmLCBkc3RvZmYpID0gaWYgbGVmdCA8IDAgdGhlbiAtbGVmdCwgMCBlbHNlIDAsIGxlZnQgaW5cbiAgbGV0IGNweWxlbiA9IEludC5taW4gKGxlbmd0aCBzIC0gc3Jjb2ZmKSAobGVuIC0gZHN0b2ZmKSBpblxuICBpZiBjcHlsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgcyBzcmNvZmYgciBkc3RvZmYgY3B5bGVuO1xuICByXG5cbmxldCBmaWxsIHMgb2ZzIGxlbiBjID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuZmlsbCAvIEJ5dGVzLmZpbGxcIlxuICBlbHNlIHVuc2FmZV9maWxsIHMgb2ZzIGxlbiBjXG5cbmxldCBibGl0IHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCeXRlcy5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbmxldCBibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gc3RyaW5nX2xlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5ibGl0IC8gQnl0ZXMuYmxpdF9zdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9ibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlciBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJCeXRlcy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGVtcHR5XG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpblxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKGNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG5sZXQgY2F0IHMxIHMyID1cbiAgbGV0IGwxID0gbGVuZ3RoIHMxIGluXG4gIGxldCBsMiA9IGxlbmd0aCBzMiBpblxuICBsZXQgciA9IGNyZWF0ZSAobDEgKyBsMikgaW5cbiAgdW5zYWZlX2JsaXQgczEgMCByIDAgbDE7XG4gIHVuc2FmZV9ibGl0IHMyIDAgciBsMSBsMjtcbiAgclxuXG5cbmV4dGVybmFsIGNoYXJfY29kZTogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBjaGFyX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19zcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJyAnIHwgJ1xcMDEyJyB8ICdcXG4nIHwgJ1xccicgfCAnXFx0JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaSkgZG9cbiAgICBpbmNyIGlcbiAgZG9uZTtcbiAgbGV0IGogPSByZWYgKGxlbiAtIDEpIGluXG4gIHdoaWxlICFqID49ICFpICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWopIGRvXG4gICAgZGVjciBqXG4gIGRvbmU7XG4gIGlmICFqID49ICFpIHRoZW5cbiAgICBzdWIgcyAhaSAoIWogLSAhaSArIDEpXG4gIGVsc2VcbiAgICBlbXB0eVxuXG5sZXQgZXNjYXBlZCBzID1cbiAgbGV0IG4gPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgbiA6PSAhbiArXG4gICAgICAobWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcbicgfCAnXFx0JyB8ICdcXHInIHwgJ1xcYicgLT4gMlxuICAgICAgIHwgJyAnIC4uICd+JyAtPiAxXG4gICAgICAgfCBfIC0+IDQpXG4gIGRvbmU7XG4gIGlmICFuID0gbGVuZ3RoIHMgdGhlbiBjb3B5IHMgZWxzZSBiZWdpblxuICAgIGxldCBzJyA9IGNyZWF0ZSAhbiBpblxuICAgIG4gOj0gMDtcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgICBiZWdpbiBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICgnXFxcIicgfCAnXFxcXCcpIGFzIGMgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICduJ1xuICAgICAgfCAnXFx0JyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3QnXG4gICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAncidcbiAgICAgIHwgJ1xcYicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdiJ1xuICAgICAgfCAoJyAnIC4uICd+JykgYXMgYyAtPiB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgYyAtPlxuICAgICAgICAgIGxldCBhID0gY2hhcl9jb2RlIGMgaW5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSAvIDEwMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyAoYSAvIDEwKSBtb2QgMTApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSBtb2QgMTApKTtcbiAgICAgIGVuZDtcbiAgICAgIGluY3IgblxuICAgIGRvbmU7XG4gICAgcydcbiAgZW5kXG5cbmxldCBtYXAgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwaSBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmU7XG4gICFyXG5cbmxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gIGRvbmU7XG4gICFyXG5cbmxldCBleGlzdHMgcCBzID1cbiAgbGV0IG4gPSBsZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBzIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwgcCBzID1cbiAgbGV0IG4gPSBsZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IHMgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbmxldCBhcHBseTEgZiBzID1cbiAgaWYgbGVuZ3RoIHMgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjb3B5IHMgaW5cbiAgICB1bnNhZmVfc2V0IHIgMCAoZih1bnNhZmVfZ2V0IHMgMCkpO1xuICAgIHJcbiAgZW5kXG5cbmxldCBjYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBzdGFydHNfd2l0aCB+cHJlZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3ByZSA9IGxlbmd0aCBwcmVmaXggaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9wcmUgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgaSA8PiB1bnNhZmVfZ2V0IHByZWZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGxlbl9zID49IGxlbl9wcmUgJiYgYXV4IDBcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBlbmRzX3dpdGggfnN1ZmZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9zdWYgPSBsZW5ndGggc3VmZml4IGluXG4gIGxldCBkaWZmID0gbGVuX3MgLSBsZW5fc3VmIGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fc3VmIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIChkaWZmICsgaSkgPD4gdW5zYWZlX2dldCBzdWZmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBkaWZmID49IDAgJiYgYXV4IDBcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIGluZGV4X3JlY19vcHQgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleCBzIGMgPSByaW5kZXhfcmVjIHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tIHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tIC8gQnl0ZXMucmluZGV4X2Zyb21cIlxuICBlbHNlXG4gICAgcmluZGV4X3JlYyBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X29wdCBzIGMgPSByaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMucmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWNfb3B0IHMgaSBjXG5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBjb250YWluc19mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29udGFpbnNfZnJvbSAvIEJ5dGVzLmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAoaW5kZXhfcmVjIHMgbCBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBjb250YWlucyBzIGMgPSBjb250YWluc19mcm9tIHMgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cblxudHlwZSB0ID0gYnl0ZXNcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9ieXRlc19lcXVhbFwiIFtAQG5vYWxsb2NdXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgc3BsaXRfb25fY2hhciBzZXAgcyA9XG4gIGxldCByID0gcmVmIFtdIGluXG4gIGxldCBqID0gcmVmIChsZW5ndGggcykgaW5cbiAgZm9yIGkgPSBsZW5ndGggcyAtIDEgZG93bnRvIDAgZG9cbiAgICBpZiB1bnNhZmVfZ2V0IHMgaSA9IHNlcCB0aGVuIGJlZ2luXG4gICAgICByIDo9IHN1YiBzIChpICsgMSkgKCFqIC0gaSAtIDEpIDo6ICFyO1xuICAgICAgaiA6PSBpXG4gICAgZW5kXG4gIGRvbmU7XG4gIHN1YiBzIDAgIWogOjogIXJcblxuKCogRGVwcmVjYXRlZCBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgdmlhIG90aGVyIGRlcHJlY2F0ZWQgZnVuY3Rpb25zICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5sZXQgdXBwZXJjYXNlIHMgPSBtYXAgQ2hhci51cHBlcmNhc2Ugc1xubGV0IGxvd2VyY2FzZSBzID0gbWFwIENoYXIubG93ZXJjYXNlIHNcblxubGV0IGNhcGl0YWxpemUgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZSBzXG5sZXQgdW5jYXBpdGFsaXplIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2Ugc1xuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID0gbGVuZ3RoIHMgdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBnZXQgcyBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBzID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA9IGxlbmd0aCBzIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gZ2V0IHMgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBuID0gcmVmIDAgaW5cbiAgbGV0IGJ1ZiA9IHJlZiAobWFrZSAyNTYgJ1xcMDAwJykgaW5cbiAgbGV0IHJlc2l6ZSAoKSA9XG4gICAgKCogcmVzaXplICopXG4gICAgbGV0IG5ld19sZW4gPSBJbnQubWluICgyICogbGVuZ3RoICFidWYpIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBpblxuICAgIGlmIGxlbmd0aCAhYnVmID0gbmV3X2xlbiB0aGVuIGZhaWx3aXRoIFwiQnl0ZXMub2Zfc2VxOiBjYW5ub3QgZ3JvdyBieXRlc1wiO1xuICAgIGxldCBuZXdfYnVmID0gbWFrZSBuZXdfbGVuICdcXDAwMCcgaW5cbiAgICBibGl0ICFidWYgMCBuZXdfYnVmIDAgIW47XG4gICAgYnVmIDo9IG5ld19idWZcbiAgaW5cbiAgU2VxLml0ZXJcbiAgICAoZnVuIGMgLT5cbiAgICAgICBpZiAhbiA9IGxlbmd0aCAhYnVmIHRoZW4gcmVzaXplKCk7XG4gICAgICAgc2V0ICFidWYgIW4gYztcbiAgICAgICBpbmNyIG4pXG4gICAgaTtcbiAgc3ViICFidWYgMCAhblxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nL2RlY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG4oKiBUaGUgZ2V0XyBmdW5jdGlvbnMgYXJlIGFsbCBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxuXG5leHRlcm5hbCB1bnNhZmVfZ2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWJ5dGVzX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldF91aW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9ieXRlc19nZXQxNnVcIlxuZXh0ZXJuYWwgZ2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbmV4dGVybmFsIGdldF91aW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9ieXRlc19nZXQxNlwiXG5leHRlcm5hbCBnZXRfaW50MzJfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgPSBcIiVjYW1sX2J5dGVzX2dldDMyXCJcbmV4dGVybmFsIGdldF9pbnQ2NF9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCA9IFwiJWNhbWxfYnl0ZXNfZ2V0NjRcIlxuXG5leHRlcm5hbCB1bnNhZmVfc2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X3VpbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcIiVjYW1sX2J5dGVzX3NldDE2dVwiXG5leHRlcm5hbCBzZXRfaW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIHNldF9pbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZcIlxuZXh0ZXJuYWwgc2V0X2ludDMyX25lIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMyXCJcbmV4dGVybmFsIHNldF9pbnQ2NF9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NFwiXG5leHRlcm5hbCBzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiXG5leHRlcm5hbCBzd2FwMzIgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWJzd2FwX2ludDMyXCJcbmV4dGVybmFsIHN3YXA2NCA6IGludDY0IC0+IGludDY0ID0gXCIlYnN3YXBfaW50NjRcIlxuXG5sZXQgdW5zYWZlX2dldF91aW50MTZfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW5cbiAgdGhlbiBzd2FwMTYgKHVuc2FmZV9nZXRfdWludDE2X25lIGIgaSlcbiAgZWxzZSB1bnNhZmVfZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IHVuc2FmZV9nZXRfdWludDE2X2JlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gdW5zYWZlX2dldF91aW50MTZfbmUgYiBpXG4gIGVsc2Ugc3dhcDE2ICh1bnNhZmVfZ2V0X3VpbnQxNl9uZSBiIGkpXG5cbmxldCBnZXRfaW50OCBiIGkgPVxuICAoKGdldF91aW50OCBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gOCkpIGFzciAoU3lzLmludF9zaXplIC0gOClcblxubGV0IGdldF91aW50MTZfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgKGdldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIGdldF91aW50MTZfbmUgYiBpXG5cbmxldCBnZXRfdWludDE2X2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiAoZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IGdldF9pbnQxNl9uZSBiIGkgPVxuICAoKGdldF91aW50MTZfbmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9sZSBiIGkgPVxuICAoKGdldF91aW50MTZfbGUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9iZSBiIGkgPVxuICAoKGdldF91aW50MTZfYmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQzMl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiAoZ2V0X2ludDMyX25lIGIgaSlcbiAgZWxzZSBnZXRfaW50MzJfbmUgYiBpXG5cbmxldCBnZXRfaW50MzJfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIChnZXRfaW50MzJfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQzMl9uZSBiIGlcblxubGV0IGdldF9pbnQ2NF9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCAoZ2V0X2ludDY0X25lIGIgaSlcbiAgZWxzZSBnZXRfaW50NjRfbmUgYiBpXG5cbmxldCBnZXRfaW50NjRfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IChnZXRfaW50NjRfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQ2NF9uZSBiIGlcblxubGV0IHVuc2FmZV9zZXRfdWludDE2X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW5cbiAgdGhlbiB1bnNhZmVfc2V0X3VpbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHVuc2FmZV9zZXRfdWludDE2X25lIGIgaSB4XG5cbmxldCB1bnNhZmVfc2V0X3VpbnQxNl9iZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gdW5zYWZlX3NldF91aW50MTZfbmUgYiBpIHggZWxzZVxuICB1bnNhZmVfc2V0X3VpbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuXG5sZXQgc2V0X2ludDE2X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSBzZXRfaW50MTZfbmUgYiBpIHhcblxubGV0IHNldF9pbnQxNl9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHNldF9pbnQxNl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDMyX2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MzJfbmUgYiBpIChzd2FwMzIgeClcbiAgZWxzZSBzZXRfaW50MzJfbmUgYiBpIHhcblxubGV0IHNldF9pbnQzMl9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQzMl9uZSBiIGkgKHN3YXAzMiB4KVxuICBlbHNlIHNldF9pbnQzMl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDY0X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50NjRfbmUgYiBpIChzd2FwNjQgeClcbiAgZWxzZSBzZXRfaW50NjRfbmUgYiBpIHhcblxubGV0IHNldF9pbnQ2NF9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQ2NF9uZSBiIGkgKHN3YXA2NCB4KVxuICBlbHNlIHNldF9pbnQ2NF9uZSBiIGkgeFxuXG5sZXQgc2V0X3VpbnQ4ID0gc2V0X2ludDhcbmxldCBzZXRfdWludDE2X25lID0gc2V0X2ludDE2X25lXG5sZXQgc2V0X3VpbnQxNl9iZSA9IHNldF9pbnQxNl9iZVxubGV0IHNldF91aW50MTZfbGUgPSBzZXRfaW50MTZfbGVcblxuKCogVVRGIGNvZGVjcyBhbmQgdmFsaWRhdGlvbnMgKilcblxubGV0IGRlY19pbnZhbGlkID0gVWNoYXIudXRmX2RlY29kZV9pbnZhbGlkXG5sZXRbQGlubGluZV0gZGVjX3JldCBuIHUgPSBVY2hhci51dGZfZGVjb2RlIG4gKFVjaGFyLnVuc2FmZV9vZl9pbnQgdSlcblxuKCogSW4gY2FzZSBvZiBkZWNvZGluZyBlcnJvciwgaWYgd2UgZXJyb3Igb24gdGhlIGZpcnN0IGJ5dGUsIHdlXG4gICBjb25zdW1lIHRoZSBieXRlLCBvdGhlcndpc2Ugd2UgY29uc3VtZSB0aGUgW25dIGJ5dGVzIHByZWNlZWRpbmdcbiAgIHRoZSBlcnJvcmluZyBieXRlLlxuXG4gICBUaGlzIG1lYW5zIHRoYXQgaWYgYSBjbGllbnQgdXNlcyBkZWNvZGVzIHdpdGhvdXQgY2FyaW5nIGFib3V0XG4gICB2YWxpZGl0eSBpdCBuYXR1cmFsbHkgcmVwbGFjZSBib2d1cyBkYXRhIHdpdGggVWNoYXIucmVwIGFjY29yZGluZ1xuICAgdG8gdGhlIFdIQVRXRyBFbmNvZGluZyBzdGFuZGFyZC4gT3RoZXIgc2NoZW1lcyBhcmUgcG9zc2libGUgYnlcbiAgIGNvbnN1bHRpbmcgdGhlIG51bWJlciBvZiB1c2VkIGJ5dGVzIG9uIGludmFsaWQgZGVjb2Rlcy4gRm9yIG1vcmVcbiAgIGRldGFpbHMgc2VlIGh0dHBzOi8vaHNpdm9uZW4uZmkvYnJva2VuLXV0Zi04L1xuXG4gICBGb3IgdGhpcyByZWFzb24gaW4gW2dldF91dGZfOF91Y2hhcl0gd2UgZ3JhZHVhbGx5IGNoZWNrIHRoZSBuZXh0XG4gICBieXRlIGlzIGF2YWlsYWJsZSByYXRoZXIgdGhhbiBkb2luZyBpdCBpbW1lZGlhdGVseSBhZnRlciB0aGVcbiAgIGZpcnN0IGJ5dGUuIENvbnRyYXN0IHdpdGggW2lzX3ZhbGlkX3V0Zl84XS4gKilcblxuKCogVVRGLTggKilcblxubGV0W0BpbmxpbmVdIG5vdF9pbl94ODBfdG9feEJGIGIgPSBiIGxzciA2IDw+IDBiMTBcbmxldFtAaW5saW5lXSBub3RfaW5feEEwX3RvX3hCRiBiID0gYiBsc3IgNSA8PiAwYjEwMVxubGV0W0BpbmxpbmVdIG5vdF9pbl94ODBfdG9feDlGIGIgPSBiIGxzciA1IDw+IDBiMTAwXG5sZXRbQGlubGluZV0gbm90X2luX3g5MF90b194QkYgYiA9IGIgPCAweDkwIHx8IDB4QkYgPCBiXG5sZXRbQGlubGluZV0gbm90X2luX3g4MF90b194OEYgYiA9IGIgbHNyIDQgPD4gMHg4XG5cbmxldFtAaW5saW5lXSB1dGZfOF91Y2hhcl8yIGIwIGIxID1cbiAgKChiMCBsYW5kIDB4MUYpIGxzbCA2KSBsb3JcbiAgKChiMSBsYW5kIDB4M0YpKVxuXG5sZXRbQGlubGluZV0gdXRmXzhfdWNoYXJfMyBiMCBiMSBiMiA9XG4gICgoYjAgbGFuZCAweDBGKSBsc2wgMTIpIGxvclxuICAoKGIxIGxhbmQgMHgzRikgbHNsIDYpIGxvclxuICAoKGIyIGxhbmQgMHgzRikpXG5cbmxldFtAaW5saW5lXSB1dGZfOF91Y2hhcl80IGIwIGIxIGIyIGIzID1cbiAgKChiMCBsYW5kIDB4MDcpIGxzbCAxOCkgbG9yXG4gICgoYjEgbGFuZCAweDNGKSBsc2wgMTIpIGxvclxuICAoKGIyIGxhbmQgMHgzRikgbHNsIDYpIGxvclxuICAoKGIzIGxhbmQgMHgzRikpXG5cbmxldCBnZXRfdXRmXzhfdWNoYXIgYiBpID1cbiAgbGV0IGIwID0gZ2V0X3VpbnQ4IGIgaSBpbiAoKiByYWlzZXMgaWYgW2ldIGlzIG5vdCBhIHZhbGlkIGluZGV4LiAqKVxuICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50OCBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIG1hdGNoIENoYXIudW5zYWZlX2NociBiMCB3aXRoICgqIFNlZSBUaGUgVW5pY29kZSBTdGFuZGFyZCwgVGFibGUgMy43ICopXG4gIHwgJ1xceDAwJyAuLiAnXFx4N0YnIC0+IGRlY19yZXQgMSBiMFxuICB8ICdcXHhDMicgLi4gJ1xceERGJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBkZWNfcmV0IDIgKHV0Zl84X3VjaGFyXzIgYjAgYjEpXG4gIHwgJ1xceEUwJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94QTBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGRlY19yZXQgMyAodXRmXzhfdWNoYXJfMyBiMCBiMSBiMilcbiAgfCAnXFx4RTEnIC4uICdcXHhFQycgfCAnXFx4RUUnIC4uICdcXHhFRicgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBkZWNfcmV0IDMgKHV0Zl84X3VjaGFyXzMgYjAgYjEgYjIpXG4gIHwgJ1xceEVEJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feDlGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGRlY19yZXQgMyAodXRmXzhfdWNoYXJfMyBiMCBiMSBiMilcbiAgfCAnXFx4RjAnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g5MF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBsZXQgYjMgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIzIHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBkZWNfcmV0IDQgKHV0Zl84X3VjaGFyXzQgYjAgYjEgYjIgYjMpXG4gIHwgJ1xceEYxJyAuLiAnXFx4RjMnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBsZXQgYjMgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIzIHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBkZWNfcmV0IDQgKHV0Zl84X3VjaGFyXzQgYjAgYjEgYjIgYjMpXG4gIHwgJ1xceEY0JyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feDhGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgbGV0IGIzID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMyB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgZGVjX3JldCA0ICh1dGZfOF91Y2hhcl80IGIwIGIxIGIyIGIzKVxuICB8IF8gLT4gZGVjX2ludmFsaWQgMVxuXG5sZXQgc2V0X3V0Zl84X3VjaGFyIGIgaSB1ID1cbiAgbGV0IHNldCA9IHVuc2FmZV9zZXRfdWludDggaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuICB8IHUgd2hlbiB1IDw9IDB4MDA3RiAtPlxuICAgICAgc2V0X3VpbnQ4IGIgaSB1O1xuICAgICAgMVxuICB8IHUgd2hlbiB1IDw9IDB4MDdGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMSBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgKHNldF91aW50OCBiIGkgKDB4QzAgbG9yICh1IGxzciA2KSk7XG4gICAgICAgc2V0IGIgbGFzdCAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSk7XG4gICAgICAgMilcbiAgfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDIgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIChzZXRfdWludDggYiBpICgweEUwIGxvciAodSBsc3IgMTIpKTtcbiAgICAgICBzZXQgYiAoaSArIDEpICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpO1xuICAgICAgIHNldCBiIGxhc3QgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpO1xuICAgICAgIDMpXG4gIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIChzZXRfdWludDggYiBpICgweEYwIGxvciAodSBsc3IgMTgpKTtcbiAgICAgICBzZXQgYiAoaSArIDEpICgweDgwIGxvciAoKHUgbHNyIDEyKSBsYW5kIDB4M0YpKTtcbiAgICAgICBzZXQgYiAoaSArIDIpICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpO1xuICAgICAgIHNldCBiIGxhc3QgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpO1xuICAgICAgIDQpXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGlzX3ZhbGlkX3V0Zl84IGIgPVxuICBsZXQgcmVjIGxvb3AgbWF4IGIgaSA9XG4gICAgaWYgaSA+IG1heCB0aGVuIHRydWUgZWxzZVxuICAgIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQ4IGluXG4gICAgbWF0Y2ggQ2hhci51bnNhZmVfY2hyIChnZXQgYiBpKSB3aXRoXG4gICAgfCAnXFx4MDAnIC4uICdcXHg3RicgLT4gbG9vcCBtYXggYiAoaSArIDEpXG4gICAgfCAnXFx4QzInIC4uICdcXHhERicgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMSBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RTAnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDIgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feEEwX3RvX3hCRiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhFMScgLi4gJ1xceEVDJyB8ICdcXHhFRScgLi4gJ1xceEVGJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAyIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RUQnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDIgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3g5RiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhGMCcgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94OTBfdG9feEJGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAyKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhGMScgLi4gJ1xceEYzJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDIpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEY0JyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194OEYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDIpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgXyAtPiBmYWxzZVxuICBpblxuICBsb29wIChsZW5ndGggYiAtIDEpIGIgMFxuXG4oKiBVVEYtMTZCRSAqKVxuXG5sZXQgZ2V0X3V0Zl8xNmJlX3VjaGFyIGIgaSA9XG4gIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQxNl9iZSBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBtYXggdGhlbiBpbnZhbGlkX2FyZyBcImluZGV4IG91dCBvZiBib3VuZHNcIiBlbHNlXG4gIGlmIGkgPSBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAweEQ4MDAgfHwgdSA+IDB4REZGRiAtPiBkZWNfcmV0IDIgdVxuICB8IHUgd2hlbiB1ID4gMHhEQkZGIC0+IGRlY19pbnZhbGlkIDJcbiAgfCBoaSAtPiAoKiBjb21iaW5lIFtoaV0gd2l0aCBhIGxvdyBzdXJyb2dhdGUgKilcbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAobWF4IC0gaSArIDEpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIChpICsgMikgd2l0aFxuICAgICAgfCB1IHdoZW4gdSA8IDB4REMwMCB8fCB1ID4gMHhERkZGIC0+IGRlY19pbnZhbGlkIDIgKCogcmV0cnkgaGVyZSAqKVxuICAgICAgfCBsbyAtPlxuICAgICAgICAgIGxldCB1ID0gKCgoaGkgbGFuZCAweDNGRikgbHNsIDEwKSBsb3IgKGxvIGxhbmQgMHgzRkYpKSArIDB4MTAwMDAgaW5cbiAgICAgICAgICBkZWNfcmV0IDQgdVxuXG5sZXQgc2V0X3V0Zl8xNmJlX3VjaGFyIGIgaSB1ID1cbiAgbGV0IHNldCA9IHVuc2FmZV9zZXRfdWludDE2X2JlIGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IG1heCB0aGVuIGludmFsaWRfYXJnIFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiIGVsc2VcbiAgbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuICB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiAgfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDEgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2UgKHNldCBiIGkgdTsgMilcbiAgfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgIGxldCBoaSA9ICgweEQ4MDAgbG9yICh1JyBsc3IgMTApKSBpblxuICAgICAgbGV0IGxvID0gKDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpKSBpblxuICAgICAgc2V0IGIgaSBoaTsgc2V0IGIgKGkgKyAyKSBsbzsgNFxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBpc192YWxpZF91dGZfMTZiZSBiID1cbiAgbGV0IHJlYyBsb29wIG1heCBiIGkgPVxuICAgIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQxNl9iZSBpblxuICAgIGlmIGkgPiBtYXggdGhlbiB0cnVlIGVsc2VcbiAgICBpZiBpID0gbWF4IHRoZW4gZmFsc2UgZWxzZVxuICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgIHwgdSB3aGVuIHUgPCAweEQ4MDAgfHwgdSA+IDB4REZGRiAtPiBsb29wIG1heCBiIChpICsgMilcbiAgICB8IHUgd2hlbiB1ID4gMHhEQkZGIC0+IGZhbHNlXG4gICAgfCBfaGkgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICBtYXRjaCBnZXQgYiAoaSArIDIpIHdpdGhcbiAgICAgICAgfCB1IHdoZW4gdSA8IDB4REMwMCB8fCB1ID4gMHhERkZGIC0+IGZhbHNlXG4gICAgICAgIHwgX2xvIC0+IGxvb3AgbWF4IGIgKGkgKyA0KVxuICBpblxuICBsb29wIChsZW5ndGggYiAtIDEpIGIgMFxuXG4oKiBVVEYtMTZMRSAqKVxuXG5sZXQgZ2V0X3V0Zl8xNmxlX3VjaGFyIGIgaSA9XG4gIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQxNl9sZSBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBtYXggdGhlbiBpbnZhbGlkX2FyZyBcImluZGV4IG91dCBvZiBib3VuZHNcIiBlbHNlXG4gIGlmIGkgPSBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAweEQ4MDAgfHwgdSA+IDB4REZGRiAtPiBkZWNfcmV0IDIgdVxuICB8IHUgd2hlbiB1ID4gMHhEQkZGIC0+IGRlY19pbnZhbGlkIDJcbiAgfCBoaSAtPiAoKiBjb21iaW5lIFtoaV0gd2l0aCBhIGxvdyBzdXJyb2dhdGUgKilcbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAobWF4IC0gaSArIDEpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIChpICsgMikgd2l0aFxuICAgICAgfCB1IHdoZW4gdSA8IDB4REMwMCB8fCB1ID4gMHhERkZGIC0+IGRlY19pbnZhbGlkIDIgKCogcmV0cnkgaGVyZSAqKVxuICAgICAgfCBsbyAtPlxuICAgICAgICAgIGxldCB1ID0gKCgoaGkgbGFuZCAweDNGRikgbHNsIDEwKSBsb3IgKGxvIGxhbmQgMHgzRkYpKSArIDB4MTAwMDAgaW5cbiAgICAgICAgICBkZWNfcmV0IDQgdVxuXG5sZXQgc2V0X3V0Zl8xNmxlX3VjaGFyIGIgaSB1ID1cbiAgbGV0IHNldCA9IHVuc2FmZV9zZXRfdWludDE2X2xlIGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IG1heCB0aGVuIGludmFsaWRfYXJnIFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiIGVsc2VcbiAgbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuICB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiAgfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDEgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2UgKHNldCBiIGkgdTsgMilcbiAgfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgIGxldCBoaSA9ICgweEQ4MDAgbG9yICh1JyBsc3IgMTApKSBpblxuICAgICAgbGV0IGxvID0gKDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpKSBpblxuICAgICAgc2V0IGIgaSBoaTsgc2V0IGIgKGkgKyAyKSBsbzsgNFxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBpc192YWxpZF91dGZfMTZsZSBiID1cbiAgbGV0IHJlYyBsb29wIG1heCBiIGkgPVxuICAgIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQxNl9sZSBpblxuICAgIGlmIGkgPiBtYXggdGhlbiB0cnVlIGVsc2VcbiAgICBpZiBpID0gbWF4IHRoZW4gZmFsc2UgZWxzZVxuICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgIHwgdSB3aGVuIHUgPCAweEQ4MDAgfHwgdSA+IDB4REZGRiAtPiBsb29wIG1heCBiIChpICsgMilcbiAgICB8IHUgd2hlbiB1ID4gMHhEQkZGIC0+IGZhbHNlXG4gICAgfCBfaGkgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICBtYXRjaCBnZXQgYiAoaSArIDIpIHdpdGhcbiAgICAgICAgfCB1IHdoZW4gdSA8IDB4REMwMCB8fCB1ID4gMHhERkZGIC0+IGZhbHNlXG4gICAgICAgIHwgX2xvIC0+IGxvb3AgbWF4IGIgKGkgKyA0KVxuICBpblxuICBsb29wIChsZW5ndGggYiAtIDEpIGIgMFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfYnl0ZXNfbWwiLCJjc3RfaW5kZXhfb3V0X29mX2JvdW5kcyIsImNhbWxfYmxpdF9ieXRlcyIsImNhbWxfYnN3YXAxNiIsImNhbWxfYnl0ZXNfZ2V0IiwiY2FtbF9ieXRlc19nZXQxNiIsImNhbWxfYnl0ZXNfZ2V0MzIiLCJjYW1sX2J5dGVzX2dldDY0IiwiY2FtbF9ieXRlc19vZl9zdHJpbmciLCJjYW1sX2J5dGVzX3NldCIsImNhbWxfYnl0ZXNfc2V0MTYiLCJjYW1sX2J5dGVzX3NldDMyIiwiY2FtbF9ieXRlc19zZXQ2NCIsImNhbWxfYnl0ZXNfdW5zYWZlX2dldCIsImNhbWxfYnl0ZXNfdW5zYWZlX3NldCIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9maWxsX2J5dGVzIiwiY2FtbF9pbnQzMl9ic3dhcCIsImNhbWxfaW50NjRfYnN3YXAiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX2J5dGVzX2xlbmd0aCIsImNhbWxfc3RyaW5nX29mX2J5dGVzIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJkdW1teSIsImdsb2JhbF9kYXRhIiwiU3RkbGliIiwiU3RkbGliX1VjaGFyIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfU3lzIiwiU3RkbGliX0ludCIsIlN0ZGxpYl9TZXEiLCJTdGRsaWJfQ2hhciIsIm1ha2UiLCJuIiwiYyIsInMiLCJpbml0IiwiaSIsImVtcHR5IiwiY3N0X1N0cmluZ19zdWJfQnl0ZXNfc3ViIiwiY3N0X0J5dGVzX2V4dGVuZCIsImNzdF9TdHJpbmdfZmlsbF9CeXRlc19maWxsIiwiY3N0X0J5dGVzX2JsaXQiLCJjc3RfU3RyaW5nX2JsaXRfQnl0ZXNfYmxpdF9zdHIiLCJjc3RfQnl0ZXNfY29uY2F0IiwiY3N0X1N0cmluZ19pbmRleF9mcm9tX0J5dGVzX2luIiwiY3N0X1N0cmluZ19pbmRleF9mcm9tX29wdF9CeXRlIiwiY3N0X1N0cmluZ19yaW5kZXhfZnJvbV9CeXRlc19yIiwiY3N0X1N0cmluZ19yaW5kZXhfZnJvbV9vcHRfQnl0IiwiY3N0X1N0cmluZ19jb250YWluc19mcm9tX0J5dGVzIiwiY3N0X1N0cmluZ19yY29udGFpbnNfZnJvbV9CeXRlIiwiY29weSIsImxlbiIsInIiLCJ0b19zdHJpbmciLCJiIiwib2Zfc3RyaW5nIiwic3ViIiwib2ZzIiwic3ViX3N0cmluZyIsInN5bWJvbCIsImEiLCJtYXRjaCIsImV4dGVuZCIsImxlZnQiLCJyaWdodCIsImRzdG9mZiIsInNyY29mZiIsImNweWxlbiIsImZpbGwiLCJibGl0IiwiczEiLCJvZnMxIiwiczIiLCJvZnMyIiwiYmxpdF9zdHJpbmciLCJpdGVyIiwiaXRlcmkiLCJjb25jYXQiLCJzZXAiLCJsIiwic2VwbGVuIiwiYWNjIiwicGFyYW0iLCJwb3MiLCJoZCIsInRsIiwieCIsImRzdCIsImNhdCIsImwxIiwibDIiLCJpc19zcGFjZSIsInRyaW0iLCJqIiwiZXNjYXBlZCIsIm1hcCIsIm1hcGkiLCJmb2xkX2xlZnQiLCJmb2xkX3JpZ2h0IiwiZXhpc3RzIiwicCIsImZvcl9hbGwiLCJ1cHBlcmNhc2VfYXNjaWkiLCJsb3dlcmNhc2VfYXNjaWkiLCJhcHBseTEiLCJjYXBpdGFsaXplX2FzY2lpIiwidW5jYXBpdGFsaXplX2FzY2lpIiwic3RhcnRzX3dpdGgiLCJwcmVmaXgiLCJsZW5fcyIsImxlbl9wcmUiLCJlbmRzX3dpdGgiLCJzdWZmaXgiLCJsZW5fc3VmIiwiZGlmZiIsImluZGV4X3JlYyIsImxpbSIsImluZGV4IiwiaW5kZXhfcmVjX29wdCIsImluZGV4X29wdCIsImluZGV4X2Zyb20iLCJpbmRleF9mcm9tX29wdCIsInJpbmRleF9yZWMiLCJyaW5kZXgiLCJyaW5kZXhfZnJvbSIsInJpbmRleF9yZWNfb3B0IiwicmluZGV4X29wdCIsInJpbmRleF9mcm9tX29wdCIsImNvbnRhaW5zX2Zyb20iLCJleG4iLCJjb250YWlucyIsInJjb250YWluc19mcm9tIiwiY29tcGFyZSIsImNzdF9CeXRlc19vZl9zZXFfY2Fubm90X2dyb3dfYiIsInNwbGl0X29uX2NoYXIiLCJ1cHBlcmNhc2UiLCJsb3dlcmNhc2UiLCJjYXBpdGFsaXplIiwidW5jYXBpdGFsaXplIiwidG9fc2VxIiwiYXV4IiwidG9fc2VxaSIsIm9mX3NlcSIsImJ1ZiIsIm5ld19sZW4iLCJuZXdfYnVmIiwidW5zYWZlX2dldF91aW50MTZfbGUiLCJ1bnNhZmVfZ2V0X3VpbnQxNl9iZSIsImdldF9pbnQ4IiwiZ2V0X3VpbnQxNl9sZSIsImdldF91aW50MTZfYmUiLCJnZXRfaW50MTZfbmUiLCJnZXRfaW50MTZfbGUiLCJnZXRfaW50MTZfYmUiLCJnZXRfaW50MzJfbGUiLCJnZXRfaW50MzJfYmUiLCJnZXRfaW50NjRfbGUiLCJnZXRfaW50NjRfYmUiLCJ1bnNhZmVfc2V0X3VpbnQxNl9sZSIsInVuc2FmZV9zZXRfdWludDE2X2JlIiwic2V0X2ludDE2X2xlIiwic2V0X2ludDE2X2JlIiwic2V0X2ludDMyX2xlIiwic2V0X2ludDMyX2JlIiwic2V0X2ludDY0X2xlIiwic2V0X2ludDY0X2JlIiwic2V0X3VpbnQ4Iiwic2V0X3VpbnQxNl9uZSIsImRlY19pbnZhbGlkIiwiZGVjX3JldCIsInUiLCJub3RfaW5feDgwX3RvX3hCRiIsIm5vdF9pbl94QTBfdG9feEJGIiwibm90X2luX3g4MF90b194OUYiLCJub3RfaW5feDkwX3RvX3hCRiIsIm5vdF9pbl94ODBfdG9feDhGIiwidXRmXzhfdWNoYXJfMyIsImIwIiwiYjEiLCJiMiIsInV0Zl84X3VjaGFyXzQiLCJiMyIsImdldF91dGZfOF91Y2hhciIsIm1heCIsInNldF91dGZfOF91Y2hhciIsInNldCIsImxhc3QiLCJpc192YWxpZF91dGZfOCIsImdldF91dGZfMTZiZV91Y2hhciIsImhpIiwibG8iLCJzZXRfdXRmXzE2YmVfdWNoYXIiLCJpc192YWxpZF91dGZfMTZiZSIsImdldF91dGZfMTZsZV91Y2hhciIsInNldF91dGZfMTZsZV91Y2hhciIsImlzX3ZhbGlkX3V0Zl8xNmxlIiwiU3RkbGliX0J5dGVzIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7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QUFBQUEsTUEvd0JMO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEcERwQiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ5MDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9zdHJpbmcubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBHYWxsaXVtLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFN0cmluZyBvcGVyYXRpb25zLCBiYXNlZCBvbiBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIGJ5dGVzLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVzdHJpbmdfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5tb2R1bGUgQiA9IEJ5dGVzXG5cbmxldCBidHMgPSBCLnVuc2FmZV90b19zdHJpbmdcbmxldCBib3MgPSBCLnVuc2FmZV9vZl9zdHJpbmdcblxubGV0IG1ha2UgbiBjID1cbiAgQi5tYWtlIG4gYyB8PiBidHNcbmxldCBpbml0IG4gZiA9XG4gIEIuaW5pdCBuIGYgfD4gYnRzXG5sZXQgZW1wdHkgPSBcIlwiXG5sZXQgY29weSBzID1cbiAgQi5jb3B5IChib3MgcykgfD4gYnRzXG5sZXQgb2ZfYnl0ZXMgPSBCLnRvX3N0cmluZ1xubGV0IHRvX2J5dGVzID0gQi5vZl9zdHJpbmdcbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgQi5zdWIgKGJvcyBzKSBvZnMgbGVuIHw+IGJ0c1xubGV0IGZpbGwgPVxuICBCLmZpbGxcbmxldCBibGl0ID1cbiAgQi5ibGl0X3N0cmluZ1xuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IFwiXCJcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluIGJ0cyBAQFxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKEIuY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbmxldCBjYXQgPSAoIF4gKVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlciBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyaSBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxubGV0IG1hcCBmIHMgPVxuICBCLm1hcCBmIChib3MgcykgfD4gYnRzXG5sZXQgbWFwaSBmIHMgPVxuICBCLm1hcGkgZiAoYm9zIHMpIHw+IGJ0c1xubGV0IGZvbGRfcmlnaHQgZiB4IGEgPVxuICBCLmZvbGRfcmlnaHQgZiAoYm9zIHgpIGFcbmxldCBmb2xkX2xlZnQgZiBhIHggPVxuICBCLmZvbGRfbGVmdCBmIGEgKGJvcyB4KVxubGV0IGV4aXN0cyBmIHMgPVxuICBCLmV4aXN0cyBmIChib3MgcylcbmxldCBmb3JfYWxsIGYgcyA9XG4gIEIuZm9yX2FsbCBmIChib3MgcylcblxuKCogQmV3YXJlOiB3ZSBjYW5ub3QgdXNlIEIudHJpbSBvciBCLmVzY2FwZSBiZWNhdXNlIHRoZXkgYWx3YXlzIG1ha2UgYVxuICAgY29weSwgYnV0IFN0cmluZy5tbGkgc3BlbGxzIG91dCBzb21lIGNhc2VzIHdoZXJlIHdlIGFyZSBub3QgYWxsb3dlZFxuICAgdG8gbWFrZSBhIGNvcHkuICopXG5cbmxldCBpc19zcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJyAnIHwgJ1xcMDEyJyB8ICdcXG4nIHwgJ1xccicgfCAnXFx0JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSBzID1cbiAgaWYgcyA9IFwiXCIgdGhlbiBzXG4gIGVsc2UgaWYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAwKSB8fCBpc19zcGFjZSAodW5zYWZlX2dldCBzIChsZW5ndGggcyAtIDEpKVxuICAgIHRoZW4gYnRzIChCLnRyaW0gKGJvcyBzKSlcbiAgZWxzZSBzXG5cbmxldCBlc2NhcGVkIHMgPVxuICBsZXQgcmVjIGVzY2FwZV9pZl9uZWVkZWQgcyBuIGkgPVxuICAgIGlmIGkgPj0gbiB0aGVuIHMgZWxzZVxuICAgICAgbWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFwwMDAnLi4nXFwwMzEnIHwgJ1xcMTI3Jy4uICdcXDI1NScgLT5cbiAgICAgICAgICBidHMgKEIuZXNjYXBlZCAoYm9zIHMpKVxuICAgICAgfCBfIC0+IGVzY2FwZV9pZl9uZWVkZWQgcyBuIChpKzEpXG4gIGluXG4gIGVzY2FwZV9pZl9uZWVkZWQgcyAobGVuZ3RoIHMpIDBcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICAgIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMuaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgcmluZGV4X3JlYyBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIHJpbmRleF9yZWMgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleCBzIGMgPSByaW5kZXhfcmVjIHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgcmluZGV4X3JlY19vcHQgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSByaW5kZXhfcmVjX29wdCBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X29wdCBzIGMgPSByaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJjb250YWluc19mcm9tIHMgaSBjID1cbiAgaWYgaSA8IDAgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5yY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChyaW5kZXhfcmVjIHMgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIHMgPVxuICBCLnVwcGVyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGxvd2VyY2FzZV9hc2NpaSBzID1cbiAgQi5sb3dlcmNhc2VfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCBjYXBpdGFsaXplX2FzY2lpIHMgPVxuICBCLmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCB1bmNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIudW5jYXBpdGFsaXplX2FzY2lpIChib3MgcykgfD4gYnRzXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBzdGFydHNfd2l0aCB+cHJlZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3ByZSA9IGxlbmd0aCBwcmVmaXggaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9wcmUgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgaSA8PiB1bnNhZmVfZ2V0IHByZWZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGxlbl9zID49IGxlbl9wcmUgJiYgYXV4IDBcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGVuZHNfd2l0aCB+c3VmZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3N1ZiA9IGxlbmd0aCBzdWZmaXggaW5cbiAgbGV0IGRpZmYgPSBsZW5fcyAtIGxlbl9zdWYgaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9zdWYgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgKGRpZmYgKyBpKSA8PiB1bnNhZmVfZ2V0IHN1ZmZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGRpZmYgPj0gMCAmJiBhdXggMFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgc3BsaXRfb25fY2hhciBzZXAgcyA9XG4gIGxldCByID0gcmVmIFtdIGluXG4gIGxldCBqID0gcmVmIChsZW5ndGggcykgaW5cbiAgZm9yIGkgPSBsZW5ndGggcyAtIDEgZG93bnRvIDAgZG9cbiAgICBpZiB1bnNhZmVfZ2V0IHMgaSA9IHNlcCB0aGVuIGJlZ2luXG4gICAgICByIDo9IHN1YiBzIChpICsgMSkgKCFqIC0gaSAtIDEpIDo6ICFyO1xuICAgICAgaiA6PSBpXG4gICAgZW5kXG4gIGRvbmU7XG4gIHN1YiBzIDAgIWogOjogIXJcblxuKCogRGVwcmVjYXRlZCBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgdmlhIG90aGVyIGRlcHJlY2F0ZWQgZnVuY3Rpb25zICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5sZXQgdXBwZXJjYXNlIHMgPVxuICBCLnVwcGVyY2FzZSAoYm9zIHMpIHw+IGJ0c1xubGV0IGxvd2VyY2FzZSBzID1cbiAgQi5sb3dlcmNhc2UgKGJvcyBzKSB8PiBidHNcbmxldCBjYXBpdGFsaXplIHMgPVxuICBCLmNhcGl0YWxpemUgKGJvcyBzKSB8PiBidHNcbmxldCB1bmNhcGl0YWxpemUgcyA9XG4gIEIudW5jYXBpdGFsaXplIChib3MgcykgfD4gYnRzXG5cbnR5cGUgdCA9IHN0cmluZ1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbCA9IFwiY2FtbF9zdHJpbmdfZXF1YWxcIiBbQEBub2FsbG9jXVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPSBib3MgcyB8PiBCLnRvX3NlcVxuXG5sZXQgdG9fc2VxaSBzID0gYm9zIHMgfD4gQi50b19zZXFpXG5cbmxldCBvZl9zZXEgZyA9IEIub2Zfc2VxIGcgfD4gYnRzXG5cbigqIFVURiBkZWNvZGVycyBhbmQgdmFsaWRhdG9ycyAqKVxuXG5sZXQgZ2V0X3V0Zl84X3VjaGFyIHMgaSA9IEIuZ2V0X3V0Zl84X3VjaGFyIChib3MgcykgaVxubGV0IGlzX3ZhbGlkX3V0Zl84IHMgPSBCLmlzX3ZhbGlkX3V0Zl84IChib3MgcylcblxubGV0IGdldF91dGZfMTZiZV91Y2hhciBzIGkgPSBCLmdldF91dGZfMTZiZV91Y2hhciAoYm9zIHMpIGlcbmxldCBpc192YWxpZF91dGZfMTZiZSBzID0gQi5pc192YWxpZF91dGZfMTZiZSAoYm9zIHMpXG5cbmxldCBnZXRfdXRmXzE2bGVfdWNoYXIgcyBpID0gQi5nZXRfdXRmXzE2bGVfdWNoYXIgKGJvcyBzKSBpXG5sZXQgaXNfdmFsaWRfdXRmXzE2bGUgcyA9IEIuaXNfdmFsaWRfdXRmXzE2bGUgKGJvcyBzKVxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nL2RlY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG5leHRlcm5hbCBnZXRfdWludDggOiBzdHJpbmcgLT4gaW50IC0+IGludCA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5leHRlcm5hbCBnZXRfdWludDE2X25lIDogc3RyaW5nIC0+IGludCAtPiBpbnQgPSBcIiVjYW1sX3N0cmluZ19nZXQxNlwiXG5leHRlcm5hbCBnZXRfaW50MzJfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludDMyID0gXCIlY2FtbF9zdHJpbmdfZ2V0MzJcIlxuZXh0ZXJuYWwgZ2V0X2ludDY0X25lIDogc3RyaW5nIC0+IGludCAtPiBpbnQ2NCA9IFwiJWNhbWxfc3RyaW5nX2dldDY0XCJcblxubGV0IGdldF9pbnQ4IHMgaSA9IEIuZ2V0X2ludDggKGJvcyBzKSBpXG5sZXQgZ2V0X3VpbnQxNl9sZSBzIGkgPSBCLmdldF91aW50MTZfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X3VpbnQxNl9iZSBzIGkgPSBCLmdldF91aW50MTZfYmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDE2X25lIHMgaSA9IEIuZ2V0X2ludDE2X25lIChib3MgcykgaVxubGV0IGdldF9pbnQxNl9sZSBzIGkgPSBCLmdldF9pbnQxNl9sZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MTZfYmUgcyBpID0gQi5nZXRfaW50MTZfYmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDMyX2xlIHMgaSA9IEIuZ2V0X2ludDMyX2xlIChib3MgcykgaVxubGV0IGdldF9pbnQzMl9iZSBzIGkgPSBCLmdldF9pbnQzMl9iZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50NjRfbGUgcyBpID0gQi5nZXRfaW50NjRfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDY0X2JlIHMgaSA9IEIuZ2V0X2ludDY0X2JlIChib3MgcykgaVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjYW1sX2JsaXRfc3RyaW5nIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfZXF1YWwiLCJjYW1sX3N0cmluZ191bnNhZmVfZ2V0IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsImVtcHR5IiwiU3RkbGliIiwiU3RkbGliX0J5dGVzIiwiYnRzIiwiYm9zIiwibWFrZSIsIm4iLCJjIiwiaW5pdCIsImNvcHkiLCJzIiwib2ZfYnl0ZXMiLCJ0b19ieXRlcyIsInN1YiIsIm9mcyIsImxlbiIsImZpbGwiLCJibGl0IiwiY3N0X1N0cmluZ19jb25jYXQiLCJjb25jYXQiLCJzZXAiLCJsIiwic2VwbGVuIiwiYWNjIiwicGFyYW0iLCJwb3MiLCJoZCIsInRsIiwieCIsImRzdCIsImNhdCIsImNzdF9TdHJpbmdfaW5kZXhfZnJvbV9CeXRlc19pbiIsImNzdF9TdHJpbmdfaW5kZXhfZnJvbV9vcHRfQnl0ZSIsImNzdF9TdHJpbmdfcmluZGV4X2Zyb21fQnl0ZXNfciIsImNzdF9TdHJpbmdfcmluZGV4X2Zyb21fb3B0X0J5dCIsImNzdF9TdHJpbmdfY29udGFpbnNfZnJvbV9CeXRlcyIsImNzdF9TdHJpbmdfcmNvbnRhaW5zX2Zyb21fQnl0ZSIsIml0ZXIiLCJpIiwiaXRlcmkiLCJtYXAiLCJtYXBpIiwiZm9sZF9yaWdodCIsImEiLCJmb2xkX2xlZnQiLCJleGlzdHMiLCJmb3JfYWxsIiwiaXNfc3BhY2UiLCJ0cmltIiwiZXNjYXBlZCIsImluZGV4X3JlYyIsImxpbSIsImluZGV4IiwiaW5kZXhfcmVjX29wdCIsImluZGV4X29wdCIsImluZGV4X2Zyb20iLCJpbmRleF9mcm9tX29wdCIsInJpbmRleF9yZWMiLCJyaW5kZXgiLCJyaW5kZXhfZnJvbSIsInJpbmRleF9yZWNfb3B0IiwicmluZGV4X29wdCIsInJpbmRleF9mcm9tX29wdCIsImNvbnRhaW5zX2Zyb20iLCJleG4iLCJjb250YWlucyIsInJjb250YWluc19mcm9tIiwidXBwZXJjYXNlX2FzY2lpIiwibG93ZXJjYXNlX2FzY2lpIiwiY2FwaXRhbGl6ZV9hc2NpaSIsInVuY2FwaXRhbGl6ZV9hc2NpaSIsInN0YXJ0c193aXRoIiwicHJlZml4IiwibGVuX3MiLCJsZW5fcHJlIiwiZW5kc193aXRoIiwic3VmZml4IiwibGVuX3N1ZiIsImRpZmYiLCJzcGxpdF9vbl9jaGFyIiwiciIsImoiLCJ1cHBlcmNhc2UiLCJsb3dlcmNhc2UiLCJjYXBpdGFsaXplIiwidW5jYXBpdGFsaXplIiwiY29tcGFyZSIsInRvX3NlcSIsInRvX3NlcWkiLCJvZl9zZXEiLCJnIiwiZ2V0X3V0Zl84X3VjaGFyIiwiaXNfdmFsaWRfdXRmXzgiLCJnZXRfdXRmXzE2YmVfdWNoYXIiLCJpc192YWxpZF91dGZfMTZiZSIsImdldF91dGZfMTZsZV91Y2hhciIsImlzX3ZhbGlkX3V0Zl8xNmxlIiwiZ2V0X2ludDgiLCJnZXRfdWludDE2X2xlIiwiZ2V0X3VpbnQxNl9iZSIsImdldF9pbnQxNl9uZSIsImdldF9pbnQxNl9sZSIsImdldF9pbnQxNl9iZSIsImdldF9pbnQzMl9sZSIsImdldF9pbnQzMl9iZSIsImdldF9pbnQ2NF9sZSIsImdldF9pbnQ2NF9iZSIsIlN0ZGxpYl9TdHJpbmciXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQVosTUFBQTtBQUFBLElBQUFhLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsWUFBQUMsS0FBQUMsR0FBQUMsR0N3Q0UsT0FBVSxJQUFWLGlDQUFpQjtBQUFBLFlBQUFDLEtBQUFGLEdBQUFYLEdBRWpCLE9BQVUsSUFBVixpQ0FBaUI7QUFBQSxZQUFBYyxLQUFBQztBQUFBQSxRQUFBLElBR1Y7QUFBQSxJQUFQLE9BQWMsSUFBZCw4QkFBcUI7QUFBQTtBQUFBLE9BQUFDLFdEN0N2QixpQkFBQUMsV0FBQTtBQUFBLFlBQUFDLElBQUFILEdBQUFJLEtBQUFDO0FBQUFBLFFBQUEsSUNpRFE7QUFBQSxJQUFOLE9BQXFCLElBQXJCLHdDQUE0QjtBQUFBO0FBQUE7QUFBQSxJQUFBQyxPRGpEOUI7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxZQUFBQyxPQUFBQyxLQUFBQztBQUFBQSxJQ3VFVyxRQUNEO0FB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LElBQ2I7QUFBQSxJQUFPO0FBQUE7QUFBQSxZQUFBcUYsbUJBQUFyRixHQUFBNEI7QUFBQUEsUUFBQSxJQUVIO0FBQUEsSUFBTyx3Q0FBRTtBQUFBO0FBQUEsWUFBQTBELGtCQUFBdEY7QUFBQUEsUUFBQSxJQUNiO0FBQUEsSUFBTztBQUFBO0FBQUEsWUFBQXVGLFNBQUF2RixHQUFBNEI7QUFBQUEsUUFBQSxJQVN2QjtBQUFBLElBQU8sd0NBQUU7QUFBQTtBQUFBLFlBQUE0RCxjQUFBeEYsR0FBQTRCO0FBQUFBLFFBQUEsSUFDQztBQUFBLElBQU8sd0NBQUU7QUFBQTtBQUFBLFlBQUE2RCxjQUFBekYsR0FBQTRCO0FBQUFBLFFBQUEsSUFDVDtBQUFBLElBQU8sd0NBQUU7QUFBQTtBQUFBLFlBQUE4RCxhQUFBMUYsR0FBQTRCO0FBQUFBLFFBQUEsSUFDWDtBQUFBLElBQU8sd0NBQUU7QUFBQTtBQUFBLFlBQUErRCxhQUFBM0YsR0FBQTRCO0FBQUFBLFFBQUEsSUFDVDtBQUFBLElBQU8sd0NBQUU7QUFBQTtBQUFBLFlBQUFnRSxhQUFBNUYsR0FBQTRCO0FBQUFBLFFBQUEsSUFDVDtBQUFBLElBQU8sd0NBQUU7QUFBQTtBQUFBLFlBQUFpRSxhQUFBN0YsR0FBQTRCO0FBQUFBLFFBQUEsSUFDVDtBQUFBLElBQU8sd0NBQUU7QUFBQTtBQUFBLFlBQUFrRSxhQUFBOUYsR0FBQTRCO0FBQUFBLFFBQUEsSUFDVDtBQUFBLElBQU8sd0NBQUU7QUFBQTtBQUFBLFlBQUFtRSxhQUFBL0YsR0FBQTRCO0FBQUFBLFFBQUEsSUFDVDtBQUFBLElBQU8sd0NBQUU7QUFBQTtBQUFBLFlBQUFvRSxhQUFBaEcsR0FBQTRCO0FBQUFBLFFBQUEsSUFDVDtBQUFBLElBQU8sd0NBQUU7QUFBQTtBQUFBO0FBQUEsSUFBQXFFO0FBQUFBLE1EeFMvQyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjU0MDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC91bml0Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSB1bml0ID0gKClcblxubGV0IGVxdWFsICgpICgpID0gdHJ1ZVxubGV0IGNvbXBhcmUgKCkgKCkgPSAwXG5sZXQgdG9fc3RyaW5nICgpID0gXCIoKVwiXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImVxdWFsIiwicGFyYW0iLCJjb21wYXJlIiwidG9fc3RyaW5nIiwiU3RkbGliX1VuaXQiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxNQUFBO0FBQUEsWUFBQUMsTUFBQUMsT0FBQSxHQ2lCa0IsU0FBSTtBQUFBLFlBQUFDLFFBQUFELE9BQUEsR0FDRixTQUFDO0FBQUEsWUFBQUUsVUFBQUYsT0FDRixXQUFJO0FBQUEsT0FBQUcsY0RuQnZCIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NTQyNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL21hcnNoYWwubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgZXh0ZXJuX2ZsYWdzID1cbiAgICBOb19zaGFyaW5nXG4gIHwgQ2xvc3VyZXNcbiAgfCBDb21wYXRfMzJcbigqIG5vdGU6IHRoaXMgdHlwZSBkZWZpbml0aW9uIGlzIHVzZWQgaW4gJ3J1bnRpbWUvZGVidWdnZXIuYycgKilcblxuZXh0ZXJuYWwgdG9fY2hhbm5lbDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gdW5pdFxuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5leHRlcm5hbCB0b19ieXRlczogJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gYnl0ZXNcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXNcIlxuZXh0ZXJuYWwgdG9fc3RyaW5nOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBzdHJpbmdcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHRvX2J1ZmZlcl91bnNhZmU6XG4gICAgICBieXRlcyAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IGludFxuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXJcIlxuXG5sZXQgdG9fYnVmZmVyIGJ1ZmYgb2ZzIGxlbiB2IGZsYWdzID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLnRvX2J1ZmZlcjogc3Vic3RyaW5nIG91dCBvZiBib3VuZHNcIlxuICBlbHNlIHRvX2J1ZmZlcl91bnNhZmUgYnVmZiBvZnMgbGVuIHYgZmxhZ3NcblxuKCogVGhlIGZ1bmN0aW9ucyBiZWxvdyB1c2UgYnl0ZSBzZXF1ZW5jZXMgYXMgaW5wdXQsIG5ldmVyIHVzaW5nIGFueVxuICAgbXV0YXRpb24uIEl0IG1ha2VzIHNlbnNlIHRvIHVzZSBub24tbXV0YXRlZCBbYnl0ZXNdIHJhdGhlciB0aGFuXG4gICBbc3RyaW5nXSwgYmVjYXVzZSB3ZSByZWFsbHkgd29yayB3aXRoIHNlcXVlbmNlcyBvZiBieXRlcywgbm90XG4gICBhIHRleHQgcmVwcmVzZW50YXRpb24uXG4qKVxuXG5leHRlcm5hbCBmcm9tX2NoYW5uZWw6IGluX2NoYW5uZWwgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZnJvbV9ieXRlc191bnNhZmU6IGJ5dGVzIC0+IGludCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzXCJcbmV4dGVybmFsIGRhdGFfc2l6ZV91bnNhZmU6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcImNhbWxfbWFyc2hhbF9kYXRhX3NpemVcIlxuXG5sZXQgaGVhZGVyX3NpemUgPSAyMFxubGV0IGRhdGFfc2l6ZSBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5kYXRhX3NpemVcIlxuICBlbHNlIGRhdGFfc2l6ZV91bnNhZmUgYnVmZiBvZnNcbmxldCB0b3RhbF9zaXplIGJ1ZmYgb2ZzID0gaGVhZGVyX3NpemUgKyBkYXRhX3NpemUgYnVmZiBvZnNcblxubGV0IGZyb21fYnl0ZXMgYnVmZiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gaGVhZGVyX3NpemVcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbGVuID0gZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mcyBpblxuICAgIGlmIG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gKGhlYWRlcl9zaXplICsgbGVuKVxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmZyb21fYnl0ZXNcIlxuICAgIGVsc2UgZnJvbV9ieXRlc191bnNhZmUgYnVmZiBvZnNcbiAgZW5kXG5cbmxldCBmcm9tX3N0cmluZyBidWZmIG9mcyA9XG4gICgqIEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgaXMgc2FmZSBoZXJlLCBhcyB0aGUgcHJvZHVjZWQgYnl0ZVxuICAgICBzZXF1ZW5jZSBpcyBuZXZlciBtdXRhdGVkICopXG4gIGZyb21fYnl0ZXMgKEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgYnVmZikgb2ZzXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9NYXJzaGFsX2Zyb21fYnl0ZXMiLCJjYW1sX21hcnNoYWxfZGF0YV9zaXplIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9CeXRlcyIsIlN0ZGxpYiIsImNzdF9NYXJzaGFsX3RvX2J1ZmZlcl9zdWJzdHJpbiIsInRvX2J1ZmZlciIsImJ1ZmYiLCJvZnMiLCJsZW4iLCJ2IiwiZmxhZ3MiLCJjc3RfTWFyc2hhbF9kYXRhX3NpemUiLCJkYXRhX3NpemUiLCJ0b3RhbF9zaXplIiwiZnJvbV9ieXRlcyIsImZyb21fc3RyaW5nIiwiU3RkbGliX01hcnNoYWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLFlBQUFDLFVBQUFDLE1BQUFDLEtBQUFDLEtBQUFDLEdBQUFDO0FBQUFBLElDZ0NFO0FBQUEsS0FFSyxvRUFBcUM7QUFBQSxJQURyQywyREFDcUM7QUFBQTtBQUFBO0FBQUEsSUFBQUMsd0JEbEM1QztBQUFBLElBQUFiLHlCQUFBO0FBQUEsSUFBQUEsMkJBQUE7QUFBQSxZQUFBYyxVQUFBTixNQUFBQztBQUFBQSxJQ2dERTtBQUFBLEtBRUssd0NBQXlCO0FBQUEsSUFEekIsa0RBQ3lCO0FBQUE7QUFBQSxZQUFBTSxXQUFBUCxNQUFBQyxLQUNRLG9DQUFrQjtBQUFBLFlBQUFPLFdBQUFSLE1BQUFDO0FBQUFBLElBR3hEO0FBQUEsU0FBQUMsTUFHWTtBQUFBLEtBQ1Y7QUFBQSxlQUNLO0FBQUEsZUFDQSw4Q0FDSjtBQUFBO0FBQUEsSUFORSxtREFNRjtBQUFBO0FBQUEsWUFBQU8sWUFBQVQsTUFBQUM7QUFBQUEsSUFLUSxPQUE2QixXQUE3Qix1Q0FBaUM7QUFBQTtBQUFBO0FBQUEsSUFBQVM7QUFBQUEsTURsRTlDIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NTQ4MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL2FycmF5Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgYXJyYXlzLiAqKVxudHlwZSAnYSB0ID0gJ2EgYXJyYXlcblxuKCogQXJyYXkgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBsZW5ndGggOiAnYSBhcnJheSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgbWFrZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCBjcmVhdGU6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgdW5zYWZlX3N1YiA6ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfc3ViXCJcbmV4dGVybmFsIGFwcGVuZF9wcmltIDogJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfYXBwZW5kXCJcbmV4dGVybmFsIGNvbmNhdCA6ICdhIGFycmF5IGxpc3QgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfY29uY2F0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9ibGl0XCJcbmV4dGVybmFsIHVuc2FmZV9maWxsIDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2FycmF5X2ZpbGxcIlxuZXh0ZXJuYWwgY3JlYXRlX2Zsb2F0OiBpbnQgLT4gZmxvYXQgYXJyYXkgPSBcImNhbWxfbWFrZV9mbG9hdF92ZWN0XCJcbmxldCBtYWtlX2Zsb2F0ID0gY3JlYXRlX2Zsb2F0XG5cbm1vZHVsZSBGbG9hdGFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBmbG9hdGFycmF5ID0gXCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogZmxvYXRhcnJheSAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCIlZmxvYXRhcnJheV91bnNhZmVfc2V0XCJcbmVuZFxuXG5sZXQgaW5pdCBsIGYgPVxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZVxuICBpZiBsIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuaW5pdFwiXG4gICgqIFNlZSAjNjU3NS4gV2UgY291bGQgYWxzbyBjaGVjayBmb3IgbWF4aW11bSBhcnJheSBzaXplLCBidXQgdGhpcyBkZXBlbmRzXG4gICAgIG9uIHdoZXRoZXIgd2UgY3JlYXRlIGEgZmxvYXQgYXJyYXkgb3IgYSByZWd1bGFyIG9uZS4uLiAqKVxuICBlbHNlXG4gICBsZXQgcmVzID0gY3JlYXRlIGwgKGYgMCkgaW5cbiAgIGZvciBpID0gMSB0byBwcmVkIGwgZG9cbiAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgZG9uZTtcbiAgIHJlc1xuXG5sZXQgbWFrZV9tYXRyaXggc3ggc3kgaW5pdCA9XG4gIGxldCByZXMgPSBjcmVhdGUgc3ggW3x8XSBpblxuICBmb3IgeCA9IDAgdG8gcHJlZCBzeCBkb1xuICAgIHVuc2FmZV9zZXQgcmVzIHggKGNyZWF0ZSBzeSBpbml0KVxuICBkb25lO1xuICByZXNcblxubGV0IGNyZWF0ZV9tYXRyaXggPSBtYWtlX21hdHJpeFxuXG5sZXQgY29weSBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpbiBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSB1bnNhZmVfc3ViIGEgMCBsXG5cbmxldCBhcHBlbmQgYTEgYTIgPVxuICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgaWYgbDEgPSAwIHRoZW4gY29weSBhMlxuICBlbHNlIGlmIGxlbmd0aCBhMiA9IDAgdGhlbiB1bnNhZmVfc3ViIGExIDAgbDFcbiAgZWxzZSBhcHBlbmRfcHJpbSBhMSBhMlxuXG5sZXQgc3ViIGEgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuc3ViXCJcbiAgZWxzZSB1bnNhZmVfc3ViIGEgb2ZzIGxlblxuXG5sZXQgZmlsbCBhIG9mcyBsZW4gdiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxubGV0IGJsaXQgYTEgb2ZzMSBhMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBhMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggYTIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IGExIG9mczEgYTIgb2ZzMiBsZW5cblxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBpdGVyMiBmIGEgYiA9XG4gIGlmIGxlbmd0aCBhIDw+IGxlbmd0aCBiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lml0ZXIyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2VcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpIGRvbmVcblxubGV0IG1hcCBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZih1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZih1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwMiBmIGEgYiA9XG4gIGxldCBsYSA9IGxlbmd0aCBhIGluXG4gIGxldCBsYiA9IGxlbmd0aCBiIGluXG4gIGlmIGxhIDw+IGxiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lm1hcDI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgZWxzZSBiZWdpblxuICAgIGlmIGxhID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBjcmVhdGUgbGEgKGYgKHVuc2FmZV9nZXQgYSAwKSAodW5zYWZlX2dldCBiIDApKSBpblxuICAgICAgZm9yIGkgPSAxIHRvIGxhIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuICBlbmRcblxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgbWFwaSBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZiAwICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgdG9fbGlzdCBhID1cbiAgbGV0IHJlYyB0b2xpc3QgaSByZXMgPVxuICAgIGlmIGkgPCAwIHRoZW4gcmVzIGVsc2UgdG9saXN0IChpIC0gMSkgKHVuc2FmZV9nZXQgYSBpIDo6IHJlcykgaW5cbiAgdG9saXN0IChsZW5ndGggYSAtIDEpIFtdXG5cbigqIENhbm5vdCB1c2UgTGlzdC5sZW5ndGggaGVyZSBiZWNhdXNlIHRoZSBMaXN0IG1vZHVsZSBkZXBlbmRzIG9uIEFycmF5LiAqKVxubGV0IHJlYyBsaXN0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2N1XG4gIHwgXzo6dCAtPiBsaXN0X2xlbmd0aCAoc3VjYyBhY2N1KSB0XG5cbmxldCBvZl9saXN0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbfHxdXG4gIHwgaGQ6OnRsIGFzIGwgLT5cbiAgICAgIGxldCBhID0gY3JlYXRlIChsaXN0X2xlbmd0aCAwIGwpIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaSsxKSB0bCBpblxuICAgICAgZmlsbCAxIHRsXG5cbmxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhclxuXG5sZXQgZm9sZF9sZWZ0X21hcCBmIGFjYyBpbnB1dF9hcnJheSA9XG4gIGxldCBsZW4gPSBsZW5ndGggaW5wdXRfYXJyYXkgaW5cbiAgaWYgbGVuID0gMCB0aGVuIChhY2MsIFt8fF0pIGVsc2UgYmVnaW5cbiAgICBsZXQgYWNjLCBlbHQgPSBmIGFjYyAodW5zYWZlX2dldCBpbnB1dF9hcnJheSAwKSBpblxuICAgIGxldCBvdXRwdXRfYXJyYXkgPSBjcmVhdGUgbGVuIGVsdCBpblxuICAgIGxldCBhY2MgPSByZWYgYWNjIGluXG4gICAgZm9yIGkgPSAxIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCBhY2MnLCBlbHQgPSBmICFhY2MgKHVuc2FmZV9nZXQgaW5wdXRfYXJyYXkgaSkgaW5cbiAgICAgIGFjYyA6PSBhY2MnO1xuICAgICAgdW5zYWZlX3NldCBvdXRwdXRfYXJyYXkgaSBlbHQ7XG4gICAgZG9uZTtcbiAgICAhYWNjLCBvdXRwdXRfYXJyYXlcbiAgZW5kXG5cbmxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gIGRvbmU7XG4gICFyXG5cbmxldCBleGlzdHMgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwyIHAgbDEgbDIgPVxuICBsZXQgbjEgPSBsZW5ndGggbDFcbiAgYW5kIG4yID0gbGVuZ3RoIGwyIGluXG4gIGlmIG4xIDw+IG4yIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5mb3JfYWxsMlwiXG4gIGVsc2UgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuMSB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgbDEgaSkgKHVuc2FmZV9nZXQgbDIgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IGV4aXN0czIgcCBsMSBsMiA9XG4gIGxldCBuMSA9IGxlbmd0aCBsMVxuICBhbmQgbjIgPSBsZW5ndGggbDIgaW5cbiAgaWYgbjEgPD4gbjIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmV4aXN0czJcIlxuICBlbHNlIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbjEgdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBsMSBpKSAodW5zYWZlX2dldCBsMiBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW0geCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhIGkpIHggPSAwIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IG1lbXEgeCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgeCA9PSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZpbmRfb3B0IHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gTm9uZVxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIGlmIHAgeCB0aGVuIFNvbWUgeFxuICAgICAgZWxzZSBsb29wIChzdWNjIGkpXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgZmluZF9tYXAgZiBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBOb25lXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZiAodW5zYWZlX2dldCBhIGkpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBsb29wIChzdWNjIGkpXG4gICAgICB8IFNvbWUgXyBhcyByIC0+IHJcbiAgaW5cbiAgbG9vcCAwXG5cbmxldCBzcGxpdCB4ID1cbiAgaWYgeCA9IFt8fF0gdGhlbiBbfHxdLCBbfHxdXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgYTAsIGIwID0gdW5zYWZlX2dldCB4IDAgaW5cbiAgICBsZXQgbiA9IGxlbmd0aCB4IGluXG4gICAgbGV0IGEgPSBjcmVhdGUgbiBhMCBpblxuICAgIGxldCBiID0gY3JlYXRlIG4gYjAgaW5cbiAgICBmb3IgaSA9IDEgdG8gbiAtIDEgZG9cbiAgICAgIGxldCBhaSwgYmkgPSB1bnNhZmVfZ2V0IHggaSBpblxuICAgICAgdW5zYWZlX3NldCBhIGkgYWk7XG4gICAgICB1bnNhZmVfc2V0IGIgaSBiaVxuICAgIGRvbmU7XG4gICAgYSwgYlxuICBlbmRcblxubGV0IGNvbWJpbmUgYSBiID1cbiAgbGV0IG5hID0gbGVuZ3RoIGEgaW5cbiAgbGV0IG5iID0gbGVuZ3RoIGIgaW5cbiAgaWYgbmEgPD4gbmIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmNvbWJpbmVcIjtcbiAgaWYgbmEgPSAwIHRoZW4gW3x8XVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHggPSBjcmVhdGUgbmEgKHVuc2FmZV9nZXQgYSAwLCB1bnNhZmVfZ2V0IGIgMCkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbmEgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHggaSAodW5zYWZlX2dldCBhIGksIHVuc2FmZV9nZXQgYiBpKVxuICAgIGRvbmU7XG4gICAgeFxuICBlbmRcblxuZXhjZXB0aW9uIEJvdHRvbSBvZiBpbnRcbmxldCBzb3J0IGNtcCBhID1cbiAgbGV0IG1heHNvbiBsIGkgPVxuICAgIGxldCBpMzEgPSBpK2kraSsxIGluXG4gICAgbGV0IHggPSByZWYgaTMxIGluXG4gICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgIGlmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwIHRoZW4geCA6PSBpMzErMTtcbiAgICAgIGlmIGNtcCAoZ2V0IGEgIXgpIChnZXQgYSAoaTMxKzIpKSA8IDAgdGhlbiB4IDo9IGkzMSsyO1xuICAgICAgIXhcbiAgICBlbmQgZWxzZVxuICAgICAgaWYgaTMxKzEgPCBsICYmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwXG4gICAgICB0aGVuIGkzMSsxXG4gICAgICBlbHNlIGlmIGkzMSA8IGwgdGhlbiBpMzEgZWxzZSByYWlzZSAoQm90dG9tIGkpXG4gIGluXG4gIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIGlmIGNtcCAoZ2V0IGEgaikgZSA+IDAgdGhlbiBiZWdpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICB0cmlja2xlZG93biBsIGogZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgbGV0IHJlYyBidWJibGVkb3duIGwgaSA9XG4gICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgYnViYmxlZG93biBsIGpcbiAgaW5cbiAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gIGxldCByZWMgdHJpY2tsZXVwIGkgZSA9XG4gICAgbGV0IGZhdGhlciA9IChpIC0gMSkgLyAzIGluXG4gICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgaWYgY21wIChnZXQgYSBmYXRoZXIpIGUgPCAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGZhdGhlcik7XG4gICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBzZXQgYSBpIGU7XG4gICAgZW5kO1xuICBpblxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgZm9yIGkgPSBsIC0gMSBkb3dudG8gMiBkb1xuICAgIGxldCBlID0gKGdldCBhIGkpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgdHJpY2tsZXVwIChidWJibGUgaSAwKSBlO1xuICBkb25lO1xuICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG5cbmxldCBjdXRvZmYgPSA1XG5sZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICBsZXQgbWVyZ2Ugc3JjMW9mcyBzcmMxbGVuIHNyYzIgc3JjMm9mcyBzcmMybGVuIGRzdCBkc3RvZnMgPVxuICAgIGxldCBzcmMxciA9IHNyYzFvZnMgKyBzcmMxbGVuIGFuZCBzcmMyciA9IHNyYzJvZnMgKyBzcmMybGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgaWYgY21wIHMxIHMyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgZHN0IGQgczE7XG4gICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICBpZiBpMSA8IHNyYzFyIHRoZW5cbiAgICAgICAgICBsb29wIGkxIChnZXQgYSBpMSkgaTIgczIgKGQgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmxpdCBzcmMyIGkyIGRzdCAoZCArIDEpIChzcmMyciAtIGkyKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICBsZXQgaTIgPSBpMiArIDEgaW5cbiAgICAgICAgaWYgaTIgPCBzcmMyciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgYSBpMSBkc3QgKGQgKyAxKSAoc3JjMXIgLSBpMSlcbiAgICAgIGVuZFxuICAgIGluIGxvb3Agc3JjMW9mcyAoZ2V0IGEgc3JjMW9mcykgc3JjMm9mcyAoZ2V0IHNyYzIgc3JjMm9mcykgZHN0b2ZzO1xuICBpblxuICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSAoc3Jjb2ZzICsgaSkpIGluXG4gICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICB3aGlsZSAoIWogPj0gZHN0b2ZzICYmIGNtcCAoZ2V0IGRzdCAhaikgZSA+IDApIGRvXG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgKGdldCBkc3QgIWopO1xuICAgICAgICBkZWNyIGo7XG4gICAgICBkb25lO1xuICAgICAgc2V0IGRzdCAoIWogKyAxKSBlO1xuICAgIGRvbmU7XG4gIGluXG4gIGxldCByZWMgc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgIGxldCBsMSA9IGxlbiAvIDIgaW5cbiAgICAgIGxldCBsMiA9IGxlbiAtIGwxIGluXG4gICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgIHNvcnR0byBzcmNvZnMgYSAoc3Jjb2ZzICsgbDIpIGwxO1xuICAgICAgbWVyZ2UgKHNyY29mcyArIGwyKSBsMSBkc3QgKGRzdG9mcyArIGwxKSBsMiBkc3QgZHN0b2ZzO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgbGV0IGwxID0gbCAvIDIgaW5cbiAgICBsZXQgbDIgPSBsIC0gbDEgaW5cbiAgICBsZXQgdCA9IG1ha2UgbDIgKGdldCBhIDApIGluXG4gICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICBzb3J0dG8gMCBhIGwyIGwxO1xuICAgIG1lcmdlIGwyIGwxIHQgMCBsMiBhIDA7XG4gIGVuZFxuXG5cbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGEgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICB0aGVuXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gICAgZWxzZSBTZXEuTmlsXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9yZXZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgbGVuID0gbGlzdF9sZW5ndGggMCBsIGluXG4gICAgICBsZXQgYSA9IGNyZWF0ZSBsZW4gaGQgaW5cbiAgICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgICBbXSAtPiBhXG4gICAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpLTEpIHRsXG4gICAgICBpblxuICAgICAgZmlsbCAobGVuLTIpIHRsXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBsID0gU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gaSBpblxuICBvZl9yZXZfbGlzdCBsXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfYXJyYXlfc3ViIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfbWFrZV92ZWN0IiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9TZXEiLCJBc3NlcnRfZmFpbHVyZSIsIlN0ZGxpYiIsIm1ha2VfZmxvYXQiLCJGbG9hdGFycmF5IiwiY3N0X0FycmF5X2luaXQiLCJjc3RfQXJyYXlfc3ViIiwiY3N0X0FycmF5X2ZpbGwiLCJjc3RfQXJyYXlfYmxpdCIsImNzdF9BcnJheV9pdGVyMl9hcnJheXNfbXVzdF9oYSIsImNzdF9BcnJheV9tYXAyX2FycmF5c19tdXN0X2hhdiIsImNzdF9BcnJheV9mb3JfYWxsMiIsImNzdF9BcnJheV9leGlzdHMyIiwiY3N0X0FycmF5X2NvbWJpbmUiLCJpbml0IiwibCIsInJlcyIsImkiLCJtYWtlX21hdHJpeCIsInN4Iiwic3kiLCJ4IiwiY29weSIsImEiLCJhcHBlbmQiLCJhMiIsImwxIiwic3ViIiwib2ZzIiwibGVuIiwiZmlsbCIsInYiLCJibGl0Iiwib2ZzMSIsIm9mczIiLCJpdGVyIiwiaXRlcjIiLCJiIiwibWFwIiwiciIsIm1hcDIiLCJsYSIsImxiIiwiaXRlcmkiLCJtYXBpIiwidG9fbGlzdCIsImxpc3RfbGVuZ3RoIiwiYWNjdSIsInBhcmFtIiwidCIsIm9mX2xpc3QiLCJ0bCIsImhkIiwiZm9sZF9sZWZ0IiwiZm9sZF9sZWZ0X21hcCIsImFjYyIsImlucHV0X2FycmF5IiwibWF0Y2giLCJlbHQiLCJvdXRwdXRfYXJyYXkiLCJmb2xkX3JpZ2h0IiwiZXhpc3RzIiwicCIsIm4iLCJmb3JfYWxsIiwiZm9yX2FsbDIiLCJsMiIsIm4xIiwibjIiLCJleGlzdHMyIiwibWVtIiwibWVtcSIsImZpbmRfb3B0IiwiZmluZF9tYXAiLCJzcGxpdCIsImIwIiwiYmkiLCJhaSIsImNvbWJpbmUiLCJuYSIsIm5iIiwiQm90dG9tIiwic29ydCIsImNtcCIsIm1heHNvbiIsImkzMSIsImUiLCJqIiwiZXhuIiwidGFnIiwiZmF0aGVyIiwic3RhYmxlX3NvcnQiLCJtZXJnZSIsInNyYzFvZnMiLCJzcmMxbGVuIiwic3JjMiIsInNyYzJvZnMiLCJzcmMybGVuIiwiZHN0IiwiZHN0b2ZzIiwic3JjMXIiLCJzcmMyciIsInMyIiwiczEiLCJpMSIsImkyIiwiZCIsImlzb3J0dG8iLCJzcmNvZnMiLCJzb3J0dG8iLCJ0b19zZXEiLCJhdXgiLCJ0b19zZXFpIiwib2Zfc2VxIiwiU3RkbGliX0FycmF5Il0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxZQUFBQyxLQUFBQyxHQUFBcEI7QUFBQUEsSUNnREUsWUFBYztBQUFBLElBQ2QsVUFBYywyQ0FRVjtBQUFBLFFBQUFxQixNQUpPLGtCQUFTLHVCQUNuQjtBQUFBO0FBQUEsU0FBQUMsSUFBQTtBQUFBO0FBQUEsTUFDbUI7QUFBQSxjQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUV4QjtBQUFBLEdBQUc7QUFBQSxZQUFBQyxZQUFBQyxJQUFBQyxJQUFBTjtBQUFBQSxRQUFBRSxNQUdNLDZCQUNWO0FBQUE7QUFBQSxTQUFBSyxJQUFBO0FBQUE7QUFBQSxNQUNtQjtBQUFBLGNBQWdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUVuQztBQUFBLEdBQUc7QUFBQSxZQUFBQyxLQUFBQztBQUFBQSxRQUFBUixJQUtIO0FBQUEsSUFBb0IsdUJBQXdCLHVCQUFnQjtBQUFBO0FBQUEsWUFBQVMsT0FBQTFCLElBQUEyQjtBQUFBQSxRQUFBQyxLQUc1RDtBQUFBLElBQ0E7QUFBQSxjQUFlO0FBQUE7QUFBQTtBQUFBLGdCQUNZO0FBQUEsZ0JBQ3RCLGlDQUFpQjtBQUFBO0FBQUEsWUFBQUMsSUFBQUosR0FBQUssS0FBQUM7QUFBQUEsSUFHdEI7QUFBQSxLQUVLLGtDQUFvQjtBQUFBLElBRHBCLDBDQUNvQjtBQUFBO0FBQUEsWUFBQUMsS0FBQVAsR0FBQUssS0FBQUMsS0FBQUU7QUFBQUEsSUFHekI7QUFBQSxLQUVLLDhDQUF1QjtBQUFBLElBRHZCLDJDQUN1QjtBQUFBO0FBQUEsWUFBQUMsS0FBQWxDLElBQUFtQyxNQUFBUixJQUFBUyxNQUFBTDtBQUFBQSxJQUc1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBR0ssdURBQStCO0FBQUEsSUFEL0IsMkNBQytCO0FBQUE7QUFBQSxZQUFBTSxLQUFBeEMsR0FBQTRCO0FBQUFBLFFBQUEsSUFHcEM7QUFBQTtBQUFBLFNBQUFOLElBQUE7QUFBQTtBQUFBLE1BQTZCO0FBQUEsY0FBaUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQTlDO0FBQUEsR0FBbUQ7QUFBQSxZQUFBbUIsTUFBQXpDLEdBQUE0QixHQUFBYztBQUFBQSxJQUduRDtBQUFBLEtBQ0UsMkRBRXFFO0FBQUEsWUFBckU7QUFBQTtBQUFBLFNBQUFwQixJQUFBO0FBQUE7QUFBQSxNQUE2QjtBQUFBLGNBQW1DO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFoRTtBQUFBLEdBQXFFO0FBQUEsWUFBQXFCLElBQUEzQyxHQUFBNEI7QUFBQUEsUUFBQVIsSUFHdkU7QUFBQSxJQUNBLFlBQWM7QUFBQSxRQUFBd0IsSUFDSixrQkFBUywwQkFDakI7QUFBQTtBQUFBLFNBQUF0QixJQUFBO0FBQUE7QUFBQSxNQUNpQjtBQUFBLGNBQW1CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUVwQztBQUFBLEdBQ0M7QUFBQSxZQUFBdUIsS0FBQTdDLEdBQUE0QixHQUFBYztBQUFBQSxRQUFBSSxLQUdILGNBQUFDLEtBQ0E7QUFBQSxJQUNBLGNBQ0UsMkRBU0M7QUFBQSxJQVJFLGFBQ1k7QUFBQTtBQUFBLEtBQUFILElBQ0wsbUJBQVU7QUFBQSxTQUNsQjtBQUFBO0FBQUE7QUFBQSxTQUFBdEIsSUFBQTtBQUFBO0FBQUEsTUFDaUI7QUFBQSxjQUFxQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFFdEQ7QUFBQSxHQUVEO0FBQUEsWUFBQTBCLE1BQUFoRCxHQUFBNEI7QUFBQUEsUUFBQSxJQUdIO0FBQUE7QUFBQSxTQUFBTixJQUFBO0FBQUE7QUFBQSxNQUE2QjtBQUFBLGNBQW9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFqRDtBQUFBLEdBQXNEO0FBQUEsWUFBQTJCLEtBQUFqRCxHQUFBNEI7QUFBQUEsUUFBQVIsSUFHdEQ7QUFBQSxJQUNBLFlBQWM7QUFBQSxRQUFBd0IsSUFDSixrQkFBUyw2QkFDakI7QUFBQTtBQUFBLFNBQUF0QixJQUFBO0FBQUE7QUFBQSxNQUNpQjtBQUFBLGNBQXNCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUV2QztBQUFBLEdBQ0M7QUFBQSxZQUFBNEIsUUFBQXRCO0FBQUFBLFFBQUFOLE1BS0gsa0JBQUFBLElBQUEsS0FBQUQsTUFBQTtBQUFBO0FBQUEsS0FERSxVQUFjO0FBQUEsU0FBQUEsUUFBdUMsb0JBQUFDLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUMvQjtBQUFBLFlBQUE2QixZQUFBQyxRQUFBQztBQUFBQSxRQUFBRCxPQUdOLFFBQUFDLFFBQUE7QUFBQTtBQUFBLGlCQUNWO0FBQUEsU0FBQUMsSUFEVSxVQUFBRixTQUVSO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FBeUI7QUFBQSxZQUFBRyxRQUFBbkM7QUFBQUEsSUFFdkIsUUFDSjtBQUFBO0FBQUEsS0FBQW9DLEtBREk7QUFBQSxLQUFBQyxLQUFBO0FBQUEsS0FBQTdCLElBR0EsZUFBTztBQUFBLEtBQUFOLElBSWY7QUFBQSxLQUFBK0IsUUFBQTtBQUFBO0FBQUEsS0FIYSxZQUNIO0FBQUEsU0FBQUcsT0FERyxVQUFBQyxPQUFBO0FBQUEsS0FFQztBQUFBLFNBQUFuQyxNQUFpQjtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQ3RCO0FBQUEsWUFBQW9DLFVBQUExRCxHQUFBMEIsR0FBQUU7QUFBQUEsUUFBQWdCLElBR2IsWUFDQTtBQUFBO0FBQUEsU0FBQXRCLElBQUE7QUFBQTtBQUFBLE1BQ087QUFBQSxjQUFxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFFNUI7QUFBQSxHQUFFO0FBQUEsWUFBQXFDLGNBQUEzRCxHQUFBNEQsS0FBQUM7QUFBQUEsUUFBQTNCLE1BR0Y7QUFBQSxJQUNBLGNBQWdCO0FBQUE7QUFBQSxLQUFBNEIsUUFDQztBQUFBLEtBQUFDLE1BQWdDO0FBQUEsS0FBQUgsUUFBQTtBQUFBLEtBQUFJLGVBQzVCO0FBQUEsS0FBQUosUUFDbkI7QUFBQSxTQUNBO0FBQUE7QUFBQTtBQUFBLFNBQUF0QyxJQUFBO0FBQUE7QUFBQTtBQUFBLE9BQUF3QyxVQUNrQjtBQUFBLE9BQUFDLFFBQWlDO0FBQUEsT0FBQUgsUUFBQTtBQUFBLE1BQ2pEO0FBQUEsTUFDQTtBQUFBLGNBQTZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUUvQjtBQUFBLEdBQ0M7QUFBQSxZQUFBSyxXQUFBakUsR0FBQTRCLEdBQUFGO0FBQUFBLFFBQUFrQixJQUdILFlBQ0E7QUFBQTtBQUFBLFNBQUF0QixJQUFBO0FBQUE7QUFBQSxNQUNPO0FBQUEsY0FBcUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRTVCO0FBQUEsR0FBRTtBQUFBLFlBQUE0QyxPQUFBQyxHQUFBdkM7QUFBQUEsUUFBQXdDLElBR0YsY0FBQTlDLElBS0E7QUFBQTtBQUFBLEtBSEUsWUFBYztBQUFBLEtBQ04sNEJBQXdCO0FBQUEsU0FBQUEsTUFDM0I7QUFBQTtBQUFBO0FBQUEsR0FDRDtBQUFBLFlBQUErQyxRQUFBRixHQUFBdkM7QUFBQUEsUUFBQXdDLElBR04sY0FBQTlDLElBS0E7QUFBQTtBQUFBLEtBSEUsWUFBYztBQUFBLEtBQ04sOEJBQ0g7QUFBQSxTQUFBQSxNQUQyQjtBQUFBO0FBQUE7QUFBQSxHQUU1QjtBQUFBLFlBQUFnRCxTQUFBSCxHQUFBcEMsSUFBQXdDO0FBQUFBLFFBQUFDLEtBR04sZUFBQUMsS0FBQTtBQUFBLElBRUEsY0FBaUIsK0NBS1g7QUFBQSxRQUFBbkQsSUFBTjtBQUFBO0FBQUEsS0FIRSxhQUFlO0FBQUEsS0FDUCwwQ0FDSDtBQUFBLFNBQUFBLE1BRDhDO0FBQUE7QUFBQTtBQUFBLEdBRS9DO0FBQUEsWUFBQW9ELFFBQUFQLEdBQUFwQyxJQUFBd0M7QUFBQUEsUUFBQUMsS0FHTixlQUFBQyxLQUFBO0FBQUEsSUFFQSxjQUFpQiw4Q0FLWDtBQUFBLFFBQUFuRCxJQUFOO0FBQUE7QUFBQSxLQUhFLGFBQWU7QUFBQSxLQUNQLHdDQUEyQztBQUFBLFNBQUFBLE1BQzlDO0FBQUE7QUFBQTtBQUFBLEdBQ0Q7QUFBQSxZQUFBcUQsSUFBQWpELEdBQUFFO0FBQUFBLFFBQUF3QyxJQUdOLGNBQUE5QyxJQUtBO0FBQUE7QUFBQSxLQUhFLFlBQWM7QUFBQSxLQUNOLDRDQUFvQztBQUFBLFNBQUFBLE1BQ3ZDO0FBQUE7QUFBQTtBQUFBLEdBQ0Q7QUFBQSxZQUFBc0QsS0FBQWxELEdBQUFFO0FBQUFBLFFBQUF3QyxJQUdOLGNBQUE5QyxJQUtBO0FBQUE7QUFBQSxLQUhFLFlBQWM7QUFBQSxLQUNlLG1CQUFNO0FBQUEsU0FBQUEsTUFDOUI7QUFBQTtBQUFBO0FBQUEsR0FDRDtBQUFBLFlBQUF1RCxTQUFBVixHQUFBdkM7QUFBQUEsUUFBQXdDLElBR04sY0FBQTlDLElBUUE7QUFBQTtBQUFBLEtBTkUsWUFBYztBQUFBLFNBQUFJLElBRUo7QUFBQSxLQUNMLHFCQUFTO0FBQUEsU0FBQUosTUFDUDtBQUFBO0FBQUE7QUFBQSxHQUVIO0FBQUEsWUFBQXdELFNBQUE5RSxHQUFBNEI7QUFBQUEsUUFBQXdDLElBR04sY0FBQTlDLElBUUE7QUFBQTtBQUFBLEtBTkUsWUFBYztBQUFBLFNBQUFzQixJQUVOO0FBQUEsS0FBa0IsTUFFUDtBQUFBLFNBQUF0QixNQURQO0FBQUE7QUFBQTtBQUFBLEdBR1I7QUFBQSxZQUFBeUQsTUFBQXJEO0FBQUFBLElBR0gsK0JBQWM7QUFBQTtBQUFBLEtBQUFvQyxRQUNaO0FBQUEsS0FBQWtCLEtBQUE7QUFBQSxLQUFBL0UsS0FBQTtBQUFBLEtBQUFtRSxJQUVIO0FBQUEsS0FBQXhDLElBQ1E7QUFBQSxLQUFBYyxJQUNBO0FBQUEsU0FDUjtBQUFBO0FBQUE7QUFBQSxTQUFBcEIsSUFBQTtBQUFBO0FBQUEsVUFBQXdDLFVBQ0UsVUFBQW1CLEtBQUEsWUFBQUMsS0FBQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsY0FBaUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRW5CO0FBQUEsR0FDQztBQUFBLFlBQUFDLFFBQUF2RCxHQUFBYztBQUFBQSxRQUFBMEMsS0FHSCxjQUFBQyxLQUNBO0FBQUEsSUFDQSxjQUFpQjtBQUFBLElBQ2pCLGFBQWU7QUFBQSxRQUFBM0QsSUFFTCx5Q0FDUjtBQUFBO0FBQUEsU0FBQUosSUFBQTtBQUFBO0FBQUEsTUFDZ0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFFaEM7QUFBQSxHQUNDO0FBQUE7QUFBQSxJQUFBZ0UsU0QvUkw7QUFBQTtBQUFBLFlBQUFDLEtBQUFDLEtBQUE1RDtBQUFBQSxhQUFBNkQsT0FBQXJFLEdBQUFFO0FBQUFBLFNBQUFvRSxNQ29TSSwrQkFBQWhFLElBQ0E7QUFBQSxLQUNBO0FBQUEsY0FBa0IsaUJBQ0c7QUFBQSxNQUFaLEdBQUosZ0JBQUk7QUFBQSxPQUFxQztBQUFBLGNBQzVDLGlCQUFrQixxQ0FBZTtBQUFBLE1BQTFCLEdBQUosZ0JBQUk7QUFBQSxPQUFvQztBQUFBLE1BQzNDO0FBQUE7QUFBQSxLQUVBO0FBQUEsK0JBQWdDO0FBQUEsTUFBWixPQUFKLGdCQUFJO0FBQUEsT0FDZjtBQUFBO0FBQUEsS0FDQSxZQUFnQjtBQUFBLEtBQVM7QUFBQSxJQUFnQjtBQUFBLFFBQUFOLElBNEJsRCxvQkFDQTtBQUFBO0FBQUEsU0FBQUUsTUFBQTtBQUFBO0FBQUEsVUFBQXFFLE1BQWdEO0FBQUEsTUFsQjVCO0FBQUEsV0FBQXJFLElBQUE7QUFBQTtBQUFBLFlBQUFzRSxJQVJWO0FBQUEsUUFDRCxRQUFKLGdCQUFJLHVDQUdFO0FBQUEsZ0JBRkM7QUFBQSxRQUFSO0FBQUEsUUFBaUI7QUFBQTtBQUFBO0FBQUEsWUFBQUM7QUFBQUEsV0FBQUEsTURsVHZCLDRCQUFBQyxNQUFBO0FBQUE7QUFBQSxXQUFBeEUsTUFBQTtBQUFBLE9Dd1Q2RDtBQUFBO0FBQUEsY0FrQkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQ3pEO0FBQUE7QUFBQSxTQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBLFVBQUFxRSxNQUNVO0FBQUEsTUFDQTtBQUFBLFVBQUFyRSxNQWZPO0FBQUE7QUFBQSxXQUFBQSxNQUFBO0FBQUE7QUFBQSxZQUFBc0UsTUFKUCxzQkFDQTtBQUFBLFFBQVI7QUFBQSxRQUFpQjtBQUFBO0FBQUE7QUFBQSxZQUFBQztBQUFBQSxXQUFBQSxRRDNUckIsMEJBQUFDLFFBQUE7QUFBQTtBQUFBLFdBQUF4RSxNQUFBLFVBQUFBLE1DOFVJO0FBQUE7QUFBQSxZQUFBeUUsU0FkQTtBQUFBLFFBQ0E7QUFBQTtBQUFBLFFBQ087QUFBQSxlQUFKLGdCQUFJO0FBQUEsU0FHRTtBQUFBO0FBQUEsaUJBRkM7QUFBQSxTQUFSO0FBQUEsU0FBc0I7QUFBQSxTQUNxQjtBQUFBO0FBQUEsZ0JBVXJCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUUxQjtBQUFBO0FBQUEsU0FBQUosSUFBdUI7QUFBQSxLQUFxQjtBQUFBLEtBQVc7QUFBQSxhQUFTO0FBQUE7QUFBQTtBQUFBLGFBQWhFO0FBQUE7QUFBQSxHQUFpRTtBQUFBLFlBQUFLLFlBQUFSLEtBQUE1RDtBQUFBQSxhQUFBcUUsTUFBQUMsU0FBQUMsU0FBQUMsTUFBQUMsU0FBQUMsU0FBQUMsS0FBQUM7QUFBQUE7QUFBQUEsTUFBQUMsUUFNL0Q7QUFBQSxNQUFBQyxRQUFBO0FBQUEsTUFBQUMsT0FpQndDO0FBQUEsTUFBQUMsT0FBeEI7QUFBQSxNQUFBQyxLQUFlO0FBQUEsTUFBQUQsS0FBQTtBQUFBLE1BQUFFLEtBQUE7QUFBQSxNQUFBSCxLQUFBO0FBQUEsTUFBQUksSUFBQTtBQUFBO0FBQUEsTUFmMUI7QUFBQSxPQVFEO0FBQUEsV0FBQUQsT0FBWTtBQUFBLE9BRVosa0JBR0Usa0RBRTREO0FBQUEsV0FBQUMsTUFKNUQsV0FBQUosT0FBYztBQUFBLE9BQWE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BVjdCO0FBQUEsV0FBQUUsT0FBWTtBQUFBLE9BRVo7QUFBQSxRQUdFLHFEQVM0RDtBQUFBLFdBQUFFLE1BWDVELFdBQUFILE9BQVE7QUFBQSxPQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFXMEM7QUFBQSxhQUFBSSxRQUFBQyxRQUFBVixLQUFBQyxRQUFBdEU7QUFBQUEsU0FBQSxJQUdsRTtBQUFBO0FBQUEsVUFBQVosSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQ0U7QUFBQSxRQUFBcUUsSUFBUTtBQUFBLFFBQUFDLElBQ1I7QUFBQSxPQUNBO0FBQUE7QUFBQTtBQUFBLFNBQTJCLE9BQUosZ0JBQUk7QUFBQSxrQkFDekIsVUFBaUIscUNBQVk7QUFBQSxVQUE3QjtBQUFBLFVBQTZCO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBRy9CO0FBQUE7QUFBQSxnQkFBa0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQVBwQjtBQUFBLElBUUk7QUFBQSxhQUFBc0IsT0FBQUQsUUFBQVYsS0FBQUMsUUFBQXRFO0FBQUFBLEtBR0osYUFBc0Isd0NBTW5CO0FBQUEsU0FBQUgsS0FOc0QsYUFBQXdDLEtBRXZEO0FBQUEsS0FDQTtBQUFBLEtBQ0E7QUFBQSxLQUFnQyx3RUFFL0I7QUFBQTtBQUFBLFFBQUFuRCxJQUVMO0FBQUEsSUFDQSxXQUFvQiwwQkFPakI7QUFBQTtBQUFBLEtBQUFXLEtBUHNDO0FBQUEsS0FBQXdDLEtBRXZDO0FBQUEsS0FBQWpCLElBQ1EsbUJBQVE7QUFBQSxJQUNoQjtBQUFBLElBQ0E7QUFBQSxJQUFnQixvQ0FFZjtBQUFBO0FBQUEsWUFBQTZELE9BQUF2RjtBQUFBQSxhQUFBd0YsSUFBQTlGLEdBQUErQjtBQUFBQSxLQVNELHNCQUlLO0FBQUEsU0FBQTNCLElBRkssY0FDSztBQUFBLEtBQVMsMEJBQVQsbUJBQVM7QUFBQSxJQUNaO0FBQUEsWUFFZDtBQUFBLHVCRHBaRixrQkNvWkU7QUFBQSxHQUFLO0FBQUEsWUFBQTJGLFFBQUF6RjtBQUFBQSxhQUFBd0YsSUFBQTlGLEdBQUErQjtBQUFBQSxLQUlILHNCQUlLO0FBQUEsU0FBQTNCLElBRkssY0FDUztBQUFBLEtBQVMsa0NBQVQsbUJBQVM7QUFBQSxJQUNoQjtBQUFBLFlBRWQ7QUFBQSx1QkQ5WkYsa0JDOFpFO0FBQUEsR0FBSztBQUFBLFlBQUE0RixPQUFBaEc7QUFBQUE7QUFBQUEsS0FBQUY7QUFBQUEsT0FjRyxrQ0FBQXdDLEtBQUFsQyxHQUE0QixtQkFBTTtBQUFBLElBWjFCLFFBQ1I7QUFBQTtBQUFBLEtBQUE4QixLQURRO0FBQUEsS0FBQUMsS0FBQTtBQUFBLEtBQUF2QixNQUdGO0FBQUEsS0FBQU4sSUFDRjtBQUFBLEtBQUFOLE1BS1I7QUFBQSxLQUFBQSxJQUFBO0FBQUEsS0FBQStCLFFBQUE7QUFBQTtBQUFBLEtBSmEsWUFDSDtBQUFBLFNBQUFHLE9BREcsVUFBQUMsT0FBQTtBQUFBLEtBRUM7QUFBQSxTQUFBbkMsTUFBaUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQU10QjtBQUFBO0FBQUEsSUFBQWlHO0FBQUFBLE1EN2FmIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NjE1MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL2Zsb2F0Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICBOaWNvbGFzIE9qZWRhIEJhciwgTGV4aUZpICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBuZWcgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsIGFkZCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgc3ViIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCBtdWwgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsIGRpdiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgcmVtIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbWEgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbWFfZmxvYXRcIiBcImNhbWxfZm1hXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFicyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuXG5sZXQgemVybyA9IDAuXG5sZXQgb25lID0gMS5cbmxldCBtaW51c19vbmUgPSAtMS5cbmxldCBpbmZpbml0eSA9IFN0ZGxpYi5pbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IFN0ZGxpYi5uZWdfaW5maW5pdHlcbmxldCBuYW4gPSBTdGRsaWIubmFuXG5sZXQgaXNfZmluaXRlICh4OiBmbG9hdCkgPSB4IC0uIHggPSAwLlxubGV0IGlzX2luZmluaXRlICh4OiBmbG9hdCkgPSAxLiAvLiB4ID0gMC5cbmxldCBpc19uYW4gKHg6IGZsb2F0KSA9IHggPD4geFxuXG5sZXQgcGkgPSAweDEuOTIxZmI1NDQ0MmQxOHArMVxubGV0IG1heF9mbG9hdCA9IFN0ZGxpYi5tYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBTdGRsaWIubWluX2Zsb2F0XG5sZXQgZXBzaWxvbiA9IFN0ZGxpYi5lcHNpbG9uX2Zsb2F0XG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5sZXQgb2Zfc3RyaW5nX29wdCA9IFN0ZGxpYi5mbG9hdF9vZl9zdHJpbmdfb3B0XG5sZXQgdG9fc3RyaW5nID0gU3RkbGliLnN0cmluZ19vZl9mbG9hdFxudHlwZSBmcGNsYXNzID0gU3RkbGliLmZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHBvdyA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2JydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NicnRfZmxvYXRcIiBcImNhbWxfY2JydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAyIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwMl9mbG9hdFwiIFwiY2FtbF9leHAyXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzIgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cyX2Zsb2F0XCIgXCJjYW1sX2xvZzJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc2hfZmxvYXRcIiBcImNhbWxfYWNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luaF9mbG9hdFwiIFwiY2FtbF9hc2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5oX2Zsb2F0XCIgXCJjYW1sX2F0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGVyZiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2VyZl9mbG9hdFwiIFwiY2FtbF9lcmZcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXJmYyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2VyZmNfZmxvYXRcIiBcImNhbWxfZXJmY1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0cnVuYyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RydW5jX2Zsb2F0XCIgXCJjYW1sX3RydW5jXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHJvdW5kIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcm91bmRfZmxvYXRcIiBcImNhbWxfcm91bmRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IGlzX2ludGVnZXIgeCA9IHggPSB0cnVuYyB4ICYmIGlzX2Zpbml0ZSB4XG5cbmV4dGVybmFsIG5leHRfYWZ0ZXIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICA9IFwiY2FtbF9uZXh0YWZ0ZXJfZmxvYXRcIiBcImNhbWxfbmV4dGFmdGVyXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IHN1Y2MgeCA9IG5leHRfYWZ0ZXIgeCBpbmZpbml0eVxubGV0IHByZWQgeCA9IG5leHRfYWZ0ZXIgeCBuZWdfaW5maW5pdHlcblxuZXh0ZXJuYWwgY29weV9zaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaWduX2JpdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBib29sXG4gID0gXCJjYW1sX3NpZ25iaXRfZmxvYXRcIiBcImNhbWxfc2lnbmJpdFwiIFtAQG5vYWxsb2NdXG5cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG50eXBlIHQgPSBmbG9hdFxuZXh0ZXJuYWwgY29tcGFyZSA6IGZsb2F0IC0+IGZsb2F0IC0+IGludCA9IFwiJWNvbXBhcmVcIlxubGV0IGVxdWFsIHggeSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXRbQGlubGluZV0gbWluICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB5IHRoZW4geSBlbHNlIHhcbiAgZWxzZSBpZiBpc19uYW4geCB0aGVuIHggZWxzZSB5XG5cbmxldFtAaW5saW5lXSBtYXggKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4geSBlbHNlIHhcblxubGV0W0BpbmxpbmVdIG1pbl9tYXggKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgaXNfbmFuIHggfHwgaXNfbmFuIHkgdGhlbiAobmFuLCBuYW4pXG4gIGVsc2UgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuICh4LCB5KSBlbHNlICh5LCB4KVxuXG5sZXRbQGlubGluZV0gbWluX251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSB4XG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgeVxuXG5sZXRbQGlubGluZV0gbWF4X251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geSB0aGVuIHggZWxzZSB5XG4gIGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgeFxuXG5sZXRbQGlubGluZV0gbWluX21heF9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgaXNfbmFuIHggdGhlbiAoeSx5KVxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4gKHgseClcbiAgZWxzZSBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW4gKHgseSkgZWxzZSAoeSx4KVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6IGludCAtPiBpbnQgLT4gaW50IC0+IGZsb2F0IC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfaGFzaFwiIFtAQG5vYWxsb2NdXG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxuXG5tb2R1bGUgQXJyYXkgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSBmbG9hdGFycmF5XG5cbiAgZXh0ZXJuYWwgbGVuZ3RoIDogdCAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IHQgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IHQgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZmxvYXRhcnJheV9jcmVhdGVcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5cbiAgbGV0IHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBmb3IgaSA9IG9mcyB0byBvZnMgKyBsZW4gLSAxIGRvIHVuc2FmZV9zZXQgYSBpIHYgZG9uZVxuXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0OiB0IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9XG4gICAgXCJjYW1sX2Zsb2F0YXJyYXlfYmxpdFwiIFtAQG5vYWxsb2NdXG5cbiAgbGV0IGNoZWNrIGEgb2ZzIGxlbiBtc2cgPVxuICAgIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgKyBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IGxlbmd0aCBhIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIG1zZ1xuXG4gIGxldCBtYWtlIG4gdiA9XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBuIGluXG4gICAgdW5zYWZlX2ZpbGwgcmVzdWx0IDAgbiB2O1xuICAgIHJlc3VsdFxuXG4gIGxldCBpbml0IGwgZiA9XG4gICAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5LmluaXRcIlxuICAgIGVsc2VcbiAgICAgIGxldCByZXMgPSBjcmVhdGUgbCBpblxuICAgICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgICAgIGRvbmU7XG4gICAgICByZXNcblxuICBsZXQgYXBwZW5kIGExIGEyID1cbiAgICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgICBsZXQgbDIgPSBsZW5ndGggYTIgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChsMSArIGwyKSBpblxuICAgIHVuc2FmZV9ibGl0IGExIDAgcmVzdWx0IDAgbDE7XG4gICAgdW5zYWZlX2JsaXQgYTIgMCByZXN1bHQgbDEgbDI7XG4gICAgcmVzdWx0XG5cbiAgKCogbmV4dCAzIGZ1bmN0aW9uczogbW9kaWZpZWQgY29weSBvZiBjb2RlIGZyb20gc3RyaW5nLm1sICopXG4gIGxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID1cbiAgICBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5jb25jYXRcIlxuXG4gIGxldCByZWMgc3VtX2xlbmd0aHMgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgYWNjKSBhY2MpIHRsXG5cbiAgbGV0IGNvbmNhdCBsID1cbiAgICBsZXQgbGVuID0gc3VtX2xlbmd0aHMgMCBsIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgbCBpID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgKGkgPSBsZW4pXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGxldCBobGVuID0gbGVuZ3RoIGhkIGluXG4gICAgICAgIHVuc2FmZV9ibGl0IGhkIDAgcmVzdWx0IGkgaGxlbjtcbiAgICAgICAgbG9vcCB0bCAoaSArIGhsZW4pXG4gICAgaW5cbiAgICBsb29wIGwgMDtcbiAgICByZXN1bHRcblxuICBsZXQgc3ViIGEgb2ZzIGxlbiA9XG4gICAgY2hlY2sgYSBvZnMgbGVuIFwiRmxvYXQuQXJyYXkuc3ViXCI7XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBhIG9mcyByZXN1bHQgMCBsZW47XG4gICAgcmVzdWx0XG5cbiAgbGV0IGNvcHkgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbCBpblxuICAgIHVuc2FmZV9ibGl0IGEgMCByZXN1bHQgMCBsO1xuICAgIHJlc3VsdFxuXG4gIGxldCBmaWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBjaGVjayBhIG9mcyBsZW4gXCJGbG9hdC5BcnJheS5maWxsXCI7XG4gICAgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxuICBsZXQgYmxpdCBzcmMgc29mcyBkc3QgZG9mcyBsZW4gPVxuICAgIGNoZWNrIHNyYyBzb2ZzIGxlbiBcIkZsb2F0LmFycmF5LmJsaXRcIjtcbiAgICBjaGVjayBkc3QgZG9mcyBsZW4gXCJGbG9hdC5hcnJheS5ibGl0XCI7XG4gICAgdW5zYWZlX2JsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuXG5cbiAgbGV0IHRvX2xpc3QgYSA9XG4gICAgTGlzdC5pbml0IChsZW5ndGggYSkgKHVuc2FmZV9nZXQgYSlcblxuICBsZXQgb2ZfbGlzdCBsID1cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICAgIGxldCByZWMgZmlsbCBpIGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IHJlc3VsdFxuICAgICAgfCBoIDo6IHQgLT4gdW5zYWZlX3NldCByZXN1bHQgaSBoOyBmaWxsIChpICsgMSkgdFxuICAgIGluXG4gICAgZmlsbCAwIGxcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGl0ZXIgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyMiBmIGEgYiA9XG4gICAgaWYgbGVuZ3RoIGEgPD4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2VcbiAgICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkgZG9uZVxuXG4gIGxldCBtYXAgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICBsZXQgbWFwMiBmIGEgYiA9XG4gICAgbGV0IGxhID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICAgIGlmIGxhIDw+IGxiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkubWFwMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGEgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyaSBmIGEgPVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4gIGxldCBtYXBpIGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gICAgZG9uZTtcbiAgICAhclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICAgIGRvbmU7XG4gICAgIXJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGV4aXN0cyBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb3JfYWxsIHAgYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChpICsgMSlcbiAgICAgIGVsc2UgZmFsc2UgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG1lbSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sLCBidXQgc2xpZ2h0bHkgZGlmZmVyZW50ICopXG4gIGxldCBtZW1faWVlZSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHggPSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBleGNlcHRpb24gQm90dG9tIG9mIGludFxuICBsZXQgc29ydCBjbXAgYSA9XG4gICAgbGV0IG1heHNvbiBsIGkgPVxuICAgICAgbGV0IGkzMSA9IGkraStpKzEgaW5cbiAgICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgICAgaWYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDAgdGhlbiB4IDo9IGkzMSsxO1xuICAgICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICAgIXhcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgICB0aGVuIGkzMSsxXG4gICAgICAgIGVsc2UgaWYgaTMxIDwgbCB0aGVuIGkzMSBlbHNlIHJhaXNlIChCb3R0b20gaSlcbiAgICBpblxuICAgIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICAgIHRyaWNrbGVkb3duIGwgaiBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgICBsZXQgcmVjIGJ1YmJsZWRvd24gbCBpID1cbiAgICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICBidWJibGVkb3duIGwgalxuICAgIGluXG4gICAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gICAgbGV0IHJlYyB0cmlja2xldXAgaSBlID1cbiAgICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgICBpZiBjbXAgKGdldCBhIGZhdGhlcikgZSA8IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgICBmb3IgaSA9IGwgLSAxIGRvd250byAyIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgICB0cmlja2xldXAgKGJ1YmJsZSBpIDApIGU7XG4gICAgZG9uZTtcbiAgICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCwgZXhjZXB0IGZvciB0aGUgY2FsbCB0byBbY3JlYXRlXSAqKVxuICBsZXQgY3V0b2ZmID0gNVxuICBsZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICAgIGxldCBtZXJnZSBzcmMxb2ZzIHNyYzFsZW4gc3JjMiBzcmMyb2ZzIHNyYzJsZW4gZHN0IGRzdG9mcyA9XG4gICAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgICBpZiBjbXAgczEgczIgPD0gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICAgIGlmIGkxIDwgc3JjMXIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IHNyYzIgaTIgZHN0IChkICsgMSkgKHNyYzJyIC0gaTIpXG4gICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICAgIGxldCBpMiA9IGkyICsgMSBpblxuICAgICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICAgIGVuZFxuICAgICAgaW4gbG9vcCBzcmMxb2ZzIChnZXQgYSBzcmMxb2ZzKSBzcmMyb2ZzIChnZXQgc3JjMiBzcmMyb2ZzKSBkc3RvZnM7XG4gICAgaW5cbiAgICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICAgIHdoaWxlICghaiA+PSBkc3RvZnMgJiYgY21wIChnZXQgZHN0ICFqKSBlID4gMCkgZG9cbiAgICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgICBkZWNyIGo7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICAgIGRvbmU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGwxID0gbGVuIC8gMiBpblxuICAgICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgICAgc29ydHRvIHNyY29mcyBhIChzcmNvZnMgKyBsMikgbDE7XG4gICAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsIC8gMiBpblxuICAgICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgICBsZXQgdCA9IGNyZWF0ZSBsMiBpblxuICAgICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICAgIHNvcnR0byAwIGEgbDIgbDE7XG4gICAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICAgIGVuZFxuXG4gIGxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgdG9fc2VxIGEgPVxuICAgIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgICB0aGVuXG4gICAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IHRvX3NlcWkgYSA9XG4gICAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICAgIHRoZW5cbiAgICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9yZXZfbGlzdCBsID1cbiAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCBhID0gY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgW10gLT4gYVxuICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGktMSkgdGxcbiAgICBpblxuICAgIGZpbGwgKGxlbi0xKSBsXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9zZXEgaSA9XG4gICAgbGV0IGwgPSBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBpIGluXG4gICAgb2ZfcmV2X2xpc3QgbFxuXG5cbiAgbGV0IG1hcF90b19hcnJheSBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsID0gMCB0aGVuIFt8IHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gQXJyYXkubWFrZSBsIChmICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgICAgQXJyYXkudW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgbGV0IG1hcF9mcm9tX2FycmF5IGYgYSA9XG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIChBcnJheS51bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbmVuZFxuXG5tb2R1bGUgQXJyYXlMYWJlbHMgPSBBcnJheVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfRmxvYXRfYXJyYXlfYmxpdCIsImNzdF9mbG9hdF9tbCIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX2Zsb2F0YXJyYXlfYmxpdCIsImNhbWxfZmxvYXRhcnJheV9jcmVhdGUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX25leHRhZnRlcl9mbG9hdCIsImNhbWxfc2lnbmJpdF9mbG9hdCIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfU2VxIiwiU3RkbGliX0xpc3QiLCJBc3NlcnRfZmFpbHVyZSIsIlN0ZGxpYiIsImluZmluaXR5IiwibmVnX2luZmluaXR5IiwibmFuIiwiaXNfZmluaXRlIiwieCIsImlzX2luZmluaXRlIiwiaXNfbmFuIiwibWF4X2Zsb2F0IiwibWluX2Zsb2F0IiwiZXBzaWxvbiIsIm9mX3N0cmluZ19vcHQiLCJ0b19zdHJpbmciLCJjc3RfRmxvYXRfQXJyYXlfaW5pdCIsImNzdF9GbG9hdF9BcnJheV9jb25jYXQiLCJjc3RfRmxvYXRfQXJyYXlfc3ViIiwiY3N0X0Zsb2F0X0FycmF5X2ZpbGwiLCJjc3RfRmxvYXRfQXJyYXlfaXRlcjJfYXJyYXlzX20iLCJjc3RfRmxvYXRfQXJyYXlfbWFwMl9hcnJheXNfbXUiLCJpc19pbnRlZ2VyIiwic3VjYyIsInByZWQiLCJlcXVhbCIsInkiLCJtaW4iLCJtYXgiLCJtaW5fbWF4IiwibWluX251bSIsIm1heF9udW0iLCJtaW5fbWF4X251bSIsImhhc2giLCJ1bnNhZmVfZmlsbCIsImEiLCJvZnMiLCJsZW4iLCJ2IiwiaSIsImNoZWNrIiwibXNnIiwibWFrZSIsIm4iLCJyZXN1bHQiLCJpbml0IiwibCIsInJlcyIsImFwcGVuZCIsImEyIiwibDEiLCJsMiIsImNvbmNhdCIsImFjYyIsInBhcmFtIiwidGwiLCJoZCIsImhsZW4iLCJzdWIiLCJjb3B5IiwiZmlsbCIsImJsaXQiLCJzcmMiLCJzb2ZzIiwiZHN0IiwiZG9mcyIsInRvX2xpc3QiLCJvZl9saXN0IiwidCIsImgiLCJpdGVyIiwiaXRlcjIiLCJiIiwibWFwIiwiciIsIm1hcDIiLCJsYSIsImxiIiwiaXRlcmkiLCJtYXBpIiwiZm9sZF9sZWZ0IiwiZm9sZF9yaWdodCIsImV4aXN0cyIsInAiLCJmb3JfYWxsIiwibWVtIiwibWVtX2llZWUiLCJCb3R0b20iLCJzb3J0IiwiY21wIiwibWF4c29uIiwiaTMxIiwiZSIsImoiLCJleG4iLCJ0YWciLCJmYXRoZXIiLCJzdGFibGVfc29ydCIsIm1lcmdlIiwic3JjMW9mcyIsInNyYzFsZW4iLCJzcmMyIiwic3JjMm9mcyIsInNyYzJsZW4iLCJkc3RvZnMiLCJzcmMxciIsInNyYzJyIiwiczIiLCJzMSIsImkxIiwiaTIiLCJkIiwiaXNvcnR0byIsInNyY29mcyIsInNvcnR0byIsInRvX3NlcSIsImF1eCIsInRvX3NlcWkiLCJvZl9zZXEiLCJtYXBfdG9fYXJyYXkiLCJtYXBfZnJvbV9hcnJheSIsIlN0ZGxpYl9GbG9hdCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLFlBQUFDLFVBQUFDLEdDaUNpQyw0QkFBSztBQUFBLFlBQUFDLFlBQUFELEdBQ0YsNkJBQUs7QUFBQSxZQUFBRSxPQUFBRixHQUNqQix1QkFBTTtBQUFBO0FBQUEsSUFBQUcsWURuQzlCO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFB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QUFBd0M7QUFBQUEsUUFBQVcsSUFHSCxjQUFBNEIsSUFDUSwrQkFDUjtBQUFBO0FBQUEsU0FBQW5DLElBQUE7QUFBQTtBQUFBLE1BQ2lCO0FBQUEsY0FBMEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRTNDO0FBQUEsR0FBQztBQUFBO0FBQUEsSUFBQWtGO0FBQUFBLE1EeGdCTCIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjY4NzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9pbnQzMi5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtJbnQzMl06IDMyLWJpdCBpbnRlZ2VycyAqKVxuXG5leHRlcm5hbCBuZWcgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX25lZ1wiXG5leHRlcm5hbCBhZGQgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2FkZFwiXG5leHRlcm5hbCBzdWIgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3N1YlwiXG5leHRlcm5hbCBtdWwgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX211bFwiXG5leHRlcm5hbCBkaXYgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2RpdlwiXG5leHRlcm5hbCByZW0gOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX21vZFwiXG5leHRlcm5hbCBsb2dhbmQgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2FuZFwiXG5leHRlcm5hbCBsb2dvciA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfb3JcIlxuZXh0ZXJuYWwgbG9neG9yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2FzclwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNyXCJcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBpbnQzMiA9IFwiJWludDMyX29mX2ludFwiXG5leHRlcm5hbCB0b19pbnQgOiBpbnQzMiAtPiBpbnQgPSBcIiVpbnQzMl90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9vZl9mbG9hdFwiIFwiY2FtbF9pbnQzMl9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfdG9fZmxvYXRcIiBcImNhbWxfaW50MzJfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDMyIC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IHplcm8gPSAwbFxubGV0IG9uZSA9IDFsXG5sZXQgbWludXNfb25lID0gLTFsXG5sZXQgc3VjYyBuID0gYWRkIG4gMWxcbmxldCBwcmVkIG4gPSBzdWIgbiAxbFxubGV0IGFicyBuID0gaWYgbiA+PSAwbCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwbFxubGV0IG1heF9pbnQgPSAweDdGRkZGRkZGbFxubGV0IGxvZ25vdCBuID0gbG9neG9yIG4gKC0xbClcblxubGV0IHVuc2lnbmVkX3RvX2ludCA9XG4gIG1hdGNoIFN5cy53b3JkX3NpemUgd2l0aFxuICB8IDMyIC0+XG4gICAgICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICAgICAgZnVuIG4gLT5cbiAgICAgICAgaWYgY29tcGFyZSB6ZXJvIG4gPD0gMCAmJiBjb21wYXJlIG4gbWF4X2ludCA8PSAwIHRoZW5cbiAgICAgICAgICBTb21lICh0b19pbnQgbilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIE5vbmVcbiAgfCA2NCAtPlxuICAgICAgKCogU28gdGhhdCBpdCBjb21waWxlcyBpbiAzMi1iaXQgKilcbiAgICAgIGxldCBtYXNrID0gMHhGRkZGIGxzbCAxNiBsb3IgMHhGRkZGIGluXG4gICAgICBmdW4gbiAtPiBTb21lICh0b19pbnQgbiBsYW5kIG1hc2spXG4gIHwgXyAtPlxuICAgICAgYXNzZXJ0IGZhbHNlXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQzMiAtPiBzdHJpbmcgPSBcImNhbWxfaW50MzJfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50MzIgPSBcImNhbWxfaW50MzJfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbnR5cGUgdCA9IGludDMyXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldCB1bnNpZ25lZF9jb21wYXJlIG4gbSA9XG4gIGNvbXBhcmUgKHN1YiBuIG1pbl9pbnQpIChzdWIgbSBtaW5faW50KVxuXG5sZXQgbWluIHggeSA6IHQgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgOiB0ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9ncmVhdGVyZXF1YWwiLCJjYW1sX2ludF9jb21wYXJlIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tdWwiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJTdGRsaWJfU3lzIiwiQXNzZXJ0X2ZhaWx1cmUiLCJ6ZXJvIiwib25lIiwic3VjYyIsIm4iLCJwcmVkIiwiYWJzIiwibG9nbm90IiwibWF0Y2giLCJtaW51c19vbmUiLCJtaW5faW50IiwibWF4X2ludCIsInVuc2lnbmVkX3RvX2ludCIsInRvX3N0cmluZyIsIm9mX3N0cmluZ19vcHQiLCJzIiwiZXhuIiwidGFnIiwiY29tcGFyZSIsImVxdWFsIiwieCIsInkiLCJ1bnNpZ25lZF9jb21wYXJlIiwibSIsIm1pbiIsIm1heCIsInVuc2lnbmVkX2RpdiIsImQiLCJxIiwiciIsInVuc2lnbmVkX3JlbSIsIlN0ZGxpYl9JbnQzMiJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsWUFBQUMsS0FBQUMsR0MrQ3FCO0FBQUEsWUFBQUMsS0FBQUQsR0FDQTtBQUFBLFlBQUFFLElBQUFGLEdBQ04sNENBQXlCO0FBQUEsWUFBQUcsT0FBQUgsR0FHWDtBQUFBO0FBQUEsSUFBQUksUURwRDdCO0FBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQTtBQUFBO0FBQUEsS0FBQUEsWUN5RG9CO0FBQUEsS0FBQUM7QUFBQUEsT0FDZCxTQUFBUjtBQUFBQSxRQUNLLHVDQUF1QjtBQUFBLFNBQ3hCO0FBQUEsUUFFQTtBQUFBLE9BQUk7QUFBQTtBQUFBLElEOURkO0FBQUEsS0NvRU07QUFBQSxRQUFBUSxrQkFGQSxTQUFBUixHQUFTLG1CQUF5QjtBQUFBO0FBQUEsWUFBQVMsVUFBQVQsR0FLdEIsdUNBQWE7QUFBQSxZQUFBVSxjQUFBQztBQUFBQSxJQU03QixZQUFTO0FBQUEsVUFBQUM7QUFBQUEsU0FBQUEsTUQ3RVgsNEJBQUFDLE1BQUE7QUFBQSwyQkM4RW9CO0FBQUEsS0Q5RXBCO0FBQUE7QUFBQSxHQzhFd0I7QUFBQSxPQUFBQyxVRDlFeEI7QUFBQSxZQUFBQyxNQUFBQyxHQUFBQyxHQ2tGNEIsMkNBQ1MsQ0FBSTtBQUFBLFlBQUFDLGlCQUFBbEIsR0FBQW1CO0FBQUFBLFFBQUFGLElBR2Ysb0JBQUFELElBQWhCO0FBQUEsSUFKa0IsNkJBSWE7QUFBQTtBQUFBLFlBQUFJLElBQUFKLEdBQUFDLEdBRXBCLDJDQUFvQjtBQUFBLFlBQUFJLElBQUFMLEdBQUFDLEdBQ3BCLHNDQUFvQjtBQUFBLFlBQUFLLGFBQUF0QixHQUFBdUI7QUFBQUEsSUFNcEM7QUFBQSxLQUNFLCtDQUk0QztBQUFBLFFBQUFDLElBRjVCLHVDQUFBQyxJQUNMO0FBQUEsSUFDWCxrREFBNEM7QUFBQTtBQUFBLFlBQUFDLGFBQUExQixHQUFBdUI7QUFBQUEsSUFHdEMsV0FBTCxTQUFLLDBCQUFxQjtBQUFBO0FBQUE7QUFBQSxJQUFBSTtBQUFBQSxNRHZHbEMiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo2OTcxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvaW50NjQubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50NjRdOiA2NC1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxubGV0IHplcm8gPSAwTFxubGV0IG9uZSA9IDFMXG5sZXQgbWludXNfb25lID0gLTFMXG5sZXQgc3VjYyBuID0gYWRkIG4gMUxcbmxldCBwcmVkIG4gPSBzdWIgbiAxTFxubGV0IGFicyBuID0gaWYgbiA+PSAwTCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwMDAwMDAwMDBMXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZGRkZGRkZGRkxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMUwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmcgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cblxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxudHlwZSB0ID0gaW50NjRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2dyZWF0ZXJlcXVhbCIsImNhbWxfaW50NjRfYWRkIiwiY2FtbF9pbnQ2NF9jb21wYXJlIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkiLCJjYW1sX2ludDY0X211bCIsImNhbWxfaW50NjRfc3ViIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImdsb2JhbF9kYXRhIiwiemVybyIsIm9uZSIsIm1pbnVzX29uZSIsIm1pbl9pbnQiLCJtYXhfaW50IiwiU3RkbGliIiwic3VjYyIsIm4iLCJwcmVkIiwiYWJzIiwibG9nbm90IiwidW5zaWduZWRfdG9faW50IiwidG9fc3RyaW5nIiwib2Zfc3RyaW5nX29wdCIsInMiLCJleG4iLCJ0YWciLCJjb21wYXJlIiwieCIsInkiLCJlcXVhbCIsInVuc2lnbmVkX2NvbXBhcmUiLCJtIiwibWluIiwibWF4IiwidW5zaWduZWRfZGl2IiwiZCIsInEiLCJyIiwidW5zaWduZWRfcmVtIiwiU3RkbGliX0ludDY0Il0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxLQUFBQyxHQzZDYSwyQkFBUTtBQUFBLFlBQUFDLEtBQUFELEdBQ1IsMkJBQVE7QUFBQSxZQUFBRSxJQUFBRjtBQUFBQSxJQUNOLHFDQUFvQix5QkFBSztBQUFBO0FBQUEsWUFBQUcsT0FBQUgsR0FHekIsbUNBQWM7QUFBQSxPQUFBSCxZQUdiO0FBQUEsWUFBQU8sZ0JBQUFKO0FBQUFBLElBRVQ7QUFBQTtBQUFBLGNBQXVCO0FBQUEsS0FDeEI7QUFBQSxJQUVBO0FBQUEsR0FBSTtBQUFBLFlBQUFLLFVBQUFMLEdBR1EseUNBQWE7QUFBQSxZQUFBTSxjQUFBQztBQUFBQSxJQU03QixZQUFTO0FBQUEsVUFBQUM7QUFBQUEsU0FBQUEsTURuRVgsNEJBQUFDLE1BQUE7QUFBQSwyQkNvRW9CO0FBQUEsS0RwRXBCO0FBQUE7QUFBQSxHQ29Fd0I7QUFBQSxZQUFBQyxRQUFBQyxHQUFBQyxHQWFJLCtCQUFrQjtBQUFBLFlBQUFDLE1BQUFGLEdBQUFDLEdBQWxCLDZDQUNTLENBQUk7QUFBQSxZQUFBRSxpQkFBQWQsR0FBQWU7QUFBQUEsUUFBQUgsSUFHZiw0QkFBQUQsSUFBaEI7QUFBQSxJQUprQiwrQkFJYTtBQUFBO0FBQUEsWUFBQUssSUFBQUwsR0FBQUMsR0FFcEIsMkNBQW9CO0FBQUEsWUFBQUssSUFBQU4sR0FBQUMsR0FDcEIsc0NBQW9CO0FBQUEsWUFBQU0sYUFBQWxCLEdBQUFtQjtBQUFBQSxJQU1wQztBQUFBLEtBQ0UsK0NBSTRDO0FBQUE7QUFBQSxLQUFBQztBQUFBQSxPQUZ2QztBQUFBLFNBQVc7QUFBQSxXQUFLO0FBQUE7QUFBQSxLQUFBQyxJQUNoQixrQkFBTTtBQUFBLElBQ1gscUNBdERNLHdCQXNEc0M7QUFBQTtBQUFBLFlBQUFDLGFBQUF0QixHQUFBbUI7QUFBQUEsSUFHdEMsT0FBWCxrQkFBTSxlQUFLLHVCQUFxQjtBQUFBO0FBQUE7QUFBQSxJQUFBSTtBQUFBQSxNQWhEaEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHRERiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjcwNzEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9uYXRpdmVpbnQubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbTmF0aXZlaW50XTogcHJvY2Vzc29yLW5hdGl2ZSBpbnRlZ2VycyAqKVxuXG5leHRlcm5hbCBuZWc6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbmVnXCJcbmV4dGVybmFsIGFkZDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYWRkXCJcbmV4dGVybmFsIHN1YjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfc3ViXCJcbmV4dGVybmFsIG11bDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbXVsXCJcbmV4dGVybmFsIGRpdjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfZGl2XCJcbmV4dGVybmFsIHJlbTogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYW5kXCJcbmV4dGVybmFsIGxvZ29yOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vclwiXG5leHRlcm5hbCBsb2d4b3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0OiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FzclwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsOiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50OiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludFwiXG5leHRlcm5hbCB0b19pbnQ6IG5hdGl2ZWludCAtPiBpbnQgPSBcIiVuYXRpdmVpbnRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gbmF0aXZlaW50XG4gID0gXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IG5hdGl2ZWludCAtPiBmbG9hdFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRcIiBcImNhbWxfbmF0aXZlaW50X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzI6IGludDMyIC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vZl9pbnQzMlwiXG5leHRlcm5hbCB0b19pbnQzMjogbmF0aXZlaW50IC0+IGludDMyID0gXCIlbmF0aXZlaW50X3RvX2ludDMyXCJcblxubGV0IHplcm8gPSAwblxubGV0IG9uZSA9IDFuXG5sZXQgbWludXNfb25lID0gLTFuXG5sZXQgc3VjYyBuID0gYWRkIG4gMW5cbmxldCBwcmVkIG4gPSBzdWIgbiAxblxubGV0IGFicyBuID0gaWYgbiA+PSAwbiB0aGVuIG4gZWxzZSBuZWcgblxubGV0IHNpemUgPSBTeXMud29yZF9zaXplXG5sZXQgbWluX2ludCA9IHNoaWZ0X2xlZnQgMW4gKHNpemUgLSAxKVxubGV0IG1heF9pbnQgPSBzdWIgbWluX2ludCAxblxubGV0IGxvZ25vdCBuID0gbG9neG9yIG4gKC0xbilcblxubGV0IHVuc2lnbmVkX3RvX2ludCA9XG4gIGxldCBtYXhfaW50ID0gb2ZfaW50IFN0ZGxpYi5tYXhfaW50IGluXG4gIGZ1biBuIC0+XG4gICAgaWYgY29tcGFyZSB6ZXJvIG4gPD0gMCAmJiBjb21wYXJlIG4gbWF4X2ludCA8PSAwIHRoZW5cbiAgICAgIFNvbWUgKHRvX2ludCBuKVxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IG5hdGl2ZWludCAtPiBzdHJpbmcgPSBcImNhbWxfbmF0aXZlaW50X2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nOiBzdHJpbmcgLT4gbmF0aXZlaW50ID0gXCJjYW1sX25hdGl2ZWludF9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxudHlwZSB0ID0gbmF0aXZlaW50XG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldCB1bnNpZ25lZF9jb21wYXJlIG4gbSA9XG4gIGNvbXBhcmUgKHN1YiBuIG1pbl9pbnQpIChzdWIgbSBtaW5faW50KVxuXG5sZXQgbWluIHggeSA6IHQgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgOiB0ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9ncmVhdGVyZXF1YWwiLCJjYW1sX2ludF9jb21wYXJlIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tdWwiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJTdGRsaWJfU3lzIiwiemVybyIsIm9uZSIsInN1Y2MiLCJuIiwicHJlZCIsImFicyIsInNpemUiLCJtaW5faW50IiwibWF4X2ludCIsImxvZ25vdCIsInVuc2lnbmVkX3RvX2ludCIsInRvX3N0cmluZyIsIm9mX3N0cmluZ19vcHQiLCJzIiwiZXhuIiwidGFnIiwiY29tcGFyZSIsImVxdWFsIiwieCIsInkiLCJ1bnNpZ25lZF9jb21wYXJlIiwibSIsIm1pbiIsIm1heCIsInVuc2lnbmVkX2RpdiIsImQiLCJxIiwiciIsInVuc2lnbmVkX3JlbSIsIlN0ZGxpYl9OYXRpdmVpbnQiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxZQUFBQyxLQUFBQyxHQzJDcUI7QUFBQSxZQUFBQyxLQUFBRCxHQUNBO0FBQUEsWUFBQUUsSUFBQUYsR0FDTiw0Q0FBeUI7QUFBQTtBQUFBLElBQUFHLE9EN0N4QztBQUFBLElBQUFDLFVDK0NjO0FBQUEsSUFBQUMsVUFDQTtBQUFBLFlBQUFDLE9BQUFOLEdBQ2U7QUFBQSxPQUFBSyxZQUdiO0FBQUEsWUFBQUUsZ0JBQUFQO0FBQUFBLElBRVQsdUNBQXVCO0FBQUEsS0FDeEI7QUFBQSxJQUVBO0FBQUEsR0FBSTtBQUFBLFlBQUFRLFVBQUFSLEdBR1EsdUNBQWE7QUFBQSxZQUFBUyxjQUFBQztBQUFBQSxJQU03QixZQUFTO0FBQUEsVUFBQUM7QUFBQUEsU0FBQUEsTURsRVgsNEJBQUFDLE1BQUE7QUFBQSwyQkNtRW9CO0FBQUEsS0RuRXBCO0FBQUE7QUFBQSxHQ21Fd0I7QUFBQSxPQUFBQyxVQWR0QjtBQUFBLFlBQUFDLE1BQUFDLEdBQUFDLEdBa0IwQiwyQ0FDUyxDQUFJO0FBQUEsWUFBQUMsaUJBQUFqQixHQUFBa0I7QUFBQUEsUUFBQUYsSUFHZixpQkFBQUQsSUFBaEI7QUFBQSxJQUprQiw2QkFJYTtBQUFBO0FBQUEsWUFBQUksSUFBQUosR0FBQUMsR0FFcEIsMkNBQW9CO0FBQUEsWUFBQUksSUFBQUwsR0FBQUMsR0FDcEIsc0NBQW9CO0FBQUEsWUFBQUssYUFBQXJCLEdBQUFzQjtBQUFBQSxJQU1wQztBQUFBLEtBQ0UsK0NBSTRDO0FBQUEsUUFBQUMsSUFGNUIsdUNBQUFDLElBQ0w7QUFBQSxJQUNYLGtEQUE0QztBQUFBO0FBQUEsWUFBQUMsYUFBQXpCLEdBQUFzQjtBQUFBQSxJQUd0QyxXQUFMLFNBQUssMEJBQXFCO0FBQUE7QUFBQTtBQUFBLElBQUFJO0FBQUFBLE1BdkNoQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURyREYiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo3MTU3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvbGV4aW5nLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4ICopXG5cbnR5cGUgcG9zaXRpb24gPSB7XG4gIHBvc19mbmFtZSA6IHN0cmluZztcbiAgcG9zX2xudW0gOiBpbnQ7XG4gIHBvc19ib2wgOiBpbnQ7XG4gIHBvc19jbnVtIDogaW50O1xufVxuXG5sZXQgZHVtbXlfcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDA7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IC0xO1xufVxuXG50eXBlIGxleGJ1ZiA9XG4gIHsgcmVmaWxsX2J1ZmYgOiBsZXhidWYgLT4gdW5pdDtcbiAgICBtdXRhYmxlIGxleF9idWZmZXIgOiBieXRlcztcbiAgICBtdXRhYmxlIGxleF9idWZmZXJfbGVuIDogaW50O1xuICAgIG11dGFibGUgbGV4X2Fic19wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2N1cnJfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfYWN0aW9uIDogaW50O1xuICAgIG11dGFibGUgbGV4X2VvZl9yZWFjaGVkIDogYm9vbDtcbiAgICBtdXRhYmxlIGxleF9tZW0gOiBpbnQgYXJyYXk7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcCA6IHBvc2l0aW9uO1xuICAgIG11dGFibGUgbGV4X2N1cnJfcCA6IHBvc2l0aW9uO1xuICB9XG5cbnR5cGUgbGV4X3RhYmxlcyA9XG4gIHsgbGV4X2Jhc2U6IHN0cmluZztcbiAgICBsZXhfYmFja3Ryazogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0OiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrOiBzdHJpbmc7XG4gICAgbGV4X2Jhc2VfY29kZSA6IHN0cmluZztcbiAgICBsZXhfYmFja3Rya19jb2RlIDogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0X2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NvZGU6IHN0cmluZzt9XG5cbmV4dGVybmFsIGNfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludCA9IFwiY2FtbF9sZXhfZW5naW5lXCJcbmV4dGVybmFsIGNfbmV3X2VuZ2luZSA6IGxleF90YWJsZXMgLT4gaW50IC0+IGxleGJ1ZiAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9uZXdfbGV4X2VuZ2luZVwiXG5cbmxldCBlbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cblxubGV0IG5ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX25ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiBpblxuICBpZiByZXN1bHQgPj0gMCAmJiBidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3MgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5sZXQgbGV4X3JlZmlsbCByZWFkX2Z1biBhdXhfYnVmZmVyIGxleGJ1ZiA9XG4gIGxldCByZWFkID1cbiAgICByZWFkX2Z1biBhdXhfYnVmZmVyIChCeXRlcy5sZW5ndGggYXV4X2J1ZmZlcikgaW5cbiAgbGV0IG4gPVxuICAgIGlmIHJlYWQgPiAwXG4gICAgdGhlbiByZWFkXG4gICAgZWxzZSAobGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlOyAwKSBpblxuICAoKiBDdXJyZW50IHN0YXRlIG9mIHRoZSBidWZmZXI6XG4gICAgICAgIDwtLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLT5cbiAgICAgICAgfCAganVuayB8ICAgICAgdmFsaWQgZGF0YSAgICAgfCAgIGp1bmsgICAgfFxuICAgICAgICBeICAgICAgIF4gICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICBeXG4gICAgICAgIDAgICAgc3RhcnRfcG9zICAgICAgICAgICAgIGJ1ZmZlcl9lbmQgICAgQnl0ZXMubGVuZ3RoIGJ1ZmZlclxuICAqKVxuICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gKyBuID4gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyIHRoZW4gYmVnaW5cbiAgICAoKiBUaGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgblxuICAgICAgIDw9IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlclxuICAgIHRoZW4gYmVnaW5cbiAgICAgICgqIEJ1dCB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgaWYgd2UgcmVjbGFpbSB0aGUganVuayBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICBvZiB0aGUgYnVmZmVyICopXG4gICAgICBCeXRlcy5ibGl0IGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zXG4gICAgICAgICAgICAgICAgICBsZXhidWYubGV4X2J1ZmZlciAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpXG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICgqIFdlIG11c3QgZ3JvdyB0aGUgYnVmZmVyLiAgRG91YmxpbmcgaXRzIHNpemUgd2lsbCBwcm92aWRlIGVub3VnaFxuICAgICAgICAgc3BhY2Ugc2luY2UgbiA8PSBTdHJpbmcubGVuZ3RoIGF1eF9idWZmZXIgPD0gU3RyaW5nLmxlbmd0aCBidWZmZXIuXG4gICAgICAgICBXYXRjaCBvdXQgZm9yIHN0cmluZyBsZW5ndGggb3ZlcmZsb3csIHRob3VnaC4gKilcbiAgICAgIGxldCBuZXdsZW4gPVxuICAgICAgICBJbnQubWluICgyICogQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgbiA+IG5ld2xlblxuICAgICAgdGhlbiBmYWlsd2l0aCBcIkxleGluZy5sZXhfcmVmaWxsOiBjYW5ub3QgZ3JvdyBidWZmZXJcIjtcbiAgICAgIGxldCBuZXdidWYgPSBCeXRlcy5jcmVhdGUgbmV3bGVuIGluXG4gICAgICAoKiBDb3B5IHRoZSB2YWxpZCBkYXRhIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIG5ld2J1ZiAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpO1xuICAgICAgbGV4YnVmLmxleF9idWZmZXIgPC0gbmV3YnVmXG4gICAgZW5kO1xuICAgICgqIFJlYWxsb2NhdGlvbiBvciBub3QsIHdlIGhhdmUgc2hpZnRlZCB0aGUgZGF0YSBsZWZ0IGJ5XG4gICAgICAgc3RhcnRfcG9zIGNoYXJhY3RlcnM7IHVwZGF0ZSB0aGUgcG9zaXRpb25zICopXG4gICAgbGV0IHMgPSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICAgIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBsZXhidWYubGV4X2Fic19wb3MgKyBzO1xuICAgIGxleGJ1Zi5sZXhfY3Vycl9wb3MgPC0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9zdGFydF9wb3MgPC0gMDtcbiAgICBsZXhidWYubGV4X2xhc3RfcG9zIDwtIGxleGJ1Zi5sZXhfbGFzdF9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBzIDtcbiAgICBsZXQgdCA9IGxleGJ1Zi5sZXhfbWVtIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LTEgZG9cbiAgICAgIGxldCB2ID0gdC4oaSkgaW5cbiAgICAgIGlmIHYgPj0gMCB0aGVuXG4gICAgICAgIHQuKGkpIDwtIHYtc1xuICAgIGRvbmVcbiAgZW5kO1xuICAoKiBUaGVyZSBpcyBub3cgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICBCeXRlcy5ibGl0IGF1eF9idWZmZXIgMCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X2J1ZmZlcl9sZW4gbjtcbiAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG5cblxubGV0IHplcm9fcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDE7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IDA7XG59XG5cbmxldCBmcm9tX2Z1bmN0aW9uID8od2l0aF9wb3NpdGlvbnMgPSB0cnVlKSBmID1cbiAgeyByZWZpbGxfYnVmZiA9IGxleF9yZWZpbGwgZiAoQnl0ZXMuY3JlYXRlIDUxMik7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAxMDI0O1xuICAgIGxleF9idWZmZXJfbGVuID0gMDtcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gZmFsc2U7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBmcm9tX2NoYW5uZWwgP3dpdGhfcG9zaXRpb25zIGljID1cbiAgZnJvbV9mdW5jdGlvbiA/d2l0aF9wb3NpdGlvbnMgKGZ1biBidWYgbiAtPiBpbnB1dCBpYyBidWYgMCBuKVxuXG5sZXQgZnJvbV9zdHJpbmcgPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIHMgPVxuICB7IHJlZmlsbF9idWZmID0gKGZ1biBsZXhidWYgLT4gbGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMub2Zfc3RyaW5nIHM7ICgqIGhhdmUgdG8gbWFrZSBhIGNvcHkgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdW5zYWZlLXN0cmluZyBtb2RlICopXG4gICAgbGV4X2J1ZmZlcl9sZW4gPSBTdHJpbmcubGVuZ3RoIHM7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IHRydWU7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBzZXRfcG9zaXRpb24gbGV4YnVmIHBvc2l0aW9uID1cbiAgbGV4YnVmLmxleF9jdXJyX3AgIDwtIHtwb3NpdGlvbiB3aXRoIHBvc19mbmFtZSA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19mbmFtZX07XG4gIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBwb3NpdGlvbi5wb3NfY251bVxuXG5sZXQgc2V0X2ZpbGVuYW1lIGxleGJ1ZiBmbmFtZSA9XG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHtsZXhidWYubGV4X2N1cnJfcCB3aXRoIHBvc19mbmFtZSA9IGZuYW1lfVxuXG5sZXQgd2l0aF9wb3NpdGlvbnMgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zXG5cbmxldCBsZXhlbWUgbGV4YnVmID1cbiAgbGV0IGxlbiA9IGxleGJ1Zi5sZXhfY3Vycl9wb3MgLSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGxlblxuXG5sZXQgc3ViX2xleGVtZSBsZXhidWYgaTEgaTIgPVxuICBsZXQgbGVuID0gaTItaTEgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW5cblxubGV0IHN1Yl9sZXhlbWVfb3B0IGxleGJ1ZiBpMSBpMiA9XG4gIGlmIGkxID49IDAgdGhlbiBiZWdpblxuICAgIGxldCBsZW4gPSBpMi1pMSBpblxuICAgIFNvbWUgKEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgaTEgbGVuKVxuICBlbmQgZWxzZSBiZWdpblxuICAgIE5vbmVcbiAgZW5kXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPSBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaVxuXG5sZXQgc3ViX2xleGVtZV9jaGFyX29wdCBsZXhidWYgaSA9XG4gIGlmIGkgPj0gMCB0aGVuXG4gICAgU29tZSAoQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIGkpXG4gIGVsc2VcbiAgICBOb25lXG5cblxubGV0IGxleGVtZV9jaGFyIGxleGJ1ZiBpID1cbiAgQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIChsZXhidWYubGV4X3N0YXJ0X3BvcyArIGkpXG5cbmxldCBsZXhlbWVfc3RhcnQgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wLnBvc19jbnVtXG5sZXQgbGV4ZW1lX2VuZCBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcC5wb3NfY251bVxuXG5sZXQgbGV4ZW1lX3N0YXJ0X3AgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wXG5sZXQgbGV4ZW1lX2VuZF9wIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wXG5cbmxldCBuZXdfbGluZSBsZXhidWYgPVxuICBsZXQgbGNwID0gbGV4YnVmLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGV4YnVmLmxleF9jdXJyX3AgPC1cbiAgICAgIHsgbGNwIHdpdGhcbiAgICAgICAgcG9zX2xudW0gPSBsY3AucG9zX2xudW0gKyAxO1xuICAgICAgICBwb3NfYm9sID0gbGNwLnBvc19jbnVtO1xuICAgICAgfVxuXG5cblxuKCogRGlzY2FyZCBkYXRhIGxlZnQgaW4gbGV4ZXIgYnVmZmVyLiAqKVxuXG5sZXQgZmx1c2hfaW5wdXQgbGIgPVxuICBsYi5sZXhfY3Vycl9wb3MgPC0gMDtcbiAgbGIubGV4X2Fic19wb3MgPC0gMDtcbiAgbGV0IGxjcCA9IGxiLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGIubGV4X2N1cnJfcCA8LSB7emVyb19wb3Mgd2l0aCBwb3NfZm5hbWUgPSBsY3AucG9zX2ZuYW1lfTtcbiAgbGIubGV4X2J1ZmZlcl9sZW4gPC0gMDtcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY2FtbF9ieXRlc19nZXQiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX21sX2J5dGVzX2xlbmd0aCIsImNhbWxfY2FsbDIiLCJmIiwiYTAiLCJhMSIsImdsb2JhbF9kYXRhIiwiZHVtbXlfcG9zIiwiemVyb19wb3MiLCJTdGRsaWJfQnl0ZXMiLCJTdGRsaWIiLCJTdGRsaWJfU3lzIiwiU3RkbGliX0ludCIsImNzdF9MZXhpbmdfbGV4X3JlZmlsbF9jYW5ub3RfZyIsImVuZ2luZSIsInRibCIsInN0YXRlIiwiYnVmIiwicmVzdWx0IiwibmV3X2VuZ2luZSIsImZyb21fZnVuY3Rpb24iLCJvcHQiLCJyZWFkX2Z1biIsInN0aCIsIndpdGhfcG9zaXRpb25zIiwiYXV4X2J1ZmZlciIsImxleGJ1ZiIsInJlYWQiLCJuIiwibmV3bGVuIiwibmV3YnVmIiwicyIsInQiLCJpIiwidiIsImZyb21fY2hhbm5lbCIsImljIiwiZnJvbV9zdHJpbmciLCJzZXRfcG9zaXRpb24iLCJwb3NpdGlvbiIsInNldF9maWxlbmFtZSIsImZuYW1lIiwibGV4ZW1lIiwibGVuIiwic3ViX2xleGVtZSIsImkxIiwiaTIiLCJzdWJfbGV4ZW1lX29wdCIsInN1Yl9sZXhlbWVfY2hhciIsInN1Yl9sZXhlbWVfY2hhcl9vcHQiLCJsZXhlbWVfY2hhciIsImxleGVtZV9zdGFydCIsImxleGVtZV9lbmQiLCJsZXhlbWVfc3RhcnRfcCIsImxleGVtZV9lbmRfcCIsIm5ld19saW5lIiwibGNwIiwiZmx1c2hfaW5wdXQiLCJsYiIsIlN0ZGxpYl9MZXhpbmciXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUMsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsWUFBQUMsT0FBQUMsS0FBQUMsT0FBQUM7QUFBQUE7QUFBQUEsS0FBQUMsU0NnRWU7QUFBQSxTQUNiO0FBQUE7QUFBQTtBQUFBLEtBQW1EO0FBQUEsYUFFakQ7QUFBQTtBQUFBO0FBQUEsSUFHRjtBQUFBLEdBQU07QUFBQSxZQUFBQyxXQUFBSixLQUFBQyxPQUFBQztBQUFBQTtBQUFBQSxLQUFBQyxTQUlPO0FBQUEsU0FDYjtBQUFBO0FBQUE7QUFBQSxLQUFtRDtBQUFBLGFBRWpEO0FBQUE7QUFBQTtBQUFBLElBR0Y7QUFB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QSxRQUFBRixNQUNBO0FBQUEsSUFDQTtBQUFBLEtBQ0U7QUFBQSxJQUNGO0FBQUE7QUFBQSxHQUF1QjtBQUFBO0FBQUEsSUFBQUc7QUFBQUEsTURsUHpCIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NzM5NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL3BhcnNpbmcubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBwYXJzaW5nIGVuZ2luZSAqKVxuXG5vcGVuIExleGluZ1xuXG4oKiBJbnRlcm5hbCBpbnRlcmZhY2UgdG8gdGhlIHBhcnNpbmcgZW5naW5lICopXG5cbnR5cGUgcGFyc2VyX2VudiA9XG4gIHsgbXV0YWJsZSBzX3N0YWNrIDogaW50IGFycmF5OyAgICAgICAgKCogU3RhdGVzICopXG4gICAgbXV0YWJsZSB2X3N0YWNrIDogT2JqLnQgYXJyYXk7ICAgICAgKCogU2VtYW50aWMgYXR0cmlidXRlcyAqKVxuICAgIG11dGFibGUgc3ltYl9zdGFydF9zdGFjayA6IHBvc2l0aW9uIGFycmF5OyAoKiBTdGFydCBwb3NpdGlvbnMgKilcbiAgICBtdXRhYmxlIHN5bWJfZW5kX3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICAgKCogRW5kIHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3RhY2tzaXplIDogaW50OyAgICAgICAgICAgICgqIFNpemUgb2YgdGhlIHN0YWNrcyAqKVxuICAgIG11dGFibGUgc3RhY2tiYXNlIDogaW50OyAgICAgICAgICAgICgqIEJhc2Ugc3AgZm9yIGN1cnJlbnQgcGFyc2UgKilcbiAgICBtdXRhYmxlIGN1cnJfY2hhciA6IGludDsgICAgICAgICAgICAoKiBMYXN0IHRva2VuIHJlYWQgKilcbiAgICBtdXRhYmxlIGx2YWwgOiBPYmoudDsgICAgICAgICAgICAgICAoKiBJdHMgc2VtYW50aWMgYXR0cmlidXRlICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0IDogcG9zaXRpb247ICAgICAgKCogU3RhcnQgcG9zLiBvZiB0aGUgY3VycmVudCBzeW1ib2wqKVxuICAgIG11dGFibGUgc3ltYl9lbmQgOiBwb3NpdGlvbjsgICAgICAgICgqIEVuZCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCAqKVxuICAgIG11dGFibGUgYXNwIDogaW50OyAgICAgICAgICAgICAgICAgICgqIFRoZSBzdGFjayBwb2ludGVyIGZvciBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBydWxlX2xlbiA6IGludDsgICAgICAgICAgICAgKCogTnVtYmVyIG9mIHJocyBpdGVtcyBpbiB0aGUgcnVsZSAqKVxuICAgIG11dGFibGUgcnVsZV9udW1iZXIgOiBpbnQ7ICAgICAgICAgICgqIFJ1bGUgbnVtYmVyIHRvIHJlZHVjZSBieSAqKVxuICAgIG11dGFibGUgc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgICgqIFNhdmVkIHNwIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIHN0YXRlIDogaW50OyAgICAgICAgICAgICAgICAoKiBTYXZlZCBzdGF0ZSBmb3IgcGFyc2VfZW5naW5lICopXG4gICAgbXV0YWJsZSBlcnJmbGFnIDogaW50IH0gICAgICAgICAgICAgKCogU2F2ZWQgZXJyb3IgZmxhZyBmb3IgcGFyc2VfZW5naW5lICopXG5bQEB3YXJuaW5nIFwiLXVudXNlZC1maWVsZFwiXVxuXG50eXBlIHBhcnNlX3RhYmxlcyA9XG4gIHsgYWN0aW9ucyA6IChwYXJzZXJfZW52IC0+IE9iai50KSBhcnJheTtcbiAgICB0cmFuc2xfY29uc3QgOiBpbnQgYXJyYXk7XG4gICAgdHJhbnNsX2Jsb2NrIDogaW50IGFycmF5O1xuICAgIGxocyA6IHN0cmluZztcbiAgICBsZW4gOiBzdHJpbmc7XG4gICAgZGVmcmVkIDogc3RyaW5nO1xuICAgIGRnb3RvIDogc3RyaW5nO1xuICAgIHNpbmRleCA6IHN0cmluZztcbiAgICByaW5kZXggOiBzdHJpbmc7XG4gICAgZ2luZGV4IDogc3RyaW5nO1xuICAgIHRhYmxlc2l6ZSA6IGludDtcbiAgICB0YWJsZSA6IHN0cmluZztcbiAgICBjaGVjayA6IHN0cmluZztcbiAgICBlcnJvcl9mdW5jdGlvbiA6IHN0cmluZyAtPiB1bml0O1xuICAgIG5hbWVzX2NvbnN0IDogc3RyaW5nO1xuICAgIG5hbWVzX2Jsb2NrIDogc3RyaW5nIH1cblxuZXhjZXB0aW9uIFlZZXhpdCBvZiBPYmoudFxuZXhjZXB0aW9uIFBhcnNlX2Vycm9yXG5cbnR5cGUgcGFyc2VyX2lucHV0ID1cbiAgICBTdGFydFxuICB8IFRva2VuX3JlYWRcbiAgfCBTdGFja3NfZ3Jvd25fMVxuICB8IFN0YWNrc19ncm93bl8yXG4gIHwgU2VtYW50aWNfYWN0aW9uX2NvbXB1dGVkXG4gIHwgRXJyb3JfZGV0ZWN0ZWRcblxudHlwZSBwYXJzZXJfb3V0cHV0ID1cbiAgICBSZWFkX3Rva2VuXG4gIHwgUmFpc2VfcGFyc2VfZXJyb3JcbiAgfCBHcm93X3N0YWNrc18xXG4gIHwgR3Jvd19zdGFja3NfMlxuICB8IENvbXB1dGVfc2VtYW50aWNfYWN0aW9uXG4gIHwgQ2FsbF9lcnJvcl9mdW5jdGlvblxuXG4oKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxubGV0IF8gPSBbUmVhZF90b2tlbjsgUmFpc2VfcGFyc2VfZXJyb3I7IEdyb3dfc3RhY2tzXzE7IEdyb3dfc3RhY2tzXzI7XG4gICAgICAgICBDb21wdXRlX3NlbWFudGljX2FjdGlvbjsgQ2FsbF9lcnJvcl9mdW5jdGlvbl1cblxuZXh0ZXJuYWwgcGFyc2VfZW5naW5lIDpcbiAgICBwYXJzZV90YWJsZXMgLT4gcGFyc2VyX2VudiAtPiBwYXJzZXJfaW5wdXQgLT4gT2JqLnQgLT4gcGFyc2VyX291dHB1dFxuICAgID0gXCJjYW1sX3BhcnNlX2VuZ2luZVwiXG5cbmV4dGVybmFsIHNldF90cmFjZTogYm9vbCAtPiBib29sXG4gICAgPSBcImNhbWxfc2V0X3BhcnNlcl90cmFjZVwiXG5cbmxldCBlbnYgPVxuICB7IHNfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCAwO1xuICAgIHZfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCAoT2JqLnJlcHIgKCkpO1xuICAgIHN5bWJfc3RhcnRfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCBkdW1teV9wb3M7XG4gICAgc3ltYl9lbmRfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCBkdW1teV9wb3M7XG4gICAgc3RhY2tzaXplID0gMTAwO1xuICAgIHN0YWNrYmFzZSA9IDA7XG4gICAgY3Vycl9jaGFyID0gMDtcbiAgICBsdmFsID0gT2JqLnJlcHIgKCk7XG4gICAgc3ltYl9zdGFydCA9IGR1bW15X3BvcztcbiAgICBzeW1iX2VuZCA9IGR1bW15X3BvcztcbiAgICBhc3AgPSAwO1xuICAgIHJ1bGVfbGVuID0gMDtcbiAgICBydWxlX251bWJlciA9IDA7XG4gICAgc3AgPSAwO1xuICAgIHN0YXRlID0gMDtcbiAgICBlcnJmbGFnID0gMCB9XG5cbmxldCBncm93X3N0YWNrcygpID1cbiAgbGV0IG9sZHNpemUgPSBlbnYuc3RhY2tzaXplIGluXG4gIGxldCBuZXdzaXplID0gb2xkc2l6ZSAqIDIgaW5cbiAgbGV0IG5ld19zID0gQXJyYXkubWFrZSBuZXdzaXplIDBcbiAgYW5kIG5ld192ID0gQXJyYXkubWFrZSBuZXdzaXplIChPYmoucmVwciAoKSlcbiAgYW5kIG5ld19zdGFydCA9IEFycmF5Lm1ha2UgbmV3c2l6ZSBkdW1teV9wb3NcbiAgYW5kIG5ld19lbmQgPSBBcnJheS5tYWtlIG5ld3NpemUgZHVtbXlfcG9zIGluXG4gICAgQXJyYXkuYmxpdCBlbnYuc19zdGFjayAwIG5ld19zIDAgb2xkc2l6ZTtcbiAgICBlbnYuc19zdGFjayA8LSBuZXdfcztcbiAgICBBcnJheS5ibGl0IGVudi52X3N0YWNrIDAgbmV3X3YgMCBvbGRzaXplO1xuICAgIGVudi52X3N0YWNrIDwtIG5ld192O1xuICAgIEFycmF5LmJsaXQgZW52LnN5bWJfc3RhcnRfc3RhY2sgMCBuZXdfc3RhcnQgMCBvbGRzaXplO1xuICAgIGVudi5zeW1iX3N0YXJ0X3N0YWNrIDwtIG5ld19zdGFydDtcbiAgICBBcnJheS5ibGl0IGVudi5zeW1iX2VuZF9zdGFjayAwIG5ld19lbmQgMCBvbGRzaXplO1xuICAgIGVudi5zeW1iX2VuZF9zdGFjayA8LSBuZXdfZW5kO1xuICAgIGVudi5zdGFja3NpemUgPC0gbmV3c2l6ZVxuXG5sZXQgY2xlYXJfcGFyc2VyKCkgPVxuICBBcnJheS5maWxsIGVudi52X3N0YWNrIDAgZW52LnN0YWNrc2l6ZSAoT2JqLnJlcHIgKCkpO1xuICBlbnYubHZhbCA8LSBPYmoucmVwciAoKVxuXG5sZXQgY3VycmVudF9sb29rYWhlYWRfZnVuID0gcmVmIChmdW4gKF8gOiBPYmoudCkgLT4gZmFsc2UpXG5cbmxldCB5eXBhcnNlIHRhYmxlcyBzdGFydCBsZXhlciBsZXhidWYgPVxuICBsZXQgcmVjIGxvb3AgY21kIGFyZyA9XG4gICAgbWF0Y2ggcGFyc2VfZW5naW5lIHRhYmxlcyBlbnYgY21kIGFyZyB3aXRoXG4gICAgICBSZWFkX3Rva2VuIC0+XG4gICAgICAgIGxldCB0ID0gT2JqLnJlcHIobGV4ZXIgbGV4YnVmKSBpblxuICAgICAgICBlbnYuc3ltYl9zdGFydCA8LSBsZXhidWYubGV4X3N0YXJ0X3A7XG4gICAgICAgIGVudi5zeW1iX2VuZCA8LSBsZXhidWYubGV4X2N1cnJfcDtcbiAgICAgICAgbG9vcCBUb2tlbl9yZWFkIHRcbiAgICB8IFJhaXNlX3BhcnNlX2Vycm9yIC0+XG4gICAgICAgIHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgfCBDb21wdXRlX3NlbWFudGljX2FjdGlvbiAtPlxuICAgICAgICBsZXQgKGFjdGlvbiwgdmFsdWUpID1cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIChTZW1hbnRpY19hY3Rpb25fY29tcHV0ZWQsIHRhYmxlcy5hY3Rpb25zLihlbnYucnVsZV9udW1iZXIpIGVudilcbiAgICAgICAgICB3aXRoIFBhcnNlX2Vycm9yIC0+XG4gICAgICAgICAgICAoRXJyb3JfZGV0ZWN0ZWQsIE9iai5yZXByICgpKSBpblxuICAgICAgICBsb29wIGFjdGlvbiB2YWx1ZVxuICAgIHwgR3Jvd19zdGFja3NfMSAtPlxuICAgICAgICBncm93X3N0YWNrcygpOyBsb29wIFN0YWNrc19ncm93bl8xIChPYmoucmVwciAoKSlcbiAgICB8IEdyb3dfc3RhY2tzXzIgLT5cbiAgICAgICAgZ3Jvd19zdGFja3MoKTsgbG9vcCBTdGFja3NfZ3Jvd25fMiAoT2JqLnJlcHIgKCkpXG4gICAgfCBDYWxsX2Vycm9yX2Z1bmN0aW9uIC0+XG4gICAgICAgIHRhYmxlcy5lcnJvcl9mdW5jdGlvbiBcInN5bnRheCBlcnJvclwiO1xuICAgICAgICBsb29wIEVycm9yX2RldGVjdGVkIChPYmoucmVwciAoKSkgaW5cbiAgbGV0IGluaXRfYXNwID0gZW52LmFzcFxuICBhbmQgaW5pdF9zcCA9IGVudi5zcFxuICBhbmQgaW5pdF9zdGFja2Jhc2UgPSBlbnYuc3RhY2tiYXNlXG4gIGFuZCBpbml0X3N0YXRlID0gZW52LnN0YXRlXG4gIGFuZCBpbml0X2N1cnJfY2hhciA9IGVudi5jdXJyX2NoYXJcbiAgYW5kIGluaXRfbHZhbCA9IGVudi5sdmFsXG4gIGFuZCBpbml0X2VycmZsYWcgPSBlbnYuZXJyZmxhZyBpblxuICBlbnYuc3RhY2tiYXNlIDwtIGVudi5zcCArIDE7XG4gIGVudi5jdXJyX2NoYXIgPC0gc3RhcnQ7XG4gIGVudi5zeW1iX2VuZCA8LSBsZXhidWYubGV4X2N1cnJfcDtcbiAgdHJ5XG4gICAgbG9vcCBTdGFydCAoT2JqLnJlcHIgKCkpXG4gIHdpdGggZXhuIC0+XG4gICAgbGV0IGN1cnJfY2hhciA9IGVudi5jdXJyX2NoYXIgaW5cbiAgICBlbnYuYXNwIDwtIGluaXRfYXNwO1xuICAgIGVudi5zcCA8LSBpbml0X3NwO1xuICAgIGVudi5zdGFja2Jhc2UgPC0gaW5pdF9zdGFja2Jhc2U7XG4gICAgZW52LnN0YXRlIDwtIGluaXRfc3RhdGU7XG4gICAgZW52LmN1cnJfY2hhciA8LSBpbml0X2N1cnJfY2hhcjtcbiAgICBlbnYubHZhbCA8LSBpbml0X2x2YWw7XG4gICAgZW52LmVycmZsYWcgPC0gaW5pdF9lcnJmbGFnO1xuICAgIG1hdGNoIGV4biB3aXRoXG4gICAgICBZWWV4aXQgdiAtPlxuICAgICAgICBPYmoubWFnaWMgdlxuICAgIHwgXyAtPlxuICAgICAgICBjdXJyZW50X2xvb2thaGVhZF9mdW4gOj1cbiAgICAgICAgICAoZnVuIHRvayAtPlxuICAgICAgICAgICAgaWYgT2JqLmlzX2Jsb2NrIHRva1xuICAgICAgICAgICAgdGhlbiB0YWJsZXMudHJhbnNsX2Jsb2NrLihPYmoudGFnIHRvaykgPSBjdXJyX2NoYXJcbiAgICAgICAgICAgIGVsc2UgdGFibGVzLnRyYW5zbF9jb25zdC4oT2JqLm1hZ2ljIHRvaykgPSBjdXJyX2NoYXIpO1xuICAgICAgICByYWlzZSBleG5cblxubGV0IHBlZWtfdmFsIGVudiBuID1cbiAgT2JqLm1hZ2ljIGVudi52X3N0YWNrLihlbnYuYXNwIC0gbilcblxubGV0IHN5bWJvbF9zdGFydF9wb3MgKCkgPVxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA8PSAwIHRoZW4gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwKVxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCBzdCA9IGVudi5zeW1iX3N0YXJ0X3N0YWNrLihlbnYuYXNwIC0gaSArIDEpIGluXG4gICAgICBsZXQgZW4gPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3AgLSBpICsgMSkgaW5cbiAgICAgIGlmIHN0IDw+IGVuIHRoZW4gc3QgZWxzZSBsb29wIChpIC0gMSlcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBlbnYucnVsZV9sZW5cblxubGV0IHN5bWJvbF9lbmRfcG9zICgpID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwKVxubGV0IHJoc19zdGFydF9wb3MgbiA9IGVudi5zeW1iX3N0YXJ0X3N0YWNrLihlbnYuYXNwIC0gKGVudi5ydWxlX2xlbiAtIG4pKVxubGV0IHJoc19lbmRfcG9zIG4gPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3AgLSAoZW52LnJ1bGVfbGVuIC0gbikpXG5cbmxldCBzeW1ib2xfc3RhcnQgKCkgPSAoc3ltYm9sX3N0YXJ0X3BvcyAoKSkucG9zX2NudW1cbmxldCBzeW1ib2xfZW5kICgpID0gKHN5bWJvbF9lbmRfcG9zICgpKS5wb3NfY251bVxubGV0IHJoc19zdGFydCBuID0gKHJoc19zdGFydF9wb3MgbikucG9zX2NudW1cbmxldCByaHNfZW5kIG4gPSAocmhzX2VuZF9wb3MgbikucG9zX2NudW1cblxubGV0IGlzX2N1cnJlbnRfbG9va2FoZWFkIHRvayA9XG4gICghY3VycmVudF9sb29rYWhlYWRfZnVuKShPYmoucmVwciB0b2spXG5cbmxldCBwYXJzZV9lcnJvciAoXyA6IHN0cmluZykgPSAoKVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9mcmVzaF9vb19pZCIsImNhbWxfbWFrZV92ZWN0IiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9PYmoiLCJTdGRsaWJfQXJyYXkiLCJTdGRsaWJfTGV4aW5nIiwiWVlleGl0IiwiUGFyc2VfZXJyb3IiLCJlbnYiLCJkdW1teSIsImdyb3dfc3RhY2tzIiwicGFyYW0iLCJvbGRzaXplIiwibmV3c2l6ZSIsIm5ld19zIiwibmV3X3YiLCJuZXdfc3RhcnQiLCJuZXdfZW5kIiwiY2xlYXJfcGFyc2VyIiwiY3VycmVudF9sb29rYWhlYWRfZnVuIiwiY3N0X3N5bnRheF9lcnJvciIsInl5cGFyc2UiLCJ0YWJsZXMiLCJzdGFydCIsImxleGVyIiwibGV4YnVmIiwiaW5pdF9hc3AiLCJpbml0X3NwIiwiaW5pdF9zdGFja2Jhc2UiLCJpbml0X3N0YXRlIiwiaW5pdF9jdXJyX2NoYXIiLCJpbml0X2x2YWwiLCJpbml0X2VycmZsYWciLCJjbWQiLCJhcmciLCJleG4iLCJjdXJyX2NoYXIiLCJ0YWciLCJ2IiwidG9rIiwicGVla192YWwiLCJuIiwic3ltYm9sX3N0YXJ0X3BvcyIsImkiLCJzdCIsImVuIiwic3ltYm9sX2VuZF9wb3MiLCJyaHNfc3RhcnRfcG9zIiwicmhzX2VuZF9wb3MiLCJzeW1ib2xfc3RhcnQiLCJzeW1ib2xfZW5kIiwicmhzX3N0YXJ0IiwicmhzX2VuZCIsImlzX2N1cnJlbnRfbG9va2FoZWFkIiwicGFyc2VfZXJyb3IiLCJTdGRsaWJfUGFyc2luZyJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDO0FBQUFBLE1DeUZjO0FBQUE7QUFBQSxPQUNBO0FBQUEsT0FDUztBQUFBLE9BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxRQUhTO0FBQUEsWUFBQUMsWUFBQUM7QUFBQUE7QUFBQUEsS0FBQUMs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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHpGOUIiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo3NTk3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvc2V0Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBTZXRzIG92ZXIgb3JkZXJlZCB0eXBlcyAqKVxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBlbHRcbiAgICB0eXBlIHRcbiAgICB2YWwgZW1wdHk6IHRcbiAgICB2YWwgaXNfZW1wdHk6IHQgLT4gYm9vbFxuICAgIHZhbCBtZW06IGVsdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBlbHQgLT4gdCAtPiB0XG4gICAgdmFsIHNpbmdsZXRvbjogZWx0IC0+IHRcbiAgICB2YWwgcmVtb3ZlOiBlbHQgLT4gdCAtPiB0XG4gICAgdmFsIHVuaW9uOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBpbnRlcjogdCAtPiB0IC0+IHRcbiAgICB2YWwgZGlzam9pbnQ6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGRpZmY6IHQgLT4gdCAtPiB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIHN1YnNldDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGVsdCAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgICB2YWwgbWFwOiAoZWx0IC0+IGVsdCkgLT4gdCAtPiB0XG4gICAgdmFsIGZvbGQ6IChlbHQgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgICB2YWwgZm9yX2FsbDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZXhpc3RzOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBmaWx0ZXI6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiB0XG4gICAgdmFsIGZpbHRlcl9tYXA6IChlbHQgLT4gZWx0IG9wdGlvbikgLT4gdCAtPiB0XG4gICAgdmFsIHBhcnRpdGlvbjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHQgKiB0XG4gICAgdmFsIGNhcmRpbmFsOiB0IC0+IGludFxuICAgIHZhbCBlbGVtZW50czogdCAtPiBlbHQgbGlzdFxuICAgIHZhbCBtaW5fZWx0OiB0IC0+IGVsdFxuICAgIHZhbCBtaW5fZWx0X29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIG1heF9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1heF9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgY2hvb3NlOiB0IC0+IGVsdFxuICAgIHZhbCBjaG9vc2Vfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgc3BsaXQ6IGVsdCAtPiB0IC0+IHQgKiBib29sICogdFxuICAgIHZhbCBmaW5kOiBlbHQgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9vcHQ6IGVsdCAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX2ZpcnN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfbGFzdF9vcHQ6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIG9mX2xpc3Q6IGVsdCBsaXN0IC0+IHRcbiAgICB2YWwgdG9fc2VxX2Zyb20gOiBlbHQgLT4gdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgdG9fc2VxIDogdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgdG9fcmV2X3NlcSA6IHQgLT4gZWx0IFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiBlbHQgU2VxLnQgLT4gdCAtPiB0XG4gICAgdmFsIG9mX3NlcSA6IGVsdCBTZXEudCAtPiB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9XG4gIHN0cnVjdFxuICAgIHR5cGUgZWx0ID0gT3JkLnRcbiAgICB0eXBlIHQgPSBFbXB0eSB8IE5vZGUgb2Yge2w6dDsgdjplbHQ7IHI6dDsgaDppbnR9XG5cbiAgICAoKiBTZXRzIGFyZSByZXByZXNlbnRlZCBieSBiYWxhbmNlZCBiaW5hcnkgdHJlZXMgKHRoZSBoZWlnaHRzIG9mIHRoZVxuICAgICAgIGNoaWxkcmVuIGRpZmZlciBieSBhdCBtb3N0IDIgKilcblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgICgqIENyZWF0ZXMgYSBuZXcgbm9kZSB3aXRoIGxlZnQgc29uIGwsIHZhbHVlIHYgYW5kIHJpZ2h0IHNvbiByLlxuICAgICAgIFdlIG11c3QgaGF2ZSBhbGwgZWxlbWVudHMgb2YgbCA8IHYgPCBhbGwgZWxlbWVudHMgb2Ygci5cbiAgICAgICBsIGFuZCByIG11c3QgYmUgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBoZWlnaHQgZm9yIGJldHRlciBzcGVlZC4gKilcblxuICAgIGxldCBjcmVhdGUgbCB2IHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUsIGJ1dCBwZXJmb3JtcyBvbmUgc3RlcCBvZiByZWJhbGFuY2luZyBpZiBuZWNlc3NhcnkuXG4gICAgICAgQXNzdW1lcyBsIGFuZCByIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAzLlxuICAgICAgIElubGluZSBleHBhbnNpb24gb2YgY3JlYXRlIGZvciBiZXR0ZXIgc3BlZWQgaW4gdGhlIG1vc3QgZnJlcXVlbnQgY2FzZVxuICAgICAgIHdoZXJlIG5vIHJlYmFsYW5jaW5nIGlzIHJlcXVpcmVkLiAqKVxuXG4gICAgbGV0IGJhbCBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgKGNyZWF0ZSBsciB2IHIpXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1scmw7IHY9bHJ2OyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbHJsKSBscnYgKGNyZWF0ZSBscnIgdiByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBybCkgcnYgcnJcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPXJsbDsgdj1ybHY7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsbCkgcmx2IChjcmVhdGUgcmxyIHJ2IHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgICgqIEluc2VydGlvbiBvZiBvbmUgZWxlbWVudCAqKVxuXG4gICAgbGV0IHJlYyBhZGQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vZGV7bD1FbXB0eTsgdj14OyByPUVtcHR5OyBoPTF9XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiB0IGVsc2VcbiAgICAgICAgICBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gdCBlbHNlIGJhbCBsbCB2IHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gdCBlbHNlIGJhbCBsIHYgcnJcblxuICAgIGxldCBzaW5nbGV0b24geCA9IE5vZGV7bD1FbXB0eTsgdj14OyByPUVtcHR5OyBoPTF9XG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIHYgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQgZWxlbWVudHMgaW4gdGhlIHRyZWU7IGl0XG4gICAgICAgZG9lcyBub3QgdGVzdCBmb3IgZXF1YWxpdHkgd2l0aCB0aGUgY3VycmVudCBtaW4gKG9yIG1heCkgZWxlbWVudC5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fZWxlbWVudCB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgYmFsIChhZGRfbWluX2VsZW1lbnQgeCBsKSB2IHJcblxuICAgIGxldCByZWMgYWRkX21heF9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgbCB2IChhZGRfbWF4X2VsZW1lbnQgeCByKVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZVxuICAgICAgIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCByZWMgam9pbiBsIHYgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fZWxlbWVudCB2IHJcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBhZGRfbWF4X2VsZW1lbnQgdiBsXG4gICAgICB8IChOb2Rle2w9bGw7IHY9bHY7IHI9bHI7IGg9bGh9LCBOb2Rle2w9cmw7IHY9cnY7IHI9cnI7IGg9cmh9KSAtPlxuICAgICAgICAgIGlmIGxoID4gcmggKyAyIHRoZW4gYmFsIGxsIGx2IChqb2luIGxyIHYgcikgZWxzZVxuICAgICAgICAgIGlmIHJoID4gbGggKyAyIHRoZW4gYmFsIChqb2luIGwgdiBybCkgcnYgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgclxuXG4gICAgKCogU21hbGxlc3QgYW5kIGdyZWF0ZXN0IGVsZW1lbnQgb2YgYSBzZXQgKilcblxuICAgIGxldCByZWMgbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHZ9IC0+IHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0IGxcblxuICAgIGxldCByZWMgbWluX2VsdF9vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gU29tZSB2XG4gICAgICB8IE5vZGV7bH0gLT4gbWluX2VsdF9vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7djsgcj1FbXB0eX0gLT4gdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHQgclxuXG4gICAgbGV0IHJlYyBtYXhfZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtyfSAtPiBtYXhfZWx0X29wdCByXG5cbiAgICAoKiBSZW1vdmUgdGhlIHNtYWxsZXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNldCAqKVxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyByfSAtPiByXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2VsdCBsKSB2IHJcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBBc3N1bWUgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi4gKilcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGJhbCB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCBjb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiBqb2luIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBTcGxpdHRpbmcuICBzcGxpdCB4IHMgcmV0dXJucyBhIHRyaXBsZSAobCwgcHJlc2VudCwgcikgd2hlcmVcbiAgICAgICAgLSBsIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgb2YgcyB0aGF0IGFyZSA8IHhcbiAgICAgICAgLSByIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgb2YgcyB0aGF0IGFyZSA+IHhcbiAgICAgICAgLSBwcmVzZW50IGlzIGZhbHNlIGlmIHMgY29udGFpbnMgbm8gZWxlbWVudCBlcXVhbCB0byB4LFxuICAgICAgICAgIG9yIHRydWUgaWYgcyBjb250YWlucyBhbiBlbGVtZW50IGVxdWFsIHRvIHguICopXG5cbiAgICBsZXQgcmVjIHNwbGl0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIChFbXB0eSwgZmFsc2UsIEVtcHR5KVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIChsLCB0cnVlLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IHIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsciwgcHJlcywgcnIpID0gc3BsaXQgeCByIGluIChqb2luIGwgdiBsciwgcHJlcywgcnIpXG5cbiAgICAoKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgc2V0IG9wZXJhdGlvbnMgKilcblxuICAgIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvbiBFbXB0eSAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w7IHY7IHJ9IGFzIHQpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpblxuICAgICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIGJhbCBsbCB2IHJcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpblxuICAgICAgICAgICAgICBpZiByID09IHJyIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIGJhbCBsIHYgcnJcblxuICAgIGxldCByZWMgdW5pb24gczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIHQyKSAtPiB0MlxuICAgICAgfCAodDEsIEVtcHR5KSAtPiB0MVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxOyBoPWgxfSwgTm9kZXtsPWwyOyB2PXYyOyByPXIyOyBoPWgyfSkgLT5cbiAgICAgICAgICBpZiBoMSA+PSBoMiB0aGVuXG4gICAgICAgICAgICBpZiBoMiA9IDEgdGhlbiBhZGQgdjIgczEgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwyLCBfLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjEgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgaDEgPSAxIHRoZW4gYWRkIHYxIHMyIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbGV0IChsMSwgXywgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYyICh1bmlvbiByMSByMilcbiAgICAgICAgICAgIGVuZFxuXG4gICAgbGV0IHJlYyBpbnRlciBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gRW1wdHlcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggc3BsaXQgdjEgdDIgd2l0aFxuICAgICAgICAgICAgKGwyLCBmYWxzZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGNvbmNhdCAoaW50ZXIgbDEgbDIpIChpbnRlciByMSByMilcbiAgICAgICAgICB8IChsMiwgdHJ1ZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGpvaW4gKGludGVyIGwxIGwyKSB2MSAoaW50ZXIgcjEgcjIpXG5cbiAgICAoKiBTYW1lIGFzIHNwbGl0LCBidXQgY29tcHV0ZSB0aGUgbGVmdCBhbmQgcmlnaHQgc3VidHJlZXNcbiAgICAgICBvbmx5IGlmIHRoZSBwaXZvdCBlbGVtZW50IGlzIG5vdCBpbiB0aGUgc2V0LiAgVGhlIHJpZ2h0IHN1YnRyZWVcbiAgICAgICBpcyBjb21wdXRlZCBvbiBkZW1hbmQuICopXG5cbiAgICB0eXBlIHNwbGl0X2JpcyA9XG4gICAgICB8IEZvdW5kXG4gICAgICB8IE5vdEZvdW5kIG9mIHQgKiAodW5pdCAtPiB0KVxuXG4gICAgbGV0IHJlYyBzcGxpdF9iaXMgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm90Rm91bmQgKEVtcHR5LCAoZnVuICgpIC0+IEVtcHR5KSlcbiAgICAgIHwgTm9kZXtsOyB2OyByOyBffSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBGb3VuZFxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbWF0Y2ggc3BsaXRfYmlzIHggbCB3aXRoXG4gICAgICAgICAgICB8IEZvdW5kIC0+IEZvdW5kXG4gICAgICAgICAgICB8IE5vdEZvdW5kIChsbCwgcmwpIC0+IE5vdEZvdW5kIChsbCwgKGZ1biAoKSAtPiBqb2luIChybCAoKSkgdiByKSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXRjaCBzcGxpdF9iaXMgeCByIHdpdGhcbiAgICAgICAgICAgIHwgRm91bmQgLT4gRm91bmRcbiAgICAgICAgICAgIHwgTm90Rm91bmQgKGxyLCBycikgLT4gTm90Rm91bmQgKGpvaW4gbCB2IGxyLCBycilcblxuICAgIGxldCByZWMgZGlzam9pbnQgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIHwgKF8sIEVtcHR5KSAtPiB0cnVlXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBpZiBzMSA9PSBzMiB0aGVuIGZhbHNlXG4gICAgICAgICAgZWxzZSBtYXRjaCBzcGxpdF9iaXMgdjEgdDIgd2l0aFxuICAgICAgICAgICAgICBOb3RGb3VuZChsMiwgcjIpIC0+IGRpc2pvaW50IGwxIGwyICYmIGRpc2pvaW50IHIxIChyMiAoKSlcbiAgICAgICAgICAgIHwgRm91bmQgLT4gZmFsc2VcblxuICAgIGxldCByZWMgZGlmZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gRW1wdHlcbiAgICAgIHwgKHQxLCBFbXB0eSkgLT4gdDFcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIG1hdGNoIHNwbGl0IHYxIHQyIHdpdGhcbiAgICAgICAgICAgIChsMiwgZmFsc2UsIHIyKSAtPlxuICAgICAgICAgICAgICBqb2luIChkaWZmIGwxIGwyKSB2MSAoZGlmZiByMSByMilcbiAgICAgICAgICB8IChsMiwgdHJ1ZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGNvbmNhdCAoZGlmZiBsMSBsMikgKGRpZmYgcjEgcjIpXG5cbiAgICB0eXBlIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBlbHQgKiB0ICogZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIHIsIGUpKVxuXG4gICAgbGV0IHJlYyBjb21wYXJlX2F1eCBlMSBlMiA9XG4gICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICB8IChFbmQsIF8pICAtPiAtMVxuICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICB8IChNb3JlKHYxLCByMSwgZTEpLCBNb3JlKHYyLCByMiwgZTIpKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICBlbHNlIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG5cbiAgICBsZXQgY29tcGFyZSBzMSBzMiA9XG4gICAgICBjb21wYXJlX2F1eCAoY29uc19lbnVtIHMxIEVuZCkgKGNvbnNfZW51bSBzMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgczEgczIgPVxuICAgICAgY29tcGFyZSBzMSBzMiA9IDBcblxuICAgIGxldCByZWMgc3Vic2V0IHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgRW1wdHksIF8gLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IF8sIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bD1sMTsgdj12MTsgcj1yMX0sIChOb2RlIHtsPWwyOyB2PXYyOyByPXIyfSBhcyB0MikgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IGwxIGwyICYmIHN1YnNldCByMSByMlxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IChOb2RlIHtsPWwxOyB2PXYxOyByPUVtcHR5OyBoPTB9KSBsMiAmJiBzdWJzZXQgcjEgdDJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9RW1wdHk7IHY9djE7IHI9cjE7IGg9MH0pIHIyICYmIHN1YnNldCBsMSB0MlxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGl0ZXIgZiBsOyBmIHY7IGl0ZXIgZiByXG5cbiAgICBsZXQgcmVjIGZvbGQgZiBzIGFjY3UgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBmb2xkIGYgciAoZiB2IChmb2xkIGYgbCBhY2N1KSlcblxuICAgIGxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHAgdiAmJiBmb3JfYWxsIHAgbCAmJiBmb3JfYWxsIHAgclxuXG4gICAgbGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2IHx8IGV4aXN0cyBwIGwgfHwgZXhpc3RzIHAgclxuXG4gICAgbGV0IHJlYyBmaWx0ZXIgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w7IHY7IHJ9KSBhcyB0IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXIgcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyIHAgciBpblxuICAgICAgICAgIGlmIHB2IHRoZW5cbiAgICAgICAgICAgIGlmIGw9PWwnICYmIHI9PXInIHRoZW4gdCBlbHNlIGpvaW4gbCcgdiByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdiA9IHAgdiBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdlxuICAgICAgICAgIHRoZW4gKGpvaW4gbHQgdiBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IHJmKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZXtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgZWxlbWVudHNfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gZWxlbWVudHNfYXV4ICh2IDo6IGVsZW1lbnRzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBlbGVtZW50cyBzID1cbiAgICAgIGVsZW1lbnRzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2VsdFxuXG4gICAgbGV0IGNob29zZV9vcHQgPSBtaW5fZWx0X29wdFxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiB2XG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSB2XG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHRyeV9qb2luIGwgdiByID1cbiAgICAgICgqIFtqb2luIGwgdiByXSBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiAoZWxlbWVudHMgb2YgbCA8IHYgPFxuICAgICAgICAgZWxlbWVudHMgb2Ygcik7IHVzZSBbdHJ5X2pvaW4gbCB2IHJdIHdoZW4gdGhpcyBwcm9wZXJ0eSBtYXlcbiAgICAgICAgIG5vdCBob2xkLCBidXQgeW91IGhvcGUgaXQgZG9lcyBob2xkIGluIHRoZSBjb21tb24gY2FzZSAqKVxuICAgICAgaWYgKGwgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSAobWF4X2VsdCBsKSB2IDwgMClcbiAgICAgICYmIChyID0gRW1wdHkgfHwgT3JkLmNvbXBhcmUgdiAobWluX2VsdCByKSA8IDApXG4gICAgICB0aGVuIGpvaW4gbCB2IHJcbiAgICAgIGVsc2UgdW5pb24gbCAoYWRkIHYgcilcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICgqIGVuZm9yY2UgbGVmdC10by1yaWdodCBldmFsdWF0aW9uIG9yZGVyICopXG4gICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgIGlmIGwgPT0gbCcgJiYgdiA9PSB2JyAmJiByID09IHInIHRoZW4gdFxuICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuXG4gICAgbGV0IHRyeV9jb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiB0cnlfam9pbiB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgbGV0IHJlYyBmaWx0ZXJfbWFwIGYgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICgqIGVuZm9yY2UgbGVmdC10by1yaWdodCBldmFsdWF0aW9uIG9yZGVyICopXG4gICAgICAgICBsZXQgbCcgPSBmaWx0ZXJfbWFwIGYgbCBpblxuICAgICAgICAgbGV0IHYnID0gZiB2IGluXG4gICAgICAgICBsZXQgcicgPSBmaWx0ZXJfbWFwIGYgciBpblxuICAgICAgICAgYmVnaW4gbWF0Y2ggdicgd2l0aFxuICAgICAgICAgICB8IFNvbWUgdicgLT5cbiAgICAgICAgICAgICAgaWYgbCA9PSBsJyAmJiB2ID09IHYnICYmIHIgPT0gcicgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgdHJ5X2pvaW4gbCcgdicgcidcbiAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIHRyeV9jb25jYXQgbCcgcidcbiAgICAgICAgIGVuZFxuXG4gICAgbGV0IG9mX3NvcnRlZF9saXN0IGwgPVxuICAgICAgbGV0IHJlYyBzdWIgbiBsID1cbiAgICAgICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgICAgIHwgMCwgbCAtPiBFbXB0eSwgbFxuICAgICAgICB8IDEsIHgwIDo6IGwgLT4gTm9kZSB7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfSwgbFxuICAgICAgICB8IDIsIHgwIDo6IHgxIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7IHI9RW1wdHk7IGg9Mn0sIGxcbiAgICAgICAgfCAzLCB4MCA6OiB4MSA6OiB4MiA6OiBsIC0+XG4gICAgICAgICAgICBOb2Rle2w9Tm9kZXtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9OyB2PXgxO1xuICAgICAgICAgICAgICAgICByPU5vZGV7bD1FbXB0eTsgdj14Mjsgcj1FbXB0eTsgaD0xfTsgaD0yfSwgbFxuICAgICAgICB8IG4sIGwgLT5cbiAgICAgICAgICBsZXQgbmwgPSBuIC8gMiBpblxuICAgICAgICAgIGxldCBsZWZ0LCBsID0gc3ViIG5sIGwgaW5cbiAgICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgbWlkIDo6IGwgLT5cbiAgICAgICAgICAgIGxldCByaWdodCwgbCA9IHN1YiAobiAtIG5sIC0gMSkgbCBpblxuICAgICAgICAgICAgY3JlYXRlIGxlZnQgbWlkIHJpZ2h0LCBsXG4gICAgICBpblxuICAgICAgZnN0IChzdWIgKExpc3QubGVuZ3RoIGwpIGwpXG5cbiAgICBsZXQgb2ZfbGlzdCBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBlbXB0eVxuICAgICAgfCBbeDBdIC0+IHNpbmdsZXRvbiB4MFxuICAgICAgfCBbeDA7IHgxXSAtPiBhZGQgeDEgKHNpbmdsZXRvbiB4MClcbiAgICAgIHwgW3gwOyB4MTsgeDJdIC0+IGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDNdIC0+IGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDM7IHg0XSAtPiBhZGQgeDQgKGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKSlcbiAgICAgIHwgXyAtPiBvZl9zb3J0ZWRfbGlzdCAoTGlzdC5zb3J0X3VuaXEgT3JkLmNvbXBhcmUgbClcblxuICAgIGxldCBhZGRfc2VxIGkgbSA9XG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gcyB4IC0+IGFkZCB4IHMpIG0gaVxuXG4gICAgbGV0IG9mX3NlcSBpID0gYWRkX3NlcSBpIGVtcHR5XG5cbiAgICBsZXQgcmVjIHNlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKHgsIHQsIHJlc3QpIC0+IFNlcS5Db25zICh4LCBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3NlcSBjID0gc2VxX29mX2VudW1fIChjb25zX2VudW0gYyBFbmQpXG5cbiAgICBsZXQgcmVjIHNub2NfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBzbm9jX2VudW0gciAoTW9yZSh2LCBsLCBlKSlcblxuICAgIGxldCByZWMgcmV2X3NlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKHgsIHQsIHJlc3QpIC0+IFNlcS5Db25zICh4LCByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19yZXZfc2VxIGMgPSByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gYyBFbmQpXG5cbiAgICBsZXQgdG9fc2VxX2Zyb20gbG93IHMgPVxuICAgICAgbGV0IHJlYyBhdXggbG93IHMgYyA9IG1hdGNoIHMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGNcbiAgICAgICAgfCBOb2RlIHtsOyByOyB2OyBffSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggT3JkLmNvbXBhcmUgdiBsb3cgd2l0aFxuICAgICAgICAgICAgICB8IDAgLT4gTW9yZSAodiwgciwgYylcbiAgICAgICAgICAgICAgfCBuIHdoZW4gbjwwIC0+IGF1eCBsb3cgciBjXG4gICAgICAgICAgICAgIHwgXyAtPiBhdXggbG93IGwgKE1vcmUgKHYsIHIsIGMpKVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgc2VxX29mX2VudW1fIChhdXggbG93IHMgRW5kKVxuICBlbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X1NldF9iYWwiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJTdGRsaWJfU2VxIiwiU3RkbGliX0xpc3QiLCJBc3NlcnRfZmFpbHVyZSIsImNzdF9TZXRfcmVtb3ZlX21pbl9lbHQiLCJTdGRsaWJfU2V0IiwiT3JkIiwiaGVpZ2h0IiwicGFyYW0iLCJoIiwiY3JlYXRlIiwibCIsInYiLCJyIiwiaGwiLCJociIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiIsImxybCIsInJyIiwicnYiLCJybCIsInJsciIsInJsdiIsInJsbCIsImFkZCIsIngiLCJ0IiwiYyIsInNpbmdsZXRvbiIsImFkZF9taW5fZWxlbWVudCIsImFkZF9tYXhfZWxlbWVudCIsImpvaW4iLCJyaCIsImxoIiwibWluX2VsdCIsIm1pbl9lbHRfb3B0IiwibWF4X2VsdCIsIm1heF9lbHRfb3B0IiwicmVtb3ZlX21pbl9lbHQiLCJjb25jYXQiLCJ0MSIsInQyIiwic3BsaXQiLCJtYXRjaCIsInByZXMiLCJlbXB0eSIsImlzX2VtcHR5IiwibWVtIiwicmVtb3ZlIiwidW5pb24iLCJzMSIsInMyIiwiaDIiLCJyMiIsInYyIiwibDIiLCJoMSIsInIxIiwidjEiLCJsMSIsImludGVyIiwic3BsaXRfYmlzIiwiZGlzam9pbnQiLCJkaWZmIiwiY29uc19lbnVtIiwicyIsImUiLCJjb21wYXJlIiwiZTIiLCJlMSIsImVxdWFsIiwic3Vic2V0IiwiaXRlciIsImZvbGQiLCJhY2N1IiwiZm9yX2FsbCIsInAiLCJleGlzdHMiLCJmaWx0ZXIiLCJwdiIsInBhcnRpdGlvbiIsImxmIiwibHQiLCJyZiIsInJ0IiwiY2FyZGluYWwiLCJlbGVtZW50c19hdXgiLCJlbGVtZW50cyIsImZpbmQiLCJmaW5kX2ZpcnN0IiwidjAiLCJmaW5kX2ZpcnN0X29wdCIsImZpbmRfbGFzdCIsImZpbmRfbGFzdF9vcHQiLCJmaW5kX29wdCIsInRyeV9qb2luIiwibWFwIiwiZmlsdGVyX21hcCIsIm9mX2xpc3QiLCJ4MCIsIngxIiwieDIiLCJ4MyIsInN1YiIsIm4iLCJubCIsImxlZnQiLCJtaWQiLCJyaWdodCIsIng0IiwiYWRkX3NlcSIsImkiLCJtIiwib2Zfc2VxIiwic2VxX29mX2VudW0iLCJyZXN0IiwidG9fc2VxIiwic25vY19lbnVtIiwicmV2X3NlcV9vZl9lbnVtIiwidG9fcmV2X3NlcSIsInRvX3NlcV9mcm9tIiwibG93Il0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FB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QztBQUFBLFFBQUM7QUFBQSxpQkFBQThGLFdBQUE1RjtBQUFBQSxhQUFBLElBRXRDO0FBQUEsU0FBaUI7QUFBQTtBQUFBLGlCQUFBNkYsWUFBQUMsS0FBQXhEO0FBQUFBO0FBQUFBO0FBQUFBLGNBQUFBLE1BWXRDLEdBQUF0QyxJQUFBO0FBQUE7QUFBQSxXQVRTO0FBQUE7QUFBQSxZQUFBbkIsSUFBQTtBQUFBLFlBQUFELElBQUE7QUFBQSxZQUFBRCxJQUFBO0FBQUEsWUFBQWtHLElBR0o7QUFBQSxXQUFpQjtBQUFBLFdBRWxCLGVBQUE3RSxNQUNGLHNDQURFO0FBQUE7QUFBQSxrQkFERjtBQUFBO0FBQUEsU0FLYTtBQUFBO0FBQUEsUUQxbUJsQyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjgzNjMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9tYXAubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgISsnYSB0XG4gICAgdmFsIGVtcHR5OiAnYSB0XG4gICAgdmFsIGlzX2VtcHR5OiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgbWVtOiAga2V5IC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBhZGQ6IGtleSAtPiAnYSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgdXBkYXRlOiBrZXkgLT4gKCdhIG9wdGlvbiAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBzaW5nbGV0b246IGtleSAtPiAnYSAtPiAnYSB0XG4gICAgdmFsIHJlbW92ZToga2V5IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBtZXJnZTpcbiAgICAgICAgICAoa2V5IC0+ICdhIG9wdGlvbiAtPiAnYiBvcHRpb24gLT4gJ2Mgb3B0aW9uKSAtPiAnYSB0IC0+ICdiIHQgLT4gJ2MgdFxuICAgIHZhbCB1bmlvbjogKGtleSAtPiAnYSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGNvbXBhcmU6ICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6ICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGZvcl9hbGw6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGV4aXN0czogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgZmlsdGVyOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBmaWx0ZXJfbWFwOiAoa2V5IC0+ICdhIC0+ICdiIG9wdGlvbikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIHBhcnRpdGlvbjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgKiAnYSB0XG4gICAgdmFsIGNhcmRpbmFsOiAnYSB0IC0+IGludFxuICAgIHZhbCBiaW5kaW5nczogJ2EgdCAtPiAoa2V5ICogJ2EpIGxpc3RcbiAgICB2YWwgbWluX2JpbmRpbmc6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBtaW5fYmluZGluZ19vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgbWF4X2JpbmRpbmc6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBtYXhfYmluZGluZ19vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgY2hvb3NlOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgY2hvb3NlX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBzcGxpdDoga2V5IC0+ICdhIHQgLT4gJ2EgdCAqICdhIG9wdGlvbiAqICdhIHRcbiAgICB2YWwgZmluZDoga2V5IC0+ICdhIHQgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6IGtleSAtPiAnYSB0IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9maXJzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2xhc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgbWFwOiAoJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBtYXBpOiAoa2V5IC0+ICdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3Jldl9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2Zyb20gOiBrZXkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID0gc3RydWN0XG5cbiAgICB0eXBlIGtleSA9IE9yZC50XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIG9mIHtsOidhIHQ7IHY6a2V5OyBkOidhOyByOidhIHQ7IGg6aW50fVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgbGV0IGNyZWF0ZSBsIHggZCByID1cbiAgICAgIGxldCBobCA9IGhlaWdodCBsIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IHNpbmdsZXRvbiB4IGQgPSBOb2Rle2w9RW1wdHk7IHY9eDsgZDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgbGV0IGJhbCBsIHggZCByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiBsZCAoY3JlYXRlIGxyIHggZCByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgZD1scmQ7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBscmwpIGxydiBscmQgKGNyZWF0ZSBscnIgeCBkIHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmwpIHJ2IHJkIHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyBkPXJsZDsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybGwpIHJsdiBybGQgKGNyZWF0ZSBybHIgcnYgcmQgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdj14OyBkOyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgYWRkIHggZGF0YSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9kZXtsPUVtcHR5OyB2PXg7IGQ9ZGF0YTsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSBhcyBtIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGRhdGEgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCBkYXRhIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIGRcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZDAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIGRcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+ICh2LCBkKVxuICAgICAgfCBOb2RlIHtsfSAtPiBtaW5fYmluZGluZyBsXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nX29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgdjsgZH0gLT4gU29tZSAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0tPiBtaW5fYmluZGluZ19vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7cn0gLT4gbWF4X2JpbmRpbmcgclxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge3Y7IGQ7IHI9RW1wdHl9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nX29wdCByXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiYWwgKHJlbW92ZV9taW5fYmluZGluZyBsKSB2IGQgclxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT5cbiAgICAgICAgICBsZXQgKHgsIGQpID0gbWluX2JpbmRpbmcgdDIgaW5cbiAgICAgICAgICBiYWwgdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCAoTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpbiBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyB1cGRhdGUgeCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBmIE5vbmUgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBFbXB0eVxuICAgICAgICAgIHwgU29tZSBkYXRhIC0+IE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgICAgICBlbmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBiZWdpblxuICAgICAgICAgICAgbWF0Y2ggZiAoU29tZSBkKSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gbWVyZ2UgbCByXG4gICAgICAgICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgIGlmIGQgPT0gZGF0YSB0aGVuIG0gZWxzZSBOb2Rle2w7IHY9eDsgZD1kYXRhOyByOyBofVxuICAgICAgICAgIGVuZCBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IHVwZGF0ZSB4IGYgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSB1cGRhdGUgeCBmIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaXRlciBmIGw7IGYgdiBkOyBpdGVyIGYgclxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICAgbGV0IGQnID0gZiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgIE5vZGV7bD1sJzsgdjsgZD1kJzsgcj1yJzsgaH1cblxuICAgIGxldCByZWMgbWFwaSBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSAtPlxuICAgICAgICAgIGxldCBsJyA9IG1hcGkgZiBsIGluXG4gICAgICAgICAgbGV0IGQnID0gZiB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBtYXBpIGYgciBpblxuICAgICAgICAgIE5vZGV7bD1sJzsgdjsgZD1kJzsgcj1yJzsgaH1cblxuICAgIGxldCByZWMgZm9sZCBmIG0gYWNjdSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGZvbGQgZiByIChmIHYgZCAoZm9sZCBmIGwgYWNjdSkpXG5cbiAgICBsZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgJiYgZm9yX2FsbCBwIGwgJiYgZm9yX2FsbCBwIHJcblxuICAgIGxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBwIHYgZCB8fCBleGlzdHMgcCBsIHx8IGV4aXN0cyBwIHJcblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgayBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBrZXlzIGluIHRoZSB0cmVlOyBpdFxuICAgICAgIGRvZXMgbm90IHRlc3QgZm9yIGVxdWFsaXR5IHdpdGggdGhlIGN1cnJlbnQgbWluIChvciBtYXgpIGtleS5cblxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9iaW5kaW5nIGsgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiBrIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgYmFsIChhZGRfbWluX2JpbmRpbmcgayB4IGwpIHYgZCByXG5cbiAgICBsZXQgcmVjIGFkZF9tYXhfYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgZCAoYWRkX21heF9iaW5kaW5nIGsgeCByKVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZVxuICAgICAgIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCByZWMgam9pbiBsIHYgZCByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9iaW5kaW5nIHYgZCByXG4gICAgICB8IChfLCBFbXB0eSkgLT4gYWRkX21heF9iaW5kaW5nIHYgZCBsXG4gICAgICB8IChOb2Rle2w9bGw7IHY9bHY7IGQ9bGQ7IHI9bHI7IGg9bGh9LFxuICAgICAgICAgTm9kZXtsPXJsOyB2PXJ2OyBkPXJkOyByPXJyOyBoPXJofSkgLT5cbiAgICAgICAgICBpZiBsaCA+IHJoICsgMiB0aGVuIGJhbCBsbCBsdiBsZCAoam9pbiBsciB2IGQgcikgZWxzZVxuICAgICAgICAgIGlmIHJoID4gbGggKyAyIHRoZW4gYmFsIChqb2luIGwgdiBkIHJsKSBydiByZCByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiBkIHJcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgY29uY2F0IHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT5cbiAgICAgICAgICBsZXQgKHgsIGQpID0gbWluX2JpbmRpbmcgdDIgaW5cbiAgICAgICAgICBqb2luIHQxIHggZCAocmVtb3ZlX21pbl9iaW5kaW5nIHQyKVxuXG4gICAgbGV0IGNvbmNhdF9vcl9qb2luIHQxIHYgZCB0MiA9XG4gICAgICBtYXRjaCBkIHdpdGhcbiAgICAgIHwgU29tZSBkIC0+IGpvaW4gdDEgdiBkIHQyXG4gICAgICB8IE5vbmUgLT4gY29uY2F0IHQxIHQyXG5cbiAgICBsZXQgcmVjIHNwbGl0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIChFbXB0eSwgTm9uZSwgRW1wdHkpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIChsLCBTb21lIGQsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgZCByKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobHIsIHByZXMsIHJyKSA9IHNwbGl0IHggciBpbiAoam9pbiBsIHYgZCBsciwgcHJlcywgcnIpXG5cbiAgICBsZXQgcmVjIG1lcmdlIGYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIEVtcHR5KSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZSB7bD1sMTsgdj12MTsgZD1kMTsgcj1yMTsgaD1oMX0sIF8pIHdoZW4gaDEgPj0gaGVpZ2h0IHMyIC0+XG4gICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYxIChmIHYxIChTb21lIGQxKSBkMikgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IChfLCBOb2RlIHtsPWwyOyB2PXYyOyBkPWQyOyByPXIyfSkgLT5cbiAgICAgICAgICBsZXQgKGwxLCBkMSwgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICBjb25jYXRfb3Jfam9pbiAobWVyZ2UgZiBsMSBsMikgdjIgKGYgdjIgZDEgKFNvbWUgZDIpKSAobWVyZ2UgZiByMSByMilcbiAgICAgIHwgXyAtPlxuICAgICAgICAgIGFzc2VydCBmYWxzZVxuXG4gICAgbGV0IHJlYyB1bmlvbiBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgIHwgKEVtcHR5LCBzKSB8IChzLCBFbXB0eSkgLT4gc1xuICAgICAgfCAoTm9kZSB7bD1sMTsgdj12MTsgZD1kMTsgcj1yMTsgaD1oMX0sXG4gICAgICAgICBOb2RlIHtsPWwyOyB2PXYyOyBkPWQyOyByPXIyOyBoPWgyfSkgLT5cbiAgICAgICAgICBpZiBoMSA+PSBoMiB0aGVuXG4gICAgICAgICAgICBsZXQgKGwyLCBkMiwgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICAgIGxldCBsID0gdW5pb24gZiBsMSBsMiBhbmQgciA9IHVuaW9uIGYgcjEgcjIgaW5cbiAgICAgICAgICAgIG1hdGNoIGQyIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBqb2luIGwgdjEgZDEgclxuICAgICAgICAgICAgfCBTb21lIGQyIC0+IGNvbmNhdF9vcl9qb2luIGwgdjEgKGYgdjEgZDEgZDIpIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGwxLCBkMSwgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICAgIGxldCBsID0gdW5pb24gZiBsMSBsMiBhbmQgciA9IHVuaW9uIGYgcjEgcjIgaW5cbiAgICAgICAgICAgIG1hdGNoIGQxIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBqb2luIGwgdjIgZDIgclxuICAgICAgICAgICAgfCBTb21lIGQxIC0+IGNvbmNhdF9vcl9qb2luIGwgdjIgKGYgdjIgZDEgZDIpIHJcblxuICAgIGxldCByZWMgZmlsdGVyIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSBhcyBtIC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXIgcCBsIGluXG4gICAgICAgICAgbGV0IHB2ZCA9IHAgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyIHAgciBpblxuICAgICAgICAgIGlmIHB2ZCB0aGVuIGlmIGw9PWwnICYmIHI9PXInIHRoZW4gbSBlbHNlIGpvaW4gbCcgdiBkIHInXG4gICAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcblxuICAgIGxldCByZWMgZmlsdGVyX21hcCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtmXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlcl9tYXAgZiBsIGluXG4gICAgICAgICAgbGV0IGZ2ZCA9IGYgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyX21hcCBmIHIgaW5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBmdmQgd2l0aFxuICAgICAgICAgICAgfCBTb21lIGQnIC0+IGpvaW4gbCcgdiBkJyByJ1xuICAgICAgICAgICAgfCBOb25lIC0+IGNvbmNhdCBsJyByJ1xuICAgICAgICAgIGVuZFxuXG4gICAgbGV0IHJlYyBwYXJ0aXRpb24gcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IChFbXB0eSwgRW1wdHkpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgKGx0LCBsZikgPSBwYXJ0aXRpb24gcCBsIGluXG4gICAgICAgICAgbGV0IHB2ZCA9IHAgdiBkIGluXG4gICAgICAgICAgbGV0IChydCwgcmYpID0gcGFydGl0aW9uIHAgciBpblxuICAgICAgICAgIGlmIHB2ZFxuICAgICAgICAgIHRoZW4gKGpvaW4gbHQgdiBkIHJ0LCBjb25jYXQgbGYgcmYpXG4gICAgICAgICAgZWxzZSAoY29uY2F0IGx0IHJ0LCBqb2luIGxmIHYgZCByZilcblxuICAgIHR5cGUgJ2EgZW51bWVyYXRpb24gPSBFbmQgfCBNb3JlIG9mIGtleSAqICdhICogJ2EgdCAqICdhIGVudW1lcmF0aW9uXG5cbiAgICBsZXQgcmVjIGNvbnNfZW51bSBtIGUgPVxuICAgICAgbWF0Y2ggbSB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gY29uc19lbnVtIGwgKE1vcmUodiwgZCwgciwgZSkpXG5cbiAgICBsZXQgY29tcGFyZSBjbXAgbTEgbTIgPVxuICAgICAgbGV0IHJlYyBjb21wYXJlX2F1eCBlMSBlMiA9XG4gICAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAgIChFbmQsIEVuZCkgLT4gMFxuICAgICAgICB8IChFbmQsIF8pICAtPiAtMVxuICAgICAgICB8IChfLCBFbmQpIC0+IDFcbiAgICAgICAgfCAoTW9yZSh2MSwgZDEsIHIxLCBlMSksIE1vcmUodjIsIGQyLCByMiwgZTIpKSAtPlxuICAgICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCBkMSBkMiBpblxuICAgICAgICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlXG4gICAgICAgICAgICBjb21wYXJlX2F1eCAoY29uc19lbnVtIHIxIGUxKSAoY29uc19lbnVtIHIyIGUyKVxuICAgICAgaW4gY29tcGFyZV9hdXggKGNvbnNfZW51bSBtMSBFbmQpIChjb25zX2VudW0gbTIgRW5kKVxuXG4gICAgbGV0IGVxdWFsIGNtcCBtMSBtMiA9XG4gICAgICBsZXQgcmVjIGVxdWFsX2F1eCBlMSBlMiA9XG4gICAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAgIChFbmQsIEVuZCkgLT4gdHJ1ZVxuICAgICAgICB8IChFbmQsIF8pICAtPiBmYWxzZVxuICAgICAgICB8IChfLCBFbmQpIC0+IGZhbHNlXG4gICAgICAgIHwgKE1vcmUodjEsIGQxLCByMSwgZTEpLCBNb3JlKHYyLCBkMiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICAgIE9yZC5jb21wYXJlIHYxIHYyID0gMCAmJiBjbXAgZDEgZDIgJiZcbiAgICAgICAgICAgIGVxdWFsX2F1eCAoY29uc19lbnVtIHIxIGUxKSAoY29uc19lbnVtIHIyIGUyKVxuICAgICAgaW4gZXF1YWxfYXV4IChjb25zX2VudW0gbTEgRW5kKSAoY29uc19lbnVtIG0yIEVuZClcblxuICAgIGxldCByZWMgY2FyZGluYWwgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2w7IHJ9IC0+IGNhcmRpbmFsIGwgKyAxICsgY2FyZGluYWwgclxuXG4gICAgbGV0IHJlYyBiaW5kaW5nc19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gYmluZGluZ3NfYXV4ICgodiwgZCkgOjogYmluZGluZ3NfYXV4IGFjY3UgcikgbFxuXG4gICAgbGV0IGJpbmRpbmdzIHMgPVxuICAgICAgYmluZGluZ3NfYXV4IFtdIHNcblxuICAgIGxldCBjaG9vc2UgPSBtaW5fYmluZGluZ1xuXG4gICAgbGV0IGNob29zZV9vcHQgPSBtaW5fYmluZGluZ19vcHRcblxuICAgIGxldCBhZGRfc2VxIGkgbSA9XG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gbSAoayx2KSAtPiBhZGQgayB2IG0pIG0gaVxuXG4gICAgbGV0IG9mX3NlcSBpID0gYWRkX3NlcSBpIGVtcHR5XG5cbiAgICBsZXQgcmVjIHNlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKGssdix0LHJlc3QpIC0+IFNlcS5Db25zICgoayx2KSwgc2VxX29mX2VudW1fIChjb25zX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19zZXEgbSA9XG4gICAgICBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSBtIEVuZClcblxuICAgIGxldCByZWMgc25vY19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IGQ7IHJ9IC0+IHNub2NfZW51bSByIChNb3JlKHYsIGQsIGwsIGUpKVxuXG4gICAgbGV0IHJlYyByZXZfc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoayx2LHQscmVzdCkgLT5cbiAgICAgICAgICBTZXEuQ29ucyAoKGssdiksIHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3Jldl9zZXEgYyA9XG4gICAgICByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gYyBFbmQpXG5cbiAgICBsZXQgdG9fc2VxX2Zyb20gbG93IG0gPVxuICAgICAgbGV0IHJlYyBhdXggbG93IG0gYyA9IG1hdGNoIG0gd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGNcbiAgICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBffSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggT3JkLmNvbXBhcmUgdiBsb3cgd2l0aFxuICAgICAgICAgICAgICB8IDAgLT4gTW9yZSAodiwgZCwgciwgYylcbiAgICAgICAgICAgICAgfCBuIHdoZW4gbjwwIC0+IGF1eCBsb3cgciBjXG4gICAgICAgICAgICAgIHwgXyAtPiBhdXggbG93IGwgKE1vcmUgKHYsIGQsIHIsIGMpKVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgc2VxX29mX2VudW1fIChhdXggbG93IG0gRW5kKVxuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9NYXBfYmFsIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiU3RkbGliIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfU2VxIiwiY3N0X01hcF9yZW1vdmVfbWluX2VsdCIsIlN0ZGxpYl9NYXAiLCJPcmQiLCJoZWlnaHQiLCJwYXJhbSIsImgiLCJjcmVhdGUiLCJsIiwieCIsImQiLCJyIiwiaGwiLCJociIsInNpbmdsZXRvbiIsImJhbCIsImxyIiwibGQiLCJsdiIsImxsIiwibHJyIiwibHJkIiwibHJ2IiwibHJsIiwicnIiLCJyZCIsInJ2IiwicmwiLCJybHIiLCJybGQiLCJybHYiLCJybGwiLCJlbXB0eSIsImlzX2VtcHR5IiwiYWRkIiwiZGF0YSIsIm0iLCJ2IiwiYyIsImZpbmQiLCJmaW5kX2ZpcnN0IiwiZDAiLCJ2MCIsImZpbmRfZmlyc3Rfb3B0IiwiZmluZF9sYXN0IiwiZmluZF9sYXN0X29wdCIsImZpbmRfb3B0IiwibWVtIiwibWluX2JpbmRpbmciLCJtaW5fYmluZGluZ19vcHQiLCJtYXhfYmluZGluZyIsIm1heF9iaW5kaW5nX29wdCIsInJlbW92ZV9taW5fYmluZGluZyIsInQxIiwidDIiLCJtYXRjaCIsInJlbW92ZSIsInVwZGF0ZSIsIml0ZXIiLCJtYXAiLCJtYXBpIiwiZm9sZCIsImFjY3UiLCJmb3JfYWxsIiwicCIsImV4aXN0cyIsImFkZF9taW5fYmluZGluZyIsImsiLCJhZGRfbWF4X2JpbmRpbmciLCJqb2luIiwicmgiLCJsaCIsImNvbmNhdCIsImNvbmNhdF9vcl9qb2luIiwic3BsaXQiLCJwcmVzIiwibWVyZ2UiLCJzMSIsInMyIiwiaDEiLCJyMSIsImQxIiwidjEiLCJsMSIsInIyIiwiZDIiLCJsMiIsInYyIiwidW5pb24iLCJoMiIsInMiLCJmaWx0ZXIiLCJwdmQiLCJmaWx0ZXJfbWFwIiwiZnZkIiwicGFydGl0aW9uIiwibGYiLCJsdCIsInJmIiwicnQiLCJjb25zX2VudW0iLCJlIiwiY29tcGFyZSIsImNtcCIsIm0xIiwibTIiLCJlMiIsImUxIiwiZXF1YWwiLCJjYXJkaW5hbCIsImJpbmRpbmdzX2F1eCIsImJpbmRpbmdzIiwiYWRkX3NlcSIsImkiLCJvZl9zZXEiLCJzZXFfb2ZfZW51bSIsInJlc3QiLCJ0IiwidG9fc2VxIiwic25vY19lbnVtIiwicmV2X3NlcV9vZl9lbnVtIiwidG9fcmV2X3NlcSIsInRvX3NlcV9mcm9tIiwibG93IiwibiJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFD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LElBQUE7QUFBQTtBQUFBLGtCQUNXO0FBQUEsY0FBQTFGLElBRFgsTUFBQUQsSUFBQSxNQUFBMkIsSUFBQSxNQUFBN0IsSUFBQSxNQUFBNkYsTUFFc0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUE4QjtBQUFBLGlCQUFBbUIsZ0JBQUFsRixHQUFBakM7QUFBQUEsU0FFdEIsUUFDckI7QUFBQTtBQUFBLFVBQUErRyxPQURxQjtBQUFBLFVBQUFDLElBQUE7QUFBQSxVQUFBaEYsSUFBQTtBQUFBLFVBQUE4QixJQUFBO0FBQUEsY0FHUTtBQUFBLFNBQWtCLGtDQUFuQywrQkFBbUM7QUFBQSxRQUFDO0FBQUEsaUJBQUFzRCxXQUFBbkY7QUFBQUEsYUFBQSxJQUd4QztBQUFBLFNBQWlCO0FBQUE7QUFBQSxpQkFBQW9GLFlBQUFDLEtBQUF2RjtBQUFBQTtBQUFBQTtBQUFBQSxjQUFBQSxNQVlyQixHQUFBRSxJQUFBO0FBQUE7QUFBQSxXQVRTO0FBQUE7QUFBQSxZQUFBM0IsSUFBQTtBQUFBLFlBQUFELElBQUE7QUFBQSxZQUFBMkIsSUFBQTtBQUFBLFlBQUE3QixJQUFBO0FBQUEsWUFBQW9ILElBR0o7QUFBQSxXQUFpQjtBQUFBLFdBRWxCO0FBQUEsZ0JBQUF0RixNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQURFO0FBQUE7QUFBQSxrQkFERjtBQUFBO0FBQUEsU0FLYTtBQUFBO0FBQUEsUUR0aEJsQyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjkxOTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9zdGFjay5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0geyBtdXRhYmxlIGMgOiAnYSBsaXN0OyBtdXRhYmxlIGxlbiA6IGludDsgfVxuXG5leGNlcHRpb24gRW1wdHlcblxubGV0IGNyZWF0ZSAoKSA9IHsgYyA9IFtdOyBsZW4gPSAwOyB9XG5cbmxldCBjbGVhciBzID0gcy5jIDwtIFtdOyBzLmxlbiA8LSAwXG5cbmxldCBjb3B5IHMgPSB7IGMgPSBzLmM7IGxlbiA9IHMubGVuOyB9XG5cbmxldCBwdXNoIHggcyA9IHMuYyA8LSB4IDo6IHMuYzsgcy5sZW4gPC0gcy5sZW4gKyAxXG5cbmxldCBwb3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6OnRsIC0+IHMuYyA8LSB0bDsgcy5sZW4gPC0gcy5sZW4gLSAxOyBoZFxuICB8IFtdICAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgcG9wX29wdCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IFNvbWUgaGRcbiAgfCBbXSAgICAgLT4gTm9uZVxuXG5sZXQgdG9wIHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjpfIC0+IGhkXG4gIHwgW10gICAgLT4gcmFpc2UgRW1wdHlcblxubGV0IHRvcF9vcHQgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gU29tZSBoZFxuICB8IFtdICAgIC0+IE5vbmVcblxubGV0IGlzX2VtcHR5IHMgPSAocy5jID0gW10pXG5cbmxldCBsZW5ndGggcyA9IHMubGVuXG5cbmxldCBpdGVyIGYgcyA9IExpc3QuaXRlciBmIHMuY1xuXG5sZXQgZm9sZCBmIGFjYyBzID0gTGlzdC5mb2xkX2xlZnQgZiBhY2Mgcy5jXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9IExpc3QudG9fc2VxIHMuY1xuXG5sZXQgYWRkX3NlcSBxIGkgPSBTZXEuaXRlciAoZnVuIHggLT4gcHVzaCB4IHEpIGlcblxubGV0IG9mX3NlcSBnID1cbiAgbGV0IHMgPSBjcmVhdGUoKSBpblxuICBhZGRfc2VxIHMgZztcbiAgc1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9TZXEiLCJTdGRsaWJfTGlzdCIsIkVtcHR5IiwiY3JlYXRlIiwicGFyYW0iLCJjbGVhciIsInMiLCJjb3B5IiwicHVzaCIsIngiLCJwb3AiLCJtYXRjaCIsInRsIiwiaGQiLCJwb3Bfb3B0IiwidG9wIiwidG9wX29wdCIsImlzX2VtcHR5IiwibGVuZ3RoIiwiaXRlciIsImYiLCJmb2xkIiwiYWNjIiwidG9fc2VxIiwiYWRkX3NlcSIsInEiLCJpIiwib2Zfc2VxIiwiZyIsIlN0ZGxpYl9TdGFjayJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxZQUFBQyxPQUFBQyxPQ21CZ0IsaUJBQW9CO0FBQUEsWUFBQUMsTUFBQUMsR0FFdEIsVUFBVyxtQkFBVTtBQUFBLFlBQUFDLEtBQUFELEdBRXRCLHVCQUF5QjtBQUFBLFlBQUFFLEtBQUFDLEdBQUFILEdBRXZCLHFCQUFpQiw4QkFBa0I7QUFBQSxZQUFBSSxJQUFBSjtBQUFBQSxRQUFBSyxRQUdoRDtBQUFBLGdCQUVZO0FBQUEsUUFBQUMsS0FGWixVQUFBQyxLQUFBO0FBQUEsSUFDWTtBQUFBLElBQVc7QUFBQSxJQUFvQjtBQUFBLEdBQ3BCO0FBQUEsWUFBQUMsUUFBQVI7QUFBQUEsUUFBQUssUUFHdkI7QUFBQSxnQkFFWTtBQUFBLFFBQUFDLEtBRlosVUFBQUMsS0FBQTtBQUFBLElBQ1k7QUFBQSxJQUFXO0FBQUEsSUFBb0I7QUFBQSxHQUMzQjtBQUFBLFlBQUFFLElBQUFUO0FBQUFBLFFBQUFLLFFBR2hCO0FBQUEsZ0JBRVc7QUFBQSxRQUFBRSxLQUZYO0FBQUEsSUFDVztBQUFBLEdBQ1c7QUFBQSxZQUFBRyxRQUFBVjtBQUFBQSxRQUFBSyxRQUd0QjtBQUFBLGdCQUVXO0FBQUEsUUFBQUUsS0FGWDtBQUFBLElBQ1c7QUFBQSxHQUNJO0FBQUEsWUFBQUksU0FBQVgsR0FFQSwwQkFBVTtBQUFBLFlBQUFZLE9BQUFaLEdBRVosWUFBSztBQUFBLFlBQUFhLEtBQUFDLEdBQUFkLEdBRUwsMENBQWU7QUFBQSxZQUFBZSxLQUFBRCxHQUFBRSxLQUFBaEIsR0FFWCwrQ0FBd0I7QUFBQSxZQUFBaUIsT0FBQWpCLEdBSTVCLHVDQUFlO0FBQUEsWUFBQWtCLFFBQUFDLEdBQUFDO0FBQUFBLElBRVoseUNBQUFqQixHQUFtQixpQkFBUSxNQUFHO0FBQUE7QUFBQSxZQUFBa0IsT0FBQUMsT0FBQXRCLElBR3RDLFdBQ1IsZUFBVyxTQUNWO0FBQUE7QUFBQSxJQUFBdUI7QUFBQUEsTURoRUgiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo5Mjc3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvcXVldWUubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEZyYW5jb2lzIFBvdHRpZXIsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIGNlbGwgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgeyBjb250ZW50OiAnYTsgbXV0YWJsZSBuZXh0OiAnYSBjZWxsIH1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIGxlbmd0aDogaW50O1xuICBtdXRhYmxlIGZpcnN0OiAnYSBjZWxsO1xuICBtdXRhYmxlIGxhc3Q6ICdhIGNlbGxcbn1cblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgbGVuZ3RoID0gMDtcbiAgZmlyc3QgPSBOaWw7XG4gIGxhc3QgPSBOaWxcbn1cblxubGV0IGNsZWFyIHEgPVxuICBxLmxlbmd0aCA8LSAwO1xuICBxLmZpcnN0IDwtIE5pbDtcbiAgcS5sYXN0IDwtIE5pbFxuXG5sZXQgYWRkIHggcSA9XG4gIGxldCBjZWxsID0gQ29ucyB7XG4gICAgY29udGVudCA9IHg7XG4gICAgbmV4dCA9IE5pbFxuICB9IGluXG4gIG1hdGNoIHEubGFzdCB3aXRoXG4gIHwgTmlsIC0+XG4gICAgcS5sZW5ndGggPC0gMTtcbiAgICBxLmZpcnN0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcbiAgfCBDb25zIGxhc3QgLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCArIDE7XG4gICAgbGFzdC5uZXh0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcblxubGV0IHB1c2ggPVxuICBhZGRcblxubGV0IHBlZWsgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gY29udGVudFxuXG5sZXQgcGVla19vcHQgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiBOb25lXG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBTb21lIGNvbnRlbnRcblxubGV0IHRvcCA9XG4gIHBlZWtcblxubGV0IHRha2UgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBjb250ZW50XG5cbmxldCB0YWtlX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBTb21lIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBTb21lIGNvbnRlbnRcblxubGV0IHBvcCA9XG4gIHRha2VcblxubGV0IGNvcHkgPVxuICBsZXQgcmVjIGNvcHkgcV9yZXMgcHJldiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBxX3Jlcy5sYXN0IDwtIHByZXY7IHFfcmVzXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgcmVzID0gQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSBpblxuICAgICAgYmVnaW4gbWF0Y2ggcHJldiB3aXRoXG4gICAgICB8IE5pbCAtPiBxX3Jlcy5maXJzdCA8LSByZXNcbiAgICAgIHwgQ29ucyBwIC0+IHAubmV4dCA8LSByZXNcbiAgICAgIGVuZDtcbiAgICAgIGNvcHkgcV9yZXMgcmVzIG5leHRcbiAgaW5cbiAgZnVuIHEgLT4gY29weSB7IGxlbmd0aCA9IHEubGVuZ3RoOyBmaXJzdCA9IE5pbDsgbGFzdCA9IE5pbCB9IE5pbCBxLmZpcnN0XG5cbmxldCBpc19lbXB0eSBxID1cbiAgcS5sZW5ndGggPSAwXG5cbmxldCBsZW5ndGggcSA9XG4gIHEubGVuZ3RoXG5cbmxldCBpdGVyID1cbiAgbGV0IHJlYyBpdGVyIGYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGYgY29udGVudDtcbiAgICAgIGl0ZXIgZiBuZXh0XG4gIGluXG4gIGZ1biBmIHEgLT4gaXRlciBmIHEuZmlyc3RcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGZvbGQgZiBhY2N1IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IGFjY3VcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGNvbnRlbnQgaW5cbiAgICAgIGZvbGQgZiBhY2N1IG5leHRcbiAgaW5cbiAgZnVuIGYgYWNjdSBxIC0+IGZvbGQgZiBhY2N1IHEuZmlyc3RcblxubGV0IHRyYW5zZmVyIHExIHEyID1cbiAgaWYgcTEubGVuZ3RoID4gMCB0aGVuXG4gICAgbWF0Y2ggcTIubGFzdCB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMS5sZW5ndGg7XG4gICAgICBxMi5maXJzdCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4gICAgfCBDb25zIGxhc3QgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMi5sZW5ndGggKyBxMS5sZW5ndGg7XG4gICAgICBsYXN0Lm5leHQgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHEgPVxuICBsZXQgcmVjIGF1eCBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgfCBOaWwgLT4gU2VxLk5pbFxuICAgIHwgQ29ucyB7IGNvbnRlbnQ9eDsgbmV4dDsgfSAtPiBTZXEuQ29ucyAoeCwgYXV4IG5leHQpXG4gIGluXG4gIGF1eCBxLmZpcnN0XG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcSA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcSBnO1xuICBxXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9TZXEiLCJFbXB0eSIsImNyZWF0ZSIsInBhcmFtIiwiY2xlYXIiLCJxIiwiYWRkIiwieCIsImNlbGwiLCJtYXRjaCIsInBlZWsiLCJjb250ZW50IiwicGVla19vcHQiLCJ0YWtlIiwibmV4dCIsInRha2Vfb3B0IiwiY29weSIsInFfcmVzIiwicHJldiIsImlzX2VtcHR5IiwibGVuZ3RoIiwiaXRlciIsImZvbGQiLCJhY2N1IiwidHJhbnNmZXIiLCJxMSIsInEyIiwidG9fc2VxIiwiYXV4IiwiYyIsImFkZF9zZXEiLCJpIiwib2Zfc2VxIiwiZyIsIlN0ZGxpYl9RdWV1ZSJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxZQUFBQyxPQUFBQyxPQzRCZ0Isb0JBSWY7QUFBQSxZQUFBQyxNQUFBQyxHQUdDLFVBQ0EsVUFDQSxtQkFBYTtBQUFBLFlBQUFDLElBQUFDLEdBQUFGO0FBQUFBLFFBQUFHLE9BR2IsV0FBQUMsUUFJQTtBQUFBO0FBQUE7QUFBQSxxREFRZ0I7QUFBQTtBQUFBLFlBQUFDLEtBQUFMO0FBQUFBLFFBQUFJLFFBTWhCO0FBQUEsZ0JBQ1M7QUFBQSxRQUFBRSxVQURUO0FBQUEsSUFFc0I7QUFBQSxHQUFPO0FBQUEsWUFBQUMsU0FBQVA7QUFBQUEsUUFBQUksUUFHN0I7QUFBQSxnQkFDUztBQUFBLFFBQUFFLFVBRFQ7QUFBQSxJQUVzQjtBQUFBLEdBQVk7QUFBQSxZQUFBRSxLQUFBUjtBQUFBQSxRQUFBSSxRQU1sQztBQUFBLGdCQUNTO0FBQUEsUUFBQUUsVUFEVDtBQUFBO0FBQUEsU0FBQUcsT0FBQTtBQUFBLEtBTUU7QUFBQSxLQUNBO0FBQUEsS0FDQTtBQUFBO0FBQUEsSUFMQTtBQUFBLElBQU87QUFBQSxHQUtBO0FBQUEsWUFBQUMsU0FBQVY7QUFBQUEsUUFBQUksUUFHVDtBQUFBLGdCQUNTO0FBQUEsUUFBQUUsVUFEVDtBQUFBO0FBQUEsU0FBQUcsT0FBQTtBQUFBLEtBTUU7QUFBQSxLQUNBO0FBQUEsS0FDQTtBQUFBO0FBQUEsSUFMQTtBQUFBLElBQU87QUFBQSxHQUtLO0FBQUEsWUFBQUUsS0FBQVg7QUFBQUEsUUFBQUcsU0FpQkwsTUFBQVMsUUFBQSxpQkFBQUMsT0FBQSxHQUFBVixPQUFBO0FBQUE7QUFBQSxLQVZQLFdBQ1MsaUJBQW9CO0FBQUEsU0FBQUcsVUFEN0IsU0FBQUcsT0FBQSxTQUFBSSxTQUdFO0FBQUEsS0FDQTtBQUFBLE1BRVk7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQURILG1CQUdUO0FBQUE7QUFBQSxHQUVvRTtBQUFBLFlBQUFDLFNBQUFkLEdBR3hFLDBCQUFZO0FBQUEsWUFBQWUsT0FBQWYsR0FHWixZQUFRO0FBQUEsWUFBQWdCLEtBQUExQixHQUFBVTtBQUFBQSxRQUFBRyxTQVVHLE1BQUFBLE9BQUE7QUFBQTtBQUFBLEtBTlQsV0FDUztBQUFBLFNBQUFHLFVBRFQsU0FBQUcsT0FBQTtBQUFBLEtBR0U7QUFBQSxLQUFTO0FBQUE7QUFBQSxHQUdZO0FBQUEsWUFBQVEsS0FBQTNCLEdBQUE0QixRQUFBbEI7QUFBQUEsUUFBQUcsU0FVVCxNQUFBZSxPQUFBLFFBQUFmLE9BQUE7QUFBQTtBQUFBLEtBTmQsV0FDUztBQUFBO0FBQUEsTUFBQUcsVUFEVDtBQUFBLE1BQUFHLE9BQUE7QUFBQSxNQUFBUyxTQUdhO0FBQUEsS0FDWDtBQUFBO0FBQUE7QUFBQSxHQUUrQjtBQUFBLFlBQUFDLFNBQUFDLElBQUFDO0FBQUFBLFFBQUEsSUFHbkM7QUFBQTtBQUFBLFFBQUFqQixRQUNFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FVRTtBQUFBLDREQUxBLFVBS1E7QUFBQTtBQUFBLFlBQUFrQixPQUFBdEI7QUFBQUEsYUFBQXVCLElBQUFDLEdBQUExQjtBQUFBQSxLQUtPLFFBQ1I7QUFBQSxTQUFBSSxJQURRLE1BQUFPLE9BQUE7QUFBQSxLQUVtQywwQkFBUixzQkFBUTtBQUFBLElBQUM7QUFBQSxZQUV2RDtBQUFBLHVCRDVKRixrQkM0SkU7QUFBQSxHQUFXO0FBQUEsWUFBQWdCLFFBQUF6QixHQUFBMEI7QUFBQUEsSUFFSyx5Q0FBQXhCLEdBQW1CLGdCQUFRLE1BQUc7QUFBQTtBQUFBLFlBQUF5QixPQUFBQyxPQUFBNUIsSUFHdEMsV0FDUixlQUFXLFNBQ1Y7QUFBQTtBQUFBLElBQUE2QjtBQUFBQSxNQTlCRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURySUYiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo5NDM2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvc3RyZWFtLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICBEYW5pZWwgZGUgUmF1Z2xhdWRyZSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSAnYSBjZWxsIG9wdGlvblxuYW5kICdhIGNlbGwgPSB7IG11dGFibGUgY291bnQgOiBpbnQ7IG11dGFibGUgZGF0YSA6ICdhIGRhdGEgfVxuYW5kICdhIGRhdGEgPVxuICAgIFNlbXB0eVxuICB8IFNjb25zIG9mICdhICogJ2EgZGF0YVxuICB8IFNhcHAgb2YgJ2EgZGF0YSAqICdhIGRhdGFcbiAgfCBTbGF6eSBvZiAnYSBkYXRhIExhenkudFxuICB8IFNnZW4gb2YgJ2EgZ2VuXG4gIHwgU2J1ZmZpbyA6IGJ1ZmZpbyAtPiBjaGFyIGRhdGFcbmFuZCAnYSBnZW4gPSB7IG11dGFibGUgY3VyciA6ICdhIG9wdGlvbiBvcHRpb247IGZ1bmMgOiBpbnQgLT4gJ2Egb3B0aW9uIH1cbmFuZCBidWZmaW8gPVxuICB7IGljIDogaW5fY2hhbm5lbDsgYnVmZiA6IGJ5dGVzOyBtdXRhYmxlIGxlbiA6IGludDsgbXV0YWJsZSBpbmQgOiBpbnQgfVxuXG5leGNlcHRpb24gRmFpbHVyZVxuZXhjZXB0aW9uIEVycm9yIG9mIHN0cmluZ1xuXG5sZXQgY291bnQgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gMFxuICB8IFNvbWUgeyBjb3VudCB9IC0+IGNvdW50XG5sZXQgZGF0YSA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBTZW1wdHlcbiAgfCBTb21lIHsgZGF0YSB9IC0+IGRhdGFcblxubGV0IGZpbGxfYnVmZiBiID1cbiAgYi5sZW4gPC0gaW5wdXQgYi5pYyBiLmJ1ZmYgMCAoQnl0ZXMubGVuZ3RoIGIuYnVmZik7IGIuaW5kIDwtIDBcblxuXG5sZXQgcmVjIGdldF9kYXRhIDogdHlwZSB2LiBpbnQgLT4gdiBkYXRhIC0+IHYgZGF0YSA9IGZ1biBjb3VudCBkIC0+IG1hdGNoIGQgd2l0aFxuICgqIFJldHVybnMgZWl0aGVyIFNlbXB0eSBvciBTY29ucyhhLCBfKSBldmVuIHdoZW4gZCBpcyBhIGdlbmVyYXRvclxuICAgIG9yIGEgYnVmZmVyLiBJbiB0aG9zZSBjYXNlcywgdGhlIGl0ZW0gYSBpcyBzZWVuIGFzIGV4dHJhY3RlZCBmcm9tXG4gdGhlIGdlbmVyYXRvci9idWZmZXIuXG4gVGhlIGNvdW50IHBhcmFtZXRlciBpcyB1c2VkIGZvciBjYWxsaW5nIGBTZ2VuLWZ1bmN0aW9ucycuICAqKVxuICAgU2VtcHR5IHwgU2NvbnMgKF8sIF8pIC0+IGRcbiB8IFNhcHAgKGQxLCBkMikgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZ2V0X2RhdGEgY291bnQgZDEgd2l0aFxuICAgICAgIFNjb25zIChhLCBkMTEpIC0+IFNjb25zIChhLCBTYXBwIChkMTEsIGQyKSlcbiAgICAgfCBTZW1wdHkgLT4gZ2V0X2RhdGEgY291bnQgZDJcbiAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICBlbmRcbiB8IFNnZW4ge2N1cnIgPSBTb21lIE5vbmV9IC0+IFNlbXB0eVxuIHwgU2dlbiAoe2N1cnIgPSBTb21lKFNvbWUgYSl9IGFzIGcpIC0+XG4gICAgIGcuY3VyciA8LSBOb25lOyBTY29ucyhhLCBkKVxuIHwgU2dlbiBnIC0+XG4gICAgIGJlZ2luIG1hdGNoIGcuZnVuYyBjb3VudCB3aXRoXG4gICAgICAgTm9uZSAtPiBnLmN1cnIgPC0gU29tZShOb25lKTsgU2VtcHR5XG4gICAgIHwgU29tZSBhIC0+IFNjb25zKGEsIGQpXG4gICAgICAgICAoKiBXYXJuaW5nOiBhbnlvbmUgdXNpbmcgZyB0aGlua3MgdGhhdCBhbiBpdGVtIGhhcyBiZWVuIHJlYWQgKilcbiAgICAgZW5kXG4gfCBTYnVmZmlvIGIgLT5cbiAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIFNlbXB0eSBlbHNlXG4gICAgICAgbGV0IHIgPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZiBiLmluZCBpblxuICAgICAgICgqIFdhcm5pbmc6IGFueW9uZSB1c2luZyBnIHRoaW5rcyB0aGF0IGFuIGl0ZW0gaGFzIGJlZW4gcmVhZCAqKVxuICAgICAgIGIuaW5kIDwtIHN1Y2MgYi5pbmQ7IFNjb25zKHIsIGQpXG4gfCBTbGF6eSBmIC0+IGdldF9kYXRhIGNvdW50IChMYXp5LmZvcmNlIGYpXG5cblxubGV0IHJlYyBwZWVrX2RhdGEgOiB0eXBlIHYuIHYgY2VsbCAtPiB2IG9wdGlvbiA9IGZ1biBzIC0+XG4gKCogY29uc3VsdCB0aGUgZmlyc3QgaXRlbSBvZiBzICopXG4gbWF0Y2ggcy5kYXRhIHdpdGhcbiAgIFNlbXB0eSAtPiBOb25lXG4gfCBTY29ucyAoYSwgXykgLT4gU29tZSBhXG4gfCBTYXBwIChfLCBfKSAtPlxuICAgICBiZWdpbiBtYXRjaCBnZXRfZGF0YSBzLmNvdW50IHMuZGF0YSB3aXRoXG4gICAgICAgU2NvbnMoYSwgXykgYXMgZCAtPiBzLmRhdGEgPC0gZDsgU29tZSBhXG4gICAgIHwgU2VtcHR5IC0+IE5vbmVcbiAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICBlbmRcbiB8IFNsYXp5IGYgLT4gcy5kYXRhIDwtIChMYXp5LmZvcmNlIGYpOyBwZWVrX2RhdGEgc1xuIHwgU2dlbiB7Y3VyciA9IFNvbWUgYX0gLT4gYVxuIHwgU2dlbiBnIC0+IGxldCB4ID0gZy5mdW5jIHMuY291bnQgaW4gZy5jdXJyIDwtIFNvbWUgeDsgeFxuIHwgU2J1ZmZpbyBiIC0+XG4gICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgIGlmIGIubGVuID09IDAgdGhlbiBiZWdpbiBzLmRhdGEgPC0gU2VtcHR5OyBOb25lIGVuZFxuICAgICBlbHNlIFNvbWUgKEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmIGIuaW5kKVxuXG5cbmxldCBwZWVrID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHMgLT4gcGVla19kYXRhIHNcblxuXG5sZXQgcmVjIGp1bmtfZGF0YSA6IHR5cGUgdi4gdiBjZWxsIC0+IHVuaXQgPSBmdW4gcyAtPlxuICBtYXRjaCBzLmRhdGEgd2l0aFxuICAgIFNjb25zIChfLCBkKSAtPiBzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBzLmRhdGEgPC0gZFxuICB8IFNnZW4gKHtjdXJyID0gU29tZSBffSBhcyBnKSAtPiBzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBnLmN1cnIgPC0gTm9uZVxuICB8IFNidWZmaW8gYiAtPlxuICAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgIGlmIGIubGVuID09IDAgdGhlbiBzLmRhdGEgPC0gU2VtcHR5XG4gICAgICBlbHNlIChzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBiLmluZCA8LSBzdWNjIGIuaW5kKVxuICB8IF8gLT5cbiAgICAgIG1hdGNoIHBlZWtfZGF0YSBzIHdpdGhcbiAgICAgICAgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIF8gLT4ganVua19kYXRhIHNcblxuXG5sZXQganVuayA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgZGF0YSAtPiBqdW5rX2RhdGEgZGF0YVxuXG5sZXQgcmVjIG5nZXRfZGF0YSBuIHMgPVxuICBpZiBuIDw9IDAgdGhlbiBbXSwgcy5kYXRhLCAwXG4gIGVsc2VcbiAgICBtYXRjaCBwZWVrX2RhdGEgcyB3aXRoXG4gICAgICBTb21lIGEgLT5cbiAgICAgICAganVua19kYXRhIHM7XG4gICAgICAgIGxldCAoYWwsIGQsIGspID0gbmdldF9kYXRhIChwcmVkIG4pIHMgaW4gYSA6OiBhbCwgU2NvbnMgKGEsIGQpLCBzdWNjIGtcbiAgICB8IE5vbmUgLT4gW10sIHMuZGF0YSwgMFxuXG5cbmxldCBucGVla19kYXRhIG4gcyA9XG4gIGxldCAoYWwsIGQsIGxlbikgPSBuZ2V0X2RhdGEgbiBzIGluXG4gIHMuY291bnQgPC0gKHMuY291bnQgLSBsZW4pO1xuICBzLmRhdGEgPC0gZDtcbiAgYWxcblxuXG5sZXQgbnBlZWsgbiA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBbXVxuICB8IFNvbWUgZCAtPiBucGVla19kYXRhIG4gZFxuXG5sZXQgbmV4dCBzID1cbiAgbWF0Y2ggcGVlayBzIHdpdGhcbiAgICBTb21lIGEgLT4ganVuayBzOyBhXG4gIHwgTm9uZSAtPiByYWlzZSBGYWlsdXJlXG5cblxubGV0IGVtcHR5IHMgPVxuICBtYXRjaCBwZWVrIHMgd2l0aFxuICAgIFNvbWUgXyAtPiByYWlzZSBGYWlsdXJlXG4gIHwgTm9uZSAtPiAoKVxuXG5cbmxldCBpdGVyIGYgc3RybSA9XG4gIGxldCByZWMgZG9fcmVjICgpID1cbiAgICBtYXRjaCBwZWVrIHN0cm0gd2l0aFxuICAgICAgU29tZSBhIC0+IGp1bmsgc3RybTsgaWdub3JlKGYgYSk7IGRvX3JlYyAoKVxuICAgIHwgTm9uZSAtPiAoKVxuICBpblxuICBkb19yZWMgKClcblxuXG4oKiBTdHJlYW0gYnVpbGRpbmcgZnVuY3Rpb25zICopXG5cbmxldCBmcm9tIGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTZ2VuIHtjdXJyID0gTm9uZTsgZnVuYyA9IGZ9fVxuXG5sZXQgb2ZfbGlzdCBsID1cbiAgU29tZSB7Y291bnQgPSAwOyBkYXRhID0gTGlzdC5mb2xkX3JpZ2h0IChmdW4geCBsIC0+IFNjb25zICh4LCBsKSkgbCBTZW1wdHl9XG5cblxubGV0IG9mX3N0cmluZyBzID1cbiAgbGV0IGNvdW50ID0gcmVmIDAgaW5cbiAgZnJvbSAoZnVuIF8gLT5cbiAgICAoKiBXZSBjYW5ub3QgdXNlIHRoZSBpbmRleCBwYXNzZWQgYnkgdGhlIFtmcm9tXSBmdW5jdGlvbiBkaXJlY3RseVxuICAgICAgIGJlY2F1c2UgaXQgcmV0dXJucyB0aGUgY3VycmVudCBzdHJlYW0gY291bnQsIHdpdGggYWJzb2x1dGVseSBub1xuICAgICAgIGd1YXJhbnRlZSB0aGF0IGl0IHdpbGwgc3RhcnQgZnJvbSAwLiBGb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2VcbiAgICAgICBvZiBbU3RyZWFtLmljb25zICdjJyAoU3RyZWFtLmZyb21fc3RyaW5nIFwiYWJcIildLCB0aGUgZmlyc3RcbiAgICAgICBhY2Nlc3MgdG8gdGhlIHN0cmluZyB3aWxsIGJlIG1hZGUgd2l0aCBjb3VudCBbMV0gYWxyZWFkeS5cbiAgICAqKVxuICAgIGxldCBjID0gIWNvdW50IGluXG4gICAgaWYgYyA8IFN0cmluZy5sZW5ndGggc1xuICAgIHRoZW4gKGluY3IgY291bnQ7IFNvbWUgcy5bY10pXG4gICAgZWxzZSBOb25lKVxuXG5cbmxldCBvZl9ieXRlcyBzID1cbiAgbGV0IGNvdW50ID0gcmVmIDAgaW5cbiAgZnJvbSAoZnVuIF8gLT5cbiAgICBsZXQgYyA9ICFjb3VudCBpblxuICAgIGlmIGMgPCBCeXRlcy5sZW5ndGggc1xuICAgIHRoZW4gKGluY3IgY291bnQ7IFNvbWUgKEJ5dGVzLmdldCBzIGMpKVxuICAgIGVsc2UgTm9uZSlcblxuXG5sZXQgb2ZfY2hhbm5lbCBpYyA9XG4gIFNvbWUge2NvdW50ID0gMDtcbiAgICAgICAgZGF0YSA9IFNidWZmaW8ge2ljID0gaWM7IGJ1ZmYgPSBCeXRlcy5jcmVhdGUgNDA5NjsgbGVuID0gMDsgaW5kID0gMH19XG5cblxuKCogU3RyZWFtIGV4cHJlc3Npb25zIGJ1aWxkZXJzICopXG5cbmxldCBpYXBwIGkgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNhcHAgKGRhdGEgaSwgZGF0YSBzKX1cbmxldCBpY29ucyBpIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTY29ucyAoaSwgZGF0YSBzKX1cbmxldCBpc2luZyBpID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2NvbnMgKGksIFNlbXB0eSl9XG5cbmxldCBsYXBwIGYgcyA9XG4gIFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNhcHAgKGRhdGEgKGYgKCkpLCBkYXRhIHMpKSl9XG5cbmxldCBsY29ucyBmIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTY29ucyAoZiAoKSwgZGF0YSBzKSkpfVxubGV0IGxzaW5nIGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTY29ucyAoZiAoKSwgU2VtcHR5KSkpfVxuXG5sZXQgc2VtcHR5ID0gTm9uZVxubGV0IHNsYXp5IGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShkYXRhIChmICgpKSkpfVxuXG4oKiBGb3IgZGVidWdnaW5nIHVzZSAqKVxuXG5sZXQgcmVjIGR1bXAgOiB0eXBlIHYuICh2IC0+IHVuaXQpIC0+IHYgdCAtPiB1bml0ID0gZnVuIGYgcyAtPlxuICBwcmludF9zdHJpbmcgXCJ7Y291bnQgPSBcIjtcbiAgcHJpbnRfaW50IChjb3VudCBzKTtcbiAgcHJpbnRfc3RyaW5nIFwiOyBkYXRhID0gXCI7XG4gIGR1bXBfZGF0YSBmIChkYXRhIHMpO1xuICBwcmludF9zdHJpbmcgXCJ9XCI7XG4gIHByaW50X25ld2xpbmUgKClcbmFuZCBkdW1wX2RhdGEgOiB0eXBlIHYuICh2IC0+IHVuaXQpIC0+IHYgZGF0YSAtPiB1bml0ID0gZnVuIGYgLT5cbiAgZnVuY3Rpb25cbiAgICBTZW1wdHkgLT4gcHJpbnRfc3RyaW5nIFwiU2VtcHR5XCJcbiAgfCBTY29ucyAoYSwgZCkgLT5cbiAgICAgIHByaW50X3N0cmluZyBcIlNjb25zIChcIjtcbiAgICAgIGYgYTtcbiAgICAgIHByaW50X3N0cmluZyBcIiwgXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiKVwiXG4gIHwgU2FwcCAoZDEsIGQyKSAtPlxuICAgICAgcHJpbnRfc3RyaW5nIFwiU2FwcCAoXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkMTtcbiAgICAgIHByaW50X3N0cmluZyBcIiwgXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkMjtcbiAgICAgIHByaW50X3N0cmluZyBcIilcIlxuICB8IFNsYXp5IF8gLT4gcHJpbnRfc3RyaW5nIFwiU2xhenlcIlxuICB8IFNnZW4gXyAtPiBwcmludF9zdHJpbmcgXCJTZ2VuXCJcbiAgfCBTYnVmZmlvIF8gLT4gcHJpbnRfc3RyaW5nIFwiU2J1ZmZpb1wiXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9zdHJlYW1fbWwiLCJjYW1sX2J5dGVzX3Vuc2FmZV9nZXQiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX29ial90YWciLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsX2RhdGEiLCJBc3NlcnRfZmFpbHVyZSIsIkNhbWxpbnRlcm5hbExhenkiLCJTdGRsaWIiLCJTdGRsaWJfTGlzdCIsIkZhaWx1cmUiLCJFcnJvciIsImR1bW15IiwiY291bnQiLCJwYXJhbSIsImRhdGEiLCJmaWxsX2J1ZmYiLCJiIiwiZ2V0X2RhdGEiLCJkIiwiZDIiLCJkMSIsIm1hdGNoIiwiZDExIiwiYSIsImciLCJyIiwicGVla19kYXRhIiwicyIsIngiLCJwZWVrIiwianVua19kYXRhIiwianVuayIsIm5nZXRfZGF0YSIsIm4iLCJrIiwiYWwiLCJucGVlayIsImxlbiIsIm5leHQiLCJlbXB0eSIsIml0ZXIiLCJzdHJtIiwiZnJvbSIsIm9mX2xpc3QiLCJsIiwib2Zfc3RyaW5nIiwiYyIsIm9mX2J5dGVzIiwib2ZfY2hhbm5lbCIsImljIiwiaWFwcCIsImkiLCJpY29ucyIsImlzaW5nIiwibGFwcCIsImxjb25zIiwibHNpbmciLCJjc3RfY291bnQiLCJjc3RfZGF0YSIsImNzdF9TZW1wdHkiLCJjc3RfU2NvbnMiLCJjc3RfU2FwcCIsImNzdF9TbGF6eSIsImNzdF9TZ2VuIiwiY3N0X1NidWZmaW8iLCJzbGF6eSIsImR1bXAiLCJkdW1wX2RhdGEiLCJTdGRsaWJfU3RyZWFt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QUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxZQUFBQyxNQUFBL0Q7QUFBQUEsSUMrTWM7QUFBQTtBQUFBO0FBQUEsZ0NBQUFXLE9BQXlDLE9BQU0sS0FBTixpQkFBTSxNQUEvQztBQUFBLEdBQWtEO0FBQUEsWUFBQXFELEtBQUFoRSxHQUFBeUI7QUFBQUEsSUFLOUQ7QUFBQSxZQUNVO0FBQUEsSUFBVjtBQUFBLElBQ0E7QUFBQSxJQUNBLGFBQVk7QUFBQSxJQUNaO0FBQUEsSUFBZ0IsK0JBQ0E7QUFBQTtBQUFBLFlBQUF3QyxVQUFBakUsR0FBQVc7QUFBQUEsSUFDZCw4QkFFVSx3Q0FleUI7QUFBQSxJQWpCbkM7QUFBQTtBQUFBLFdBQUFLLElBQUEsVUFBQUssSUFBQTtBQUFBLE9BSUU7QUFBQSxPQUNBO0FBQUEsT0FDQTtBQUFBLE9BQ0E7QUFBQSxPQUFhLG1DQVVvQjtBQUFBO0FBQUEsV0FBQUosS0FqQm5DLFVBQUFDLEtBQUE7QUFBQSxPQVVFO0FBQUEsT0FDQTtBQUFBLE9BQ0E7QUFBQSxPQUNBO0FBQUEsT0FBYyxtQ0FJbUI7QUFBQTtBQUFBLE9BRnhCLHVDQUV3QjtBQUFBO0FBQUEsT0FEekIsc0NBQ3lCO0FBQUEsZUFBdEIseUNBQXNCO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQWdEO0FBQUFBLE1EM092QyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjk3OTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9idWZmZXIubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICBQaWVycmUgV2VpcyBhbmQgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4dGVuc2libGUgYnVmZmVycyAqKVxuXG50eXBlIHQgPVxuIHttdXRhYmxlIGJ1ZmZlciA6IGJ5dGVzO1xuICBtdXRhYmxlIHBvc2l0aW9uIDogaW50O1xuICBtdXRhYmxlIGxlbmd0aCA6IGludDtcbiAgaW5pdGlhbF9idWZmZXIgOiBieXRlc31cbigqIEludmFyaWFudHM6IGFsbCBwYXJ0cyBvZiB0aGUgY29kZSBwcmVzZXJ2ZSB0aGUgaW52YXJpYW50cyB0aGF0OlxuICAgLSBbMCA8PSBiLnBvc2l0aW9uIDw9IGIubGVuZ3RoXVxuICAgLSBbYi5sZW5ndGggPSBCeXRlcy5sZW5ndGggYi5idWZmZXJdXG5cbiAgIE5vdGUgaW4gcGFydGljdWxhciB0aGF0IFtiLnBvc2l0aW9uID0gYi5sZW5ndGhdIGlzIGxlZ2FsLFxuICAgaXQgbWVhbnMgdGhhdCB0aGUgYnVmZmVyIGlzIGZ1bGwgYW5kIHdpbGwgaGF2ZSB0byBiZSBleHRlbmRlZFxuICAgYmVmb3JlIGFueSBmdXJ0aGVyIGFkZGl0aW9uLiAqKVxuXG5sZXQgY3JlYXRlIG4gPVxuIGxldCBuID0gaWYgbiA8IDEgdGhlbiAxIGVsc2UgbiBpblxuIGxldCBuID0gaWYgbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBlbHNlIG4gaW5cbiBsZXQgcyA9IEJ5dGVzLmNyZWF0ZSBuIGluXG4ge2J1ZmZlciA9IHM7IHBvc2l0aW9uID0gMDsgbGVuZ3RoID0gbjsgaW5pdGlhbF9idWZmZXIgPSBzfVxuXG5sZXQgY29udGVudHMgYiA9IEJ5dGVzLnN1Yl9zdHJpbmcgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5sZXQgdG9fYnl0ZXMgYiA9IEJ5dGVzLnN1YiBiLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IHN1YiBiIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYi5wb3NpdGlvbiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLnN1YlwiXG4gIGVsc2UgQnl0ZXMuc3ViX3N0cmluZyBiLmJ1ZmZlciBvZnMgbGVuXG5cblxubGV0IGJsaXQgc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgc3Jjb2ZmIDwgMCB8fCBzcmNvZmYgPiBzcmMucG9zaXRpb24gLSBsZW5cbiAgICAgICAgICAgICB8fCBkc3RvZmYgPCAwIHx8IGRzdG9mZiA+IChCeXRlcy5sZW5ndGggZHN0KSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmJsaXRcIlxuICBlbHNlXG4gICAgQnl0ZXMudW5zYWZlX2JsaXQgc3JjLmJ1ZmZlciBzcmNvZmYgZHN0IGRzdG9mZiBsZW5cblxuXG5sZXQgbnRoIGIgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPj0gYi5wb3NpdGlvbiB0aGVuXG4gICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5udGhcIlxuICBlbHNlIEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgb2ZzXG5cblxubGV0IGxlbmd0aCBiID0gYi5wb3NpdGlvblxuXG5sZXQgY2xlYXIgYiA9IGIucG9zaXRpb24gPC0gMFxuXG5sZXQgcmVzZXQgYiA9XG4gIGIucG9zaXRpb24gPC0gMDtcbiAgYi5idWZmZXIgPC0gYi5pbml0aWFsX2J1ZmZlcjtcbiAgYi5sZW5ndGggPC0gQnl0ZXMubGVuZ3RoIGIuYnVmZmVyXG5cbigqIFtyZXNpemUgYiBtb3JlXSBlbnN1cmVzIHRoYXQgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoXSBob2xkc1xuICAgYnkgZHluYW1pY2FsbHkgZXh0ZW5kaW5nIFtiLmJ1ZmZlcl0gaWYgbmVjZXNzYXJ5IC0tIGFuZCB0aHVzXG4gICBpbmNyZWFzaW5nIFtiLmxlbmd0aF0uXG5cbiAgIEluIHBhcnRpY3VsYXIsIGFmdGVyIFtyZXNpemUgYiBtb3JlXSBpcyBjYWxsZWQsIGEgZGlyZWN0IGFjY2VzcyBvZlxuICAgc2l6ZSBbbW9yZV0gYXQgW2IucG9zaXRpb25dIHdpbGwgYWx3YXlzIGJlIGluLWJvdW5kcywgc28gdGhhdFxuICAgKHVuc2FmZV97Z2V0LHNldH0pIG1heSBiZSB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbiopXG5sZXQgcmVzaXplIGIgbW9yZSA9XG4gIGxldCBvbGRfcG9zID0gYi5wb3NpdGlvbiBpblxuICBsZXQgb2xkX2xlbiA9IGIubGVuZ3RoIGluXG4gIGxldCBuZXdfbGVuID0gcmVmIG9sZF9sZW4gaW5cbiAgd2hpbGUgb2xkX3BvcyArIG1vcmUgPiAhbmV3X2xlbiBkbyBuZXdfbGVuIDo9IDIgKiAhbmV3X2xlbiBkb25lO1xuICBpZiAhbmV3X2xlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgaWYgb2xkX3BvcyArIG1vcmUgPD0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgdGhlbiBuZXdfbGVuIDo9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIGVsc2UgZmFpbHdpdGggXCJCdWZmZXIuYWRkOiBjYW5ub3QgZ3JvdyBidWZmZXJcIlxuICBlbmQ7XG4gIGxldCBuZXdfYnVmZmVyID0gQnl0ZXMuY3JlYXRlICFuZXdfbGVuIGluXG4gICgqIFBSIzYxNDg6IGxldCdzIGtlZXAgdXNpbmcgW2JsaXRdIHJhdGhlciB0aGFuIFt1bnNhZmVfYmxpdF0gaW5cbiAgICAgdGhpcyB0cmlja3kgZnVuY3Rpb24gdGhhdCBpcyBzbG93IGFueXdheS4gKilcbiAgQnl0ZXMuYmxpdCBiLmJ1ZmZlciAwIG5ld19idWZmZXIgMCBiLnBvc2l0aW9uO1xuICBiLmJ1ZmZlciA8LSBuZXdfYnVmZmVyO1xuICBiLmxlbmd0aCA8LSAhbmV3X2xlbjtcbiAgYXNzZXJ0IChiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aCk7XG4gIGFzc2VydCAob2xkX3BvcyArIG1vcmUgPD0gYi5sZW5ndGgpO1xuICAoKVxuICAoKiBOb3RlOiB0aGVyZSBhcmUgdmFyaW91cyBzaXR1YXRpb25zIChwcmVlbXB0aXZlIHRocmVhZHMsIHNpZ25hbHMgYW5kXG4gICAgIGdjIGZpbmFsaXplcnMpIHdoZXJlIE9DYW1sIGNvZGUgbWF5IGJlIHJ1biBhc3luY2hyb25vdXNseTsgaW5cbiAgICAgcGFydGljdWxhciwgdGhlcmUgbWF5IGJlIGEgcmFjZSB3aXRoIGFub3RoZXIgdXNlciBvZiBbYl0sIGNoYW5naW5nXG4gICAgIGl0cyBtdXRhYmxlIGZpZWxkcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBbcmVzaXplXSBjYWxsLiBUaGUgQnVmZmVyXG4gICAgIG1vZHVsZSBkb2VzIG5vdCBwcm92aWRlIGFueSBjb3JyZWN0bmVzcyBndWFyYW50ZWUgaWYgdGhhdCBoYXBwZW5zLFxuICAgICBidXQgd2UgbXVzdCBzdGlsbCBlbnN1cmUgdGhhdCB0aGUgZGF0YXN0cnVjdHVyZSBpbnZhcmlhbnRzIGhvbGQgZm9yXG4gICAgIG1lbW9yeS1zYWZldHkgLS0gYXMgd2UgcGxhbiB0byB1c2UgW3Vuc2FmZV97Z2V0LHNldH1dLlxuXG4gICAgIFRoZXJlIGFyZSB0d28gcG90ZW50aWFsIGFsbG9jYXRpb24gcG9pbnRzIGluIHRoaXMgZnVuY3Rpb24sXG4gICAgIFtyZWZdIGFuZCBbQnl0ZXMuY3JlYXRlXSwgYnV0IGFsbCByZWFkcyBhbmQgd3JpdGVzIHRvIHRoZSBmaWVsZHNcbiAgICAgb2YgW2JdIGhhcHBlbiBiZWZvcmUgYm90aCBvZiB0aGVtIG9yIGFmdGVyIGJvdGggb2YgdGhlbS5cblxuICAgICBXZSB0aGVyZWZvcmUgYXNzdW1lIHRoYXQgW2IucG9zaXRpb25dIG1heSBjaGFuZ2UgYXQgdGhlc2UgYWxsb2NhdGlvbnMsXG4gICAgIGFuZCBjaGVjayB0aGF0IHRoZSBbYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGhdIHBvc3Rjb25kaXRpb25cbiAgICAgaG9sZHMgZm9yIGJvdGggdmFsdWVzIG9mIFtiLnBvc2l0aW9uXSwgYmVmb3JlIG9yIGFmdGVyIHRoZSBmdW5jdGlvblxuICAgICBpcyBjYWxsZWQuIE1vcmUgcHJlY2lzZWx5LCB0aGUgZm9sbG93aW5nIGludmFyaWFudHMgbXVzdCBob2xkIGlmIHRoZVxuICAgICBmdW5jdGlvbiByZXR1cm5zIGNvcnJlY3RseSwgaW4gYWRkaXRpb24gdG8gdGhlIHVzdWFsIGJ1ZmZlciBpbnZhcmlhbnRzOlxuICAgICAtIFtvbGQoYi5wb3NpdGlvbikgKyBtb3JlIDw9IG5ldyhiLmxlbmd0aCldXG4gICAgIC0gW25ldyhiLnBvc2l0aW9uKSArIG1vcmUgPD0gbmV3KGIubGVuZ3RoKV1cbiAgICAgLSBbb2xkKGIubGVuZ3RoKSA8PSBuZXcoYi5sZW5ndGgpXVxuXG4gICAgIE5vdGU6IFtiLnBvc2l0aW9uICsgbW9yZSA8PSBvbGQoYi5sZW5ndGgpXSBkb2VzICpub3QqXG4gICAgIGhvbGQgaW4gZ2VuZXJhbCwgYXMgaXQgaXMgcHJlY2lzZWx5IHRoZSBjYXNlIHdoZXJlIHlvdSBuZWVkXG4gICAgIHRvIGNhbGwgW3Jlc2l6ZV0gdG8gaW5jcmVhc2UgW2IubGVuZ3RoXS5cblxuICAgICBOb3RlOiBbYXNzZXJ0XSBhYm92ZSBkb2VzIG5vdCBtZWFuIHRoYXQgd2Uga25vdyB0aGUgY29uZGl0aW9uc1xuICAgICBhbHdheXMgaG9sZCwgYnV0IHRoYXQgdGhlIGZ1bmN0aW9uIG1heSByZXR1cm4gY29ycmVjdGx5XG4gICAgIG9ubHkgaWYgdGhleSBob2xkLlxuXG4gICAgIE5vdGU6IHRoZSBvdGhlciBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgZG9lcyBub3QgbmVlZFxuICAgICB0byBiZSBjaGVja2VkIHdpdGggdGhpcyBsZXZlbCBvZiBzY3J1dGlueSwgZ2l2ZW4gdGhhdCB0aGV5XG4gICAgIHJlYWQvd3JpdGUgdGhlIGJ1ZmZlciBpbW1lZGlhdGVseSBhZnRlciBjaGVja2luZyB0aGF0XG4gICAgIFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aF0gaG9sZCBvciBjYWxsaW5nIFtyZXNpemVdLlxuICAqKVxuXG5sZXQgYWRkX2NoYXIgYiBjID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMTtcbiAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciBwb3MgYztcbiAgYi5wb3NpdGlvbiA8LSBwb3MgKyAxXG5cbmxldCB1Y2hhcl91dGZfOF9ieXRlX2xlbmd0aF9tYXggPSA0XG5sZXQgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heCA9IDRcblxubGV0IHJlYyBhZGRfdXRmXzhfdWNoYXIgYiB1ID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgdWNoYXJfdXRmXzhfYnl0ZV9sZW5ndGhfbWF4O1xuICBsZXQgbiA9IEJ5dGVzLnNldF91dGZfOF91Y2hhciBiLmJ1ZmZlciBwb3MgdSBpblxuICBpZiBuID0gMFxuICB0aGVuIChyZXNpemUgYiB1Y2hhcl91dGZfOF9ieXRlX2xlbmd0aF9tYXg7IGFkZF91dGZfOF91Y2hhciBiIHUpXG4gIGVsc2UgKGIucG9zaXRpb24gPC0gcG9zICsgbilcblxubGV0IHJlYyBhZGRfdXRmXzE2YmVfdWNoYXIgYiB1ID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heDtcbiAgbGV0IG4gPSBCeXRlcy5zZXRfdXRmXzE2YmVfdWNoYXIgYi5idWZmZXIgcG9zIHUgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiAocmVzaXplIGIgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heDsgYWRkX3V0Zl8xNmJlX3VjaGFyIGIgdSlcbiAgZWxzZSAoYi5wb3NpdGlvbiA8LSBwb3MgKyBuKVxuXG5sZXQgcmVjIGFkZF91dGZfMTZsZV91Y2hhciBiIHUgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5sZW5ndGggdGhlbiByZXNpemUgYiB1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4O1xuICBsZXQgbiA9IEJ5dGVzLnNldF91dGZfMTZsZV91Y2hhciBiLmJ1ZmZlciBwb3MgdSBpblxuICBpZiBuID0gMFxuICB0aGVuIChyZXNpemUgYiB1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4OyBhZGRfdXRmXzE2bGVfdWNoYXIgYiB1KVxuICBlbHNlIChiLnBvc2l0aW9uIDwtIHBvcyArIG4pXG5cbmxldCBhZGRfc3Vic3RyaW5nIGIgcyBvZmZzZXQgbGVuID1cbiAgaWYgb2Zmc2V0IDwgMCB8fCBsZW4gPCAwIHx8IG9mZnNldCA+IFN0cmluZy5sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9zdWJzdHJpbmcvYWRkX3N1YmJ5dGVzXCI7XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBCeXRlcy51bnNhZmVfYmxpdF9zdHJpbmcgcyBvZmZzZXQgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW47XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfc3ViYnl0ZXMgYiBzIG9mZnNldCBsZW4gPVxuICBhZGRfc3Vic3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcykgb2Zmc2V0IGxlblxuXG5sZXQgYWRkX3N0cmluZyBiIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBCeXRlcy51bnNhZmVfYmxpdF9zdHJpbmcgcyAwIGIuYnVmZmVyIGIucG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2J5dGVzIGIgcyA9IGFkZF9zdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKVxuXG5sZXQgYWRkX2J1ZmZlciBiIGJzID1cbiAgYWRkX3N1YmJ5dGVzIGIgYnMuYnVmZmVyIDAgYnMucG9zaXRpb25cblxuKCogdGhpcyAocHJpdmF0ZSkgZnVuY3Rpb24gY291bGQgbW92ZSBpbnRvIHRoZSBzdGFuZGFyZCBsaWJyYXJ5ICopXG5sZXQgcmVhbGx5X2lucHV0X3VwX3RvIGljIGJ1ZiBvZnMgbGVuID1cbiAgbGV0IHJlYyBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkIH5vZnMgfnRvX3JlYWQgPVxuICAgIGlmIHRvX3JlYWQgPSAwIHRoZW4gYWxyZWFkeV9yZWFkXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBpbnB1dCBpYyBidWYgb2ZzIHRvX3JlYWQgaW5cbiAgICAgIGlmIHIgPSAwIHRoZW4gYWxyZWFkeV9yZWFkXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBhbHJlYWR5X3JlYWQgPSBhbHJlYWR5X3JlYWQgKyByIGluXG4gICAgICAgIGxldCBvZnMgPSBvZnMgKyByIGluXG4gICAgICAgIGxldCB0b19yZWFkID0gdG9fcmVhZCAtIHIgaW5cbiAgICAgICAgbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZCB+b2ZzIH50b19yZWFkXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW4gbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZDowIH5vZnMgfnRvX3JlYWQ6bGVuXG5cblxubGV0IHVuc2FmZV9hZGRfY2hhbm5lbF91cF90byBiIGljIGxlbiA9XG4gIGlmIGIucG9zaXRpb24gKyBsZW4gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgbGV0IG4gPSByZWFsbHlfaW5wdXRfdXBfdG8gaWMgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW4gaW5cbiAgKCogVGhlIGFzc2VydGlvbiBiZWxvdyBtYXkgZmFpbCBpbiB3ZWlyZCBzY2VuYXJpbyB3aGVyZVxuICAgICB0aHJlYWRlZC9maW5hbGl6ZXIgY29kZSwgcnVuIGFzeW5jaHJvbm91c2x5IGR1cmluZyB0aGVcbiAgICAgW3JlYWxseV9pbnB1dF91cF90b10gY2FsbCwgcmFjZXMgb24gdGhlIGJ1ZmZlcjsgd2UgZG9uJ3QgZW5zdXJlXG4gICAgIGNvcnJlY3RuZXNzIGluIHRoaXMgY2FzZSwgYnV0IG5lZWQgdG8gcHJlc2VydmUgdGhlIGludmFyaWFudHMgZm9yXG4gICAgIG1lbW9yeS1zYWZldHkgKHNlZSBkaXNjdXNzaW9uIG9mIFtyZXNpemVdKS4gKilcbiAgYXNzZXJ0IChiLnBvc2l0aW9uICsgbiA8PSBiLmxlbmd0aCk7XG4gIGIucG9zaXRpb24gPC0gYi5wb3NpdGlvbiArIG47XG4gIG5cblxubGV0IGFkZF9jaGFubmVsIGIgaWMgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBsZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiAgICgqIFBSIzUwMDQgKilcbiAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfY2hhbm5lbFwiO1xuICBsZXQgbiA9IHVuc2FmZV9hZGRfY2hhbm5lbF91cF90byBiIGljIGxlbiBpblxuICAoKiBJdCBpcyBpbnRlbnRpb25hbCB0aGF0IGEgY29uc3VtZXIgY2F0Y2hpbmcgRW5kX29mX2ZpbGVcbiAgICAgd2lsbCBzZWUgdGhlIGRhdGEgd3JpdHRlbiAoc2VlICM2NzE5LCAjNzEzNikuICopXG4gIGlmIG4gPCBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZTtcbiAgKClcblxubGV0IG91dHB1dF9idWZmZXIgb2MgYiA9XG4gIG91dHB1dCBvYyBiLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IGNsb3NpbmcgPSBmdW5jdGlvblxuICB8ICcoJyAtPiAnKSdcbiAgfCAneycgLT4gJ30nXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuKCogb3BlbmluZyBhbmQgY2xvc2luZzogb3BlbiBhbmQgY2xvc2UgY2hhcmFjdGVycywgdHlwaWNhbGx5ICggYW5kIClcbiAgIGs6IGJhbGFuY2Ugb2Ygb3BlbmluZyBhbmQgY2xvc2luZyBjaGFyc1xuICAgczogdGhlIHN0cmluZyB3aGVyZSB3ZSBhcmUgc2VhcmNoaW5nXG4gICBzdGFydDogdGhlIGluZGV4IHdoZXJlIHdlIHN0YXJ0IHRoZSBzZWFyY2guICopXG5sZXQgYWR2YW5jZV90b19jbG9zaW5nIG9wZW5pbmcgY2xvc2luZyBrIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgayBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICAgIGlmIHMuW2ldID0gb3BlbmluZyB0aGVuIGFkdmFuY2UgKGsgKyAxKSAoaSArIDEpIGxpbSBlbHNlXG4gICAgaWYgcy5baV0gPSBjbG9zaW5nIHRoZW5cbiAgICAgIGlmIGsgPSAwIHRoZW4gaSBlbHNlIGFkdmFuY2UgKGsgLSAxKSAoaSArIDEpIGxpbVxuICAgIGVsc2UgYWR2YW5jZSBrIChpICsgMSkgbGltIGluXG4gIGFkdmFuY2UgayBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG5sZXQgYWR2YW5jZV90b19ub25fYWxwaGEgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiBsaW0gZWxzZVxuICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIHwgJzAnIC4uICc5JyB8ICdfJyAtPiBhZHZhbmNlIChpICsgMSkgbGltXG4gICAgfCBfIC0+IGkgaW5cbiAgYWR2YW5jZSBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG4oKiBXZSBhcmUganVzdCBhdCB0aGUgYmVnaW5uaW5nIG9mIGFuIGlkZW50IGluIHMsIHN0YXJ0aW5nIGF0IHN0YXJ0LiAqKVxubGV0IGZpbmRfaWRlbnQgcyBzdGFydCBsaW0gPVxuICBpZiBzdGFydCA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBtYXRjaCBzLltzdGFydF0gd2l0aFxuICAoKiBQYXJlbnRoZXNpemVkIGlkZW50ID8gKilcbiAgfCAnKCcgfCAneycgYXMgYyAtPlxuICAgICBsZXQgbmV3X3N0YXJ0ID0gc3RhcnQgKyAxIGluXG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19jbG9zaW5nIGMgKGNsb3NpbmcgYykgMCBzIG5ld19zdGFydCBpblxuICAgICBTdHJpbmcuc3ViIHMgbmV3X3N0YXJ0IChzdG9wIC0gc3RhcnQgLSAxKSwgc3RvcCArIDFcbiAgKCogUmVndWxhciBpZGVudCAqKVxuICB8IF8gLT5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIChzdGFydCArIDEpIGluXG4gICAgIFN0cmluZy5zdWIgcyBzdGFydCAoc3RvcCAtIHN0YXJ0KSwgc3RvcFxuXG4oKiBTdWJzdGl0dXRlICRpZGVudCwgJChpZGVudCksIG9yICR7aWRlbnR9IGluIHMsXG4gICAgYWNjb3JkaW5nIHRvIHRoZSBmdW5jdGlvbiBtYXBwaW5nIGYuICopXG5sZXQgYWRkX3N1YnN0aXR1dGUgYiBmIHMgPVxuICBsZXQgbGltID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgc3Vic3QgcHJldmlvdXMgaSA9XG4gICAgaWYgaSA8IGxpbSB0aGVuIGJlZ2luXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICckJyBhcyBjdXJyZW50IHdoZW4gcHJldmlvdXMgPSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICckJyAtPlxuICAgICAgICAgbGV0IGogPSBpICsgMSBpblxuICAgICAgICAgbGV0IGlkZW50LCBuZXh0X2kgPSBmaW5kX2lkZW50IHMgaiBsaW0gaW5cbiAgICAgICAgIGFkZF9zdHJpbmcgYiAoZiBpZGVudCk7XG4gICAgICAgICBzdWJzdCAnICcgbmV4dF9pXG4gICAgICB8IGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9PSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgJ1xcXFwnO1xuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJ1xcXFwnIGFzIGN1cnJlbnQgLT5cbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgICAgfCBjdXJyZW50IC0+XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICBlbmQgZWxzZVxuICAgIGlmIHByZXZpb3VzID0gJ1xcXFwnIHRoZW4gYWRkX2NoYXIgYiBwcmV2aW91cyBpblxuICBzdWJzdCAnICcgMFxuXG5sZXQgdHJ1bmNhdGUgYiBsZW4gPVxuICAgIGlmIGxlbiA8IDAgfHwgbGVuID4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJCdWZmZXIudHJ1bmNhdGVcIlxuICAgIGVsc2VcbiAgICAgIGIucG9zaXRpb24gPC0gbGVuXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICgqIE5vdGUgdGhhdCBiLnBvc2l0aW9uIGlzIG5vdCBhIGNvbnN0YW50IGFuZCBjYW5ub3QgYmUgbGlmdGVkIG91dCBvZiBhdXggKilcbiAgICBpZiBpID49IGIucG9zaXRpb24gdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIGIgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAoKiBOb3RlIHRoYXQgYi5wb3NpdGlvbiBpcyBub3QgYSBjb25zdGFudCBhbmQgY2Fubm90IGJlIGxpZnRlZCBvdXQgb2YgYXV4ICopXG4gICAgaWYgaSA+PSBiLnBvc2l0aW9uIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmZlciBpIGluXG4gICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IGFkZF9zZXEgYiBzZXEgPSBTZXEuaXRlciAoYWRkX2NoYXIgYikgc2VxXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBiID0gY3JlYXRlIDMyIGluXG4gIGFkZF9zZXEgYiBpO1xuICBiXG5cbigqKiB7NiBCaW5hcnkgZW5jb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQxNiA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZ1XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50MzIgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MzJ1XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50NjQgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjR1XCJcbmV4dGVybmFsIHN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcbmV4dGVybmFsIHN3YXAzMiA6IGludDMyIC0+IGludDMyID0gXCIlYnN3YXBfaW50MzJcIlxuZXh0ZXJuYWwgc3dhcDY0IDogaW50NjQgLT4gaW50NjQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cblxubGV0IGFkZF9pbnQ4IGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgMSBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDE7XG4gIHVuc2FmZV9zZXRfaW50OCBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MTZfbmUgYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyAyIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgdW5zYWZlX3NldF9pbnQxNiBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MzJfbmUgYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyA0IGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgdW5zYWZlX3NldF9pbnQzMiBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50NjRfbmUgYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyA4IGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgODtcbiAgdW5zYWZlX3NldF9pbnQ2NCBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MTZfbGUgYiB4ID1cbiAgYWRkX2ludDE2X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDE2X2JlIGIgeCA9XG4gIGFkZF9pbnQxNl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwMTYgeClcblxubGV0IGFkZF9pbnQzMl9sZSBiIHggPVxuICBhZGRfaW50MzJfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50MzJfYmUgYiB4ID1cbiAgYWRkX2ludDMyX25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXAzMiB4KVxuXG5sZXQgYWRkX2ludDY0X2xlIGIgeCA9XG4gIGFkZF9pbnQ2NF9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQ2NF9iZSBiIHggPVxuICBhZGRfaW50NjRfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDY0IHgpXG5cbmxldCBhZGRfdWludDggPSBhZGRfaW50OFxubGV0IGFkZF91aW50MTZfbmUgPSBhZGRfaW50MTZfbmVcbmxldCBhZGRfdWludDE2X2xlID0gYWRkX2ludDE2X2xlXG5sZXQgYWRkX3VpbnQxNl9iZSA9IGFkZF9pbnQxNl9iZVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfYnVmZmVyX21sIiwiY2FtbF9ibGl0X3N0cmluZyIsImNhbWxfYnN3YXAxNiIsImNhbWxfYnl0ZXNfdW5zYWZlX2dldCIsImNhbWxfYnl0ZXNfdW5zYWZlX3NldCIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9pbnQzMl9ic3dhcCIsImNhbWxfaW50NjRfYnN3YXAiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX2J5dGVzX2xlbmd0aCIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfc3RyaW5nX2dldCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9CeXRlcyIsIlN0ZGxpYl9TeXMiLCJTdGRsaWJfU2VxIiwiU3RkbGliIiwiU3RkbGliX1N0cmluZyIsIkFzc2VydF9mYWlsdXJlIiwiY3N0X0J1ZmZlcl9zdWIiLCJjc3RfQnVmZmVyX2JsaXQiLCJjc3RfQnVmZmVyX250aCIsImNzdF9CdWZmZXJfYWRkX2Nhbm5vdF9ncm93X2J1ZiIsImR1bW15IiwiY3JlYXRlIiwibiIsInMiLCJjb250ZW50cyIsImIiLCJ0b19ieXRlcyIsInN1YiIsIm9mcyIsImxlbiIsImJsaXQiLCJzcmMiLCJzcmNvZmYiLCJkc3QiLCJkc3RvZmYiLCJudGgiLCJsZW5ndGgiLCJjbGVhciIsInJlc2V0IiwicmVzaXplIiwibW9yZSIsIm9sZF9wb3MiLCJvbGRfbGVuIiwibmV3X2xlbiIsIm5ld19idWZmZXIiLCJhZGRfY2hhciIsImMiLCJwb3MiLCJ1Y2hhcl91dGZfOF9ieXRlX2xlbmd0aF9tYXgiLCJ1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4IiwiY3N0X0J1ZmZlcl9hZGRfc3Vic3RyaW5nX2FkZF9zIiwiY3N0X0J1ZmZlcl9hZGRfY2hhbm5lbCIsImNzdF9CdWZmZXJfdHJ1bmNhdGUiLCJhZGRfdXRmXzhfdWNoYXIiLCJ1IiwiYWRkX3V0Zl8xNmJlX3VjaGFyIiwiYWRkX3V0Zl8xNmxlX3VjaGFyIiwiYWRkX3N1YnN0cmluZyIsIm9mZnNldCIsIm5ld19wb3NpdGlvbiIsImFkZF9zdWJieXRlcyIsImFkZF9zdHJpbmciLCJhZGRfYnl0ZXMiLCJhZGRfYnVmZmVyIiwiYnMiLCJhZGRfY2hhbm5lbCIsImljIiwidG9fcmVhZCIsImJ1ZiIsImFscmVhZHlfcmVhZCIsInIiLCJvdXRwdXRfYnVmZmVyIiwib2MiLCJhZGRfc3Vic3RpdHV0ZSIsImxpbSIsInByZXZpb3VzIiwiaSIsInN0YXJ0Iiwib3BlbmluZyIsIm1hdGNoIiwic3RvcCIsIm5ld19zdGFydCIsImsiLCJjbG9zaW5nIiwibmV4dF9pIiwiaWRlbnQiLCJ0cnVuY2F0ZSIsInRvX3NlcSIsImF1eCIsInBhcmFtIiwieCIsInRvX3NlcWkiLCJhZGRfc2VxIiwic2VxIiwib2Zfc2VxIiwiYWRkX2ludDgiLCJhZGRfaW50MTZfbmUiLCJhZGRfaW50MzJfbmUiLCJhZGRfaW50NjRfbmUiLCJhZGRfaW50MTZfbGUiLCJhZGRfaW50MTZfYmUiLCJhZGRfaW50MzJfbGUiLCJhZGRfaW50MzJfYmUiLCJhZGRfaW50NjRfbGUiLCJhZGRfaW50NjRfYmUiLCJTdGRsaWJfQnVmZmVyIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFB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LHdCQUFnQztBQUFBLElBQ2hDO0FBQUEsSUFBc0M7QUFBQTtBQUFBLEdBQ1o7QUFBQSxZQUFBc0MsYUFBQXhFLEdBQUFpRTtBQUFBQSxRQUFBL0IsZUFHMUI7QUFBQSxJQUNBLHdCQUFnQztBQUFBLElBQ2hDO0FBQUEsSUFBc0M7QUFBQTtBQUFBLEdBQ1o7QUFBQSxZQUFBdUMsYUFBQXpFLEdBQUFpRTtBQUFBQSxRQUFBL0IsZUFHMUI7QUFBQSxJQUNBLHdCQUFnQztBQUFBLElBQ2hDO0FBQUEsSUFBc0M7QUFBQTtBQUFBLEdBQ1o7QUFBQSxZQUFBd0MsYUFBQTFFLEdBQUFpRTtBQUFBQSxRQUFBLElBRzFCLGlCQUF1QztBQUFBLElBQXZDLHlCQUF1RDtBQUFBO0FBQUEsWUFBQVUsYUFBQTNFLEdBQUFpRTtBQUFBQSxRQUFBQSxNQUd2RCxxQkFBOEM7QUFBQSxJQUE5QywyQkFBdUQ7QUFBQTtBQUFBLFlBQUFXLGFBQUE1RSxHQUFBaUU7QUFBQUEsUUFBQSxJQUd2RCxpQkFBdUM7QUFBQSxJQUF2Qyx5QkFBdUQ7QUFBQTtBQUFBLFlBQUFZLGFBQUE3RSxHQUFBaUU7QUFBQUEsUUFBQUEsTUFHdkQscUJBQThDO0FBQUEsSUFBOUMsMkJBQXVEO0FBQUE7QUFBQSxZQUFBYSxhQUFBOUUsR0FBQWlFO0FBQUFBLFFBQUEsSUFHdkQsaUJBQXVDO0FBQUEsSUFBdkMseUJBQXVEO0FBQUE7QUFBQSxZQUFBYyxhQUFBL0UsR0FBQWlFO0FBQUFBLFFBQUFBLE1BR3ZELHFCQUE4QztBQUFBLElBQTlDLDJCQUF1RDtBQUFBO0FBQUE7QUFBQSxJQUFBZTtBQUFBQSxNRDdYekQiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMDIzNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3NcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgKCogVG9vbHMgdG8gbWFuaXB1bGF0ZSBzY2FubmluZyBzZXQgb2YgY2hhcnMgKHNlZSAlWy4uLl0pICopXG5cbnR5cGUgbXV0YWJsZV9jaGFyX3NldCA9IGJ5dGVzXG5cbigqIENyZWF0ZSBhIGZyZXNoLCBlbXB0eSwgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBjcmVhdGVfY2hhcl9zZXQgKCkgPSBCeXRlcy5tYWtlIDMyICdcXDAwMCdcblxuKCogQWRkIGEgY2hhciBpbiBhIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgQnl0ZXMuc2V0IGNoYXJfc2V0IHN0cl9pbmRcbiAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChCeXRlcy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbG9yIG1hc2spKVxuXG5sZXQgZnJlZXplX2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgQnl0ZXMudG9fc3RyaW5nIGNoYXJfc2V0XG5cbigqIENvbXB1dGUgdGhlIGNvbXBsZW1lbnQgb2YgYSBjaGFyIHNldC4gKilcbmxldCByZXZfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBsZXQgY2hhcl9zZXQnID0gY3JlYXRlX2NoYXJfc2V0ICgpIGluXG4gIGZvciBpID0gMCB0byAzMSBkb1xuICAgIEJ5dGVzLnNldCBjaGFyX3NldCcgaVxuICAgICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoU3RyaW5nLmdldCBjaGFyX3NldCBpKSBseG9yIDB4RkYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBjaGFyX3NldCdcblxuKCogUmV0dXJuIHRydWUgaWYgYSBgYycgaXMgaW4gYGNoYXJfc2V0Jy4gKilcbmxldCBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIChpbnRfb2ZfY2hhciAoU3RyaW5nLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsYW5kIG1hc2spIDw+IDBcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIElnbm9yZWQgcGFyYW0gY29udmVyc2lvbiAqKVxuXG4oKiBHQURUIHVzZWQgdG8gYWJzdHJhY3QgYW4gZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXIuICopXG4oKiBTZWUgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0LiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFyYW1fZm9ybWF0X2ViYiA9IFBhcmFtX2Zvcm1hdF9FQkIgOlxuICAgICgneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFyYW1fZm9ybWF0X2ViYlxuXG4oKiBDb21wdXRlIGEgcGFkZGluZyBhc3NvY2lhdGVkIHRvIGEgcGFkX29wdGlvbiAoc2VlIFwiJV80MmRcIikuICopXG5sZXQgcGFkX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gTm9fcGFkZGluZ1xuICB8IFNvbWUgd2lkdGggLT4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcblxuKCogQ29tcHV0ZSBhIHByZWNpc2lvbiBhc3NvY2lhdGVkIHRvIGEgcHJlY19vcHRpb24gKHNlZSBcIiVfLjQyZlwiKS4gKilcbmxldCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0ID0gbWF0Y2ggcHJlY19vcHQgd2l0aFxuICB8IE5vbmUgLT4gTm9fcHJlY2lzaW9uXG4gIHwgU29tZSBuZGVjIC0+IExpdF9wcmVjaXNpb24gbmRlY1xuXG4oKiBUdXJuIGFuIGlnbm9yZWQgcGFyYW0gaW50byBpdHMgZXF1aXZhbGVudCBub3QtaWdub3JlZCBmb3JtYXQgbm9kZS4gKilcbigqIFVzZWQgZm9yIGZvcm1hdCBwcmV0dHktcHJpbnRpbmcgYW5kIFNjYW5mLiAqKVxubGV0IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPiAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFyYW1fZm9ybWF0X2ViYiA9XG5mdW4gaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENoYXIgZm10KVxuICB8IElnbm9yZWRfY2FtbF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9jaGFyIGZtdClcbiAgfCBJZ25vcmVkX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU3RyaW5nIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfc3RyaW5nIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfaW50IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChJbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQzMiAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDMyIChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfbmF0aXZlaW50IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoTmF0aXZlaW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50NjQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQ2NCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2Zsb2F0IChwYWRfb3B0LCBwcmVjX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRmxvYXQgKChGbG9hdF9mbGFnXywgRmxvYXRfZiksXG4gICAgICAgICAgICAgIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9ib29sIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChCb29sIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoUmVhZGVyIGZtdClcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdClcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVHlwZXMgKilcblxudHlwZSAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW4gPVxuICB8IEFjY19vcGVuX3RhZyBvZiAoJ2IsICdjKSBhY2NcbiAgfCBBY2Nfb3Blbl9ib3ggb2YgKCdiLCAnYykgYWNjXG5cbigqIFJldmVyc2VkIGxpc3Qgb2YgcHJpbnRpbmcgYXRvbXMuICopXG4oKiBVc2VkIHRvIGFjY3VtdWxhdGUgcHJpbnRmIGFyZ3VtZW50cy4gKilcbmFuZCAoJ2IsICdjKSBhY2MgPVxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCBvZiAoJ2IsICdjKSBhY2MgKiBmb3JtYXR0aW5nX2xpdFxuICAgICAgKCogU3BlY2lhbCBmbXR0aW5nIChib3gpICopXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIG9mICgnYiwgJ2MpIGFjYyAqICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlblxuICAgICAgKCogU3BlY2lhbCBmbXR0aW5nIChib3gpICopXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogTGl0ZXJhbCBzdHJpbmcgKilcbiAgfCBBY2NfY2hhcl9saXRlcmFsICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBMaXRlcmFsIGNoYXIgKilcbiAgfCBBY2NfZGF0YV9zdHJpbmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBHZW5lcmF0ZWQgc3RyaW5nICopXG4gIHwgQWNjX2RhdGFfY2hhciAgICAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogR2VuZXJhdGVkIGNoYXIgKilcbiAgfCBBY2NfZGVsYXkgICAgICAgICAgb2YgKCdiLCAnYykgYWNjICogKCdiIC0+ICdjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRGVsYXllZCBwcmludGluZyAoJWEsICV0KSAqKVxuICB8IEFjY19mbHVzaCAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgICAgICAgICAgICAgICgqIEZsdXNoICopXG4gIHwgQWNjX2ludmFsaWRfYXJnICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZ1xuICAgICAgKCogUmFpc2UgSW52YWxpZF9hcmd1bWVudCBtc2cgKilcbiAgfCBFbmRfb2ZfYWNjXG5cbigqIExpc3Qgb2YgaGV0ZXJvZ2VuZW91cyB2YWx1ZXMuICopXG4oKiBVc2VkIHRvIGFjY3VtdWxhdGUgc2NhbmYgY2FsbGJhY2sgYXJndW1lbnRzLiAqKVxudHlwZSAoJ2EsICdiKSBoZXRlcl9saXN0ID1cbiAgfCBDb25zIDogJ2MgKiAoJ2EsICdiKSBoZXRlcl9saXN0IC0+ICgnYyAtPiAnYSwgJ2IpIGhldGVyX2xpc3RcbiAgfCBOaWwgOiAoJ2IsICdiKSBoZXRlcl9saXN0XG5cbigqIEV4aXN0ZW50aWFsIEJsYWNrIEJveGVzLiAqKVxuKCogVXNlZCB0byBhYnN0cmFjdCBzb21lIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVycy4gKilcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10dHkuICopXG4oKiBTZWUgdGhlIHR5cGVfcGFkZGluZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiID0gUGFkZGluZ19mbXR0eV9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10dHkuICopXG4oKiBTZWUgdGhlIHR5cGVfcGFkcHJlYyBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiID0gUGFkcHJlY19mbXR0eV9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAneikgcHJlY2lzaW9uICogKCd6LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYiA9IFBhZGRpbmdfZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcGFkZGluZyAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiID0gUHJlY2lzaW9uX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZHByZWNfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdwLCAnYiwgJ2MsICdlLCAnZikgcGFkcHJlY19mbXRfZWJiID0gUGFkcHJlY19mbXRfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3AgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdwLCAnYiwgJ2MsICdlLCAnZikgcGFkcHJlY19mbXRfZWJiXG5cbigqIEFic3RyYWN0IHRoZSAnYSBhbmQgJ2QgcGFyYW1ldGVycyBvZiBhbiBmbXQuICopXG4oKiBPdXRwdXQgdHlwZSBvZiB0aGUgZm9ybWF0IHBhcnNpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYiwgJ2MsICdlLCAnZikgZm10X2ViYiA9IEZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgnYiwgJ2MsICdlLCAnZikgZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9mb3JtYXRfZ2VuIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYiA9IEZtdF9mbXR0eV9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10ICpcbiAgICAgKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X2ZtdF9lYmIgPSBGbXR0eV9mbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdHR5ICpcbiAgICAgKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgYWxsIGZtdHR5IHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBmb3JtYXQgdHlwZXMuICopXG50eXBlIGZtdHR5X2ViYiA9IEZtdHR5X0VCQiA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPiBmbXR0eV9lYmJcblxuKCogQWJzdHJhY3QgYWxsIHBhZGRpbmcgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHBhZGRpbmdzLiAqKVxudHlwZSBwYWRkaW5nX2ViYiA9IFBhZGRpbmdfRUJCIDogKCdhLCAnYikgcGFkZGluZyAtPiBwYWRkaW5nX2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcHJlY2lzaW9uIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwcmVjaXNpb25zLiAqKVxudHlwZSBwcmVjaXNpb25fZWJiID0gUHJlY2lzaW9uX0VCQiA6ICgnYSwgJ2IpIHByZWNpc2lvbiAtPiBwcmVjaXNpb25fZWJiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29uc3RhbnRzICopXG5cbigqIERlZmF1bHQgcHJlY2lzaW9uIGZvciBmbG9hdCBwcmludGluZy4gKilcbmxldCBkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udiA9XG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cgfCBGbG9hdF9oIHwgRmxvYXRfSFxuICB8IEZsb2F0X0NGIC0+IC02XG4gICgqIEZvciAlaCAlSCBhbmQgJSNGIGZvcm1hdHMsIGEgbmVnYXRpdmUgcHJlY2lzaW9uIG1lYW5zIFwiYXMgbWFueSBkaWdpdHMgYXNcbiAgICAgbmVjZXNzYXJ5XCIuICBGb3IgdGhlIG90aGVyIEZQIGZvcm1hdHMsIHdlIHRha2UgdGhlIGFic29sdXRlIHZhbHVlXG4gICAgIG9mIHRoZSBwcmVjaXNpb24sIGhlbmNlIDYgZGlnaXRzIGJ5IGRlZmF1bHQuICopXG4gIHwgRmxvYXRfRiAtPiAxMlxuICAoKiBEZWZhdWx0IHByZWNpc2lvbiBmb3IgT0NhbWwgZmxvYXQgcHJpbnRpbmcgKCVGKS4gKilcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBFeHRlcm5hbHMgKilcblxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0OiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5leHRlcm5hbCBmb3JtYXRfaW50OiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQzMjogc3RyaW5nIC0+IGludDMyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQzMl9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X25hdGl2ZWludDogc3RyaW5nIC0+IG5hdGl2ZWludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfbmF0aXZlaW50X2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfaW50NjQ6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmV4dGVybmFsIGhleHN0cmluZ19vZl9mbG9hdDogZmxvYXQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2hleHN0cmluZ19vZl9mbG9hdFwiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAoKiBUb29scyB0byBwcmV0dHktcHJpbnQgZm9ybWF0cyAqKVxuXG4oKiBUeXBlIG9mIGV4dGVuc2libGUgY2hhcmFjdGVyIGJ1ZmZlcnMuICopXG50eXBlIGJ1ZmZlciA9IHtcbiAgbXV0YWJsZSBpbmQgOiBpbnQ7XG4gIG11dGFibGUgYnl0ZXMgOiBieXRlcztcbn1cblxuKCogQ3JlYXRlIGEgZnJlc2ggYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jcmVhdGUgaW5pdF9zaXplID0geyBpbmQgPSAwOyBieXRlcyA9IEJ5dGVzLmNyZWF0ZSBpbml0X3NpemUgfVxuXG4oKiBDaGVjayBzaXplIG9mIHRoZSBidWZmZXIgYW5kIGdyb3cgaXQgaWYgbmVlZGVkLiAqKVxubGV0IGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiBvdmVyaGVhZCA9XG4gIGxldCBsZW4gPSBCeXRlcy5sZW5ndGggYnVmLmJ5dGVzIGluXG4gIGxldCBtaW5fbGVuID0gYnVmLmluZCArIG92ZXJoZWFkIGluXG4gIGlmIG1pbl9sZW4gPiBsZW4gdGhlbiAoXG4gICAgbGV0IG5ld19sZW4gPSBJbnQubWF4IChsZW4gKiAyKSBtaW5fbGVuIGluXG4gICAgbGV0IG5ld19zdHIgPSBCeXRlcy5jcmVhdGUgbmV3X2xlbiBpblxuICAgIEJ5dGVzLmJsaXQgYnVmLmJ5dGVzIDAgbmV3X3N0ciAwIGxlbjtcbiAgICBidWYuYnl0ZXMgPC0gbmV3X3N0cjtcbiAgKVxuXG4oKiBBZGQgdGhlIGNoYXJhY3RlciBgYycgdG8gdGhlIGJ1ZmZlciBgYnVmJy4gKilcbmxldCBidWZmZXJfYWRkX2NoYXIgYnVmIGMgPVxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgMTtcbiAgQnl0ZXMuc2V0IGJ1Zi5ieXRlcyBidWYuaW5kIGM7XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIDFcblxuKCogQWRkIHRoZSBzdHJpbmcgYHMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHMgPVxuICBsZXQgc3RyX2xlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgc3RyX2xlbjtcbiAgU3RyaW5nLmJsaXQgcyAwIGJ1Zi5ieXRlcyBidWYuaW5kIHN0cl9sZW47XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIHN0cl9sZW5cblxuKCogR2V0IHRoZSBjb250ZW50IG9mIHRoZSBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NvbnRlbnRzIGJ1ZiA9XG4gIEJ5dGVzLnN1Yl9zdHJpbmcgYnVmLmJ5dGVzIDAgYnVmLmluZFxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgY29udmVyc2lvbiB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfaWNvbnYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X2QgfCBJbnRfcGQgfCBJbnRfc2QgfCBJbnRfQ2QgLT4gJ2QnIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2lcbiAgfCBJbnRfQ2kgLT4gJ2knIHwgSW50X3ggfCBJbnRfQ3ggLT4gJ3gnIHwgSW50X1ggfCBJbnRfQ1ggLT4gJ1gnIHwgSW50X29cbiAgfCBJbnRfQ28gLT4gJ28nIHwgSW50X3UgfCBJbnRfQ3UgLT4gJ3UnXG5cbigqIENvbnZlcnQgYSBmbG9hdCBjb252ZXJzaW9uIHRvIGNoYXIuICopXG4oKiBgY0YnIHdpbGwgYmUgJ0YnIGZvciBkaXNwbGF5aW5nIGZvcm1hdCBhbmQgJ2cnIHRvIGNhbGwgbGliYyBwcmludGYgKilcbmxldCBjaGFyX29mX2Zjb252ID8oY0Y9J0YnKSBmY29udiA9IG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZiAtPiAnZicgfCBGbG9hdF9lIC0+ICdlJ1xuICB8IEZsb2F0X0UgLT4gJ0UnIHwgRmxvYXRfZyAtPiAnZydcbiAgfCBGbG9hdF9HIC0+ICdHJyB8IEZsb2F0X0YgLT4gY0ZcbiAgfCBGbG9hdF9oIC0+ICdoJyB8IEZsb2F0X0ggLT4gJ0gnXG4gIHwgRmxvYXRfQ0YgLT4gJ0YnXG5cblxuKCogQ29udmVydCBhIHNjYW5uaW5nIGNvdW50ZXIgdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2NvdW50ZXIgY291bnRlciA9IG1hdGNoIGNvdW50ZXIgd2l0aFxuICB8IExpbmVfY291bnRlciAgLT4gJ2wnXG4gIHwgQ2hhcl9jb3VudGVyICAtPiAnbidcbiAgfCBUb2tlbl9jb3VudGVyIC0+ICdOJ1xuXG4oKioqKVxuXG4oKiBQcmludCBhIGNoYXJfc2V0IGluIGEgYnVmZmVyIHdpdGggdGhlIE9DYW1sIGZvcm1hdCBsZXhpY2FsIGNvbnZlbnRpb24uICopXG5sZXQgYnByaW50X2NoYXJfc2V0IGJ1ZiBjaGFyX3NldCA9XG4gIGxldCByZWMgcHJpbnRfc3RhcnQgc2V0ID1cbiAgICBsZXQgaXNfYWxvbmUgYyA9XG4gICAgICBsZXQgYmVmb3JlLCBhZnRlciA9IENoYXIuKGNociAoY29kZSBjIC0gMSksIGNociAoY29kZSBjICsgMSkpIGluXG4gICAgICBpc19pbl9jaGFyX3NldCBzZXQgY1xuICAgICAgJiYgbm90IChpc19pbl9jaGFyX3NldCBzZXQgYmVmb3JlICYmIGlzX2luX2NoYXJfc2V0IHNldCBhZnRlcikgaW5cbiAgICBpZiBpc19hbG9uZSAnXScgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICddJztcbiAgICBwcmludF9vdXQgc2V0IDE7XG4gICAgaWYgaXNfYWxvbmUgJy0nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLSc7XG4gIGFuZCBwcmludF9vdXQgc2V0IGkgPVxuICAgIGlmIGkgPCAyNTYgdGhlblxuICAgICAgaWYgaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBpKSB0aGVuIHByaW50X2ZpcnN0IHNldCBpXG4gICAgICBlbHNlIHByaW50X291dCBzZXQgKGkgKyAxKVxuICBhbmQgcHJpbnRfZmlyc3Qgc2V0IGkgPVxuICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgIHwgJ1xcMjU1JyAtPiBwcmludF9jaGFyIGJ1ZiAyNTU7XG4gICAgfCAnXScgfCAnLScgLT4gcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIHwgXyAtPiBwcmludF9zZWNvbmQgc2V0IChpICsgMSk7XG4gIGFuZCBwcmludF9zZWNvbmQgc2V0IGkgPVxuICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlblxuICAgICAgbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgICB8ICdcXDI1NScgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU0O1xuICAgICAgICBwcmludF9jaGFyIGJ1ZiAyNTU7XG4gICAgICB8ICddJyB8ICctJyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgICAgfCBfIHdoZW4gbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IChpICsgMSkpKSAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgICBwcmludF9jaGFyIGJ1ZiBpO1xuICAgICAgICBwcmludF9vdXQgc2V0IChpICsgMik7XG4gICAgICB8IF8gLT5cbiAgICAgICAgcHJpbnRfaW4gc2V0IChpIC0gMSkgKGkgKyAyKTtcbiAgICBlbHNlIChcbiAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgKVxuICBhbmQgcHJpbnRfaW4gc2V0IGkgaiA9XG4gICAgaWYgaiA9IDI1NiB8fCBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaikpIHRoZW4gKFxuICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChpbnRfb2ZfY2hhciAnLScpO1xuICAgICAgcHJpbnRfY2hhciBidWYgKGogLSAxKTtcbiAgICAgIGlmIGogPCAyNTYgdGhlbiBwcmludF9vdXQgc2V0IChqICsgMSk7XG4gICAgKSBlbHNlXG4gICAgICBwcmludF9pbiBzZXQgaSAoaiArIDEpO1xuICBhbmQgcHJpbnRfY2hhciBidWYgaSA9IG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgIHwgJyUnIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICB8ICdAJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQCc7XG4gICAgfCBjICAgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjO1xuICBpblxuICBidWZmZXJfYWRkX2NoYXIgYnVmICdbJztcbiAgcHJpbnRfc3RhcnQgKFxuICAgIGlmIGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0ICdcXDAwMCdcbiAgICB0aGVuICggYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXic7IHJldl9jaGFyX3NldCBjaGFyX3NldCApXG4gICAgZWxzZSBjaGFyX3NldFxuICApO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmICddJ1xuXG4oKioqKVxuXG4oKiBQcmludCBhIHBhZHR5IGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcGFkdHkgYnVmIHBhZHR5ID0gbWF0Y2ggcGFkdHkgd2l0aFxuICB8IExlZnQgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nXG4gIHwgUmlnaHQgLT4gKClcbiAgfCBaZXJvcyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcwJ1xuXG4oKiBQcmludCB0aGUgJ18nIG9mIGFuIGlnbm9yZWQgZmxhZyBpZiBuZWVkZWQuICopXG5sZXQgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWcgPVxuICBpZiBpZ25fZmxhZyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ18nXG5cbigqKiopXG5cbmxldCBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIHdpZHRoIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyB3aWR0aClcblxuKCoqKilcblxuKCogUHJpbnQgcGFkZGluZyBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZGRpbmcgOiB0eXBlIGEgYiAuIGJ1ZmZlciAtPiAoYSwgYikgcGFkZGluZyAtPiB1bml0ID1cbmZ1biBidWYgcGFkIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPiAoKVxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgbikgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBuKTtcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSAtPlxuICAgIGJwcmludF9wYWR0eSBidWYgcGFkdHk7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKidcblxuKCogUHJpbnQgcHJlY2lzaW9uIGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcHJlY2lzaW9uIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHByZWNpc2lvbiAtPiB1bml0ID1cbiAgZnVuIGJ1ZiBwcmVjIC0+IG1hdGNoIHByZWMgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiAtPiAoKVxuICB8IExpdF9wcmVjaXNpb24gbiAtPlxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy4nO1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBuKTtcbiAgfCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiLipcIlxuXG4oKioqKVxuXG4oKiBQcmludCB0aGUgb3B0aW9uYWwgJysnLCAnICcgb3IgJyMnIGFzc29jaWF0ZWQgdG8gYW4gaW50IGNvbnZlcnNpb24uICopXG5sZXQgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9wZCB8IEludF9waSAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcrJ1xuICB8IEludF9zZCB8IEludF9zaSAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEludF9DeCB8IEludF9DWCB8IEludF9DbyB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnIydcbiAgfCBJbnRfZCB8IEludF9pIHwgSW50X3ggfCBJbnRfWCB8IEludF9vIHwgSW50X3UgLT4gKClcblxuKCogUHJpbnQgYW4gY29tcGxldGUgaW50IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJTMuKmRcIikuICopXG5sZXQgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqIFByaW50IGEgY29tcGxldGUgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjIGMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKioqKVxuXG4oKiBQcmludCB0aGUgb3B0aW9uYWwgJysnLCAnICcgYW5kL29yICcjJyBhc3NvY2lhdGVkIHRvIGEgZmxvYXQgY29udmVyc2lvbi4gKilcbmxldCBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnYgPVxuICBiZWdpbiBtYXRjaCBmc3QgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ZsYWdfcCAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcrJ1xuICB8IEZsb2F0X2ZsYWdfcyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEZsb2F0X2ZsYWdfIC0+ICgpIGVuZDtcbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9DRiAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcjJ1xuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HXG4gIHwgRmxvYXRfRiB8IEZsb2F0X2ggfCBGbG9hdF9IIC0+ICgpXG5cbigqIFByaW50IGEgY29tcGxldGUgZmxvYXQgZm9ybWF0IGluIGEgYnVmZmVyIChleDogXCIlKyouM2ZcIikuICopXG5sZXQgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9mY29udiBmY29udilcblxuKCogQ29tcHV0ZSB0aGUgbGl0ZXJhbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBGb3JtYXR0aW5nX2xpdC4gKilcbigqIFVzZWQgYnkgUHJpbnRmIGFuZCBTY2FuZiB3aGVyZSBmb3JtYXR0aW5nIGlzIG5vdCBpbnRlcnByZXRlZC4gKilcbmxldCBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQgPSBtYXRjaCBmb3JtYXR0aW5nX2xpdCB3aXRoXG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgLT4gXCJAXVwiXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgLT4gXCJAfVwiXG4gIHwgQnJlYWsgKHN0ciwgXywgXykgICAgLT4gc3RyXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgLT4gXCJAP1wiXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgLT4gXCJAXFxuXCJcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAtPiBcIkAuXCJcbiAgfCBNYWdpY19zaXplIChzdHIsIF8pICAtPiBzdHJcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAtPiBcIkBAXCJcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAtPiBcIkAlXCJcbiAgfCBTY2FuX2luZGljIGMgLT4gXCJAXCIgXiAoU3RyaW5nLm1ha2UgMSBjKVxuXG4oKioqKVxuXG4oKiBQcmludCBhIGxpdGVyYWwgY2hhciBpbiBhIGJ1ZmZlciwgZXNjYXBlICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyID0gbWF0Y2ggY2hyIHdpdGhcbiAgfCAnJScgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSVcIlxuICB8IF8gLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjaHJcblxuKCogUHJpbnQgYSBsaXRlcmFsIHN0cmluZyBpbiBhIGJ1ZmZlciwgZXNjYXBlIGFsbCAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyID1cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggc3RyIC0gMSBkb1xuICAgIGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIHN0ci5baV1cbiAgZG9uZVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgcHJldHR5LXByaW50aW5nICopXG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IHR5cGUgKGFuIGZtdHR5KSBpbiBhIGJ1ZmZlci4gKilcbmxldCByZWMgYnByaW50X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggaSBqIGsgbCAuXG4gICAgYnVmZmVyIC0+IChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gdW5pdCA9XG5mdW4gYnVmIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlY1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFN0cmluZ190eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVzXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWlcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQzMl90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IE5hdGl2ZWludF90eSByZXN0IC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVuaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGbG9hdF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlZlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEJvb2xfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVCXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWFcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBUaGV0YV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIldFwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFueV90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiU/XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgUmVhZGVyX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlX3JcIjtcbiAgICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBGb3JtYXRfYXJnX3R5IChzdWJfZm10dHksIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXtcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJX1cIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZvcm1hdF9zdWJzdF90eSAoc3ViX2ZtdHR5LCBfLCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUoXCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEVuZF9vZl9mbXR0eSAtPiAoKVxuXG4oKioqKVxuXG5sZXQgcmVjIGludF9vZl9jdXN0b21fYXJpdHkgOiB0eXBlIGEgYiBjIC5cbiAgKGEsIGIsIGMpIGN1c3RvbV9hcml0eSAtPiBpbnQgPVxuICBmdW5jdGlvblxuICB8IEN1c3RvbV96ZXJvIC0+IDBcbiAgfCBDdXN0b21fc3VjYyB4IC0+IDEgKyBpbnRfb2ZfY3VzdG9tX2FyaXR5IHhcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2ZtdCBidWYgZm10ID1cbiAgbGV0IHJlYyBmbXRpdGVyIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGJvb2wgLT4gdW5pdCA9XG4gIGZ1biBmbXQgaWduX2ZsYWcgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncyc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnUyc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdsJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnTCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBDaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0InO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQWxwaGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYSc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3QnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAtPlxuICAgICAgZm9yIF9pID0gMSB0byBpbnRfb2ZfY3VzdG9tX2FyaXR5IGFyaXR5IGRvXG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnPyc7XG4gICAgICBkb25lO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgUmVhZGVyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3InOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGbHVzaCByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlIVwiO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG4gICAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNocjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAneyc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnfSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJygnO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyknO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHdpZHRoX29wdDsgYnByaW50X2NoYXJfc2V0IGJ1ZiBjaGFyX3NldDtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2NvdW50ZXIgY291bnRlcik7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIFwiMGNcIjsgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICBsZXQgUGFyYW1fZm9ybWF0X0VCQiBmbXQnID0gcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0IGluXG4gICAgICBmbXRpdGVyIGZtdCcgdHJ1ZTtcblxuICAgIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCk7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGZtdGluZ19nZW4gd2l0aFxuICAgICAgfCBPcGVuX3RhZyAoRm9ybWF0IChfLCBzdHIpKSAtPlxuICAgICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCJAe1wiOyBidWZmZXJfYWRkX3N0cmluZyBidWYgc3RyXG4gICAgICB8IE9wZW5fYm94IChGb3JtYXQgKF8sIHN0cikpIC0+XG4gICAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIkBbXCI7IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzdHJcbiAgICAgIGVuZDtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgRW5kX29mX2Zvcm1hdCAtPiAoKVxuXG4gIGluIGZtdGl0ZXIgZm10IGZhbHNlXG5cbigqKiopXG5cbigqIENvbnZlcnQgYSBmb3JtYXQgdG8gc3RyaW5nLiAqKVxubGV0IHN0cmluZ19vZl9mbXQgZm10ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdCBidWYgZm10O1xuICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGUgZXh0cmFjdGlvbiAqKVxuXG50eXBlIChfLCBfKSBlcSA9IFJlZmwgOiAoJ2EsICdhKSBlcVxuXG4oKiBJbnZhcmlhbnQ6IHRoaXMgZnVuY3Rpb24gaXMgdGhlIGlkZW50aXR5IG9uIHZhbHVlcy5cblxuICAgSW4gcGFydGljdWxhciwgaWYgKHR5MSwgdHkyKSBoYXZlIGVxdWFsIHZhbHVlcywgdGhlblxuICAgKHRyYW5zIChzeW1tIHR5MSkgdHkyKSByZXNwZWN0cyB0aGUgJ3RyYW5zJyBwcmVjb25kaXRpb24uICopXG5sZXQgcmVjIHN5bW0gOiB0eXBlIGExIGIxIGMxIGQxIGUxIGYxIGEyIGIyIGMyIGQyIGUyIGYyIC5cbiAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsXG4gICAgYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10dHlfcmVsXG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+IENoYXJfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnRfdHkgcmVzdCAtPiBJbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+IEludDMyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPiBJbnQ2NF90eSAoc3ltbSByZXN0KVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+IE5hdGl2ZWludF90eSAoc3ltbSByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT4gRmxvYXRfdHkgKHN5bW0gcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT4gQm9vbF90eSAoc3ltbSByZXN0KVxuICB8IFN0cmluZ190eSByZXN0IC0+IFN0cmluZ190eSAoc3ltbSByZXN0KVxuICB8IFRoZXRhX3R5IHJlc3QgLT4gVGhldGFfdHkgKHN5bW0gcmVzdClcbiAgfCBBbHBoYV90eSByZXN0IC0+IEFscGhhX3R5IChzeW1tIHJlc3QpXG4gIHwgQW55X3R5IHJlc3QgLT4gQW55X3R5IChzeW1tIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT4gUmVhZGVyX3R5IChzeW1tIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPiBJZ25vcmVkX3JlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBzeW1tIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MiwgdHkxLCBzeW1tIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG5sZXQgcmVjIGZtdHR5X3JlbF9kZXQgOiB0eXBlIGExIGIgYyBkMSBlMSBmMSBhMiBkMiBlMiBmMiAuXG4gIChhMSwgYiwgYywgZDEsIGUxLCBmMSxcbiAgIGEyLCBiLCBjLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoKGYxLCBmMikgZXEgLT4gKGExLCBhMikgZXEpXG4gICogKChhMSwgYTIpIGVxIC0+IChmMSwgZjIpIGVxKVxuICAqICgoZTEsIGUyKSBlcSAtPiAoZDEsIGQyKSBlcSlcbiAgKiAoKGQxLCBkMikgZXEgLT4gKGUxLCBlMikgZXEpXG49IGZ1bmN0aW9uXG4gIHwgRW5kX29mX2ZtdHR5IC0+XG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcblxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuICB8IEZvcm1hdF9hcmdfdHkgKF90eSwgcmVzdCkgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIGxldCBhZywgZ2EsIGRqLCBqZCA9IGZtdHR5X3JlbF9kZXQgdHkgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIGxldCBSZWZsID0gYWcgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBnYSBSZWZsIGluIGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIGxldCBSZWZsID0gZGogUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBqZCBSZWZsIGluIGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuXG4oKiBQcmVjb25kaXRpb246IHdlIGFzc3VtZSB0aGF0IHRoZSB0d28gZm10dHlfcmVsIGFyZ3VtZW50cyBoYXZlIGVxdWFsXG4gICB2YWx1ZXMgKGF0IHBvc3NpYmx5IGRpc3RpbmN0IHR5cGVzKTsgdGhpcyBpbnZhcmlhbnQgY29tZXMgZnJvbSB0aGUgd2F5XG4gICBmbXR0eV9yZWwgd2l0bmVzc2VzIGFyZSBwcm9kdWNlZCBieSB0aGUgdHlwZS1jaGVja2VyXG5cbiAgIFRoZSBjb2RlIGJlbG93IHVzZXMgKGFzc2VydCBmYWxzZSkgd2hlbiB0aGlzIGFzc3VtcHRpb24gaXMgYnJva2VuLiBUaGVcbiAgIGNvZGUgcGF0dGVybiBpcyB0aGUgZm9sbG93aW5nOlxuXG4gICAgIHwgRm9vIHgsIEZvbyB5IC0+XG4gICAgICAgKCogY2FzZSB3aGVyZSBpbmRlZWQgYm90aCB2YWx1ZXNcbiAgICAgICAgICBzdGFydCB3aXRoIGNvbnN0cnVjdG9yIEZvbyAqKVxuICAgICB8IEZvbyBfLCBfXG4gICAgIHwgXywgRm9vIF8gLT5cbiAgICAgICAoKiBkaWZmZXJlbnQgaGVhZCBjb25zdHJ1Y3RvcnM6IGJyb2tlbiBwcmVjb25kaXRpb24gKilcbiAgICAgICBhc3NlcnQgZmFsc2VcbiopXG5hbmQgdHJhbnMgOiB0eXBlXG4gIGExIGIxIGMxIGQxIGUxIGYxXG4gIGEyIGIyIGMyIGQyIGUyIGYyXG4gIGEzIGIzIGMzIGQzIGUzIGYzXG4uXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuLT4gKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHlfcmVsXG49IGZ1biB0eTEgdHkyIC0+IG1hdGNoIHR5MSwgdHkyIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QxLCBDaGFyX3R5IHJlc3QyIC0+IENoYXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFN0cmluZ190eSByZXN0MSwgU3RyaW5nX3R5IHJlc3QyIC0+IFN0cmluZ190eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQm9vbF90eSByZXN0MSwgQm9vbF90eSByZXN0MiAtPiBCb29sX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnRfdHkgcmVzdDEsIEludF90eSByZXN0MiAtPiBJbnRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDMyX3R5IHJlc3QxLCBJbnQzMl90eSByZXN0MiAtPiBJbnQzMl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50NjRfdHkgcmVzdDEsIEludDY0X3R5IHJlc3QyIC0+IEludDY0X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdDEsIE5hdGl2ZWludF90eSByZXN0MiAtPiBOYXRpdmVpbnRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZsb2F0X3R5IHJlc3QxLCBGbG9hdF90eSByZXN0MiAtPiBGbG9hdF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG5cbiAgfCBBbHBoYV90eSByZXN0MSwgQWxwaGFfdHkgcmVzdDIgLT4gQWxwaGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEFscGhhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQWxwaGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IFRoZXRhX3R5IHJlc3QxLCBUaGV0YV90eSByZXN0MiAtPiBUaGV0YV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgVGhldGFfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBUaGV0YV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgQW55X3R5IHJlc3QxLCBBbnlfdHkgcmVzdDIgLT4gQW55X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbnlfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBBbnlfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IFJlYWRlcl90eSByZXN0MSwgUmVhZGVyX3R5IHJlc3QyIC0+IFJlYWRlcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgUmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgUmVhZGVyX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0MSwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDIgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBJZ25vcmVkX3JlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRm9ybWF0X2FyZ190eSAodHkxLCByZXN0MSksIEZvcm1hdF9hcmdfdHkgKHR5MiwgcmVzdDIpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHJhbnMgdHkxIHR5MiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X2FyZ190eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEZvcm1hdF9hcmdfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkxMiwgcmVzdDEpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkyMSwgdHkyMiwgcmVzdDIpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxMikgdHkyMSBpblxuICAgIGxldCBfLCBmMiwgXywgZjQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgbGV0IFJlZmwgPSBmMiBSZWZsIGluXG4gICAgbGV0IFJlZmwgPSBmNCBSZWZsIGluXG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTExLCB0eTIyLCB0cmFucyByZXN0MSByZXN0MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfc3Vic3RfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEVuZF9vZl9mbXR0eSwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuICB8IEVuZF9vZl9mbXR0eSwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBFbmRfb2ZfZm10dHkgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCByZWMgZm10dHlfb2ZfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZvcm1hdHRpbmdfZ2VuIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBmb3JtYXR0aW5nX2dlbiAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSkgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcblxuKCogRXh0cmFjdCB0aGUgdHlwZSByZXByZXNlbnRhdGlvbiAoYW4gZm10dHkpIG9mIGEgZm9ybWF0LiAqKVxuYW5kIGZtdHR5X29mX2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcblxuICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50MzJfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgTmF0aXZlaW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKE5hdGl2ZWludF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBJbnQ2NCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnQ2NF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChGbG9hdF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcblxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IENhbWxfY2hhciByZXN0ICAgICAgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEJvb2wgKHBhZCwgcmVzdCkgICAgICAgICAgIC0+XG4gICAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoQm9vbF90eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IEFscGhhIHJlc3QgICAgICAgICAgICAgICAgIC0+IEFscGhhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAtPiBUaGV0YV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgICAgLT4gZm10dHlfb2ZfY3VzdG9tIGFyaXR5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBSZWFkZXIgcmVzdCAgICAgICAgICAgICAgICAtPiBSZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eSwgdHksIGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPiBTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+IEludF90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgLT4gZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAgLT5cbiAgICBjb25jYXRfZm10dHkgKGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIGZtdGluZ19nZW4pIChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgIC0+IEVuZF9vZl9mbXR0eVxuXG5hbmQgZm10dHlfb2ZfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAoeSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGFyaXR5IGZtdHR5IC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBmbXR0eVxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+IEFueV90eSAoZm10dHlfb2ZfY3VzdG9tIGFyaXR5IGZtdHR5KVxuXG4oKiBFeHRyYWN0IHRoZSBmbXR0eSBvZiBhbiBpZ25vcmVkIHBhcmFtZXRlciBmb2xsb3dlZCBieSB0aGUgcmVzdCBvZlxuICAgdGhlIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IGNvbmNhdF9mbXR0eSBmbXR0eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IElnbm9yZWRfcmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcGFkZGluZyBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpzXCIpLiAqKVxuYW5kIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcGFkZGluZyBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcGFkZGluZyBfIC0+IEludF90eSBmbXR0eVxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcHJlY2lzaW9uIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpLiopXG5hbmQgZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgICB8IE5vX3ByZWNpc2lvbiAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3ByZWNpc2lvbiBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcHJlY2lzaW9uICAgLT4gSW50X3R5IGZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGluZyAqKVxuXG4oKiBFeGNlcHRpb24gcmFpc2VkIHdoZW4gYSBmb3JtYXQgZG9lcyBub3QgbWF0Y2ggYSBnaXZlbiBmb3JtYXQgdHlwZS4gKilcbmV4Y2VwdGlvbiBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBwYWRkaW5nLiAqKVxuKCogVGFrZSBhbiBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgdGhlIGludGVnZXIgc2hvdWxkIGJlIGtlcHQgYXMgYXJndW1lbnQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZGRpbmcgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkZGluZ19mbXR0eV9lYmIgPVxuZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQsIGZtdHR5IHdpdGhcbiAgfCBOb19wYWRkaW5nLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChOb19wYWRkaW5nLCBmbXR0eSlcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChMaXRfcGFkZGluZyAocGFkdHksdyksZm10dHkpXG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEludF90eSByZXN0IC0+IFBhZGRpbmdfZm10dHlfRUJCIChBcmdfcGFkZGluZyBwYWR0eSxyZXN0KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBDb252ZXJ0IGEgKHVwYWRkaW5nLCB1cHJlY2lzaW9uKSB0byBhIChwYWRkaW5nLCBwcmVjaXNpb24pLiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiBuZWVkZWQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZHByZWMgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSB6IC5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHopIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkcHJlY19mbXR0eV9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMsIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBOb19wcmVjaXNpb24sIHJlc3QpXG4gIHwgTGl0X3ByZWNpc2lvbiBwLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIExpdF9wcmVjaXNpb24gcCwgcmVzdClcbiAgfCBBcmdfcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBJbnRfdHkgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBBcmdfcHJlY2lzaW9uLCByZXN0KVxuICB8IF8sIFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogSWYgdHlwaW5nIHN1Y2NlZWQsIGdlbmVyYXRlIGEgY29weSBvZiB0aGUgZm9ybWF0IHdpdGggdGhlIHNhbWVcbiAgICB0eXBlIHBhcmFtZXRlcnMgYXMgdGhlIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgcmVjIHR5cGVfZm9ybWF0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IHdpdGhcbiAgfCBGbXRfZm10dHlfRUJCIChmbXQnLCBFbmRfb2ZfZm10dHkpIC0+IGZtdCdcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0X2dlbiA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIGZtdCwgZm10dHkgd2l0aFxuICB8IENoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBDYW1sX2NoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDYW1sX2NoYXIgZm10JywgZm10dHknKVxuICB8IFN0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChTdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBDYW1sX3N0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChDYW1sX3N0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDMyX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQ2NF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEZsb2F0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBCb29sIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBCb29sX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChCb29sIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmx1c2ggZm10X3Jlc3QsIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRmx1c2ggZm10JywgZm10dHknKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZ19saXRlcmFsIChzdHIsIGZtdCcpLCBmbXR0eScpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyX2xpdGVyYWwgKGNociwgZm10JyksIGZtdHR5JylcblxuICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1Yl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eScsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eTEsIF9zdWJfZm10dHkyLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5MSkgdGhlblxuICAgICAgcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9XG4gICAgICB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgKGVyYXNlX3JlbCBmbXR0eV9yZXN0KVxuICAgIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkxLCBmbXQnKSwgZm10dHknKVxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgQWxwaGEgZm10X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQWxwaGEgZm10JywgZm10dHknKVxuICB8IFRoZXRhIGZtdF9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFRoZXRhIGZtdCcsIGZtdHR5JylcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZ19nZW4sIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfZm9ybWF0dGluZ19nZW4gZm9ybWF0dGluZ19nZW4gZm10X3Jlc3QgZm10dHlfcmVzdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgZm10X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFJlYWRlciBmbXQnLCBmbXR0eScpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10X3Jlc3QpLCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQnKSwgZm10dHknKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10JyksIGZtdHR5JylcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtIGlnbiByZXN0IGZtdHR5X3Jlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QgLT4gRm10X2ZtdHR5X0VCQiAoRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdClcblxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYTEgYTMgYjEgYjMgYzEgYzMgZDEgZDMgZTEgZTIgZTMgZjEgZjIgZjMgLlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChmMSwgYjEsIGMxLCBlMSwgZTIsIGYyKSBmbXQgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHkgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10X2ZtdHR5X2ViYiA9XG5mdW4gZm9ybWF0dGluZ19nZW4gZm10MCBmbXR0eTAgLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG5cbigqIFR5cGUgYW4gSWdub3JlZF9wYXJhbSBub2RlIGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHAgcSB4IHkgeiB0IHUgdiBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIHksIHosIHQsIHEsIHApIGlnbm9yZWQgLT5cbiAgICAocCwgeSwgeiwgcSwgdSwgdikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGlnbiBmbXQgZm10dHkgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludCBfICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDMyIF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCBfICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDY0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zsb2F0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIChJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkpIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eScsIEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eSBmbXQgZm10dHkgaW5cbiAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10JyksXG4gICAgICAgICAgICAgICAgICAgZm10dHknKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+IChcbiAgICBtYXRjaCBmbXR0eSB3aXRoXG4gICAgfCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSA6IHR5cGUgYTEgYTIgYjEgYjIgYzEgYzIgZDEgZDIgZTEgZTIgZjEgZjIgLlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZDIsIGEyKSBpZ25vcmVkIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdCAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eSAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBpZ24gZm10IGZtdHR5IC0+XG4gIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSBpblxuICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChpZ24sIGZtdCcpLCBmbXR0eScpXG5cbigqIFR5cGluZyBvZiB0aGUgY29tcGxleCBjYXNlOiBcIiVfKC4uLiUpXCIuICopXG5hbmQgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gOiB0eXBlIHcgeCB5IHogcCBzIHQgdSBhIGIgYyBkIGUgZiAuXG4gICAgKHcsIHgsIHksIHosIHMsIHApIGZtdHR5IC0+XG4gICAgKHAsIHgsIHksIHMsIHQsIHUpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlfZm10X2ViYiA9XG5mdW4gc3ViX2ZtdHR5IGZtdCBmbXR0eSAtPiBtYXRjaCBzdWJfZm10dHksIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQzMl90eSBzdWJfZm10dHlfcmVzdCwgSW50MzJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCwgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDY0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBGbG9hdF90eSBzdWJfZm10dHlfcmVzdCwgRmxvYXRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QsIEJvb2xfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQm9vbF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBUaGV0YV90eSBzdWJfZm10dHlfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHksIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViMl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViMl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIHN1Yl9mbXR0eV9yZXN0JyksIGZtdCcpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5LCAgc3ViMl9mbXR0eSwgIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICAoKiBUT0RPIGRlZmluZSBGbXR0eV9yZWxfRUJCIHRvIHJlbW92ZSB0aG9zZSBlcmFzZV9yZWwgKilcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBzdWJfZm10dHknID0gdHJhbnMgKHN5bW0gc3ViMV9mbXR0eScpIHN1YjJfZm10dHknIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgc3ViX2ZtdHR5JyBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIChlcmFzZV9yZWwgc3ViX2ZtdHR5X3Jlc3QpIGZtdCBmbXR0eV9yZXN0XG4gICAgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bW0gc3ViX2ZtdHR5X3Jlc3QnKSxcbiAgICAgICAgICAgICAgICAgICBmbXQnKVxuICB8IEVuZF9vZl9mbXR0eSwgZm10dHkgLT5cbiAgICBGbXR0eV9mbXRfRUJCIChFbmRfb2ZfZm10dHksIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFRoaXMgaW1wbGVtZW50YXRpb24gb2YgYHJlY2FzdGAgaXMgYSBiaXQgZGlzYXBwb2ludGluZy4gVGhlXG4gICBpbnZhcmlhbnQgcHJvdmlkZWQgYnkgdGhlIHR5cGUgYXJlIHZlcnkgc3Ryb25nOiB0aGUgaW5wdXQgZm9ybWF0J3NcbiAgIHR5cGUgaXMgaW4gcmVsYXRpb24gdG8gdGhlIG91dHB1dCB0eXBlJ3MgYXMgd2l0bmVzc2VkIGJ5IHRoZVxuICAgZm10dHlfcmVsIGFyZ3VtZW50LiBPbmUgd291bGQgYXQgZmlyc3QgZXhwZWN0IHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgIHRvdGFsLCBhbmQgaW1wbGVtZW50YWJsZSBieSBleGhhdXN0aXZlIHBhdHRlcm4gbWF0Y2hpbmcuIEluc3RlYWQsXG4gICB3ZSByZXVzZSB0aGUgaGlnaGx5IHBhcnRpYWwgYW5kIG11Y2ggbGVzcyB3ZWxsLWRlZmluZWQgZnVuY3Rpb25cbiAgIGB0eXBlX2Zvcm1hdGAgdGhhdCBoYXMgbG9zdCBhbGwga25vd2xlZGdlIG9mIHRoZSBjb3JyZXNwb25kZW5jZVxuICAgYmV0d2VlbiB0aGUgYXJndW1lbnQncyB0eXBlcy5cblxuICAgQmVzaWRlcyB0aGUgZmFjdCB0aGF0IHRoaXMgZnVuY3Rpb24gcmV1c2VzIGEgbG90IG9mIHRoZVxuICAgYHR5cGVfZm9ybWF0YCBsb2dpYyAoZWcuOiBzZWVpbmcgSW50X3R5IGluIHRoZSBmbXR0eSBwYXJhbWV0ZXIgZG9lc1xuICAgbm90IGxldCB5b3UgbWF0Y2ggb24gSW50IG9ubHksIGFzIHlvdSBtYXkgaW4gZmFjdCBoYXZlIEZsb2F0XG4gICAoQXJnX3BhZGRpbmcsIC4uLikgKFwiJS4qZFwiKSBiZWdpbm5pbmcgd2l0aCBhbiBJbnRfdHkpLCBpdCBpcyBhbHNvXG4gICBhIHBhcnRpYWwgZnVuY3Rpb24sIGJlY2F1c2UgdGhlIHR5cGluZyBpbmZvcm1hdGlvbiBpbiBhIGZvcm1hdCBpc1xuICAgbm90IHF1aXRlIGVub3VnaCB0byByZWNvbnN0cnVjdCBpdCB1bmFtYmlndW91c2x5LiBGb3IgZXhhbXBsZSwgdGhlXG4gICBmb3JtYXQgdHlwZXMgb2YgXCIlZCVfclwiIGFuZCBcIiVfciVkXCIgaGF2ZSB0aGUgc2FtZSBmb3JtYXQ2XG4gICBwYXJhbWV0ZXJzLCBidXQgdGhleSBhcmUgbm90IGF0IGFsbCBleGNoYW5nZWFibGUsIGFuZCBwdXR0aW5nIG9uZVxuICAgaW4gcGxhY2Ugb2YgdGhlIG90aGVyIG11c3QgcmVzdWx0IGluIGEgZHluYW1pYyBmYWlsdXJlLlxuXG4gICBHaXZlbiB0aGF0OlxuICAgLSB3ZSdkIGhhdmUgdG8gZHVwbGljYXRlIGEgbG90IG9mIG5vbi10cml2aWFsIHR5cGluZyBsb2dpYyBmcm9tIHR5cGVfZm9ybWF0XG4gICAtIHRoaXMgd291bGRuJ3QgZXZlbiBlbGltaW5hdGUgKGFsbCkgdGhlIGR5bmFtaWMgZmFpbHVyZXNcbiAgIHdlIGRlY2lkZWQgdG8ganVzdCByZXVzZSB0eXBlX2Zvcm1hdCBkaXJlY3RseSBmb3Igbm93LlxuKilcbmxldCByZWNhc3QgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPlxuICB0eXBlX2Zvcm1hdCBmbXQgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFByaW50aW5nIHRvb2xzICopXG5cbigqIEFkZCBwYWRkaW5nIHNwYWNlcyBhcm91bmQgYSBzdHJpbmcuICopXG5sZXQgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggc3RyID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCwgcGFkdHkgPVxuICAgIGFicyB3aWR0aCxcbiAgICAoKiB3aGlsZSBsaXRlcmFsIHBhZGRpbmcgd2lkdGhzIGFyZSBhbHdheXMgbm9uLW5lZ2F0aXZlLFxuICAgICAgIGR5bmFtaWNhbGx5LXNldCB3aWR0aHMgKEFyZ19wYWRkaW5nLCBlZy4gJSpkKSBtYXkgYmUgbmVnYXRpdmU7XG4gICAgICAgd2UgaW50ZXJwcmV0IHRob3NlIGFzIHNwZWNpZnlpbmcgYSBwYWRkaW5nLXRvLXRoZS1sZWZ0OyB0aGlzXG4gICAgICAgbWVhbnMgdGhhdCAnMCcgbWF5IGdldCBkcm9wcGVkIGV2ZW4gaWYgaXQgd2FzIGV4cGxpY2l0bHkgc2V0LFxuICAgICAgIGJ1dDpcbiAgICAgICAtIHRoaXMgaXMgd2hhdCB0aGUgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRvZXMsIGFuZFxuICAgICAgICAgd2UgcHJlc2VydmUgY29tcGF0aWJpbGl0eSBpZiBwb3NzaWJsZVxuICAgICAgIC0gd2UgY291bGQgb25seSBzaWduYWwgdGhpcyBpc3N1ZSBieSBmYWlsaW5nIGF0IHJ1bnRpbWUsXG4gICAgICAgICB3aGljaCBpcyBub3QgdmVyeSBuaWNlLi4uICopXG4gICAgaWYgd2lkdGggPCAwIHRoZW4gTGVmdCBlbHNlIHBhZHR5IGluXG4gIGlmIHdpZHRoIDw9IGxlbiB0aGVuIHN0ciBlbHNlXG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2Ugd2lkdGggKGlmIHBhZHR5ID0gWmVyb3MgdGhlbiAnMCcgZWxzZSAnICcpIGluXG4gICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgIHwgTGVmdCAgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzIDAgbGVuXG4gICAgfCBSaWdodCAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMCAmJiAoc3RyLlswXSA9ICcrJyB8fCBzdHIuWzBdID0gJy0nIHx8IHN0ci5bMF0gPSAnICcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDAgc3RyLlswXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAod2lkdGggLSBsZW4gKyAxKSAobGVuIC0gMSlcbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMSAmJiBzdHIuWzBdID0gJzAnICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAod2lkdGggLSBsZW4gKyAyKSAobGVuIC0gMilcbiAgICB8IFplcm9zIC0+XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICBlbmQ7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQWRkICcwJyBwYWRkaW5nIHRvIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24uICopXG5sZXQgZml4X2ludF9wcmVjaXNpb24gcHJlYyBzdHIgPVxuICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBtYXRjaCBzdHIuWzBdIHdpdGhcbiAgfCAoJysnIHwgJy0nIHwgJyAnKSBhcyBjIHdoZW4gcHJlYyArIDEgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDEpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMCBjO1xuICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAocHJlYyAtIGxlbiArIDIpIChsZW4gLSAxKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyB3aGVuIHByZWMgKyAyID4gbGVuICYmIGxlbiA+IDEgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDIpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAocHJlYyAtIGxlbiArIDQpIChsZW4gLSAyKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyB3aGVuIHByZWMgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSBwcmVjICcwJyBpblxuICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAocHJlYyAtIGxlbikgbGVuO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgXyAtPlxuICAgIHN0clxuXG4oKiBFc2NhcGUgYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpbmcgY29udmVudGlvbi4gKilcbmxldCBzdHJpbmdfdG9fY2FtbF9zdHJpbmcgc3RyID1cbiAgbGV0IHN0ciA9IFN0cmluZy5lc2NhcGVkIHN0ciBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcXCInIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2ludC9pbnQzMi9uYXRpdmVpbnQvaW50NjQgZmlyc3QgYXJndW1lbnRcbiAgIGZyb20gYW4gaW50X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2ljb252ID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVkXCIgfCBJbnRfcGQgLT4gXCIlK2RcIiB8IEludF9zZCAtPiBcIiUgZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlaVwiIHwgSW50X3BpIC0+IFwiJStpXCIgfCBJbnRfc2kgLT4gXCIlIGlcIlxuICB8IEludF94IC0+IFwiJXhcIiB8IEludF9DeCAtPiBcIiUjeFwiXG4gIHwgSW50X1ggLT4gXCIlWFwiIHwgSW50X0NYIC0+IFwiJSNYXCJcbiAgfCBJbnRfbyAtPiBcIiVvXCIgfCBJbnRfQ28gLT4gXCIlI29cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJXVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252TCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlTGRcIiB8IEludF9wZCAtPiBcIiUrTGRcIiB8IEludF9zZCAtPiBcIiUgTGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJUxpXCIgfCBJbnRfcGkgLT4gXCIlK0xpXCIgfCBJbnRfc2kgLT4gXCIlIExpXCJcbiAgfCBJbnRfeCAtPiBcIiVMeFwiIHwgSW50X0N4IC0+IFwiJSNMeFwiXG4gIHwgSW50X1ggLT4gXCIlTFhcIiB8IEludF9DWCAtPiBcIiUjTFhcIlxuICB8IEludF9vIC0+IFwiJUxvXCIgfCBJbnRfQ28gLT4gXCIlI0xvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVMdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZsID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVsZFwiIHwgSW50X3BkIC0+IFwiJStsZFwiIHwgSW50X3NkIC0+IFwiJSBsZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlbGlcIiB8IEludF9waSAtPiBcIiUrbGlcIiB8IEludF9zaSAtPiBcIiUgbGlcIlxuICB8IEludF94IC0+IFwiJWx4XCIgfCBJbnRfQ3ggLT4gXCIlI2x4XCJcbiAgfCBJbnRfWCAtPiBcIiVsWFwiIHwgSW50X0NYIC0+IFwiJSNsWFwiXG4gIHwgSW50X28gLT4gXCIlbG9cIiB8IEludF9DbyAtPiBcIiUjbG9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJWx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udm4gPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJW5kXCIgfCBJbnRfcGQgLT4gXCIlK25kXCIgfCBJbnRfc2QgLT4gXCIlIG5kXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVuaVwiIHwgSW50X3BpIC0+IFwiJStuaVwiIHwgSW50X3NpIC0+IFwiJSBuaVwiXG4gIHwgSW50X3ggLT4gXCIlbnhcIiB8IEludF9DeCAtPiBcIiUjbnhcIlxuICB8IEludF9YIC0+IFwiJW5YXCIgfCBJbnRfQ1ggLT4gXCIlI25YXCJcbiAgfCBJbnRfbyAtPiBcIiVub1wiIHwgSW50X0NvIC0+IFwiJSNub1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlbnVcIlxuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2Zsb2F0IGZpcnN0IGFyZ3VtZW50IGZyb20gYSBmbG9hdF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjID1cbiAgICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gICAgbGV0IHN5bWIgPSBjaGFyX29mX2Zjb252IH5jRjonZycgZmNvbnYgaW5cbiAgICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICAgIGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udjtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgcHJlYyk7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBzeW1iO1xuICAgIGJ1ZmZlcl9jb250ZW50cyBidWZcblxubGV0IHRyYW5zZm9ybV9pbnRfYWx0IGljb252IHMgPVxuICBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X0NkIHwgSW50X0NpIHwgSW50X0N1IC0+XG4gICAgbGV0IGRpZ2l0cyA9XG4gICAgICBsZXQgbiA9IHJlZiAwIGluXG4gICAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgICB8ICcwJy4uJzknIC0+IGluY3IgblxuICAgICAgICB8IF8gLT4gKClcbiAgICAgIGRvbmU7XG4gICAgICAhblxuICAgIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCBzICsgKGRpZ2l0cyAtIDEpIC8gMykgaW5cbiAgICBsZXQgcG9zID0gcmVmIDAgaW5cbiAgICBsZXQgcHV0IGMgPSBCeXRlcy5zZXQgYnVmICFwb3MgYzsgaW5jciBwb3MgaW5cbiAgICBsZXQgbGVmdCA9IHJlZiAoKGRpZ2l0cyAtIDEpIG1vZCAzICsgMSkgaW5cbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgJzAnLi4nOScgYXMgYyAtPlxuICAgICAgICAgIGlmICFsZWZ0ID0gMCB0aGVuIChwdXQgJ18nOyBsZWZ0IDo9IDMpOyBkZWNyIGxlZnQ7IHB1dCBjXG4gICAgICB8IGMgLT4gcHV0IGNcbiAgICBkb25lO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYnVmXG4gIHwgXyAtPiBzXG5cbigqIENvbnZlcnQgYW4gaW50ZWdlciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gYSBjb252ZXJzaW9uLiAqKVxubGV0IGNvbnZlcnRfaW50IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludCAoZm9ybWF0X29mX2ljb252IGljb252KSBuKVxubGV0IGNvbnZlcnRfaW50MzIgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50MzIgKGZvcm1hdF9vZl9pY29udmwgaWNvbnYpIG4pXG5sZXQgY29udmVydF9uYXRpdmVpbnQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfbmF0aXZlaW50IChmb3JtYXRfb2ZfaWNvbnZuIGljb252KSBuKVxubGV0IGNvbnZlcnRfaW50NjQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50NjQgKGZvcm1hdF9vZl9pY29udkwgaWNvbnYpIG4pXG5cbigqIENvbnZlcnQgYSBmbG9hdCB0byBzdHJpbmcuICopXG4oKiBGaXggc3BlY2lhbCBjYXNlIG9mIFwiT0NhbWwgZmxvYXQgZm9ybWF0XCIuICopXG5sZXQgY29udmVydF9mbG9hdCBmY29udiBwcmVjIHggPVxuICBsZXQgaGV4ICgpID1cbiAgICBsZXQgc2lnbiA9XG4gICAgICBtYXRjaCBmc3QgZmNvbnYgd2l0aFxuICAgICAgfCBGbG9hdF9mbGFnX3AgLT4gJysnXG4gICAgICB8IEZsb2F0X2ZsYWdfcyAtPiAnICdcbiAgICAgIHwgXyAtPiAnLScgaW5cbiAgICBoZXhzdHJpbmdfb2ZfZmxvYXQgeCBwcmVjIHNpZ24gaW5cbiAgbGV0IGFkZF9kb3RfaWZfbmVlZGVkIHN0ciA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGV0IHJlYyBpc192YWxpZCBpID1cbiAgICAgIGlmIGkgPSBsZW4gdGhlbiBmYWxzZSBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICB8ICcuJyB8ICdlJyB8ICdFJyAtPiB0cnVlXG4gICAgICAgIHwgXyAtPiBpc192YWxpZCAoaSArIDEpIGluXG4gICAgaWYgaXNfdmFsaWQgMCB0aGVuIHN0ciBlbHNlIHN0ciBeIFwiLlwiIGluXG4gIGxldCBjYW1sX3NwZWNpYWxfdmFsIHN0ciA9IG1hdGNoIGNsYXNzaWZ5X2Zsb2F0IHggd2l0aFxuICAgIHwgRlBfbm9ybWFsIHwgRlBfc3Vibm9ybWFsIHwgRlBfemVybyAtPiBzdHJcbiAgICB8IEZQX2luZmluaXRlIC0+IGlmIHggPCAwLjAgdGhlbiBcIm5lZ19pbmZpbml0eVwiIGVsc2UgXCJpbmZpbml0eVwiXG4gICAgfCBGUF9uYW4gLT4gXCJuYW5cIiBpblxuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ggLT4gaGV4ICgpXG4gIHwgRmxvYXRfSCAtPiBTdHJpbmcudXBwZXJjYXNlX2FzY2lpIChoZXggKCkpXG4gIHwgRmxvYXRfQ0YgLT4gY2FtbF9zcGVjaWFsX3ZhbCAoaGV4ICgpKVxuICB8IEZsb2F0X0YgLT5cbiAgICBsZXQgc3RyID0gZm9ybWF0X2Zsb2F0IChmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYykgeCBpblxuICAgIGNhbWxfc3BlY2lhbF92YWwgKGFkZF9kb3RfaWZfbmVlZGVkIHN0cilcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRyAtPlxuICAgIGZvcm1hdF9mbG9hdCAoZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMpIHhcblxuKCogQ29udmVydCBhIGNoYXIgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpY2FsIGNvbnZlbnRpb24uICopXG5sZXQgZm9ybWF0X2NhbWxfY2hhciBjID1cbiAgbGV0IHN0ciA9IENoYXIuZXNjYXBlZCBjIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKGwgKyAyKSAnXFwnJyBpblxuICBTdHJpbmcudW5zYWZlX2JsaXQgc3RyIDAgcmVzIDEgbDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQ29udmVydCBhIGZvcm1hdCB0eXBlIHRvIHN0cmluZyAqKVxubGV0IHN0cmluZ19vZl9mbXR0eSBmbXR0eSA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXR0eSBidWYgZm10dHk7XG4gIGJ1ZmZlcl9jb250ZW50cyBidWZcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgcHJpbnRpbmcgZnVuY3Rpb24gKilcblxuKCogTWFrZSBhIGdlbmVyaWMgcHJpbnRpbmcgZnVuY3Rpb24uICopXG4oKiBVc2VkIHRvIGdlbmVyYXRlIFByaW50ZiBhbmQgRm9ybWF0IHByaW50aW5nIGZ1bmN0aW9ucy4gKilcbigqIFBhcmFtZXRlcnM6XG4gICAgIGs6IGEgY29udGludWF0aW9uIGZpbmFsbHkgYXBwbGllZCB0byB0aGUgb3V0cHV0IHN0cmVhbSBhbmQgdGhlIGFjY3VtdWxhdG9yLlxuICAgICBvOiB0aGUgb3V0cHV0IHN0cmVhbSAoc2VlIGssICVhIGFuZCAldCkuXG4gICAgIGFjYzogcmV2IGxpc3Qgb2YgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1c2gsIGZvcm1hdHRpbmcsIC4uLikuXG4gICAgIGZtdDogdGhlIGZvcm1hdC4gKilcbmxldCByZWMgbWFrZV9wcmludGYgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBDaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9jaGFyIChhY2MsIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9jYW1sX2NoYXIgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIChmdW4gc3RyIC0+IHN0cilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCBzdHJpbmdfdG9fY2FtbF9zdHJpbmdcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludCBpY29udlxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQzMiBpY29udlxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfbmF0aXZlaW50IGljb252XG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDY0IGljb252XG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGZjb252XG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCBzdHJpbmdfb2ZfYm9vbFxuICB8IEFscGhhIHJlc3QgLT5cbiAgICBmdW4gZiB4IC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kZWxheSAoYWNjLCBmdW4gbyAtPiBmIG8geCkpIHJlc3RcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgZnVuIGYgLT4gbWFrZV9wcmludGYgayAoQWNjX2RlbGF5IChhY2MsIGYpKSByZXN0XG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBtYWtlX2N1c3RvbSBrIGFjYyByZXN0IGFyaXR5IChmICgpKVxuICB8IFJlYWRlciBfIC0+XG4gICAgKCogVGhpcyBjYXNlIGlzIGltcG9zc2libGUsIGJ5IHR5cGluZyBvZiBmb3JtYXRzLiAqKVxuICAgICgqIEluZGVlZCwgc2luY2UgcHJpbnRmIGFuZCBjby4gdGFrZSBhIGZvcm1hdDQgYXMgYXJndW1lbnQsIHRoZSAnZCBhbmQgJ2VcbiAgICAgICB0eXBlIHBhcmFtZXRlcnMgb2YgZm10IGFyZSBvYnZpb3VzbHkgZXF1YWxzLiBUaGUgUmVhZGVyIGlzIHRoZVxuICAgICAgIG9ubHkgY29uc3RydWN0b3Igd2hpY2ggdG91Y2ggJ2QgYW5kICdlIHR5cGUgcGFyYW1ldGVycyBvZiB0aGUgZm9ybWF0XG4gICAgICAgdHlwZSwgaXQgYWRkcyBhbiAoLT4pIHRvIHRoZSAnZCBwYXJhbWV0ZXJzLiBDb25zZXF1ZW50bHksIGEgZm9ybWF0NFxuICAgICAgIGNhbm5vdCBjb250YWluIGEgUmVhZGVyIG5vZGUsIGV4Y2VwdCBpbiB0aGUgc3ViLWZvcm1hdCBhc3NvY2lhdGVkIHRvXG4gICAgICAgYW4gJXsuLi4lfS4gSXQncyBub3QgYSBwcm9ibGVtIGJlY2F1c2UgbWFrZV9wcmludGYgZG8gbm90IGNhbGxcbiAgICAgICBpdHNlbGYgcmVjdXJzaXZlbHkgb24gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0byAley4uLiV9LiAqKVxuICAgIGFzc2VydCBmYWxzZVxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfZmx1c2ggYWNjKSByZXN0XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19zdHJpbmdfbGl0ZXJhbCAoYWNjLCBzdHIpKSByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2NoYXJfbGl0ZXJhbCAoYWNjLCBjaHIpKSByZXN0XG5cbiAgfCBGb3JtYXRfYXJnIChfLCBzdWJfZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gc3RyaW5nX29mX2ZtdHR5IHN1Yl9mbXR0eSBpblxuICAgIChmdW4gc3RyIC0+XG4gICAgICBpZ25vcmUgc3RyO1xuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHR5KSkgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPiBtYWtlX3ByaW50ZiBrIGFjY1xuICAgICAgKGNvbmNhdF9mbXQgKHJlY2FzdCBmbXQgZm10dHkpIHJlc3QpXG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPlxuICAgIGxldCBuZXdfYWNjID0gQWNjX2ludmFsaWRfYXJnIChhY2MsIFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlW1wiKSBpblxuICAgIGZ1biBfIC0+IG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT5cbiAgICAoKiBUaGlzIGNhc2Ugc2hvdWxkIGJlIHJlZnVzZWQgZm9yIFByaW50Zi4gKilcbiAgICAoKiBBY2NlcHRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gKilcbiAgICAoKiBJbnRlcnByZXQgJWwsICVuIGFuZCAlTCBhcyAldS4gKilcbiAgICBmdW4gbiAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZm9ybWF0X2ludCBcIiV1XCIgbikgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIG1ha2VfaWdub3JlZF9wYXJhbSBrIGFjYyBpZ24gcmVzdFxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfbGl0IChhY2MsIGZtdGluZ19saXQpKSByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBsZXQgaycga2FjYyA9XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19nZW4gKGFjYywgQWNjX29wZW5fdGFnIGthY2MpKSByZXN0IGluXG4gICAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXQnXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBsZXQgaycga2FjYyA9XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19nZW4gKGFjYywgQWNjX29wZW5fYm94IGthY2MpKSByZXN0IGluXG4gICAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXQnXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgayBhY2NcblxuKCogRGVsYXkgdGhlIGVycm9yIChJbnZhbGlkX2FyZ3VtZW50IFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlX1wiKS4gKilcbigqIEdlbmVyYXRlIGZ1bmN0aW9ucyB0byB0YWtlIHJlbWFpbmluZyBhcmd1bWVudHMgKGFmdGVyIHRoZSBcIiVfXCIpLiAqKVxuYW5kIG1ha2VfaWdub3JlZF9wYXJhbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIGZtdHR5IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyICAgICAgICAgICAgICAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG5cblxuKCogU3BlY2lhbCBjYXNlIG9mIHByaW50ZiBcIiVfKFwiLiAqKVxuYW5kIG1ha2VfZnJvbV9mbXR0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGZtdHR5IC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludF90eSByZXN0ICAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludDMyX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludDY0X3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEZsb2F0X3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEFscGhhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgUmVhZGVyX3R5IF8gICAgICAgICAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgXyAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgRm9ybWF0X2FyZ190eSAoXywgcmVzdCkgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIEluc2VydCBhbiBBY2NfaW52YWxpZF9hcmcgaW4gdGhlIGFjY3VtdWxhdG9yIGFuZCBjb250aW51ZSB0byBnZW5lcmF0ZVxuICAgY2xvc3VyZXMgdG8gZ2V0IHRoZSByZW1haW5pbmcgYXJndW1lbnRzLiAqKVxuYW5kIG1ha2VfaW52YWxpZF9hcmcgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXQgLT5cbiAgbWFrZV9wcmludGYgayAoQWNjX2ludmFsaWRfYXJnIChhY2MsIFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlX1wiKSkgZm10XG5cbigqIEZpeCBwYWRkaW5nLCB0YWtlIGl0IGFzIGFuIGV4dHJhIGludGVnZXIgYXJndW1lbnQgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfcGFkZGluZyA6IHR5cGUgeCB6IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB6IC0+IGEpIHBhZGRpbmcgLT4gKHogLT4gc3RyaW5nKSAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgdHJhbnMgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIHRyYW5zIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5IC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG5cbigqIEZpeCBwYWRkaW5nIGFuZCBwcmVjaXNpb24gZm9yIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NC4gKilcbigqIFRha2Ugb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gOiB0eXBlIHggeSB6IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPiAoaW50X2NvbnYgLT4geiAtPiBzdHJpbmcpIC0+XG4gICAgaW50X2NvbnYgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHByZWMgdHJhbnMgaWNvbnYgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IHRyYW5zIGljb252IHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcblxuKCogQ29udmVydCBhIGZsb2F0LCBmaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGlmIG5lZWRlZC4gKilcbigqIFRha2UgdGhlIGZsb2F0IGFyZ3VtZW50IGFuZCBvbmUgb3IgdHdvIGV4dHJhIGludGVnZXIgYXJndW1lbnRzIGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX2Zsb2F0X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIGZsb2F0IC0+IGEpIHByZWNpc2lvbiAtPiBmbG9hdF9jb252IC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCBwcmVjIGZjb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBwIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbGV0IHN0cicgPSBmaXhfcGFkZGluZyBwYWR0eSB3IHN0ciBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cicpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbGV0IHN0cicgPSBmaXhfcGFkZGluZyBwYWR0eSB3IHN0ciBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cicpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5hbmQgbWFrZV9jdXN0b20gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IHggLT4geSA9XG4gIGZ1biBrIGFjYyByZXN0IGFyaXR5IGYgLT4gbWF0Y2ggYXJpdHkgd2l0aFxuICB8IEN1c3RvbV96ZXJvIC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgZnVuIHggLT5cbiAgICAgIG1ha2VfY3VzdG9tIGsgYWNjIHJlc3QgYXJpdHkgKGYgeClcblxubGV0IGNvbnN0IHggXyA9IHhcblxubGV0IHJlYyBtYWtlX2lwcmludGYgOiB0eXBlIGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT4gc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbiAgZnVuIGsgbyBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQ2FtbF9zdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgQm9vbCAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX2N1c3RvbV9hcml0eSBrIG8gcmVzdCBhcml0eVxuICAgIHwgUmVhZGVyIF8gLT5cbiAgICAgICAgKCogVGhpcyBjYXNlIGlzIGltcG9zc2libGUsIGJ5IHR5cGluZyBvZiBmb3JtYXRzLiAgU2VlIHRoZVxuICAgICAgICAgICBub3RlIGluIHRoZSBjb3JyZXNwb25kaW5nIGNhc2UgZm9yIG1ha2VfcHJpbnRmLiAqKVxuICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPlxuICAgICAgICAgIG1ha2VfaXByaW50ZiBrIG9cbiAgICAgICAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuICAgIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaWdub3JlZF9wYXJhbSAoZnVuIF8gLT4gayBvKSAoRW5kX29mX2FjYykgaWduIHJlc3RcbiAgICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiAoZnVuIGtvYyAtPiBtYWtlX2lwcmludGYgayBrb2MgcmVzdCkgbyBmbXQnXG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgICAgICBrIG9cbmFuZCBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiA6XG4gIHR5cGUgeCB5IHogYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPiBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPiB4ID1cbiAgZnVuIGsgbyBmbXQgcGFkIHByZWMgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgICAsIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTm9fcGFkZGluZyAgICwgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKSlcbmFuZCBmbl9vZl9jdXN0b21fYXJpdHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+XG4gIHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiB5ID1cbiAgZnVuIGsgbyBmbXQgLT4gZnVuY3Rpb25cbiAgICB8IEN1c3RvbV96ZXJvIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gZm10XG4gICAgfCBDdXN0b21fc3VjYyBhcml0eSAtPlxuICAgICAgICBjb25zdCAoZm5fb2ZfY3VzdG9tX2FyaXR5IGsgbyBmbXQgYXJpdHkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIENvbnRpbnVhdGlvbnMgZm9yIG1ha2VfcHJpbnRmICopXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgbyBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBcIkB7XCI7IG91dHB1dF9hY2MgbyBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBcIkBbXCI7IG91dHB1dF9hY2MgbyBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9jaGFyIG8gY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZiBvXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBmbHVzaCBvXG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgbyBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBidWZwdXRfYWNjIGIgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkB7XCI7IGJ1ZnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAW1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDsgZiBiXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBidWZwdXRfYWNjIGIgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogRGlmZmVyIGZyb20gYnVmcHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgJWEgYW5kICV0LiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgc3RycHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBzdHJwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgKGYgKCkpXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBzdHJwdXRfYWNjIGIgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBFcnJvciBtYW5hZ2VtZW50ICopXG5cbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgcHJldHR5LXByaW50ZWQgZXJyb3IgbWVzc2FnZS4gKilcbmxldCBmYWlsd2l0aF9tZXNzYWdlIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMjU2IGluXG4gIGxldCBrIGFjYyA9IHN0cnB1dF9hY2MgYnVmIGFjYzsgZmFpbHdpdGggKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXR0aW5nIHRvb2xzICopXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYW4gb3BlbiBibG9jayBkZXNjcmlwdGlvbiAoaW5kZW50LCBibG9ja190eXBlKSAqKVxubGV0IG9wZW5fYm94X29mX3N0cmluZyBzdHIgPVxuICBpZiBzdHIgPSBcIlwiIHRoZW4gKDAsIFBwX2JveCkgZWxzZVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCBpbnZhbGlkX2JveCAoKSA9IGZhaWx3aXRoX21lc3NhZ2UgXCJpbnZhbGlkIGJveCBkZXNjcmlwdGlvbiAlU1wiIHN0ciBpblxuICAgIGxldCByZWMgcGFyc2Vfc3BhY2VzIGkgPVxuICAgICAgaWYgaSA9IGxlbiB0aGVuIGkgZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2ldIHdpdGhcbiAgICAgICAgfCAnICcgfCAnXFx0JyAtPiBwYXJzZV9zcGFjZXMgKGkgKyAxKVxuICAgICAgICB8IF8gLT4gaVxuICAgIGFuZCBwYXJzZV9sd29yZCBpIGogPVxuICAgICAgaWYgaiA9IGxlbiB0aGVuIGogZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2pdIHdpdGhcbiAgICAgICAgfCAnYScgLi4gJ3onIC0+IHBhcnNlX2x3b3JkIGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4galxuICAgIGFuZCBwYXJzZV9pbnQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBwYXJzZV9pbnQgaSAoaiArIDEpXG4gICAgICAgIHwgXyAtPiBqIGluXG4gICAgbGV0IHdzdGFydCA9IHBhcnNlX3NwYWNlcyAwIGluXG4gICAgbGV0IHdlbmQgPSBwYXJzZV9sd29yZCB3c3RhcnQgd3N0YXJ0IGluXG4gICAgbGV0IGJveF9uYW1lID0gU3RyaW5nLnN1YiBzdHIgd3N0YXJ0ICh3ZW5kIC0gd3N0YXJ0KSBpblxuICAgIGxldCBuc3RhcnQgPSBwYXJzZV9zcGFjZXMgd2VuZCBpblxuICAgIGxldCBuZW5kID0gcGFyc2VfaW50IG5zdGFydCBuc3RhcnQgaW5cbiAgICBsZXQgaW5kZW50ID1cbiAgICAgIGlmIG5zdGFydCA9IG5lbmQgdGhlbiAwIGVsc2VcbiAgICAgICAgdHJ5IGludF9vZl9zdHJpbmcgKFN0cmluZy5zdWIgc3RyIG5zdGFydCAobmVuZCAtIG5zdGFydCkpXG4gICAgICAgIHdpdGggRmFpbHVyZSBfIC0+IGludmFsaWRfYm94ICgpIGluXG4gICAgbGV0IGV4cF9lbmQgPSBwYXJzZV9zcGFjZXMgbmVuZCBpblxuICAgIGlmIGV4cF9lbmQgPD4gbGVuIHRoZW4gaW52YWxpZF9ib3ggKCk7XG4gICAgbGV0IGJveF90eXBlID0gbWF0Y2ggYm94X25hbWUgd2l0aFxuICAgICAgfCBcIlwiIHwgXCJiXCIgLT4gUHBfYm94XG4gICAgICB8IFwiaFwiICAgICAgLT4gUHBfaGJveFxuICAgICAgfCBcInZcIiAgICAgIC0+IFBwX3Zib3hcbiAgICAgIHwgXCJodlwiICAgICAtPiBQcF9odmJveFxuICAgICAgfCBcImhvdlwiICAgIC0+IFBwX2hvdmJveFxuICAgICAgfCBfICAgICAgICAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIChpbmRlbnQsIGJveF90eXBlKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFBhcnNpbmcgdG9vbHMgKilcblxuKCogQ3JlYXRlIGEgcGFkZGluZ19mbXRfZWJiIGZyb20gYSBwYWRkaW5nIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHBhZGRpbmcgdG8gZGlzam9pbiB0aGUgdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50IGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgOiB0eXBlIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHBhZGRpbmdfZm10X2ViYiA9XG5mdW4gcGFkIGZtdCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgICAgICAgICAtPiBQYWRkaW5nX2ZtdF9FQkIgKE5vX3BhZGRpbmcsIGZtdClcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkZGluZ19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIGZtdClcbiAgfCBBcmdfcGFkZGluZyBzICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChBcmdfcGFkZGluZyBzLCBmbXQpXG5cbigqIENyZWF0ZSBhIHByZWNpc2lvbl9mbXRfZWJiIGZyb20gYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcHJlY2lzaW9uIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgOiB0eXBlIHggeSAuXG4gICAgKHgsIHkpIHByZWNpc2lvbiAtPiAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgICAoXywgXywgXywgXywgXykgcHJlY2lzaW9uX2ZtdF9lYmIgPVxuZnVuIHByZWMgZm10IC0+IG1hdGNoIHByZWMgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiAgICAtPiBQcmVjaXNpb25fZm10X0VCQiAoTm9fcHJlY2lzaW9uLCBmbXQpXG4gIHwgTGl0X3ByZWNpc2lvbiBwIC0+IFByZWNpc2lvbl9mbXRfRUJCIChMaXRfcHJlY2lzaW9uIHAsIGZtdClcbiAgfCBBcmdfcHJlY2lzaW9uICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKEFyZ19wcmVjaXNpb24sIGZtdClcblxuKCogQ3JlYXRlIGEgcGFkcHJlY19mbXRfZWJiIGZyb20gYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIGFuZCB0aGUgcHJlY2lzaW9uIHRvIGRpc2pvaW4gdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50c1xuICAgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3BhZHByZWNfZm10X2ViYiA6IHR5cGUgeCB5IHogdCAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPlxuICAgIChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAoXywgXywgXywgXywgXykgcGFkcHJlY19mbXRfZWJiID1cbmZ1biBwYWQgcHJlYyBmbXQgLT5cbiAgbGV0IFByZWNpc2lvbl9mbXRfRUJCIChwcmVjLCBmbXQnKSA9IG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgcHJlYyBmbXQgaW5cbiAgbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkcHJlY19mbXRfRUJCIChOb19wYWRkaW5nLCBwcmVjLCBmbXQnKVxuICB8IExpdF9wYWRkaW5nIChzLCB3KSAtPiBQYWRwcmVjX2ZtdF9FQkIgKExpdF9wYWRkaW5nIChzLCB3KSwgcHJlYywgZm10JylcbiAgfCBBcmdfcGFkZGluZyBzICAgICAgLT4gUGFkcHJlY19mbXRfRUJCIChBcmdfcGFkZGluZyBzLCBwcmVjLCBmbXQnKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgcGFyc2luZyAqKVxuXG4oKiBQYXJzZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBmb3JtYXQgYW5kIGNyZWF0ZSBhIGZtdF9lYmIuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gaW4gY2FzZSBvZiBpbnZhbGlkIGZvcm1hdC4gKilcbmxldCBmbXRfZWJiX29mX3N0cmluZyA/bGVnYWN5X2JlaGF2aW9yIHN0ciA9XG4gICgqIFBhcmFtZXRlcnMgbmFtaW5nIGNvbnZlbnRpb246ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIGxpdF9zdGFydDogc3RhcnQgb2YgdGhlIGxpdGVyYWwgc2VxdWVuY2UuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gc3RyX2luZDogY3VycmVudCBpbmRleCBpbiB0aGUgc3RyaW5nLiAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBlbmRfaW5kOiBlbmQgb2YgdGhlIGN1cnJlbnQgKHN1Yi0pZm9ybWF0LiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHBjdF9pbmQ6IGluZGV4IG9mIHRoZSAnJScgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAqKVxuICAoKiAgIC0gemVybzogIGlzIHRoZSAnMCcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBtaW51czogaXMgdGhlICctJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBsdXM6ICBpcyB0aGUgJysnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gaGFzaDogIGlzIHRoZSAnIycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBzcGFjZTogaXMgdGhlICcgJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGlnbjogICBpcyB0aGUgJ18nIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gcGFkOiBwYWRkaW5nIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwcmVjOiBwcmVjaXNpb24gb2YgdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN5bWI6IGNoYXIgcmVwcmVzZW50aW5nIHRoZSBjb252ZXJzaW9uICgnYycsICdzJywgJ2QnLCAuLi4pLiAqKVxuICAoKiAgIC0gY2hhcl9zZXQ6IHNldCBvZiBjaGFyYWN0ZXJzIGFzIGJpdG1hcCAoc2VlIHNjYW5mICVbLi4uXSkuICAgICopXG5cbiAgbGV0IGxlZ2FjeV9iZWhhdmlvciA9IG1hdGNoIGxlZ2FjeV9iZWhhdmlvciB3aXRoXG4gICAgfCBTb21lIGZsYWcgLT4gZmxhZ1xuICAgIHwgTm9uZSAtPiB0cnVlXG4gICgqICBXaGVuIHRoaXMgZmxhZyBpcyBlbmFibGVkLCB0aGUgZm9ybWF0IHBhcnNlciB0cmllcyB0byBiZWhhdmUgYXNcbiAgICAgIHRoZSA8NC4wMiBpbXBsZW1lbnRhdGlvbnMsIGluIHBhcnRpY3VsYXIgaXQgaWdub3JlcyBtb3N0IGJlbmluZVxuICAgICAgbm9uc2Vuc2ljYWwgZm9ybWF0LiBXaGVuIHRoZSBmbGFnIGlzIGRpc2FibGVkLCBpdCB3aWxsIHJlamVjdCBhbnlcbiAgICAgIGZvcm1hdCB0aGF0IGlzIG5vdCBhY2NlcHRlZCBieSB0aGUgc3BlY2lmaWNhdGlvbi5cblxuICAgICAgQSB0eXBpY2FsIGV4YW1wbGUgd291bGQgYmUgXCIlKyBkXCI6IHNwZWNpZnlpbmcgYm90aCAnKycgKGlmIHRoZVxuICAgICAgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aCBhICcrJyB0byBnZXQgdGhlIHNhbWUgd2lkdGggYXNcbiAgICAgIG5lZ2F0aXZlIG51bWJlcnMpIGFuZCAnICcgKGlmIHRoZSBudW1iZXIgaXMgcG9zaXRpdmUsIHBhZCB3aXRoXG4gICAgICBhIHNwYWNlKSBkb2VzIG5vdCBtYWtlIHNlbnNlLCBidXQgdGhlIGxlZ2FjeSAoPCA0LjAyKVxuICAgICAgaW1wbGVtZW50YXRpb24gd2FzIGhhcHB5IHRvIGp1c3QgaWdub3JlIHRoZSBzcGFjZS5cbiAgKilcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UuICopXG4gIGxldCBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmQgbXNnID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBtc2dcbiAgaW5cblxuICAoKiBVc2VkIHdoZW4gdGhlIGVuZCBvZiB0aGUgZm9ybWF0IChvciB0aGUgY3VycmVudCBzdWItZm9ybWF0KSB3YXMgZW5jb3VudGVyZWRcbiAgICAgIHVuZXhwZWN0ZWRseS4gKilcbiAgbGV0IHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIGVuZF9pbmRcbiAgICAgIFwidW5leHBlY3RlZCBlbmQgb2YgZm9ybWF0XCJcbiAgaW5cblxuICAoKiBVc2VkIGZvciAlMGM6IG5vIG90aGVyIHdpZHRocyBhcmUgaW1wbGVtZW50ZWQgKilcbiAgbGV0IGludmFsaWRfbm9ubnVsbF9jaGFyX3dpZHRoIHN0cl9pbmQgPVxuICAgIGludmFsaWRfZm9ybWF0X21lc3NhZ2Ugc3RyX2luZFxuICAgICAgXCJub24temVybyB3aWR0aHMgYXJlIHVuc3VwcG9ydGVkIGZvciAlYyBjb252ZXJzaW9uc1wiXG4gIGluXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBhbiBvcHRpb24gZGVwZW5kZW5jeVxuICAgICBwcm9ibGVtLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfd2l0aG91dCBzdHJfaW5kIGMgcyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJyVjJyB3aXRob3V0ICVzXCJcbiAgICAgIHN0ciBzdHJfaW5kIGMgc1xuICBpblxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBhbiB1bmV4cGVjdGVkXG4gICAgIGNoYXJhY3Rlci4gKilcbiAgbGV0IGV4cGVjdGVkX2NoYXJhY3RlciBzdHJfaW5kIGV4cGVjdGVkIHJlYWQgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXMgZXhwZWN0ZWQsIHJlYWQgJUNcIlxuICAgICAgc3RyIHN0cl9pbmQgZXhwZWN0ZWQgcmVhZFxuICBpblxuXG4gICgqIFBhcnNlIHRoZSBzdHJpbmcgZnJvbSBiZWdfaW5kIChpbmNsdWRlZCkgdG8gZW5kX2luZCAoZXhjbHVkZWQpLiAqKVxuICBsZXQgcmVjIHBhcnNlIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGJlZ19pbmQgZW5kX2luZCAtPiBwYXJzZV9saXRlcmFsIGJlZ19pbmQgYmVnX2luZCBlbmRfaW5kXG5cbiAgKCogUmVhZCBsaXRlcmFsIGNoYXJhY3RlcnMgdXAgdG8gJyUnIG9yICdAJyBzcGVjaWFsIGNoYXJhY3RlcnMuICopXG4gIGFuZCBwYXJzZV9saXRlcmFsIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBsaXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBFbmRfb2ZfZm9ybWF0IGVsc2VcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9mb3JtYXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIGZtdF9yZXN0XG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlX2FmdGVyX2F0IChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCBfIC0+XG4gICAgICAgIHBhcnNlX2xpdGVyYWwgbGl0X3N0YXJ0IChzdHJfaW5kICsgMSkgZW5kX2luZFxuXG4gICgqIFBhcnNlIGEgZm9ybWF0IGFmdGVyICclJyAqKVxuICBhbmQgcGFyc2VfZm9ybWF0IDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgZW5kX2luZCAtPiBwYXJzZV9pZ24gcGN0X2luZCAocGN0X2luZCArIDEpIGVuZF9pbmRcblxuICBhbmQgcGFyc2VfaWduIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdfJyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIChzdHJfaW5kKzEpIGVuZF9pbmQgdHJ1ZVxuICAgICAgfCBfIC0+IHBhcnNlX2ZsYWdzIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIGZhbHNlXG5cbiAgYW5kIHBhcnNlX2ZsYWdzIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiXG4gID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIGlnbiAtPlxuICAgIGxldCB6ZXJvID0gcmVmIGZhbHNlIGFuZCBtaW51cyA9IHJlZiBmYWxzZVxuICAgIGFuZCBwbHVzID0gcmVmIGZhbHNlIGFuZCBzcGFjZSA9IHJlZiBmYWxzZVxuICAgIGFuZCBoYXNoID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IHNldF9mbGFnIHN0cl9pbmQgZmxhZyA9XG4gICAgICAoKiBpbiBsZWdhY3kgbW9kZSwgZHVwbGljYXRlIGZsYWdzIGFyZSBhY2NlcHRlZCAqKVxuICAgICAgaWYgIWZsYWcgJiYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBkdXBsaWNhdGUgZmxhZyAlQ1wiXG4gICAgICAgICAgc3RyIHN0cl9pbmQgc3RyLltzdHJfaW5kXTtcbiAgICAgIGZsYWcgOj0gdHJ1ZTtcbiAgICBpblxuICAgIGxldCByZWMgcmVhZF9mbGFncyBzdHJfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzAnIC0+IHNldF9mbGFnIHN0cl9pbmQgemVybzsgIHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnLScgLT4gc2V0X2ZsYWcgc3RyX2luZCBtaW51czsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcrJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHBsdXM7ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJyMnIC0+IHNldF9mbGFnIHN0cl9pbmQgaGFzaDsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcgJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHNwYWNlOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kXG4gICAgICAgICAgIXplcm8gIW1pbnVzICFwbHVzICFoYXNoICFzcGFjZSBpZ25cbiAgICAgIGVuZFxuICAgIGluXG4gICAgcmVhZF9mbGFncyBzdHJfaW5kXG5cbiAgKCogVHJ5IHRvIHJlYWQgYSBkaWdpdGFsIG9yIGEgJyonIHBhZGRpbmcuICopXG4gIGFuZCBwYXJzZV9wYWRkaW5nIDogdHlwZSBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgemVybyBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFkdHkgPSBtYXRjaCB6ZXJvLCBtaW51cyB3aXRoXG4gICAgICB8IGZhbHNlLCBmYWxzZSAtPiBSaWdodFxuICAgICAgfCBmYWxzZSwgdHJ1ZSAgLT4gTGVmdFxuICAgICAgfCAgdHJ1ZSwgZmFsc2UgLT4gWmVyb3NcbiAgICAgIHwgIHRydWUsIHRydWUgIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExlZnRcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJy0nIFwiMFwiIGluXG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICBsZXQgbmV3X2luZCwgd2lkdGggPSBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMCBpblxuICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIChMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2VcbiAgICAgICAgaWduIChBcmdfcGFkZGluZyBwYWR0eSlcbiAgICB8IF8gLT5cbiAgICAgIGJlZ2luIG1hdGNoIHBhZHR5IHdpdGhcbiAgICAgIHwgTGVmdCAgLT5cbiAgICAgICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICAgaW52YWxpZF9mb3JtYXRfd2l0aG91dCAoc3RyX2luZCAtIDEpICctJyBcInBhZGRpbmdcIjtcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgTm9fcGFkZGluZ1xuICAgICAgfCBaZXJvcyAtPlxuICAgICAgICAgKCogYSAnMCcgcGFkZGluZyBpbmRpY2F0aW9uIG5vdCBmb2xsb3dlZCBieSBhbnl0aGluZyBzaG91bGRcbiAgICAgICAgICAgYmUgaW50ZXJwcmV0ZWQgYXMgYSBSaWdodCBwYWRkaW5nIG9mIHdpZHRoIDAuIFRoaXMgaXMgdXNlZFxuICAgICAgICAgICBieSBzY2FubmluZyBjb252ZXJzaW9ucyAlMHMgYW5kICUwYyAqKVxuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICAoTGl0X3BhZGRpbmcgKFJpZ2h0LCAwKSlcbiAgICAgIHwgUmlnaHQgLT5cbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgTm9fcGFkZGluZ1xuICAgICAgZW5kXG5cbiAgKCogSXMgcHJlY2lzaW9uIGRlZmluZWQ/ICopXG4gIGFuZCBwYXJzZV9hZnRlcl9wYWRkaW5nIDogdHlwZSB4IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIF8pIHBhZGRpbmcgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJy4nIC0+XG4gICAgICBwYXJzZV9wcmVjaXNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICBwYWRcbiAgICB8IHN5bWIgLT5cbiAgICAgIHBhcnNlX2NvbnZlcnNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWRcbiAgICAgICAgTm9fcHJlY2lzaW9uIHBhZCBzeW1iXG5cbiAgKCogUmVhZCB0aGUgZGlnaXRhbCBvciAnKicgcHJlY2lzaW9uLiAqKVxuICBhbmQgcGFyc2VfcHJlY2lzaW9uIDogdHlwZSB4IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIF8pIHBhZGRpbmcgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmQgPVxuICAgICAgbGV0IG5ld19pbmQsIHByZWMgPSBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMCBpblxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgbmV3X2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIHByZWMpIGluXG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX2xpdGVyYWwgbWludXMgc3RyX2luZFxuICAgIHwgKCcrJyB8ICctJykgYXMgc3ltYiB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPlxuICAgICAgKCogTGVnYWN5IG1vZGUgd291bGQgYWNjZXB0IGFuZCBpZ25vcmUgJysnIG9yICctJyBiZWZvcmUgdGhlXG4gICAgICAgICBpbnRlZ2VyIGRlc2NyaWJpbmcgdGhlIGRlc2lyZWQgcHJlY2lzaW9uOyBub3RlIHRoYXQgdGhpc1xuICAgICAgICAgY2Fubm90IGhhcHBlbiBmb3IgcGFkZGluZyB3aWR0aCwgYXMgJysnIGFuZCAnLScgYWxyZWFkeSBoYXZlXG4gICAgICAgICBhIHNlbWFudGljcyB0aGVyZS5cblxuICAgICAgICAgVGhhdCBzYWlkLCB0aGUgaWRlYSAoc3VwcG9ydGVkIGJ5IHRoaXMgdHdlYWspIHRoYXQgd2lkdGggYW5kXG4gICAgICAgICBwcmVjaXNpb24gbGl0ZXJhbHMgYXJlIFwiaW50ZWdlciBsaXRlcmFsc1wiIGluIHRoZSBPQ2FtbCBzZW5zZSBpc1xuICAgICAgICAgc3RpbGwgYmxhdGFudGx5IHdyb25nLCBhcyAxMjNfNDU2IG9yIDB4RkYgYXJlIHJlamVjdGVkLiAqKVxuICAgICAgcGFyc2VfbGl0ZXJhbCAobWludXMgfHwgc3ltYiA9ICctJykgKHN0cl9pbmQgKyAxKVxuICAgIHwgJyonIC0+XG4gICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiBwYWQgQXJnX3ByZWNpc2lvblxuICAgIHwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogbm90ZSB0aGF0IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBkaWQgbm90IGlnbm9yZSAnLicgd2l0aG91dFxuICAgICAgICAgICBhIG51bWJlciAoYXMgaXQgZG9lcyBmb3IgcGFkZGluZyBpbmRpY2F0aW9ucyksIGJ1dFxuICAgICAgICAgICBpbnRlcnByZXRzIGl0IGFzICcuMCcgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBwYWQgKExpdF9wcmVjaXNpb24gMClcbiAgICAgIGVsc2VcbiAgICAgICAgaW52YWxpZF9mb3JtYXRfd2l0aG91dCAoc3RyX2luZCAtIDEpICcuJyBcInByZWNpc2lvblwiXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9hZnRlcl9wcmVjaXNpb24gOiB0eXBlIHggeSB6IHQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIHByZWMgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYXJzZV9jb252ICh0eXBlIHUpICh0eXBlIHYpIChwYWRwcmVjIDogKHUsIHYpIHBhZGRpbmcpID1cbiAgICAgIHBhcnNlX2NvbnZlcnNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWRcbiAgICAgICAgcHJlYyBwYWRwcmVjIHN0ci5bc3RyX2luZF0gaW5cbiAgICAoKiBpbiBsZWdhY3kgbW9kZSwgc29tZSBmb3JtYXRzICglcyBhbmQgJVMpIGFjY2VwdCBhIHdlaXJkIG1peCBvZlxuICAgICAgIHBhZGRpbmcgYW5kIHByZWNpc2lvbiwgd2hpY2ggaXMgbWVyZ2VkIGFzIGEgc2luZ2xlIHBhZGRpbmdcbiAgICAgICBpbmZvcm1hdGlvbi4gRm9yIGV4YW1wbGUsIGluICUuMTBzIHRoZSBwcmVjaXNpb24gaXMgaW1wbGljaXRseVxuICAgICAgIHVuZGVyc3Rvb2QgYXMgcGFkZGluZyAlMTBzLCBidXQgdGhlIGxlZnQtcGFkZGluZyBjb21wb25lbnQgbWF5XG4gICAgICAgYmUgc3BlY2lmaWVkIGVpdGhlciBhcyBhIGxlZnQgcGFkZGluZyBvciBhIG5lZ2F0aXZlIHByZWNpc2lvbjpcbiAgICAgICAlLS4zcyBhbmQgJS4tM3MgYXJlIGVxdWl2YWxlbnQgdG8gJS0zcyAqKVxuICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nIC0+IChcbiAgICAgIG1hdGNoIG1pbnVzLCBwcmVjIHdpdGhcbiAgICAgICAgfCBfLCBOb19wcmVjaXNpb24gLT4gcGFyc2VfY29udiBOb19wYWRkaW5nXG4gICAgICAgIHwgZmFsc2UsIExpdF9wcmVjaXNpb24gbiAtPiBwYXJzZV9jb252IChMaXRfcGFkZGluZyAoUmlnaHQsIG4pKVxuICAgICAgICB8IHRydWUsIExpdF9wcmVjaXNpb24gbiAtPiBwYXJzZV9jb252IChMaXRfcGFkZGluZyAoTGVmdCwgbikpXG4gICAgICAgIHwgZmFsc2UsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgUmlnaHQpXG4gICAgICAgIHwgdHJ1ZSwgQXJnX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IChBcmdfcGFkZGluZyBMZWZ0KVxuICAgIClcbiAgICB8IHBhZCAtPiBwYXJzZV9jb252IHBhZFxuXG4gICgqIENhc2UgYW5hbHlzaXMgb24gY29udmVyc2lvbi4gKilcbiAgYW5kIHBhcnNlX2NvbnZlcnNpb24gOiB0eXBlIHggeSB6IHQgdSB2IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+ICh4LCB5KSBwYWRkaW5nIC0+XG4gICAgICAgICh6LCB0KSBwcmVjaXNpb24gLT4gKHUsIHYpIHBhZGRpbmcgLT4gY2hhciAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIHBhZHByZWMgc3ltYiAtPlxuICAgICgqIEZsYWdzIHVzZWQgdG8gY2hlY2sgb3B0aW9uIHVzYWdlcy9jb21wYXRpYmlsaXRpZXMuICopXG4gICAgbGV0IHBsdXNfdXNlZCAgPSByZWYgZmFsc2UgYW5kIGhhc2hfdXNlZCA9IHJlZiBmYWxzZVxuICAgIGFuZCBzcGFjZV91c2VkID0gcmVmIGZhbHNlIGFuZCBpZ25fdXNlZCAgID0gcmVmIGZhbHNlXG4gICAgYW5kIHBhZF91c2VkICAgPSByZWYgZmFsc2UgYW5kIHByZWNfdXNlZCAgPSByZWYgZmFsc2UgaW5cblxuICAgICgqIEFjY2VzcyB0byBvcHRpb25zLCB1cGRhdGUgZmxhZ3MuICopXG4gICAgbGV0IGdldF9wbHVzICAgICgpID0gcGx1c191c2VkICA6PSB0cnVlOyBwbHVzXG4gICAgYW5kIGdldF9oYXNoICAgKCkgPSBoYXNoX3VzZWQgOj0gdHJ1ZTsgaGFzaFxuICAgIGFuZCBnZXRfc3BhY2UgICAoKSA9IHNwYWNlX3VzZWQgOj0gdHJ1ZTsgc3BhY2VcbiAgICBhbmQgZ2V0X2lnbiAgICAgKCkgPSBpZ25fdXNlZCAgIDo9IHRydWU7IGlnblxuICAgIGFuZCBnZXRfcGFkICAgICAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkXG4gICAgYW5kIGdldF9wcmVjICAgICgpID0gcHJlY191c2VkICA6PSB0cnVlOyBwcmVjXG4gICAgYW5kIGdldF9wYWRwcmVjICgpID0gcGFkX3VzZWQgICA6PSB0cnVlOyBwYWRwcmVjIGluXG5cbiAgICBsZXQgZ2V0X2ludF9wYWQgKCkgOiAoeCx5KSBwYWRkaW5nID1cbiAgICAgICgqICU1LjNkIGlzIGFjY2VwdGVkIGFuZCBtZWFuaW5nZnVsOiBwYWQgdG8gbGVuZ3RoIDUgd2l0aFxuICAgICAgICAgc3BhY2VzLCBidXQgZmlyc3QgcGFkIHdpdGggemVyb3MgdXB0byBsZW5ndGggMyAoMC1wYWRkaW5nXG4gICAgICAgICBpcyB0aGUgaW50ZXJwcmV0YXRpb24gb2YgXCJwcmVjaXNpb25cIiBmb3IgaW50ZWdlciBmb3JtYXRzKS5cblxuICAgICAgICAgJTA1LjNkIGlzIHJlZHVuZGFudDogcGFkIHRvIGxlbmd0aCA1ICp3aXRoIHplcm9zKiwgYnV0XG4gICAgICAgICBmaXJzdCBwYWQgd2l0aCB6ZXJvcy4uLiBUbyBhZGQgaW5zdWx0IHRvIHRoZSBpbmp1cnksIHRoZVxuICAgICAgICAgbGVnYWN5IGltcGxlbWVudGF0aW9uIGlnbm9yZXMgdGhlIDAtcGFkZGluZyBpbmRpY2F0aW9uIGFuZFxuICAgICAgICAgZG9lcyB0aGUgNSBwYWRkaW5nIHdpdGggc3BhY2VzIGluc3RlYWQuIFdlIHJldXNlIHRoaXNcbiAgICAgICAgIGludGVycHJldGF0aW9uIGZvciBjb21wYXRpYmlsaXR5LCBidXQgc3RhdGljYWxseSByZWplY3QgdGhpc1xuICAgICAgICAgZm9ybWF0IHdoZW4gdGhlIGxlZ2FjeSBtb2RlIGlzIGRpc2FibGVkLCB0byBwcm90ZWN0IHN0cmljdFxuICAgICAgICAgdXNlcnMgZnJvbSB0aGlzIGNvcm5lciBjYXNlLiAqKVxuICAgICAgIG1hdGNoIGdldF9wYWQgKCksIGdldF9wcmVjICgpIHdpdGhcbiAgICAgICAgIHwgcGFkLCBOb19wcmVjaXNpb24gLT4gcGFkXG4gICAgICAgICB8IE5vX3BhZGRpbmcsIF8gICAgIC0+IE5vX3BhZGRpbmdcbiAgICAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCBuKSwgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIG4pXG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IEFyZ19wYWRkaW5nIFplcm9zLCBfIC0+XG4gICAgICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IExpdF9wYWRkaW5nIF8gYXMgcGFkLCBfIC0+IHBhZFxuICAgICAgICAgfCBBcmdfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWQgaW5cblxuICAgICgqIENoZWNrIHRoYXQgcGFkdHkgPD4gWmVyb3MuICopXG4gICAgbGV0IGNoZWNrX25vXzAgc3ltYiAodHlwZSBhIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgOiAoYSxiKSBwYWRkaW5nID1cbiAgICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gcGFkXG4gICAgICB8IExpdF9wYWRkaW5nICgoTGVmdCB8IFJpZ2h0KSwgXykgLT4gcGFkXG4gICAgICB8IEFyZ19wYWRkaW5nIChMZWZ0IHwgUmlnaHQpIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgICB8IEFyZ19wYWRkaW5nIFplcm9zIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCIwXCJcbiAgICBpblxuXG4gICAgKCogR2V0IHBhZGRpbmcgYXMgYSBwYWRfb3B0aW9uIChzZWUgXCIlX1wiLCBcIiV7XCIsIFwiJShcIiBhbmQgXCIlW1wiKS5cbiAgICAgICAobm8gbmVlZCBmb3IgbGVnYWN5IG1vZGUgdHdlYWtpbmcsIHRob3NlIHdlcmUgcmVqZWN0ZWQgYnkgdGhlXG4gICAgICAgbGVnYWN5IHBhcnNlciBhcyB3ZWxsKSAqKVxuICAgIGxldCBvcHRfb2ZfcGFkIGMgKHR5cGUgYSkgKHR5cGUgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA9IG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gTm9uZVxuICAgICAgfCBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKSAtPiBTb21lIHdpZHRoXG4gICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicwJ1wiXG4gICAgICB8IExpdF9wYWRkaW5nIChMZWZ0LCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gU29tZSB3aWR0aFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJy0nXCJcbiAgICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicqJ1wiXG4gICAgaW5cbiAgICBsZXQgZ2V0X3BhZF9vcHQgYyA9IG9wdF9vZl9wYWQgYyAoZ2V0X3BhZCAoKSkgaW5cbiAgICBsZXQgZ2V0X3BhZHByZWNfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWRwcmVjICgpKSBpblxuXG4gICAgKCogR2V0IHByZWNpc2lvbiBhcyBhIHByZWNfb3B0aW9uIChzZWUgXCIlX2ZcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgZ2V0X3ByZWNfb3B0ICgpID0gbWF0Y2ggZ2V0X3ByZWMgKCkgd2l0aFxuICAgICAgfCBOb19wcmVjaXNpb24gICAgICAgLT4gTm9uZVxuICAgICAgfCBMaXRfcHJlY2lzaW9uIG5kZWMgLT4gU29tZSBuZGVjXG4gICAgICB8IEFyZ19wcmVjaXNpb24gICAgICAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJyonXCJcbiAgICBpblxuXG4gICAgbGV0IGZtdF9yZXN1bHQgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICcsJyAtPlxuICAgICAgcGFyc2Ugc3RyX2luZCBlbmRfaW5kXG4gICAgfCAnYycgLT5cbiAgICAgIGxldCBjaGFyX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICVjICopXG4gICAgICAgIGlmIGdldF9pZ24gKClcbiAgICAgICAgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChDaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBzY2FuX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICUwYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9zY2FuX25leHRfY2hhciwgZm10X3Jlc3QpKVxuICAgICAgICBlbHNlIEZtdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBiZWdpbiBtYXRjaCBnZXRfcGFkX29wdCAnYycgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gY2hhcl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIDAgLT4gc2Nhbl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIF9uIC0+XG4gICAgICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3JcbiAgICAgICAgICAgdGhlbiBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kXG4gICAgICAgICAgIGVsc2UgKCogbGVnYWN5IGlnbm9yZXMgJWMgd2lkdGhzICopIGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICBlbmRcbiAgICB8ICdDJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NhbWxfY2hhcixmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKENhbWxfY2hhciBmbXRfcmVzdClcbiAgICB8ICdzJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKFN0cmluZyAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdTJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9jYW1sX3N0cmluZyAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT5cbiAgICAgIGxldCBpY29udiA9IGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdOJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gVG9rZW5fY291bnRlciBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCkpXG4gICAgfCAnbCcgfCAnbicgfCAnTCcgd2hlbiBzdHJfaW5kPWVuZF9pbmQgfHwgbm90IChpc19pbnRfYmFzZSBzdHIuW3N0cl9pbmRdKSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gY291bnRlcl9vZl9jaGFyIHN5bWIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQzMiAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDMyIChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnbicgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSlcbiAgICAgICAgICAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ0wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQ2NCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDY0IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnZicgfCAnZScgfCAnRScgfCAnZycgfCAnRycgfCAnRicgfCAnaCcgfCAnSCcgLT5cbiAgICAgIGxldCBmY29udiA9XG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmRcbiAgICAgICAgICAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSkgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZmxvYXQgKGdldF9wYWRfb3B0ICdfJywgZ2V0X3ByZWNfb3B0ICgpKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2InIHwgJ0InIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Jvb2wgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEJvb2wgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnYScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChBbHBoYSBmbXRfcmVzdClcbiAgICB8ICd0JyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKFRoZXRhIGZtdF9yZXN0KVxuICAgIHwgJ3InIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKFJlYWRlciBmbXRfcmVzdClcbiAgICB8ICchJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZsdXNoIGZtdF9yZXN0KVxuICAgIHwgKCclJyB8ICdAJykgYXMgYyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoYywgZm10X3Jlc3QpKVxuICAgIHwgJ3snIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnfScgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ3snLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICcoJyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJyknIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnKCcsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJ1snIC0+XG4gICAgICBsZXQgbmV4dF9pbmQsIGNoYXJfc2V0ID0gcGFyc2VfY2hhcl9zZXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ18nLCBjaGFyX3NldCkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnWycsIGNoYXJfc2V0LCBmbXRfcmVzdCkpXG4gICAgfCAnLScgfCAnKycgfCAnIycgfCAnICcgfCAnXycgLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGZsYWcgJUMgaXMgb25seSBhbGxvd2VkIGFmdGVyIHRoZSAnJSUnLCBiZWZvcmUgcGFkZGluZyBhbmQgcHJlY2lzaW9uXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgc3ltYlxuICAgIHwgXyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgaW52YWxpZCBjb252ZXJzaW9uIFxcXCIlJSVjXFxcIlwiIHN0ciAoc3RyX2luZCAtIDEpIHN5bWJcbiAgICBpblxuICAgICgqIENoZWNrIGZvciB1bnVzZWQgb3B0aW9ucywgYW5kIHJlamVjdCB0aGVtIGFzIGluY29tcGF0aWJsZS5cblxuICAgICAgIFN1Y2ggY2hlY2tzIG5lZWQgdG8gYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsIGFzIHRoZSBsZWdhY3lcbiAgICAgICBwYXJzZXIgc2lsZW50bHkgaWdub3JlZCBpbmNvbXBhdGlibGUgZmxhZ3MuICopXG4gICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuIGJlZ2luXG4gICAgaWYgbm90ICFwbHVzX3VzZWQgJiYgcGx1cyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiO1xuICAgIGlmIG5vdCAhaGFzaF91c2VkICYmIGhhc2ggdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIjtcbiAgICBpZiBub3QgIXNwYWNlX3VzZWQgJiYgc3BhY2UgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIjtcbiAgICBpZiBub3QgIXBhZF91c2VkICAmJiBQYWRkaW5nX0VCQiBwYWQgPD4gUGFkZGluZ19FQkIgTm9fcGFkZGluZyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcImBwYWRkaW5nJ1wiO1xuICAgIGlmIG5vdCAhcHJlY191c2VkICYmIFByZWNpc2lvbl9FQkIgcHJlYyA8PiBQcmVjaXNpb25fRUJCIE5vX3ByZWNpc2lvbiB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgKGlmIGlnbiB0aGVuICdfJyBlbHNlIHN5bWIpXG4gICAgICAgIFwiYHByZWNpc2lvbidcIjtcbiAgICBpZiBpZ24gJiYgcGx1cyB0aGVuIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnXycgXCInKydcIjtcbiAgICBlbmQ7XG4gICAgKCogdGhpcyBsYXN0IHRlc3QgbXVzdCBub3QgYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsXG4gICAgICAgYXMgaWdub3JpbmcgaXQgd291bGQgdHlwaWNhbGx5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0eXBpbmdcbiAgICAgICB0aGFuIHdoYXQgdGhlIGxlZ2FjeSBwYXJzZXIgdXNlZCAqKVxuICAgIGlmIG5vdCAhaWduX3VzZWQgJiYgaWduIHRoZW5cbiAgICAgIGJlZ2luIG1hdGNoIHN5bWIgd2l0aFxuICAgICAgICAoKiBhcmd1bWVudC1sZXNzIGZvcm1hdHMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIGluIGxlZ2FjeSBtb2RlICopXG4gICAgICAgIHwgKCdAJyB8ICclJyB8ICchJyB8ICcsJykgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gKClcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInXydcIlxuICAgICAgZW5kO1xuICAgIGZtdF9yZXN1bHRcblxuICAoKiBQYXJzZSBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIChhZnRlciAnQCcpLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgRW5kX29mX2Zvcm1hdCkpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdbJyAtPlxuICAgICAgICBwYXJzZV90YWcgZmFsc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICddJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfYm94LCBmbXRfcmVzdCkpXG4gICAgICB8ICd7JyAtPlxuICAgICAgICBwYXJzZV90YWcgdHJ1ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ30nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV90YWcsIGZtdF9yZXN0KSlcbiAgICAgIHwgJywnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJALFwiLCAwLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAgXCIsIDEsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICc7JyAtPlxuICAgICAgICBwYXJzZV9nb29kX2JyZWFrIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnPycgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZGbHVzaCwgZm10X3Jlc3QpKVxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRm9yY2VfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnLicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZsdXNoX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIHBhcnNlX21hZ2ljX3NpemUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9hdCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgd2hlbiBzdHJfaW5kICsgMSA8IGVuZF9pbmQgJiYgc3RyLltzdHJfaW5kICsgMV0gPSAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfcGVyY2VudCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIGZtdF9yZXN0KSlcbiAgICAgIHwgYyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyBjLCBmbXRfcmVzdCkpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDxuYW1lPiBhZnRlciBcIkB7XCIgb3IgXCJAW1wiLiAqKVxuICBhbmQgcGFyc2VfdGFnIDogdHlwZSBlIGYgLiBib29sIC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gaXNfb3Blbl90YWcgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgdHJ5XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnPCcgLT5cbiAgICAgICAgbGV0IGluZCA9IFN0cmluZy5pbmRleF9mcm9tIHN0ciAoc3RyX2luZCArIDEpICc+JyBpblxuICAgICAgICBpZiBpbmQgPj0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciBzdHJfaW5kIChpbmQgLSBzdHJfaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCAoaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKHN1Yl9mbXQsIHN1Yl9zdHIpIGluXG4gICAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgICBpZiBpc19vcGVuX3RhZyB0aGVuIE9wZW5fdGFnIHN1Yl9mb3JtYXQgZWxzZSBPcGVuX2JveCBzdWJfZm9ybWF0IGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoRW5kX29mX2Zvcm1hdCwgXCJcIikgaW5cbiAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPHdpZHRoIG9mZnNldD4gYWZ0ZXIgXCJAO1wiLiAqKVxuICBhbmQgcGFyc2VfZ29vZF9icmVhayA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBsZXQgbmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0ID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB8fCBzdHIuW3N0cl9pbmRdIDw+ICc8JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IChcbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCB3aWR0aCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8zXSB3aXRoXG4gICAgICAgICAgICAgIHwgJz4nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF8zLXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzMgKyAxLCBCcmVhayAocywgd2lkdGgsIDApXG4gICAgICAgICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzQsIG9mZnNldCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8zIGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF81ID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfNCBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzVdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzUtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfNSArIDEsIEJyZWFrIChzLCB3aWR0aCwgb2Zmc2V0KVxuICAgICAgICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIClcbiAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgc3RyX2luZCwgQnJlYWsgKFwiQDtcIiwgMSwgMClcbiAgICBpblxuICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIHRoZSBzaXplIGluIGEgPG4+LiAqKVxuICBhbmQgcGFyc2VfbWFnaWNfc2l6ZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBtYXRjaFxuICAgICAgdHJ5XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHNpemUgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF8zXSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZCAtIDIpIChzdHJfaW5kXzMgLSBzdHJfaW5kICsgMykgaW5cbiAgICAgICAgICBTb21lIChzdHJfaW5kXzMgKyAxLCBNYWdpY19zaXplIChzLCBzaXplKSlcbiAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIE5vbmVcbiAgICB3aXRoXG4gICAgfCBTb21lIChuZXh0X2luZCwgZm9ybWF0dGluZ19saXQpIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljICc8JywgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIGFuZCBjb25zdHJ1Y3QgYSBjaGFyIHNldC4gKilcbiAgYW5kIHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcblxuICAgIGxldCBjaGFyX3NldCA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICAgIGxldCBhZGRfY2hhciBjID1cbiAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjO1xuICAgIGluXG4gICAgbGV0IGFkZF9yYW5nZSBjIGMnID1cbiAgICAgIGZvciBpID0gaW50X29mX2NoYXIgYyB0byBpbnRfb2ZfY2hhciBjJyBkb1xuICAgICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKGNoYXJfb2ZfaW50IGkpO1xuICAgICAgZG9uZTtcbiAgICBpblxuXG4gICAgbGV0IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZCA9XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6ICclJScgYWxvbmUgaXMgbm90IGFjY2VwdGVkIGluIGNoYXJhY3RlciBzZXRzLCBcXFxuICAgICAgICAgdXNlICUlJSUgaW5zdGVhZCBhdCBwb3NpdGlvbiAlZC5cIiBzdHIgc3RyX2luZFxuICAgIGluXG5cbiAgICAoKiBQYXJzZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgY2hhciBzZXQuICopXG4gICAgbGV0IHJlYyBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGxldCBjID0gc3RyLltzdHJfaW5kXSBpblxuICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogUGFyc2UgdGhlIGNvbnRlbnQgb2YgYSBjaGFyIHNldCB1bnRpbCB0aGUgZmlyc3QgJ10nLiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9jb250ZW50IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFRlc3QgZm9yIHJhbmdlIGluIGNoYXIgc2V0LiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyB3aGVuIGMgPSAnJScgLT5cbiAgICAgICAgYWRkX2NoYXIgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGlmIGMgPSAnJScgdGhlbiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQ7XG4gICAgICAgICgqIG5vdGUgdGhhdCAnQCcgYWxvbmUgaXMgYWNjZXB0ZWQsIGFzIGRvbmUgYnkgdGhlIGxlZ2FjeVxuICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjsgdGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IHJlcXVpcmVzICVAXG4gICAgICAgICAgIHNvIHdlIGNvdWxkIHdhcm4gb24gdGhhdCAqKVxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjJ1xuXG4gICAgKCogTWFuYWdlIHJhbmdlIGluIGNoYXIgc2V0IChleGNlcHQgaWYgdGhlICctJyB0aGUgbGFzdCBjaGFyIGJlZm9yZSAnXScpICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyAtPlxuICAgICAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMikgZW5kX2luZFxuICAgICAgICAgIHwgXyAtPiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmRcbiAgICAgICAgZW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgIGluXG4gICAgbGV0IHN0cl9pbmQsIHJldmVyc2UgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgICB8ICdeJyAtPiBzdHJfaW5kICsgMSwgdHJ1ZVxuICAgICAgICB8IF8gLT4gc3RyX2luZCwgZmFsc2UgaW5cbiAgICBsZXQgbmV4dF9pbmQgPSBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICBsZXQgY2hhcl9zZXQgPSBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgaW5cbiAgICBuZXh0X2luZCwgKGlmIHJldmVyc2UgdGhlbiByZXZfY2hhcl9zZXQgY2hhcl9zZXQgZWxzZSBjaGFyX3NldClcblxuICAoKiBDb25zdW1lIGFsbCBuZXh0IHNwYWNlcywgcmFpc2UgYW4gRmFpbHVyZSBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGlmIHN0ci5bc3RyX2luZF0gPSAnICcgdGhlbiBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGVsc2Ugc3RyX2luZFxuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlIGlmIGVuZF9pbmQgaXNcbiAgICAgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCBhY2MgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gYWNjICogMTAgKyAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJykgaW5cbiAgICAgIGlmIG5ld19hY2MgPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogaW50ZWdlciAlZCBpcyBncmVhdGVyIHRoYW4gdGhlIGxpbWl0ICVkXCJcbiAgICAgICAgICBzdHIgbmV3X2FjYyBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG5ld19hY2NcbiAgICB8IF8gLT4gc3RyX2luZCwgYWNjXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmVcbiAgICAgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfaW50ZWdlciBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwXG4gICAgfCAnLScgLT4gKFxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgICAgbGV0IG5leHRfaW5kLCBuID0gcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIDAgaW5cbiAgICAgICAgbmV4dF9pbmQsIC1uXG4gICAgICB8IGMgLT5cbiAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJkaWdpdFwiIGNcbiAgICApXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIEFkZCBhIGxpdGVyYWwgdG8gYSBmb3JtYXQgZnJvbSBhIGxpdGVyYWwgY2hhcmFjdGVyIHN1Yi1zZXF1ZW5jZS4gKilcbiAgYW5kIGFkZF9saXRlcmFsIDogdHlwZSBhIGQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gKGEsIF8sIF8sIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZm10IC0+IG1hdGNoIHN0cl9pbmQgLSBsaXRfc3RhcnQgd2l0aFxuICAgIHwgMCAgICAtPiBGbXRfRUJCIGZtdFxuICAgIHwgMSAgICAtPiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKHN0ci5bbGl0X3N0YXJ0XSwgZm10KSlcbiAgICB8IHNpemUgLT4gRm10X0VCQiAoU3RyaW5nX2xpdGVyYWwgKFN0cmluZy5zdWIgc3RyIGxpdF9zdGFydCBzaXplLCBmbXQpKVxuXG4gICgqIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXRcbiAgICAgKGkuZS4gdGhlIGNvcnJlc3BvbmRpbmcgXCIlfVwiIG9yIFwiJSlcIikgKilcbiAgYW5kIHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IHVuY2xvc2VkIHN1Yi1mb3JtYXQsIFxcXG4gICAgICAgICBleHBlY3RlZCBcXFwiJSUlY1xcXCIgYXQgY2hhcmFjdGVyIG51bWJlciAlZFwiIHN0ciBjIGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnJScgLT5cbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgaWYgc3RyLltzdHJfaW5kICsgMV0gPSBjIHRoZW4gKCogRW5kIG9mIGZvcm1hdCBmb3VuZCAqKSBzdHJfaW5kIGVsc2VcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICB8ICdfJyAtPlxuICAgICAgICAgICgqIFNlYXJjaCBmb3IgXCIlXyhcIiBvciBcIiVfe1wiLiAqKVxuICAgICAgICAgIGlmIHN0cl9pbmQgKyAyID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDJdIHdpdGhcbiAgICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCBjXG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgKCogJXsuLi4lfSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgKCogJSguLi4lKSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJ30nIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICUoLi4uJX0uICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJyknXCIgJ30nXG4gICAgICAgIHwgJyknIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICV7Li4uJSkuICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJ30nXCIgJyknXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIGVuZFxuICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICgqIENoZWNrIGlmIHN5bWIgaXMgYSB2YWxpZCBpbnQgY29udmVyc2lvbiBhZnRlciBcIiVsXCIsIFwiJW5cIiBvciBcIiVMXCIgKilcbiAgYW5kIGlzX2ludF9iYXNlIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgKCogQ29udmVydCBhIGNoYXIgKGwsIG4gb3IgTCkgdG8gaXRzIGFzc29jaWF0ZWQgY291bnRlci4gKilcbiAgYW5kIGNvdW50ZXJfb2ZfY2hhciBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnbCcgLT4gTGluZV9jb3VudGVyICB8ICduJyAtPiBDaGFyX2NvdW50ZXJcbiAgICB8ICdMJyAtPiBUb2tlbl9jb3VudGVyIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBpbnRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBtYXRjaCBwbHVzLCBoYXNoLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X2QgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9pXG4gICAgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnZCcgLT4gSW50X3NkIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2knIC0+IEludF9zaVxuICAgIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9wZCB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfcGlcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd4JyAtPiBJbnRfeCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnWCcgLT4gSW50X1hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd4JyAtPiBJbnRfQ3ggfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnWCcgLT4gSW50X0NYXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnbycgLT4gSW50X29cbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdvJyAtPiBJbnRfQ29cbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd1JyAtPiBJbnRfdVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2QnIC0+IEludF9DZFxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2knIC0+IEludF9DaVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ3UnIC0+IEludF9DdVxuICAgIHwgXywgdHJ1ZSwgXywgJ3gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DeFxuICAgIHwgXywgdHJ1ZSwgXywgJ1gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DWFxuICAgIHwgXywgdHJ1ZSwgXywgJ28nIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9Db1xuICAgIHwgXywgdHJ1ZSwgXywgKCdkJyB8ICdpJyB8ICd1JykgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGZhbHNlIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIlxuICAgIHwgdHJ1ZSwgXywgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgdHJ1ZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8IHRydWUsIF8sIGZhbHNlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2UgaGFzaCBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCBmYWxzZSwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzcGFjZSwgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgZmxvYXRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIHNwYWNlIHN5bWIgPVxuICAgIGxldCBmbGFnID0gbWF0Y2ggcGx1cywgc3BhY2Ugd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlIC0+IEZsb2F0X2ZsYWdfXG4gICAgfCBmYWxzZSwgIHRydWUgLT4gRmxvYXRfZmxhZ19zXG4gICAgfCAgdHJ1ZSwgZmFsc2UgLT4gRmxvYXRfZmxhZ19wXG4gICAgfCAgdHJ1ZSwgIHRydWUgLT5cbiAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBGbG9hdF9mbGFnX3BcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiIGluXG4gICAgbGV0IGtpbmQgPSBtYXRjaCBoYXNoLCBzeW1iIHdpdGhcbiAgICB8IF8sICdmJyAtPiBGbG9hdF9mXG4gICAgfCBfLCAnZScgLT4gRmxvYXRfZVxuICAgIHwgXywgJ0UnIC0+IEZsb2F0X0VcbiAgICB8IF8sICdnJyAtPiBGbG9hdF9nXG4gICAgfCBfLCAnRycgLT4gRmxvYXRfR1xuICAgIHwgXywgJ2gnIC0+IEZsb2F0X2hcbiAgICB8IF8sICdIJyAtPiBGbG9hdF9IXG4gICAgfCBmYWxzZSwgJ0YnIC0+IEZsb2F0X0ZcbiAgICB8IHRydWUsICdGJyAtPiBGbG9hdF9DRlxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgaW5cbiAgICBmbGFnLCBraW5kXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGluY29tcGF0aWJsZSBvcHRpb25zLiopXG4gIGFuZCBpbmNvbXBhdGlibGVfZmxhZyA6IHR5cGUgYSAuIGludCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmcgLT4gYSA9XG4gICAgZnVuIHBjdF9pbmQgc3RyX2luZCBzeW1iIG9wdGlvbiAtPlxuICAgICAgbGV0IHN1YmZtdCA9IFN0cmluZy5zdWIgc3RyIHBjdF9pbmQgKHN0cl9pbmQgLSBwY3RfaW5kKSBpblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgJXMgaXMgaW5jb21wYXRpYmxlIHdpdGggJyVjJyBpbiBzdWItZm9ybWF0ICVTXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgb3B0aW9uIHN5bWIgc3ViZm10XG5cbiAgaW4gcGFyc2UgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAoKiBHdWFyZGVkIHN0cmluZyB0byBmb3JtYXQgY29udmVyc2lvbnMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHN0ciBmbXR0eSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgZm10dHksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCJcbiAgICAgIHN0ciAoc3RyaW5nX29mX2ZtdHR5IGZtdHR5KVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBhbiBvdGhlciBmb3JtYXQuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgKEZvcm1hdCAoZm10Jywgc3RyJykpID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCAoZm10dHlfb2ZfZm10IGZtdCcpLCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiIHN0ciBzdHInXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9hbmQiLCJjc3RfTGkiLCJjc3RfaSIsImNzdF9saSIsImNzdF9uaSIsImNzdF91IiwiY3N0XzAiLCJjc3RfYXRfY2hhcmFjdGVyX251bWJlciIsImNzdF9iYWRfaW5wdXRfZm9ybWF0X3R5cGVfbWlzbSIsImNzdF9jYW1saW50ZXJuYWxGb3JtYXRfbWwiLCJjc3RfaW52YWxpZF9mb3JtYXQiLCJjc3RfcHJlY2lzaW9uIiwiY2FtbF9ibGl0X3N0cmluZyIsImNhbWxfYnl0ZXNfc2V0IiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX2Zvcm1hdF9mbG9hdCIsImNhbWxfZm9ybWF0X2ludCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfbm90ZXF1YWwiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX3N0cmluZ191bnNhZmVfZ2V0IiwiY2FtbF90cmFtcG9saW5lIiwiY2FtbF90cmFtcG9saW5lX3JldHVybiIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsInN1Yl9mb3JtYXQiLCJmb3JtYXR0aW5nX2xpdCIsImNzdF91bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQiLCJjc3RfbmQiLCJjc3RfbnUiLCJjc3RfbGQiLCJjc3RfbHUiLCJjc3RfTGQiLCJjc3RfTHUiLCJjc3RfZCIsIkFzc2VydF9mYWlsdXJlIiwiQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzIiwiU3RkbGliIiwiU3RkbGliX0J1ZmZlciIsIlN0ZGxpYl9TdHJpbmciLCJTdGRsaWJfU3lzIiwiU3RkbGliX0NoYXIiLCJTdGRsaWJfQnl0ZXMiLCJTdGRsaWJfSW50IiwiY3N0X2MiLCJjc3RfcyIsImNzdF9mIiwiY3N0X0IiLCJjc3RfYSIsImNzdF90IiwiY3N0X3IiLCJjc3RfMGMiLCJjcmVhdGVfY2hhcl9zZXQiLCJwYXJhbSIsImFkZF9pbl9jaGFyX3NldCIsImNoYXJfc2V0IiwiYyIsInN0cl9pbmQiLCJtYXNrIiwiZnJlZXplX2NoYXJfc2V0IiwicmV2X2NoYXJfc2V0IiwiaSIsImlzX2luX2NoYXJfc2V0IiwicGFkX29mX3BhZF9vcHQiLCJwYWRfb3B0Iiwid2lkdGgiLCJwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQiLCJpZ24iLCJmbXQiLCJpY29udiIsInByZWNfb3B0IiwibmRlYyIsImZtdHR5Iiwid2lkdGhfb3B0IiwiY291bnRlciIsImRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIiwiZmNvbnYiLCJidWZmZXJfY3JlYXRlIiwiaW5pdF9zaXplIiwiYnVmZmVyX2NoZWNrX3NpemUiLCJidWYiLCJvdmVyaGVhZCIsImxlbiIsIm1pbl9sZW4iLCJuZXdfbGVuIiwibmV3X3N0ciIsImJ1ZmZlcl9hZGRfY2hhciIsImJ1ZmZlcl9hZGRfc3RyaW5nIiwicyIsInN0cl9sZW4iLCJidWZmZXJfY29udGVudHMiLCJjaGFyX29mX2ljb252IiwiY2hhcl9vZl9mY29udiIsIm9wdCIsInN0aCIsImNGIiwiYnByaW50X2NoYXJfc2V0IiwicHJpbnRfY2hhciIsInNldCIsImlzX2Fsb25lIiwiYWZ0ZXIiLCJiZWZvcmUiLCJzd2l0Y2hlciIsImoiLCJicHJpbnRfcGFkdHkiLCJwYWR0eSIsImJwcmludF9pZ25vcmVkX2ZsYWciLCJpZ25fZmxhZyIsImJwcmludF9wYWRfb3B0IiwiYnByaW50X3BhZGRpbmciLCJwYWQiLCJuIiwiYnByaW50X3ByZWNpc2lvbiIsInByZWMiLCJicHJpbnRfaWNvbnZfZmxhZyIsImJwcmludF9hbHRpbnRfZm10IiwiYnByaW50X2Zjb252X2ZsYWciLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQiLCJzdHIiLCJicHJpbnRfY2hhcl9saXRlcmFsIiwiY2hyIiwiYnByaW50X3N0cmluZ19saXRlcmFsIiwiYnByaW50X2ZtdHR5Iiwic3ViX2ZtdHR5IiwiaW50X29mX2N1c3RvbV9hcml0eSIsIngiLCJzdHJpbmdfb2ZfZm10IiwiZm10aXRlciIsInJlc3QiLCJmbXRpbmdfbGl0IiwiZm10aW5nX2dlbiIsImFyaXR5Iiwic3ltbSIsInR5IiwidHkyIiwidHkxIiwiZm10dHlfcmVsX2RldCIsIm1hdGNoIiwiZGUiLCJhZiIsImpkIiwiZ2EiLCJ0cmFucyIsInJlc3QxIiwicmVzdDIiLCJ0eTEyIiwidHkxMSIsInR5MjIiLCJ0eTIxIiwiZjQiLCJmMiIsImZtdHR5X29mX2ZtdCIsInR5X3Jlc3QiLCJwcmVjX3R5IiwiZm9ybWF0dGluZ19nZW4iLCJmbXR0eV9vZl9jdXN0b20iLCJmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IiwiZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IiwiVHlwZV9taXNtYXRjaCIsImNzdF94IiwiY3N0X1giLCJjc3RfbyIsImNzdF9MeCIsImNzdF9MWCIsImNzdF9MbyIsImNzdF9seCIsImNzdF9sWCIsImNzdF9sbyIsImNzdF9ueCIsImNzdF9uWCIsImNzdF9ubyIsImNzdF9uZWdfaW5maW5pdHkiLCJjc3RfaW5maW5pdHkiLCJjc3RfbmFuIiwiY3N0X1ByaW50Zl9iYWRfY29udmVyc2lvbiIsImNzdF9ub25femVyb193aWR0aHNfYXJlX3Vuc3VwcCIsImNzdF9wYWRkaW5nIiwiY3N0X2RpZ2l0IiwiY3N0X2NoYXJhY3RlciIsInR5cGVfcGFkZGluZyIsInciLCJ0eXBlX3BhZHByZWMiLCJwIiwidHlwZV9mb3JtYXQiLCJ0eXBlX2Zvcm1hdF9nZW4iLCJmbXR0eTAiLCJmbXR0eV9yZXN0IiwiZm10X3Jlc3QiLCJzdWJfZm10dHkxIiwiZm10MSIsImZtdHR5MiIsImZtdDIiLCJmbXR0eTMiLCJmbXQzIiwidHlwZV9pZ25vcmVkX3BhcmFtX29uZSIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aSIsInN1Yl9mbXR0eV9yZXN0Iiwic3ViMl9mbXR0eSIsInN1YjFfZm10dHkiLCJyZWNhc3QiLCJmaXhfcGFkZGluZyIsInJlcyIsImZpeF9pbnRfcHJlY2lzaW9uIiwic3RyaW5nX3RvX2NhbWxfc3RyaW5nIiwibCIsImZvcm1hdF9vZl9mY29udiIsInN5bWIiLCJ0cmFuc2Zvcm1faW50X2FsdCIsImRpZ2l0cyIsInBvcyIsInB1dCIsImxlZnQiLCJjb252ZXJ0X2ludCIsImNvbnZlcnRfaW50MzIiLCJjb252ZXJ0X25hdGl2ZWludCIsImNvbnZlcnRfaW50NjQiLCJjb252ZXJ0X2Zsb2F0IiwiaGV4Iiwic2lnbiIsImNhbWxfc3BlY2lhbF92YWwiLCJzdHJpbmdfb2ZfZm10dHkiLCJtYWtlX3ByaW50ZiIsImsiLCJhY2MiLCJrYWNjIiwibmV3X2FjYyIsIm8iLCJtYWtlX2lnbm9yZWRfcGFyYW0iLCJtYWtlX2Zyb21fZm10dHkiLCJtYWtlX2ludmFsaWRfYXJnIiwibWFrZV9wYWRkaW5nIiwibWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24iLCJtYWtlX2N1c3RvbSIsIm1ha2VfaXByaW50ZiIsImtvYyIsImZuX29mX2N1c3RvbV9hcml0eSIsIm91dHB1dF9hY2MiLCJtc2ciLCJidWZwdXRfYWNjIiwiYiIsInN0cnB1dF9hY2MiLCJmYWlsd2l0aF9tZXNzYWdlIiwib3Blbl9ib3hfb2Zfc3RyaW5nIiwiaW52YWxpZF9ib3giLCJwYXJzZV9zcGFjZXMiLCJ3c3RhcnQiLCJ3ZW5kIiwiYm94X25hbWUiLCJuc3RhcnQiLCJuZW5kIiwiaW5kZW50IiwiZXhuIiwidGFnIiwiZXhwX2VuZCIsImJveF90eXBlIiwibWFrZV9wYWRkaW5nX2ZtdF9lYmIiLCJtYWtlX3BhZHByZWNfZm10X2ViYiIsImZtdF9lYmJfb2Zfc3RyaW5nIiwibGVnYWN5X2JlaGF2aW9yIiwiZmxhZyIsImludmFsaWRfZm9ybWF0X21lc3NhZ2UiLCJpbnZhbGlkX2Zvcm1hdF93aXRob3V0IiwiZXhwZWN0ZWRfY2hhcmFjdGVyIiwiZXhwZWN0ZWQiLCJyZWFkIiwicGFyc2UiLCJsaXRfc3RhcnQiLCJlbmRfaW5kIiwicGFyc2VfZmxhZ3MiLCJwY3RfaW5kIiwiemVybyIsIm1pbnVzIiwicGx1cyIsInNwYWNlIiwiaGFzaCIsInNldF9mbGFnIiwibmV3X2luZCIsInBhcnNlX2FmdGVyX3BhZGRpbmciLCJwYXJzZV9saXRlcmFsIiwicGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIiwicGFyc2VfY29udiIsInBhZHByZWMiLCJwYXJzZV9jb252ZXJzaW9uIiwicGx1c191c2VkIiwiaGFzaF91c2VkIiwic3BhY2VfdXNlZCIsImlnbl91c2VkIiwicGFkX3VzZWQiLCJwcmVjX3VzZWQiLCJnZXRfcGx1cyIsImdldF9oYXNoIiwiZ2V0X3NwYWNlIiwiZ2V0X2lnbiIsImdldF9wYWQiLCJnZXRfcHJlYyIsImdldF9wYWRwcmVjIiwiZ2V0X2ludF9wYWQiLCJjaGVja19ub18wIiwib3B0X29mX3BhZCIsImdldF9wYWRfb3B0IiwiZ2V0X3BhZHByZWNfb3B0IiwiZm10X3Jlc3VsdCIsInN1Yl9lbmQiLCJzdWJfZm10IiwiaWdub3JlZCIsIm5leHRfaW5kIiwiY2hhcl9mb3JtYXQiLCJraW5kIiwicGFyc2VfYWZ0ZXJfYXQiLCJzdHJfaW5kXzEiLCJzdHJfaW5kXzIiLCJzdHJfaW5kXzMiLCJvZmZzZXQiLCJzdHJfaW5kXzQiLCJzdHJfaW5kXzUiLCJzaXplIiwicGFyc2VfdGFnIiwiaXNfb3Blbl90YWciLCJpbmQiLCJzdWJfc3RyIiwiZm9ybWF0dGluZyIsInBhcnNlX2NoYXJfc2V0IiwiYWRkX3JhbmdlIiwiZmFpbF9zaW5nbGVfcGVyY2VudCIsInBhcnNlX2NoYXJfc2V0X2NvbnRlbnQiLCJwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIiwicmV2ZXJzZSIsInBhcnNlX3Bvc2l0aXZlIiwicGFyc2VfaW50ZWdlciIsImFkZF9saXRlcmFsIiwic2VhcmNoX3N1YmZvcm1hdF9lbmQiLCJjb21wdXRlX2ludF9jb252IiwiaW5jb21wYXRpYmxlX2ZsYWciLCJvcHRpb24iLCJzdWJmbXQiLCJmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IiwiZm9ybWF0X29mX3N0cmluZ19mb3JtYXQiLCJDYW1saW50ZXJuYWxGb3JtYXQiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFOLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQU8sVUFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQVIsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBUztBQUFBQSxNQUFBO0FBQUEsSUFBQUE7QUFBQUEsTUFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQXRDLFFBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBdUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQXhDLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQXlDLCtCQUFBO0FBQUEsSUFBQXpDLFNBQUE7QUFBQSxJQUFBMEMsU0FBQTtBQUFBLElBQUFyQyxXQUFBO0FBQUEsSUFBQXND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QUFBQSxXQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBdEksV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBeEMsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBK0ssU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQTNJLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQXJDLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQWlMLFNBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQSw4QkFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBO0FBQUEsSUFBQXZMLFFBQUE7QUFBQTtBQUFBLElBQUFLLGdCQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFBLGtCQUFBO0FBQUE7QUFBQSxJQUFBQSxrQkFBQTtBQUFBLElBQUFMLFVBQUE7QUFBQTtBQUFBLElBQUFBLFVBQUE7QUFBQSxJQUFBQSxVQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQXVMLGdCQUFBO0FBQUE7QUFBQSxJQUFBbEwsa0JBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFtTCxZQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFBLGtCQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxhQUFBckUsS0FBQXRDO0FBQUFBLElDZzlCaUIsNEJBQ0k7QUFBQSxJQURKO0FBQUEsU0FBQTRHLElBQUEsUUFBQTNFLFFBQUE7QUFBQSxLQUVnQjtBQUFBO0FBQUEsSUFGaEI7QUFBQSxTQUFBdUIsT0FBQSxVQUFBdkIsVUFBQTtBQUFBLEtBR3FCO0FBQUE7QUFBQSxJQUM3QjtBQUFBLEdBQW1CO0FBQUEsWUFBQTRFLGFBQUF2RSxLQUFBRyxNQUFBekM7QUFBQUEsUUFBQWlFLFFBUU07QUFBQSxJQUFzQjtBQUFBLFNBQUFULFNBQUEsVUFBQWxCLFFBQUEsVUFBQXdFLElBQUE7QUFBQSxLQUlwRDtBQUFBO0FBQUEsSUFKb0Q7QUFBQSxTQUFBdEQsU0FBQSxVQUFBbEIsUUFBQTtBQUFBLEtBRXBEO0FBQUE7QUFBQSxRQUFBMkIsVUFGb0Q7QUFBQTtBQUFBLFNBQUFULE9BQUEsWUFBQWxCLFFBQUE7QUFBQSxLQU1wRDtBQUFBO0FBQUEsSUFDK0I7QUFBQSxHQUFtQjtBQUFBLFlBQUF5RSxZQUFBbkgsS0FBQUk7QUFBQUEsUUFBQSxJQVk3QjtBQUFBLElBQXlCO0FBQUEsS0FFekM7QUFBQSxRQUFBSixRQUZ5QztBQUFBLElBQ1I7QUFBQSxHQUNkO0FBQUEsWUFBQW9ILGdCQUFBcEgsS0FBQXFIO0FBQUFBLElBUVQsNEJBbUhjO0FBQUEsSUFuSGQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQUFBQyxhQUFBO0FBQUEsU0FBQUMsV0FBQTtBQUFBLFNBQUFsRCxRQUVvQjtBQUFBLFNBQUFqRSxRQUFtQztBQUFBLFNBQUFKLFFBQUE7QUFBQSxRQUN0RTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BSGU7QUFBQTtBQUFBLFNBQUFzSCxlQUFBO0FBQUEsU0FBQUMsYUFBQTtBQUFBLFNBQUFsRCxVQUtvQjtBQUFBLFNBQUFqRSxVQUFtQztBQUFBLFNBQUFKLFFBQUE7QUFBQSxRQUN0RTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFBQXVILGFBTmU7QUFBQSxRQUFBN0UsTUFBQTtBQUFBLFFBQUEyQixVQVFUO0FBQUEsUUFBQTNCLFFBQXNCO0FBQUEsUUFBQTJCLFVBQUE7QUFBQTtBQUFBO0FBQUEsU0FBQWlELGVBQUE7QUFBQSxTQUFBakQsVUFFUztBQUFBLFNBQUFqRSxVQUFtQztBQUFBLFNBQUFKLFFBQUE7QUFBQSxRQUN0RTtBQUFBO0FBQUEsT0FDNEI7QUFBQTtBQUFBO0FBQUEsUUFBQXVILGFBWmY7QUFBQSxRQUFBN0UsUUFBQTtBQUFBLFFBQUEyQixVQWVUO0FBQUEsUUFBQTNCLFFBQXNCO0FBQUEsUUFBQTJCLFVBQUE7QUFBQTtBQUFBO0FBQUEsU0FBQWlELGVBQUE7QUFBQSxTQUFBakQsVUFFUztBQUFBLFNBQUFqRSxVQUFtQztBQUFBLFNBQUFKLFFBQUE7QUFBQSxRQUN0RTtBQUFBO0FBQUEsT0FDNEI7QUFBQTtBQUFBO0FBQUEsUUFBQXVILGFBbkJmO0FBQUEsUUFBQTFFLE9BQUE7QUFBQSxRQUFBSCxRQUFBO0FBQUEsUUFBQXpDLFFBQUE7QUFBQSxRQUFBb0UsVUFzQlQ7QUFBQSxRQUFBM0IsUUFBMkI7QUFBQSxRQUFBMkIsVUFBQTtBQUFBO0FBQUE7QUFBQSxTQUFBaUQsZUFBQTtBQUFBLFNBQUF6RSxTQUFBO0FBQUEsU0FBQXdCLFVBRUk7QUFBQSxTQUFBakUsVUFBbUM7QUFBQSxTQUFBSixRQUFBO0FBQUEsUUFDdEU7QUFBQTtBQUFBLE9BQytCO0FBQUE7QUFBQTtBQUFBLFFBQUF1SCxhQTFCbEI7QUFBQSxRQUFBMUUsU0FBQTtBQUFBLFFBQUFILFFBQUE7QUFBQSxRQUFBekMsVUFBQTtBQUFBLFFBQUFvRSxXQTZCVDtBQUFBLFFBQUEzQixRQUEyQjtBQUFBLFFBQUEyQixXQUFBO0FBQUE7QUFBQTtBQUFBLFNBQUFpRCxlQUFBO0FBQUEsU0FBQXpFLFNBQUE7QUFBQSxTQUFBd0IsV0FFSTtBQUFBLFNBQUFqRSxVQUFtQztBQUFBLFNBQUFKLFFBQUE7QUFBQSxRQUN0RTtBQUFBO0FBQUEsT0FDK0I7QUFBQTtBQUFBO0FBQUEsUUFBQXVILGFBakNsQjtBQUFBLFFBQUExRSxTQUFBO0FBQUEsUUFBQUgsUUFBQTtBQUFBLFFBQUF6QyxVQUFBO0FBQUEsUUFBQW9FLFdBb0NUO0FBQUEsUUFBQTNCLFFBQTJCO0FBQUEsUUFBQTJCLFdBQUE7QUFBQTtBQUFBO0FBQUEsU0FBQWlELGVBQUE7QUFBQSxTQUFBekUsU0FBQTtBQUFBLFNBQUF3QixXQUVJO0FBQUEsU0FBQWpFLFVBQW1DO0FBQUEsU0FBQUosUUFBQTtBQUFBLFFBQ3RFO0FBQUE7QUFBQSxPQUMrQjtBQUFBO0FBQUE7QUFBQSxRQUFBdUgsYUF4Q2xCO0FBQUEsUUFBQTFFLFNBQUE7QUFBQSxRQUFBSCxRQUFBO0FBQUEsUUFBQXpDLFVBQUE7QUFBQSxRQUFBb0UsV0EyQ1Q7QUFBQSxRQUFBM0IsU0FBMkI7QUFBQSxRQUFBMkIsV0FBQTtBQUFBO0FBQUE7QUFBQSxTQUFBaUQsZUFBQTtBQUFBLFNBQUF6RSxTQUFBO0FBQUEsU0FBQXdCLFdBRUk7QUFBQSxTQUFBakUsVUFBbUM7QUFBQSxTQUFBSixRQUFBO0FBQUEsUUFDdEU7QUFBQTtBQUFBLE9BQytCO0FBQUE7QUFBQTtBQUFBLFFBQUF1SCxhQS9DbEI7QUFBQSxRQUFBMUUsU0FBQTtBQUFBLFFBQUFILFNBQUE7QUFBQSxRQUFBbEMsUUFBQTtBQUFBLFFBQUE2RCxXQWtEVDtBQUFBLFFBQUEzQixTQUEyQjtBQUFBLFFBQUEyQixXQUFBO0FBQUE7QUFBQTtBQUFBLFNBQUFpRCxlQUFBO0FBQUEsU0FBQXpFLFNBQUE7QUFBQSxTQUFBd0IsV0FFSTtBQUFBLFNBQUFqRSxVQUFtQztBQUFBLFNBQUFKLFFBQUE7QUFBQSxRQUN0RTtBQUFBO0FBQUEsT0FDK0I7QUFBQTtBQUFBO0FBQUEsUUFBQXVILGFBdERsQjtBQUFBLFFBQUE3RSxTQUFBO0FBQUEsUUFBQTJCLFdBeURUO0FBQUEsUUFBQTNCLFNBQXNCO0FBQUEsUUFBQTJCLFdBQUE7QUFBQTtBQUFBO0FBQUEsU0FBQWlELGVBQUE7QUFBQSxTQUFBakQsV0FFUztBQUFBLFNBQUFqRSxVQUFtQztBQUFBLFNBQUFKLFFBQUE7QUFBQSxRQUN0RTtBQUFBO0FBQUEsT0FDNEI7QUFBQTtBQUFBO0FBQUEsUUFBQXVILGFBN0RmO0FBQUEsUUFBQWxELFdBZ0VvQjtBQUFBLFFBQUFqRSxVQUFtQztBQUFBLFFBQUFKLFNBQUE7QUFBQSxPQUN0RTtBQUFBO0FBQUE7QUFBQSxRQUFBdUgsY0FqRWU7QUFBQSxRQUFBckUsTUFBQTtBQUFBLFFBQUFtQixXQW9Fb0I7QUFBQSxRQUFBakUsV0FBbUM7QUFBQSxRQUFBSixTQUFBO0FBQUEsT0FDdEU7QUFBQTtBQUFBO0FBQUEsUUFBQXVILGNBckVlO0FBQUEsUUFBQW5FLE1BQUE7QUFBQSxRQUFBaUIsV0F1RW9CO0FBQUEsUUFBQWpFLFdBQW1DO0FBQUEsUUFBQUosU0FBQTtBQUFBLE9BQ3RFO0FBQUE7QUFBQSxPQXhFZTtBQUFBO0FBQUEsU0FBQXNILGVBQUE7QUFBQSxTQUFBL0QsWUFBQTtBQUFBLFNBQUFnRSxjQUFBO0FBQUEsU0FBQWhFLGNBQUE7QUFBQSxTQUFBM0QsVUFBQTtBQUFBLFFBNEVaO0FBQUEsU0FBaUQ7QUFBQTtBQUFBLFNBQUF5RSxXQUNqQjtBQUFBLFNBQUFqRSxXQUFtQztBQUFBLFNBQUFKLFNBQUE7QUFBQSxRQUN0RTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BOUVlO0FBQUE7QUFBQSxTQUFBc0gsZ0JBQUE7QUFBQSxTQUFBRSxhQUFBO0FBQUEsU0FBQUQsY0FBQTtBQUFBLFNBQUFoRSxjQUFBO0FBQUEsU0FBQTNELFlBQUE7QUFBQSxhQWlGaUM7QUFBQSxRQUFuQztBQUFBLFVBQVY7QUFBQSxnQkFBVTtBQUFBLFNBQ1g7QUFBQTtBQUFBLFNBQUF5RTtBQUFBQSxXQUVBO0FBQUE7QUFBQSxhQUF5QjtBQUFBLFNBQUFqRSxXQUFzQjtBQUFBLFNBQUFKLFNBQUE7QUFBQSxRQUVqRDtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BdEZlO0FBQUE7QUFBQSxTQUFBc0gsZ0JBQUE7QUFBQSxTQUFBQyxjQUFBO0FBQUEsU0FBQWxELFdBeUZvQjtBQUFBLFNBQUFqRSxXQUFtQztBQUFBLFNBQUFKLFNBQUE7QUFBQSxRQUN0RTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BMUZlO0FBQUE7QUFBQSxTQUFBc0gsZ0JBQUE7QUFBQSxTQUFBQyxjQUFBO0FBQUEsU0FBQWxELFdBNEZvQjtBQUFBLFNBQUFqRSxXQUFtQztBQUFBLFNBQUFKLFNBQUE7QUFBQSxRQUN0RTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFBQXVILGNBN0ZlO0FBQUEsUUFBQWpLLGlCQUFBO0FBQUEsUUFBQStHLFdBaUdvQjtBQUFBLFFBQUFqRSxXQUFtQztBQUFBLFFBQUFKLFNBQUE7QUFBQSxPQUN0RTtBQUFBO0FBQUEsV0FBQXVILGNBbEdlLFFBQUFqQyxpQkFBQTtBQUFBLE9BNEhlO0FBQUE7QUFBQSxTQUFBakIsV0FBQTtBQUFBLFNBQUFuQixRQUFBO0FBQUEsU0FBQXVFLE9BQUE7QUFBQSxTQUFBcEQsV0FFSztBQUFBLFNBQUFxRCxTQUEyQjtBQUFBLFNBQUFDLE9BQUE7QUFBQSxTQUFBdEQsV0FDM0I7QUFBQSxTQUFBdUQsU0FBMkI7QUFBQSxTQUFBQyxPQUFBO0FBQUEsUUFDOUQ7QUFBQTtBQUFBO0FBQUEsUUFBQXhELFdBSjhCO0FBQUEsUUFBQW5CLFFBQUE7QUFBQSxRQUFBdUUsU0FBQTtBQUFBLFFBQUFwRCxXQU1LO0FBQUEsUUFBQXFELFdBQTJCO0FBQUEsUUFBQUMsU0FBQTtBQUFBLFFBQUF0RCxXQUMzQjtBQUFBLFFBQUF1RCxXQUEyQjtBQUFBLFFBQUFDLFNBQUE7QUFBQSxPQUM5RDtBQUFBO0FBQUEsT0FwSWU7QUFBQTtBQUFBLFNBQUFQLGdCQUFBO0FBQUEsU0FBQUMsY0FBQTtBQUFBLFNBQUFsRCxXQXdHb0I7QUFBQSxTQUFBakUsV0FBbUM7QUFBQSxTQUFBSixTQUFBO0FBQUEsUUFDdEU7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQXpHZTtBQUFBO0FBQUEsU0FBQXNILGdCQUFBO0FBQUEsU0FBQUMsY0FBQTtBQUFBLFNBQUFwSSxXQUFBO0FBQUEsU0FBQWtCLFlBQUE7QUFBQSxTQUFBZ0UsV0EyR29CO0FBQUEsU0FBQWpFLFdBQW1DO0FBQUEsU0FBQUosU0FBQTtBQUFBLFFBQ3RFO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0E1R2U7QUFBQTtBQUFBLFNBQUFzSCxnQkFBQTtBQUFBLFNBQUFDLGNBQUE7QUFBQSxTQUFBakgsVUFBQTtBQUFBLFNBQUErRCxXQThHb0I7QUFBQSxTQUFBakUsV0FBbUM7QUFBQSxTQUFBSixTQUFBO0FBQUEsUUFDdEU7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUFBNEQsT0EvR2UsUUFBQTdELE1BQUE7QUFBQSxPQTRJRTtBQUFBO0FBQUE7QUFBQSxlQUFBd0QsY0FBQSxRQUFBM0QsWUFBQTtBQUFBLFdBZWpCO0FBQUEsOERBdEN3QjtBQUFBO0FBQUE7QUFBQSxZQUFBMkQsY0F1QlA7QUFBQSxZQUFBM0QsWUFBQTtBQUFBLGdCQWtCZjtBQUFBLFlBQUF5RSxXQUFvRDtBQUFBLFlBQUFqRSxXQUFBO0FBQUEsWUFBQUosU0FBQTtBQUFBLFlBQUF1RCxjQUFBO0FBQUEsV0FDdEQ7QUFBQSxtQkFuQmlCLGdEQXZCTztBQUFBO0FBQUEsT0F1QlAsOERBdkJPO0FBQUEsT0E2Q047QUFBQTtBQUFBLFNBQUErRCxnQkFBQTtBQUFBLFNBQUFqRCxXQUdtQjtBQUFBLFNBQUFqRSxXQUE4QjtBQUFBLFNBQUFKLFNBQUE7QUFBQSxRQUNqRTtBQUFBO0FBQUEsT0FDSztBQUFBO0FBQUEsSUFsREY7QUFBQSxHQUFtQjtBQUFBLFlBQUE4SCx1QkFBQS9ILEtBQUFDLEtBQUFJO0FBQUFBO0FBQUFBLEtBQUFpRSxRQTJEUztBQUFBLEtBQUFqRSxVQUF5QjtBQUFBLEtBQUFKLFFBQUE7QUFBQSxJQUM1RDtBQUFBLEdBQWlEO0FBQUEsWUFBQStILCtCQUFBeEUsV0FBQXZELEtBQUFJO0FBQUFBLElBT3hCO0FBQUEsS0EwRU0sMENBQXlCO0FBQUEsSUExRS9CO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FBQWtILGFBQUE7QUFBQSxTQUFBVSxpQkFBQTtBQUFBLFNBQUEzRDtBQUFBQSxXQUdyQjtBQUFBLFNBQUFyRSxRQUE4RDtBQUFBLFNBQUFnSSxtQkFBQTtBQUFBLFFBQ2hFO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FKdUI7QUFBQTtBQUFBLFNBQUFWLGVBQUE7QUFBQSxTQUFBVSxtQkFBQTtBQUFBLFNBQUEzRDtBQUFBQSxXQU9yQjtBQUFBLFNBQUFyRSxRQUE4RDtBQUFBLFNBQUFnSSxtQkFBQTtBQUFBLFFBQ2hFO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FSdUI7QUFBQTtBQUFBLFNBQUFWLGVBQUE7QUFBQSxTQUFBVSxtQkFBQTtBQUFBLFNBQUEzRDtBQUFBQSxXQVdyQjtBQUFBLFNBQUFyRSxRQUE4RDtBQUFBLFNBQUFnSSxtQkFBQTtBQUFBLFFBQ2hFO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FadUI7QUFBQTtBQUFBLFNBQUFWLGVBQUE7QUFBQSxTQUFBVSxtQkFBQTtBQUFBLFNBQUEzRDtBQUFBQSxXQWVyQjtBQUFBLFNBQUFyRSxRQUE4RDtBQUFBLFNBQUFnSSxtQkFBQTtBQUFBLFFBQ2hFO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FoQnVCO0FBQUE7QUFBQSxTQUFBVixlQUFBO0FBQUEsU0FBQVUsbUJBQUE7QUFBQSxTQUFBM0Q7QUFBQUEsV0FtQnJCO0FBQUEsU0FBQXJFLFFBQThEO0FBQUEsU0FBQWdJLG1CQUFBO0FBQUEsUUFDaEU7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQXBCdUI7QUFBQTtBQUFBLFNBQUFWLGVBQUE7QUFBQSxTQUFBVSxtQkFBQTtBQUFBLFNBQUEzRDtBQUFBQSxXQXVCckI7QUFBQSxTQUFBckUsUUFBOEQ7QUFBQSxTQUFBZ0ksb0JBQUE7QUFBQSxRQUNoRTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BeEJ1QjtBQUFBO0FBQUEsU0FBQVYsZUFBQTtBQUFBLFNBQUFVLG9CQUFBO0FBQUEsU0FBQTNEO0FBQUFBLFdBMkJyQjtBQUFBO0FBQUEsU0FBQXJFLFFBQThEO0FBQUEsU0FBQWdJLG9CQUFBO0FBQUEsUUFDaEU7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQTVCdUI7QUFBQTtBQUFBLFNBQUFWLGVBQUE7QUFBQSxTQUFBVSxvQkFBQTtBQUFBLFNBQUEzRDtBQUFBQSxXQStCckI7QUFBQTtBQUFBLFNBQUFyRSxRQUE4RDtBQUFBLFNBQUFnSSxvQkFBQTtBQUFBLFFBQ2hFO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FoQ3VCO0FBQUE7QUFBQSxTQUFBVixlQUFBO0FBQUEsU0FBQVcsYUFBQTtBQUFBLFNBQUFELG9CQUFBO0FBQUEsU0FBQUMsZUFBQTtBQUFBLFFBb0RwQjtBQUFBLFNBQW1EO0FBQUE7QUFBQSxTQUFBNUQ7QUFBQUEsV0FFcEQ7QUFBQTtBQUFBLFNBQUFyRSxRQUE4RDtBQUFBLFNBQUFnSSxvQkFBQTtBQUFBLFFBQ2hFO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0F2RHVCO0FBQUE7QUFBQSxTQUFBVixlQUFBO0FBQUEsU0FBQVcsZUFBQTtBQUFBLFNBQUFDLGFBQUE7QUFBQSxTQUFBRixvQkFBQTtBQUFBLFNBQUFDLGVBQUE7QUFBQSxTQUFBQyxlQUFBO0FBQUEsYUEyRDBCO0FBQUEsUUFBcEM7QUFBQSxVQUFWO0FBQUEsZ0JBQVU7QUFBQSxTQUNSO0FBQUEsZ0JBQzRDO0FBQUEsUUFBcEM7QUFBQSxVQUFWO0FBQUEsZ0JBQVU7QUFBQSxTQUNSO0FBQUE7QUFBQSxTQUFBM0UsY0FDWSxNQUFNO0FBQUEsU0FBQWMsVUFDSjtBQUFBLFNBQUFZLEtBQXdCO0FBQUEsU0FBQUMsS0FBQTtBQUFBLFFBQ2hDO0FBQUEsUUFDQTtBQUFBO0FBQUEsU0FBQWI7QUFBQUEsV0FFVDtBQUFBLGFBQWlDO0FBQUE7QUFBQTtBQUFBLFNBQUFyRSxRQUF5QztBQUFBLFNBQUFnSSxvQkFBQTtBQUFBLFFBRzVDO0FBQUE7QUFBQSxzQkFBb0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQXZFN0I7QUFBQTtBQUFBLFNBQUFWLGVBQUE7QUFBQSxTQUFBVSxvQkFBQTtBQUFBLFNBQUEzRDtBQUFBQSxXQW1DckI7QUFBQTtBQUFBLFNBQUFyRSxTQUE4RDtBQUFBLFNBQUFnSSxvQkFBQTtBQUFBLFFBQ2hFO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FwQ3VCO0FBQUE7QUFBQSxTQUFBVixnQkFBQTtBQUFBLFNBQUFVLG9CQUFBO0FBQUEsU0FBQTNEO0FBQUFBLFdBdUNyQjtBQUFBO0FBQUEsU0FBQXJFLFNBQThEO0FBQUEsU0FBQWdJLG9CQUFBO0FBQUEsUUFDaEU7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQXhDdUI7QUFBQTtBQUFBLFNBQUFWLGdCQUFBO0FBQUEsU0FBQVUsb0JBQUE7QUFBQSxTQUFBM0Q7QUFBQUEsV0EyQ3JCO0FBQUE7QUFBQSxTQUFBckUsU0FBOEQ7QUFBQSxTQUFBZ0ksb0JBQUE7QUFBQSxRQUNoRTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BNUN1QjtBQUFBO0FBQUEsU0FBQVYsZ0JBQUE7QUFBQSxTQUFBVSxvQkFBQTtBQUFBLFNBQUEzRDtBQUFBQSxXQStDckI7QUFBQTtBQUFBLFNBQUFyRSxTQUE4RDtBQUFBLFNBQUFnSSxvQkFBQTtBQUFBLFFBQ2hFO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUEyQks7QUFBQSxHQUFtQjtBQUFBLFlBQUFHLE9BQUFuSSxLQUFBSTtBQUFBQSxRQUFBLElBbUNDO0FBQUEsSUFBWCxPQUF3QixpQkFBeEIsMENBQXdCO0FBQUE7QUFBQSxZQUFBZ0ksWUFBQS9GLE9BQUF4QyxPQUFBcUQ7QUFBQUE7QUFBQUEsS0FBQXBDLE1BT3hDO0FBQUEsS0FBQXVCLFVBQ0E7QUFBQSxLQUFBeEMsVUFDRTtBQUFBLElBV0YsbUJBQXFCO0FBQUE7QUFBQSxTQUNuQjtBQUFBLEtBQUF3SSxNQUFVO0FBQUEsSUFDVjtBQUFBO0FBQUEsT0FDVztBQUFBO0FBQUEsT0FDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFDYztBQUFBO0FBQUEsb0JBQWlCLGtDQUFpQjtBQUFBO0FBQUEsUUFDekQsdUJBQWdCO0FBQUEsUUFDaEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDRCQUNzQjtBQUFBLFFBQWtCLDZDQUFpQjtBQUFBO0FBQUEsUUFDekQsdUJBQWdCO0FBQUEsUUFDaEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUVBO0FBQUE7QUFBQSxJQUVGLHVDQUEwQjtBQUFBO0FBQUEsWUFBQUMsa0JBQUF6RixNQUFBSztBQUFBQTtBQUFBQSxLQUFBTCxTQUlqQjtBQUFBLEtBQUEvQixNQUNYO0FBQUEsS0FBQTFCLElBQ007QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBTUY7QUFBQTtBQUFBLFdBQThCO0FBQUEsdURBQWlCO0FBQUE7QUFBQSxlQUFBaUosUUFDOUM7QUFBQSxXQUNWLHlCQUFnQjtBQUFBLFdBQ2hCO0FBQUE7QUFBQSxXQUFnRCx5Q0FPN0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQWZ5QjtBQUFBLFdBQUFBLFFBQ2xCO0FBQUEsT0FDVjtBQUFBLE9BQ0E7QUFBQTtBQUFBLE9BQWdELHlDQVk3QztBQUFBO0FBQUEsTUFoQlE7QUFBQTtBQUFBLEtBVytCO0FBQUEsVUFBQUEsTUFDaEM7QUFBQSxNQUNWO0FBQUEsTUFBc0MsdUNBR25DO0FBQUE7QUFBQTtBQUFBLElBQUg7QUFBQSxHQUFHO0FBQUEsWUFBQUUsc0JBQUFyRjtBQUFBQTtBQUFBQSxLQUFBQSxRQUlLO0FBQUEsS0FBQXNGLElBQ1Y7QUFBQSxLQUFBSCxNQUNVO0FBQUEsSUFDVjtBQUFBLElBQWdDLHVDQUNOO0FBQUE7QUFBQSxZQUFBSSxnQkFBQWpJLE9BQUFxQztBQUFBQTtBQUFBQSxLQUFBQSxTQXNDYjtBQUFBLEtBQUE2RixPQUNBO0FBQUEsS0FBQTlILE1BQ0Q7QUFBQSxJQUNWO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBLHVCQUFzQjtBQUFBLElBQ3RCO0FBQUEsSUFBd0IsMkJBQ0w7QUFBQTtBQUFBLFlBQUErSCxrQkFBQTFJLE9BQUFtQjtBQUFBQSxJQUdyQixlQXNCTztBQUFBLFFBQUF1QixJQXBCTCxZQUVFO0FBQUE7QUFBQSxTQUFBbEQsTUFBQTtBQUFBO0FBQUEsTUFDRSxtREFDYztBQUFBLGNBRGQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBQW1KLFNBSUY7QUFBQSxLQUFBaEk7QUFBQUEsT0FFUTtBQUFBLFNBQVY7QUFBQSxLQUFBaUksTUFDQTtBQUFBLGFBQUFDLElBQUExSixHQUNZLGdDQUFvQixTQUFVO0FBQUE7QUFBQSxLQUFBMkosT0FDMUM7QUFBQSxTQUNBO0FBQUE7QUFBQTtBQUFBLFNBQUF0SixJQUFBO0FBQUE7QUFBQSxVQUFBTCxJQUNFO0FBQUE7QUFBQSxPQUdPO0FBQUEsV0FESCxrQkFBbUIsU0FBTyxjQUFjLFdBQVc7QUFBQSxjQUZ2RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFLRix1Q0FDTTtBQUFBO0FBQUEsWUFBQTRKLFlBQUEvSSxPQUFBMEM7QUFBQUEsSUFuRVk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBdUVJLE9BQXNDLHlCQUF0QyxzQkFBc0M7QUFBQTtBQUFBLFlBQUFzRyxjQUFBaEosT0FBQTBDO0FBQUFBLElBdkR6QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUF5REcsT0FBeUMseUJBQXpDLHNCQUF5QztBQUFBO0FBQUEsWUFBQXVHLGtCQUFBakosT0FBQTBDO0FBQUFBLElBakQ1QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFtREcsT0FBNkMseUJBQTdDLHNCQUE2QztBQUFBO0FBQUEsWUFBQXdHLGNBQUFsSixPQUFBMEM7QUFBQUEsSUFuRWhEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQXFFRyxPQUF5Qyx5QkFBekMsZ0NBQXlDO0FBQUE7QUFBQSxZQUFBeUcsY0FBQTVJLE9BQUFxQyxNQUFBWTtBQUFBQSxhQUFBNEYsSUFBQXBLO0FBQUFBLEtBTS9EO0FBQUE7QUFBQSxZQUFBcUssT0FJUztBQUFBO0FBQUEsWUFBQUEsT0FGVztBQUFBLG9CQUFBQSxPQUNBO0FBQUE7QUFBQSxLQUVwQixxREFBOEI7QUFBQTtBQUFBLGFBQUFDLGlCQUFBckc7QUFBQUEsU0FBQW1CLFFBU0M7QUFBQSxLQUFnQjtBQUFBO0FBQUEseUNBRzlCO0FBQUE7QUFBQSxJQUNuQjtBQUFBO0FBQUE7QUFBQSxRQUFBbkIsTUFLWSxrQkFBYTtBQUFBLFFBQUFwQyxNQWhCdkI7QUFBQSxRQUFBckIsSUFNRztBQUFBO0FBQUE7QUFBQTtBQUFBLFNBSkQ7QUFBQSxrQkFDUTtBQUFBO0FBQUE7QUFBQSxXQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBQ1E7QUFBQTtBQUFBO0FBQUEsY0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUhPO0FBQUE7QUFBQSxnQkFJTCxVQUFlO0FBQUEsUUFXWSwwQkFFRztBQUFBO0FBQUE7QUFBQSxPQVBoQyxhQU9nQztBQUFBO0FBQUEsZUFOVCxRQUFRLHNDQU1DO0FBQUE7QUFBQSxPQUxkLE9BQVEsaUJBQVIsT0FLYztBQUFBLGVBQTlCLE9BQWIsa0JBQWEsZ0NBQThCO0FBQUE7QUFBQTtBQUFBLFlBQUErSixnQkFBQXBKO0FBQUFBLFFBQUFRLE1BWW5DO0FBQUEsSUFDVjtBQUFBLElBQXNCLDJCQUNIO0FBQUE7QUFBQSxZQUFBNkksY0FBQW5KLFNBQUFvSixLQUFBQyxPQUFBM0o7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUEsa0JBQUEwSixJQWVKLEtBQUFDLE1BQUEsT0FBQTNKLE1BQUE7QUFBQTtBQUFBO0FBQUEsMkNBdUZiLHlCQUFLO0FBQUEsZUF2RlE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUFBNEQsU0FBQSxRQUFBbEIsUUFBQTtBQUFBLGtCQVliO0FBQUEsd0VBMkVLO0FBQUE7QUFBQTtBQUFBLG1CQUFBa0IsU0F2RlE7QUFBQSxtQkFBQWYsT0FBQTtBQUFBLG1CQUFBSCxRQUFBO0FBQUEsbUJBQUF6QyxRQUFBO0FBQUEsa0JBY2I7QUFBQSwyRUF5RUs7QUFBQTtBQUFBO0FBQUEsbUJBQUEyRCxTQXZGUTtBQUFBLG1CQUFBZixTQUFBO0FBQUEsbUJBQUFILFFBQUE7QUFBQSxtQkFBQXpDLFVBQUE7QUFBQSxrQkFnQmI7QUFBQSxpRkF1RUs7QUFBQTtBQUFBO0FBQUEsbUJBQUEyRCxTQXZGUTtBQUFBLG1CQUFBZixTQUFBO0FBQUEsbUJBQUFILFFBQUE7QUFBQSxtQkFBQXpDLFVBQUE7QUFBQSxrQkFrQmI7QUFBQSxxRkFxRUs7QUFBQTtBQUFBO0FBQUEsbUJBQUEyRCxTQXZGUTtBQUFBLG1CQUFBZixTQUFBO0FBQUEsbUJBQUFILFFBQUE7QUFBQSxtQkFBQXpDLFVBQUE7QUFBQSxrQkFvQmI7QUFBQSxpRkFtRUs7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBQTJELFNBdkZRLFFBQUFsQixRQUFBO0FBQUEsa0JBd0JiLHNEQStESztBQUFBO0FBQUEsc0JBQUFrQixTQXZGUSxRQUFBK0YsUUEwQ2I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUFBL0YsVUExQ2EsUUFBQVYsTUFBQSxRQUFBeUcsUUE2Q2I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUFBL0YsVUE3Q2EsUUFBQVIsTUFBQSxRQUFBdUcsUUErQ2I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUFBL0YsVUEvQ2E7QUFBQSxtQkFBQUMsYUFBQTtBQUFBLG1CQUFBOEYsUUE0RWI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDBCQTVFYTtBQUFBO0FBQUEsdUJBQUEvRixVQUFBLFFBQUE1RCxRQUFBO0FBQUEsdUJBQUEySixRQThFYixLQUFBRCxNQUFBLEdBQUE5RixPQUFBO0FBQUE7QUFBQSxvQkFBQThGO0FBQUFBLHNCQUFBLFNBQUFFO0FBQUFBLHVCQUNFLG9EQUFnRTtBQUFBO0FBQUEsbUJBQ2xFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx1QkFBQWhHLFVBaEZhLFFBQUE1RCxRQUFBO0FBQUEsdUJBQUEySixRQWtGYixLQUFBRCxNQUFBLEdBQUE5RixPQUFBO0FBQUE7QUFBQSxvQkFBQThGO0FBQUFBLHNCQUFBLFNBQUFFO0FBQUFBLHVCQUNFLG9EQUFnRTtBQUFBO0FBQUEsbUJBQ2xFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQTVDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBQUFoRyxVQXhDYSxRQUFBN0QsTUFBQTtBQUFBLGtCQXlFYjtBQUFBO0FBQUEsNEVBY0s7QUFBQSxzQkFBQU8sWUFkTDtBQUFBLDhFQWNLO0FBQUE7QUFBQTtBQUFBLG1CQUFBc0QsVUF2RlE7QUFBQSxtQkFBQW5ILElBQUE7QUFBQSxtQkFBQXNILFFBQUE7QUFBQSx1QkE4QmdCO0FBQUEsa0JBQU07QUFBQTtBQUFBLDBFQXlEOUI7QUFBQSxzQkFBQXpELFlBekQ4QjtBQUFBLDRFQXlEOUI7QUFBQTtBQUFBO0FBQUEsa0JBQUFzRCxVQXZGUTtBQUFBLGNBcUViLGdCQUFBeEU7QUFBQUEsbUJBQUF5SyxVQUNFO0FBQUEsZUFDQSx1Q0FBMEIsRUFGNUI7QUFBQTtBQUFBLGlCQUFBakcsVUFyRWE7QUFBQSxhQWlFYixnQkFBQWpCO0FBQUFBLGtCQUFBa0gsVUFDc0M7QUFBQSxjQUNwQyx1Q0FBMEIsRUFGNUI7QUFBQTtBQUFBO0FBQUEsYUFBQWpHLFVBakVhO0FBQUEsYUFBQWlHLFVBMkRiO0FBQUEsWUFDQSxnQkFBQTVLLE9BQVMsdUNBQTBCLEVBQW5DO0FBQUE7QUFBQSxlQUFBMkUsVUE1RGE7QUFBQSxXQTRCYixnQkFBQW5ILEdBQVMsMkNBQXVDLEVBQWhEO0FBQUE7QUFBQSxjQUFBbUgsVUE1QmE7QUFBQSxVQTBCYixnQkFBQW5ILEdBQUFnSDtBQUFBQSxXQUFXO0FBQUE7QUFBQSxzQ0FBQXFHLEdBQXdDLDBCQUFLO0FBQUEsNEJBQU8sRUFBL0Q7QUFBQTtBQUFBLGFBQUFsRyxVQTFCYSxRQUFBeEQsUUFBQTtBQUFBLFNBdURiLGdCQUFBbkI7QUFBQUEsY0FBQWUsTUFBQSxjQUNjO0FBQUEsVUFBWixPQUFvQztBQUFBLDJCQUFwQyxtREFBb0MsRUFEdEM7QUFBQTtBQUFBO0FBQUEsU0FBQTRELFVBdkRhO0FBQUEsU0FBQUwsWUFBQTtBQUFBLFNBQUFVLEtBa0RKO0FBQUEsUUFDVCxnQkFBQWYsS0FFRSw0Q0FBOEMsRUFGaEQ7QUFBQTtBQUFBLFdBQUFVLFNBbkRhLFFBQUFmLFNBQUEsUUFBQUgsUUFBQSxRQUFBbEMsUUFBQTtBQUFBLE9BeU5pQjtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUFBMEcsR0FBQXpEO0FBQUFBLHVCQUFBUCxNQVdsQjtBQUFBLG1CQUNWLDRDQUE4QztBQUFBO0FBQUE7QUFBQSxtQkFBQU87QUFBQUE7QUFBQUEsb0JBQUFQO0FBQUFBLHNCQVRwQyxxQkFBb0I7QUFBQSxtQkFDOUIsNENBQThDO0FBQUEsbUJBdEkzQztBQUFBLFlBQUFnRSxJQWtJeUI7QUFBQSxRQU05QixnQkFBQXpEO0FBQUFBLGFBQUFQLE1BQ1k7QUFBQSxTQUNWLDRDQUE4QyxFQUZoRDtBQUFBO0FBQUEsT0FOOEI7QUFBQSxZQUFBOEQsSUFBQSxVQUFBM0UsUUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUFBNkUsR0FBQXpEO0FBQUFBLHVCQUFBUCxNQXdCbEIsc0JBQW9CO0FBQUEsbUJBQzlCLDRDQUE4QztBQUFBO0FBQUE7QUFBQSxtQkFBQU87QUFBQUE7QUFBQUEsb0JBQUFQO0FBQUFBLHNCQVZwQyxxQkFBb0I7QUFBQSxvQkFBQUEsUUFDbkI7QUFBQSxtQkFDWCw4Q0FBK0M7QUFBQSxtQkFuSjVDO0FBQUEsWUFBQWdFLE1Ba0l5QjtBQUFBLFFBbUI5QixnQkFBQXpEO0FBQUFBLGFBQUFQLE1BQ1ksc0JBQW9CO0FBQUEsU0FDOUIsNENBQThDLEVBRmhEO0FBQUE7QUFBQSxXQUFBYixVQW5COEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFBQTJFLEdBQUFFLEdBQUF6RDtBQUFBQTtBQUFBQSxtQkFBQVAsTUFxQ2xCLHdCQUFvQjtBQUFBLGtCQUM5Qiw0Q0FBOEM7QUFBQTtBQUFBO0FBQUEsa0JBQUE4RCxHQUFBdkQ7QUFBQUE7QUFBQUEsbUJBQUFQO0FBQUFBLHFCQVZwQyxxQkFBb0I7QUFBQSxtQkFBQUEsUUFDbkI7QUFBQSxrQkFDWCw4Q0FBK0M7QUFBQSxrQkFoSzVDO0FBQUEsV0FBQWdFLE1Ba0l5QjtBQUFBLE9BZ0M5QixnQkFBQUYsR0FBQXZEO0FBQUFBLFlBQUFQLE1BQ1ksd0JBQW9CO0FBQUEsUUFDOUIsNENBQThDLEVBRmhEO0FBQUE7QUFBQSxVQUFBVSxTQXpQYSxRQUFBbEIsTUFBQTtBQUFBLE1BVWIsa0RBQUFRLEtBQXdDLFdBQUcsRUE2RXRDO0FBQUE7QUFBQSxTQUFBVSxTQXZGUTtBQUFBLEtBTWIsZ0JBQUF4RTtBQUFBQTtBQUFBQSxPQUFBOEQsTUEvQlE7QUFBQSxPQUFBc0YsSUFDVjtBQUFBLE9BQUFILE1BQ1U7QUFBQSxNQUNWO0FBQUEsVUFBQXdCLFVBQWdDO0FBQUEsTUE4QjVCLHNDQUEwQixFQUY1QjtBQUFBO0FBQUEsUUFBQWpHLE9BTmE7QUFBQSxJQUViLGdCQUFBeEU7QUFBQUEsU0FBQXlLLFVBQ0U7QUFBQSxLQUNBLG9DQUEwQixFQUY1QjtBQUFBLEdBcUZLO0FBQUEsWUFBQUosWUFBQUMsR0FBQUMsS0FBQTNKO0FBQUFBLElBdkZRLE9ENytDakIsZ0JDNitDaUIsOEJBdUZSO0FBQUE7QUFBQSxZQUFBK0oscUJBQUF6SixTQUFBb0osR0FBQUMsS0FBQTVKLEtBQUFDO0FBQUFBLElBUVk7QUFBQTtBQUFBLE1BYWtCO0FBQUEsS0FibEI7QUFBQSx1RUFnQjRDO0FBQUEsU0FBQU0sWUFoQjVDO0FBQUEsb0RBZ0I0QztBQUFBO0FBQUEsSUFoQjVDO0FBQUEsU0FBQUYsUUFBQTtBQUFBLEtBWWtCO0FBQUE7QUFBQSwwREFJMEI7QUFBQSxTQUFBRSxZQUoxQjtBQUFBLDREQUkwQjtBQUFBO0FBQUEsSUFoQjVDO0FBQUEsc0VBZ0I0QztBQUFBLFFBQUFBLFlBaEI1QztBQUFBLG1EQWdCNEM7QUFBQTtBQUFBLFlBQUF5SixtQkFBQUwsR0FBQUMsS0FBQTVKLEtBQUFDO0FBQUFBLElBaEI1QyxPRDVrRHJCLGdCQzRrRHFCLDBDQWdCNEM7QUFBQTtBQUFBLFlBQUFnSyxrQkFBQTFKLFNBQUFvSixHQUFBQyxLQUFBdkosT0FBQUo7QUFBQUEsSUFRMUM7QUFBQTtBQUFBO0FBQUEsWUFBQTRELE9BQUE7QUFBQSxRQUNRLGdCQUFBM0UsT0FBUyx5Q0FBOEIsRUFBdkM7QUFBQTtBQUFBLFlBQUEyRSxTQURSO0FBQUEsUUFFUSxnQkFBQTNFLE9BQVMsMkNBQThCLEVBQXZDO0FBQUE7QUFBQSxZQUFBMkUsU0FGUjtBQUFBLFFBR1EsZ0JBQUEzRSxPQUFTLDJDQUE4QixFQUF2QztBQUFBO0FBQUEsWUFBQTJFLFNBSFI7QUFBQSxRQUlRLGdCQUFBM0UsT0FBUywyQ0FBOEIsRUFBdkM7QUFBQTtBQUFBLFlBQUEyRSxTQUpSO0FBQUEsUUFLUSxnQkFBQTNFLE9BQVMsMkNBQThCLEVBQXZDO0FBQUE7QUFBQSxZQUFBMkUsU0FMUjtBQUFBLFFBTVEsZ0JBQUEzRSxPQUFTLDJDQUE4QixFQUF2QztBQUFBO0FBQUEsWUFBQTJFLFNBTlI7QUFBQSxRQU9RLGdCQUFBM0UsT0FBUywyQ0FBOEIsRUFBdkM7QUFBQTtBQUFBLFlBQUEyRSxTQVBSO0FBQUEsUUFRUSxnQkFBQTNFLE9BQVMsMkNBQThCLEVBQXZDO0FBQUE7QUFBQSxZQUFBMkUsU0FSUjtBQUFBLFFBY1EsZ0JBQUEzRSxPQUFTLDJDQUE4QixFQUF2QztBQUFBO0FBQUE7QUFBQSxTQUFBMkUsU0FkUjtBQUFBLFNBQUFNLE1BQUE7QUFBQSxTQUFBQyxNQUFBO0FBQUEsU0FBQUYsS0FpQlYsTUFBTTtBQUFBLFFBQ2YsZ0JBQUFoRjtBQUFBQSxTQUErQixPQUFzQjtBQUFBO0FBQUE7QUFBQSxrQkFBdEI7QUFBQSxzQkFBMEIsRUFBekQ7QUFBQTtBQUFBLFlBQUEyRSxTQWxCbUI7QUFBQSxRQVNRLGdCQUFBM0UsT0FBQTtBQUFBLFNBQVcsMkNBQThCLEVBQXpDO0FBQUE7QUFBQSxZQUFBMkUsVUFUUjtBQUFBLFFBVVEsZ0JBQUEzRSxPQUFTLDRDQUE4QixFQUF2QztBQUFBO0FBQUEsWUFBQTJFLFVBVlI7QUFBQSxRQVdRLGdCQUFBM0UsT0FBUyw0Q0FBOEIsRUFBdkM7QUFBQTtBQUFBLFFBQ0E7QUFBQSxnQkFDQTtBQUFBO0FBQUEsSUFFQTtBQUFBLHNFQUc4QjtBQUFBLFFBQUFxQixZQUg5QjtBQUFBLG1EQUc4QjtBQUFBO0FBQUEsWUFBQTBKLGdCQUFBTixHQUFBQyxLQUFBdkosT0FBQUo7QUFBQUEsSUFsQnRDLE9EcG1EdkIsZ0JDb21EdUIseUNBa0JzQztBQUFBO0FBQUEsWUFBQWlLLGlCQUFBM0osU0FBQW9KLEdBQUFDLEtBQUEzSjtBQUFBQSxRQUFBLElBUTNEO0FBQUE7QUFBQSxpRUFBc0U7QUFBQSxRQUFBTSxZQUF0RTtBQUFBLDhDQUFzRTtBQUFBO0FBQUEsWUFBQTRKLGFBQUFSLEdBQUFDLEtBQUEzSixLQUFBMEMsS0FBQWdDO0FBQUFBLElBTzNDO0FBQUEsS0FFekIsZ0JBQUFqQjtBQUFBQSxVQUFBb0csVUFDc0M7QUFBQSxNQUNwQyxtQ0FBeUIsRUFGM0I7QUFBQSxJQUZ5QjtBQUFBLFNBQUFoSyxRQUFBLFFBQUF3QyxRQUFBO0FBQUEsS0FNekIsZ0JBQUFvQjtBQUFBQSxVQUFBb0csVUFDOEQsU0FBeEIsMEJBQXdCO0FBQUEsTUFDNUQsbUNBQXlCLEVBRjNCO0FBQUE7QUFBQSxRQUFBeEgsVUFOeUI7QUFBQSxJQVV6QixnQkFBQTJFLEdBQUF2RDtBQUFBQSxTQUFBb0csVUFDMEQsU0FBcEIsd0JBQW9CO0FBQUEsS0FDeEQsbUNBQXlCLEVBRjNCO0FBQUEsR0FFMkI7QUFBQSxZQUFBTSwyQkFBQVQsR0FBQUMsS0FBQTNKLEtBQUEwQyxLQUFBRyxNQUFBNkIsT0FBQXpFO0FBQUFBLElBU1M7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQWlILEdBQUF6RDtBQUFBQSxvQkFBQVAsTUFXeEIscUJBQW9CO0FBQUEsZ0JBQzlCLHlDQUE4QztBQUFBO0FBQUE7QUFBQSxnQkFBQU87QUFBQUEsb0JBQUFQLE1BVHBDO0FBQUEsZ0JBQ1YseUNBQThDO0FBQUEsZ0JBZ0NBO0FBQUEsU0FBQWdFLElBcENaO0FBQUEsS0FNcEMsZ0JBQUF6RDtBQUFBQSxVQUFBUCxNQUNZLHFCQUFvQjtBQUFBLE1BQzlCLHlDQUE4QyxFQUZoRDtBQUFBO0FBQUEsSUFOb0M7QUFBQSxTQUFBOEQsSUFBQSxRQUFBM0UsUUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBNkUsR0FBQXpEO0FBQUFBO0FBQUFBLGlCQUFBUDtBQUFBQSxtQkF1QnhCO0FBQUE7QUFBQTtBQUFBLHFCQUFvQixxQkFBcUI7QUFBQSxnQkFDbkQseUNBQThDO0FBQUE7QUFBQTtBQUFBLGdCQUFBTztBQUFBQSxvQkFBQVAsTUFUcEMsc0JBQW9CO0FBQUEsZ0JBQzlCLHlDQUE4QztBQUFBLGdCQW9CQTtBQUFBLFNBQUFnRSxNQXBDWjtBQUFBLEtBa0JwQyxnQkFBQXpEO0FBQUFBO0FBQUFBLE9BQUFQO0FBQUFBLFNBQ1k7QUFBQSxxQkFBb0IsdUJBQXFCO0FBQUEsTUFDbkQseUNBQThDLEVBRmhEO0FBQUE7QUFBQSxRQUFBYixVQWxCb0M7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQUFBMkUsR0FBQUUsR0FBQXpEO0FBQUFBO0FBQUFBLGdCQUFBUDtBQUFBQSxrQkFtQ3hCO0FBQUE7QUFBQTtBQUFBLG9CQUFvQixxQkFBcUI7QUFBQSxlQUNuRCx5Q0FBOEM7QUFBQTtBQUFBO0FBQUEsZUFBQThELEdBQUF2RDtBQUFBQSxtQkFBQVAsTUFUcEMsd0JBQW9CO0FBQUEsZUFDOUIseUNBQThDO0FBQUEsZUFRQTtBQUFBLFFBQUFnRSxNQXBDWjtBQUFBLElBOEJwQyxnQkFBQUYsR0FBQXZEO0FBQUFBO0FBQUFBLE1BQUFQO0FBQUFBLFFBQ1k7QUFBQSxzQkFBb0IsdUJBQXFCO0FBQUEsS0FDbkQseUNBQThDLEVBRmhEO0FBQUEsR0FNZ0Q7QUFBQSxZQUFBa0gsY0FBQTlKLFNBQUFvSixHQUFBQyxLQUFBL0YsTUFBQUcsT0FBQXRIO0FBQUFBLElBbUR4QjtBQUFBLFNBQUFzSCxVQUFBO0FBQUEsS0FHeEIsZ0JBQUFOO0FBQUFBLE1BQytCLE9BQUssbUNBQUwsaUJBQUssRUFEcEM7QUFBQTtBQUFBLFlBRmU7QUFBQTtBQUFBLGtFQUdxQjtBQUFBLFFBQUFuRCxZQUhyQjtBQUFBLCtDQUdxQjtBQUFBO0FBQUEsWUFBQThKLFlBQUFWLEdBQUFDLEtBQUEvRixNQUFBRyxPQUFBdEg7QUFBQUEsSUFKWixPRGp2RDVCLGdCQ2l2RDRCLHlDQUlZO0FBQUE7QUFBQSxZQUFBNE4sZUFBQS9KLFNBQUFvSixLQUFBSSxHQUFBOUo7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUEsaUJBQUEwSixJQU12QixLQUFBMUosTUFBQTtBQUFBO0FBQUE7QUFBQSwwQ0FzRVQsdUJBQUc7QUFBQSxjQXRFTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEscUJBQUE0RCxVQUFBLFFBNENUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHlCQTVDUztBQUFBO0FBQUEsc0JBQUFBLFVBQUEsUUFBQTVELFFBQUE7QUFBQSxzQkFBQTBKLE1Ba0VULEdBQUE5RixPQUFBO0FBQUE7QUFBQSxtQkFBQThGLE1BQUEsU0FBQVksS0FBeUIsbUNBQXVCO0FBQUEsa0JBQWhEO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBQUExRyxVQWxFUyxRQUFBNUQsUUFBQTtBQUFBLHNCQUFBMEosTUFvRVQsR0FBQTlGLE9BQUE7QUFBQTtBQUFBLG1CQUFBOEYsTUFBQSxTQUFBWSxLQUF5QixtQ0FBdUI7QUFBQSxrQkFBaEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQTFCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxxQkFBQTFHLFVBMUNTLFFBQUFHLFFBQUE7QUFBQSxpQkFzQ1Q7QUFBQTtBQUFBLDJFQWdDRztBQUFBLHFCQUFBekQsWUFoQ0g7QUFBQSw2RUFnQ0c7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxxQkFBQXNELFVBdEVNO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUFBQSxVQUFBLFFBQUE3RCxNQUFBO0FBQUEsYUE4RFQ7QUFBQSwrQkFBQWQsT0FBNkIsdUJBQUcsb0JBUTdCO0FBQUE7QUFBQSxnQkFBQTJFLFVBdEVNLFFBQUFILE9BMERIO0FBQUEsWUFBdUIsZ0JBQUF4RSxPQTlEckIsYUE4RHFCO0FBQUE7QUFBQTtBQUFBLFlBQUEyRSxVQTFEcEI7QUFBQSxZQUFBSCxPQWtDSTtBQUFBLFlBQUFBLE9BQVAsU0FBQXhFLE9BdENFO0FBQUEsV0FzQzZCLGdCQUFBQSxPQXRDN0IsYUFzQzZCO0FBQUE7QUFBQSxjQUFBMkUsVUFsQzVCLFFBQUF4RCxRQUFBO0FBQUEsVUFvRFQsZ0JBQUFuQjtBQUFBQSxlQUFBZSxNQUFBLGNBRWdCO0FBQUEsV0FBWixPQUFvQztBQUFBLDBCQUFwQyxtREFBb0MsRUFGeEM7QUFBQTtBQUFBLGFBQUE0RCxVQXBEUyxRQUFBSCxPQUFBO0FBQUEseUJBQUF4RSxPQUpELGFBSUM7QUFBQTtBQUFBLFlBQUFvRixVQUFBO0FBQUE7QUFBQSxhQUFBVCxTQUFBLFFBQUFILE1BNEJIO0FBQUEsU0FBdUIsZ0JBQUF4RSxPQWhDckIsWUFnQ3FCO0FBQUE7QUFBQSxRQTVCcEI7QUFBQSxhQUFBMkUsU0FBQSxRQUFBSCxNQThCSDtBQUFBLFNBQXVCLGdCQUFBeEUsT0FsQ3JCLFlBa0NxQjtBQUFBO0FBQUE7QUFBQSxTQUFBMkUsU0E5QnBCO0FBQUEsU0FBQUgsT0FnQ0k7QUFBQSxTQUFBQSxPQUFQLFNBQUF4RSxPQXBDRTtBQUFBLFFBb0M2QixnQkFBQUEsT0FwQzdCLGFBb0M2QjtBQUFBO0FBQUEsV0FBQTJFLFNBaEM1QixRQUFBZixPQUFBLFFBQUFILE1BQUE7QUFBQSxPQTJFUztBQUFBO0FBQUEsYUFBQWUsT0FJWjtBQUFBLFNBQXNCLGdCQUFBeEUsT0FuRnBCLGFBbUZvQjtBQUFBO0FBQUEsUUFKVjtBQUFBO0FBQUEsVUFBQXdFLE9BTUw7QUFBQSxVQUFBQSxPQUFQLFNBQUF4RSxPQXJGRTtBQUFBLFNBcUY0QixnQkFBQUEsT0FyRjVCLGFBcUY0QjtBQUFBO0FBQUEsWUFBQXdFLE9BSjlCO0FBQUEsUUFBc0IsZ0JBQUF4RSxPQWpGcEIsYUFpRm9CO0FBQUE7QUFBQSxPQUZWO0FBQUE7QUFBQSxhQUFBd0UsT0FVWjtBQUFBLFNBQXNCLGdCQUFBeEUsT0F6RnBCLGFBeUZvQjtBQUFBO0FBQUEsUUFWVjtBQUFBO0FBQUEsVUFBQXdFLE9BWUw7QUFBQSxVQUFBQSxPQUFQLFNBQUF4RSxPQTNGRTtBQUFBLFNBMkY0QixnQkFBQUEsT0EzRjVCLGFBMkY0QjtBQUFBO0FBQUEsWUFBQXdFLE9BSjlCO0FBQUEsUUFBc0IsZ0JBQUF4RSxPQXZGcEIsYUF1Rm9CO0FBQUE7QUFBQSxPQVJWO0FBQUE7QUFBQSxTQUFBd0UsT0FnQkw7QUFBQSxTQUFBQSxPQUFQLFNBQUF4RSxPQS9GRTtBQUFBLFFBK0Y0QixnQkFBQUEsT0EvRjVCLGFBK0Y0QjtBQUFBO0FBQUEsT0FoQmxCO0FBQUE7QUFBQSxTQUFBd0UsT0FrQkU7QUFBQSxTQUFBQSxPQUFQLFNBQUF4RSxPQWpHTDtBQUFBLFNBQUF3RSxPQWlHRixTQUFBeEUsT0FqR0U7QUFBQSxRQWlHb0MsZ0JBQUFBLE9BakdwQyxhQWlHb0M7QUFBQTtBQUFBO0FBQUEsUUFBQXdFLE9BSi9CO0FBQUEsUUFBQUEsT0FBUCxTQUFBeEUsT0E3RkU7QUFBQSxPQTZGNEIsZ0JBQUFBLE9BN0Y1QixhQTZGNEI7QUFBQTtBQUFBLFVBQUFvRixVQXpGM0I7QUFBQTtBQUFBLFdBQUFULFNBQUEsUUFBQUgsTUFZSDtBQUFBLE9BQXVCLGdCQUFBeEUsT0FoQnJCLFlBZ0JxQjtBQUFBO0FBQUEsTUFacEI7QUFBQSxXQUFBMkUsU0FBQSxRQUFBSCxNQWNIO0FBQUEsT0FBdUIsZ0JBQUF4RSxPQWxCckIsWUFrQnFCO0FBQUE7QUFBQTtBQUFBLE9BQUEyRSxTQWRwQjtBQUFBLE9BQUFILE1BZ0JJO0FBQUEsT0FBQUEsTUFBUCxTQUFBeEUsT0FwQkU7QUFBQSxNQW9CNkIsZ0JBQUFBLE9BcEI3QixZQW9CNkI7QUFBQTtBQUFBLFNBQUFvRixRQWhCNUI7QUFBQTtBQUFBLFVBQUFULFNBQUEsUUFBQUgsTUFNSDtBQUFBLE1BQXVCLGdCQUFBeEUsT0FWckIsWUFVcUI7QUFBQTtBQUFBLEtBTnBCO0FBQUEsVUFBQTJFLFNBQUEsUUFBQUgsTUFRSDtBQUFBLE1BQXVCLGdCQUFBeEUsT0FackIsWUFZcUI7QUFBQTtBQUFBO0FBQUEsTUFBQTJFLFNBUnBCO0FBQUEsTUFBQUgsTUFVSTtBQUFBLE1BQUFBLE1BQVAsU0FBQXhFLE9BZEU7QUFBQSxLQWM2QixnQkFBQUEsT0FkN0IsWUFjNkI7QUFBQTtBQUFBLFFBQUEyRSxPQVY1QixRQUFBSCxJQUFBO0FBQUEsb0JBQUF4RSxPQUpELFVBSUM7QUFBQSxHQXNFTjtBQUFBLFlBQUFvTCxhQUFBWCxHQUFBSSxHQUFBOUo7QUFBQUEsSUF0RU0sT0QzdkRqQixnQkMydkRpQiw2QkFzRU47QUFBQTtBQUFBLFlBQUF1SyxxQkFBQWpLLFNBQUFvSixHQUFBSSxHQUFBOUosS0FBQWY7QUFBQUEsSUF3QlA7QUFBQSxTQUFBOEUsUUFBQSxVQUFBTixJQU9VO0FBQUEsS0FBa0MsZ0JBQUF4RSxPQXpHaEMsVUF5R2dDO0FBQUE7QUFBQSxJQUZ4QztBQUFBLGtFQUV3QztBQUFBLFFBQUFxQixZQUZ4QztBQUFBLCtDQUV3QztBQUFBO0FBQUEsWUFBQWlLLG1CQUFBYixHQUFBSSxHQUFBOUosS0FBQWY7QUFBQUEsSUFQNUMsT0R6MURKLGdCQ3kxREksMENBTzRDO0FBQUE7QUFBQSxZQUFBdUwsV0FBQVYsR0FBQUg7QUFBQUEsUUFBQUEsTUFRckI7QUFBQTtBQUFBLGlDQWVLO0FBQUEsS0FmTDtBQUFBO0FBQUE7QUFBQSxTQUFBOUYsYUFBQTtBQUFBLFNBQUFxRCxJQUFBO0FBQUEsU0FBQTlGLElBRWY7QUFBQSxRQUNSO0FBQUEsUUFBYyxrQ0FZZ0I7QUFBQTtBQUFBLFlBQUFpRCxRQWZQLFFBQUE2QyxNQUFBO0FBQUE7QUFBQSxhQUFBeUMsUUFBQTtBQUFBLFNBS3ZCO0FBQUEsU0FBZ0I7QUFBQSxTQUFvQjtBQUFBO0FBQUE7QUFBQSxhQUFBQSxRQUxiO0FBQUEsU0FPdkI7QUFBQSxTQUFnQjtBQUFBLFNBQW9CO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQWxOLElBUGIsUUFBQXlLLE1BQUE7QUFBQSxRQVlLO0FBQUEsUUFBYyx1QkFHWjtBQUFBO0FBQUEsWUFBQUEsTUFmUCxRQWFLLG9CQUFjLCtCQUVaO0FBQUE7QUFBQSxZQUFBdUQsTUFmUCxRQUFBdkQsTUFBQTtBQUFBLFFBY0s7QUFBQSxRQUFjLGdDQUNaO0FBQUE7QUFBQTtBQUFBLFlBQUE5RixNQWZQLFFBQUE4RixNQUFBO0FBQUEsUUFTSztBQUFBLFFBQWMsb0NBTVo7QUFBQTtBQUFBLFlBQUE5SCxJQWZQLFFBQUE4SCxNQUFBO0FBQUEsUUFXSztBQUFBLFFBQWMsa0NBSVo7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBd0QsV0FBQUMsR0FBQWhCO0FBQUFBLFFBQUFBLE1BS1A7QUFBQTtBQUFBLGlDQWVLO0FBQUEsS0FmTDtBQUFBO0FBQUE7QUFBQSxTQUFBOUYsYUFBQTtBQUFBLFNBQUFxRCxJQUFBO0FBQUEsU0FBQTlGLElBRWY7QUFBQSxRQUNSO0FBQUEsUUFBYyx5Q0FZZ0I7QUFBQTtBQUFBLFlBQUFpRCxRQWZQLFFBQUE2QyxNQUFBO0FBQUE7QUFBQSxhQUFBeUMsUUFBQTtBQUFBLFNBS3ZCO0FBQUEsU0FBZ0I7QUFBQSxTQUF3QjtBQUFBO0FBQUE7QUFBQSxhQUFBQSxRQUxqQjtBQUFBLFNBT3ZCO0FBQUEsU0FBZ0I7QUFBQSxTQUF3QjtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFsTixJQVBqQixRQUFBeUssTUFBQTtBQUFBLFFBWUs7QUFBQSxRQUFjLHVCQUdaO0FBQUE7QUFBQSxZQUFBeUMsUUFmUCxRQWFLO0FBQUE7QUFBQSxZQUFBYyxNQWJMLFFBQUF2RCxNQUFBO0FBQUEsUUFjSztBQUFBLFFBQWMsZ0NBQ1o7QUFBQTtBQUFBO0FBQUEsWUFBQTlGLE1BZlAsUUFBQThGLE1BQUE7QUFBQSxRQVNLO0FBQUEsUUFBYywyQ0FNWjtBQUFBO0FBQUEsWUFBQTlILElBZlAsUUFBQThILE1BQUE7QUFBQSxRQVdLO0FBQUEsUUFBYyx5Q0FJWjtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUEwRCxXQUFBRCxHQUFBaEI7QUFBQUEsUUFBQUEsTUFNUDtBQUFBO0FBQUEsaUNBZUs7QUFBQSxLQWZMO0FBQUE7QUFBQTtBQUFBLFNBQUE5RixhQUFBO0FBQUEsU0FBQXFELElBQUE7QUFBQSxTQUFBOUYsSUFFZjtBQUFBLFFBQ1I7QUFBQSxRQUFjLHlDQVlnQjtBQUFBO0FBQUEsWUFBQWlELFFBZlAsUUFBQTZDLE1BQUE7QUFBQTtBQUFBLGFBQUF5QyxRQUFBO0FBQUEsU0FLdkI7QUFBQSxTQUFnQjtBQUFBLFNBQXdCO0FBQUE7QUFBQTtBQUFBLGFBQUFBLFFBTGpCO0FBQUEsU0FPdkI7QUFBQSxTQUFnQjtBQUFBLFNBQXdCO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQWxOLElBUGpCLFFBQUF5SyxNQUFBO0FBQUEsUUFZSztBQUFBLGdCQUFvQztBQUFBLFFBQU0seUNBR3hDO0FBQUE7QUFBQSxZQUFBeUMsUUFmUCxRQWFLO0FBQUE7QUFBQSxZQUFBYyxNQWJMLFFBQUF2RCxNQUFBO0FBQUEsUUFjSztBQUFBLFFBQWMsZ0NBQ1o7QUFBQTtBQUFBO0FBQUEsWUFBQTlGLE1BZlAsUUFBQThGLE1BQUE7QUFBQSxRQVNLO0FBQUEsUUFBYywyQ0FNWjtBQUFBO0FBQUEsWUFBQTlILElBZlAsUUFBQThILE1BQUE7QUFBQSxRQVdLO0FBQUEsUUFBYyx5Q0FJWjtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUEyRCxpQkFBQTVMO0FBQUFBLFFBQUFlLE1BTWIsVUFBQVksTUFDVDtBQUFBLGFBQUE4SSxFQUFBQztBQUFBQSxLQUNFO0FBQUEsYUFBNkI7QUFBQSxLQUFxQjtBQUFBO0FBQUEsSUFDOUQsNkJBQTRCO0FBQUE7QUFBQSxZQUFBbUIsbUJBQUE1SDtBQUFBQSxJQU9qQixtQkFBTTtBQUFBLFFBQUFwQyxNQUNmO0FBQUEsYUFBQWlLLFlBQUE5TCxPQUNxQiwyQ0FBaUQ7QUFBQSxhQUFBK0wsYUFBQXZMO0FBQUFBLFNBQUFBLElBRXBFO0FBQUE7QUFBQSxvQkFBZ0I7QUFBQSxVQUFBNEUsUUFDUjtBQUFBLE1BQU8sZ0NBRU47QUFBQSxVQUFBNUUsTUFEUztBQUFBO0FBQUE7QUFBQSxJQUNSO0FBQUEsUUFBQXdMLFNBV0MsaUJBQUFDLE9BQ0Y7QUFBQTtBQUFBLEtBVlQ7QUFBQSxLQUNRO0FBQUEsU0FBQS9JLElBQ1U7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFBZ0osV0FTTDtBQUFBLEtBQUFDLFNBQ0Y7QUFBQSxLQUFBQyxPQUNGO0FBQUE7QUFBQSxLQVJUO0FBQUEsU0FBQWhILFFBQ1E7QUFBQSxLQUFPO0FBQUEsU0FBQWxDLE1BQ1M7QUFBQTtBQUFBO0FBQUEsSUFPMUI7QUFBQSxTQUFBbUosU0FDd0I7QUFBQTtBQUFBLEtBRHhCO0FBQUE7QUFBQTtBQUFBLFNBRVE7QUFBQSxXQUFjO0FBQUEsT0FBQUEsU0FBQTtBQUFBO0FBQUEsV0FBQUM7QUFBQUEsVUFBQUEsTUR6OEQxQiw0QkFBQUMsTUFBQTtBQUFBO0FBQUEsVUFBQUYsU0MwOEQwQjtBQUFBO0FBQUEsUUFBQUcsVUFDUjtBQUFBLElBQ2Qsb0JBQXVCO0FBQUE7QUFBQTtBQUFBLEtBQ3ZCO0FBQUEsK0JBQUFDLFdBRWdCO0FBQUEsTUFGaEIsMkJBQUFBLFdBS2dCO0FBQUEsTUFMaEIsMEJBQUFBLFdBSWdCO0FBQUEsTUFKaEIseUJBQUFBLFdBTWdCO0FBQUEsVUFBQUEsV0FIQTtBQUFBO0FBQUE7QUFBQSxTQUFBQSxXQUZBO0FBQUE7QUFBQSxJQU1oQjtBQUFBLEdBQWtCO0FBQUEsWUFBQUMscUJBQUFqSixLQUFBMUM7QUFBQUEsSUFVUCw0QkFDVztBQUFBLElBRFgscUJBQUFnSCxJQUFBLFFBQUE1RixJQUFBLFFBRVc7QUFBQSxRQUFBQSxNQUZYO0FBQUEsSUFHVztBQUFBLEdBQW9DO0FBQUEsWUFBQXdLLHFCQUFBbEosS0FBQUcsTUFBQTdDO0FBQUFBLElBTzlDO0FBQUEsU0FBQXFFLFFBQUE7QUFBQTtBQUFBLFNBQUE2QyxJQUFBLFNBQUE3QyxRQUVPO0FBQUEsUUFBQXhCLFNBVytDO0FBQUEsSUFDcEUsNEJBQ3dCO0FBQUEsSUFEeEI7QUFBQSxTQUFBbUUsSUFBQSxRQUFBNUYsSUFBQTtBQUFBLEtBRXdCO0FBQUE7QUFBQSxRQUFBQSxNQUZ4QjtBQUFBLElBR3dCO0FBQUEsR0FBMkM7QUFBQSxZQUFBeUssa0JBQUFDLGlCQUFBNUk7QUFBQUEsSUF3Qm5FO0FBQUEsU0FBQTZJLE9BQUEsb0JBQUFELG9CQUNpQjtBQUFBO0FBQUEsU0FBQUEsb0JBQ0w7QUFBQSxhQUFBRSx1QkFBQTNNLFNBQUFvTDtBQUFBQSxLQWdCVix5REFFaUI7QUFBQTtBQUFBLGFBQUF3Qix1QkFBQTVNLFNBQUFELEdBQUFnQztBQUFBQSxLQWtCakIsMERBRWlCO0FBQUE7QUFBQSxhQUFBOEssbUJBQUE3TSxTQUFBOE0sVUFBQUM7QUFBQUEsS0FNakIsb0VBRTJCO0FBQUE7QUFBQSxhQUFBQyxNQUFBQyxXQUFBQztBQUFBQSxTQUFBbE4sVUFLTjtBQUFBO0FBQUEsTUFLckIsd0JBQTBCLHlDQUxnQztBQUFBLFVBQUFnRixRQU1sRDtBQUFBLE1BQWE7QUFBQTtBQUFBLFdBQUFrRCxhQUtNO0FBQUEsT0FDdkIsa0RBWnNEO0FBQUE7QUFBQSxVQUFBbEksWUFjdEQ7QUFBQTtBQUFBO0FBQUEsU0FBQUEsWUFJaUI7QUFBQSxLQUlyQjtBQUFBLE1BakRBO0FBQUE7QUFBQSxNQUFBZ0Y7QUFBQUEsUUFrRE07QUFBQSxXQUNLO0FBQUEsV0FDRjtBQUFBLE1BQUFrRCxXQWpCOEM7QUFBQSxLQUNuRCxnREFUc0Q7QUFBQTtBQUFBLGFBQUFpRixZQUFBQyxTQUFBcE4sU0FBQWtOLFNBQUF4TTtBQUFBQTtBQUFBQSxNQUFBMk0sT0E4QjFEO0FBQUEsTUFBQUMsUUFBQTtBQUFBLE1BQUFDLE9BQUE7QUFBQSxNQUFBQyxRQUFBO0FBQUEsTUFBQUMsT0FBQTtBQUFBLGNBQUFDLFNBQUExTixTQUFBME07QUFBQUEsVUFBQSxJQUtFO0FBQUE7QUFBQSxlQUdnQjtBQUFBLE9BRmQ7QUFBQTtBQUFBLE1BR0Y7QUFBQSxLQUFhO0FBQUEsU0FBQTFNLFlBZWY7QUFBQTtBQUFBO0FBQUEsTUFaRTtBQUFBLE9BckVGO0FBQUEsVUFBQTZDLFdBc0VjO0FBQUEsTUFBYTtBQUFBO0FBQUE7QUFBQSxTQUtoQjtBQUFBLGFBQUE3QyxZQUFzQjtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBRHRCO0FBQUEsYUFBQUEsWUFBcUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQURyQjtBQUFBLGFBQUFBLFlBQXFCO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FEckI7QUFBQSxhQUFBQSxZQUFzQjtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBRHRCO0FBQUEsYUFBQUEsWUFBcUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUFBd04sVUFNNUI7QUFBQSxNQUFBQyxTQUFBO0FBQUEsTUFBQUYsU0FBQTtBQUFBLE1BQUFELFVBQUE7QUFBQSxNQUFBRCxTQUFBO0FBQUEsS0FXSjtBQUFBLE1BeEZBO0FBQUE7QUFBQSxNQUFBcks7QUFBQUEsUUF5RkE7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQU1TO0FBQUE7QUFBQTtBQUFBLE1BQUFnQyxRQUNIO0FBQUEsS0FBYTtBQUFBO0FBQUE7QUFBQSxRQUFBQSxVQUVJO0FBQUEsUUFBQXhFLFFBQWdDO0FBQUEsUUFBQW1OLFVBQUE7QUFBQSxPQUNyRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQ0FsQmdCO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFxQmhCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDBCQXJCZ0I7QUFBQSxLQXdCaEI7QUFBQTtBQUFBLFFBRUU7QUFBQSxTQUNFO0FBQUEsUUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkE1QmM7QUFBQTtBQUFBLFFBcUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQXJDYztBQUFBO0FBQUEsUUFrQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBbENjO0FBQUE7QUFBQTtBQUFBLGFBQUFDO0FBQUFBLEtBQUFSLFNBQUFwTixTQUFBa04sU0FBQUksT0FBQUMsTUFBQUUsTUFBQUQsT0FBQTlNLEtBQUEyQztBQUFBQSxLQThDbEI7QUFBQSxNQS9IQTtBQUFBLFNBQUFnRyxPQWdJTTtBQUFBLEtBQWE7QUFBQSxNQUtqQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0JBQ3VCO0FBQUEsU0FBQXJKLFlBSnZCO0FBQUEsS0FXRjtBQUFBLE1BN0lBO0FBQUEsY0FBQTZOLGNBQUFQLE9BQUF0TjtBQUFBQTtBQUFBQSxPQUFBZ0YsUUErSXNCO0FBQUEsT0FBQXhCLE9BQWdDO0FBQUEsT0FBQW1LLFVBQUE7QUFBQSxNQUNwRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHlCQUMwQjtBQUFBO0FBQUEsU0FBQXRFLFNBQ3RCO0FBQUEsS0FBYTtBQUFBLHNCQUNILHNDQWJTO0FBQUE7QUFBQTtBQUFBLE1BWU47QUFBQTtBQUFBLFNBYWpCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0JBekJ1QjtBQUFBO0FBQUE7QUFBQSxTQWNFO0FBQUE7QUFBQSxlQVN6QjtBQUFBLFdBQUFpRSxVQUFBO0FBQUEsMENBdkJ1QjtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBNEJ2QjtBQUFBLGVBSUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGVBR0EsNERBbkNxQjtBQUFBO0FBQUEsYUFBQVE7QUFBQUEsS0FBQVYsU0FBQXBOLFNBQUFrTixTQUFBSSxPQUFBQyxNQUFBRSxNQUFBRCxPQUFBOU0sS0FBQTJDLEtBQUFHO0FBQUFBLEtBMEN6QjtBQUFBLE1BaExBO0FBQUEsY0FBQXVLLFdBQUFDO0FBQUFBLE1BbUxpQixPQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQUFiLDhCQUFhO0FBQUE7QUFBQSxLQU85Qiw0QkFTUyxzQkFBYztBQUFBLEtBUlAsdUNBRVMsb0JBTUY7QUFBQSxLQVJQO0FBQUEsbUNBTWEsb0JBRU47QUFBQSxVQUFBMUssSUFSUDtBQUFBLE1BSWUsNEJBSVI7QUFBQTtBQUFBLEtBUlAsNkJBS2Msb0JBR1A7QUFBQSxTQUFBQSxNQVJQO0FBQUEsS0FHZ0IsOEJBS1Q7QUFBQTtBQUFBLGFBQUEySztBQUFBQSxLQUFBYjtBQUFBQSxLQUFBcE47QUFBQUEsS0FBQWtOO0FBQUFBLEtBQUFLO0FBQUFBLEtBQUFFO0FBQUFBLEtBQUFEO0FBQUFBLEtBQUE5TTtBQUFBQSxLQUFBMkM7QUFBQUEsS0FBQUc7QUFBQUEsS0FBQXdLO0FBQUFBLEtBQUEzRTtBQUFBQTtBQUFBQSxNQUFBNkUsWUFRdkI7QUFBQSxNQUFBQyxZQUFBO0FBQUEsTUFBQUMsYUFBQTtBQUFBLE1BQUFDLFdBQUE7QUFBQSxNQUFBQyxXQUFBO0FBQUEsTUFBQUMsWUFBQTtBQUFBLGNBQUFDLFNBQUE1TyxPQUtxQixrQkFBb0IsWUFBSTtBQUFBLGNBQUE2TyxTQUFBN08sT0FDekIsa0JBQW1CLFlBQUk7QUFBQSxjQUFBOE8sVUFBQTlPLE9BQ3RCLG1CQUFvQixhQUFLO0FBQUEsY0FBQStPLFFBQUEvTyxPQUN6QixpQkFBb0IsV0FBRztBQUFBLGNBQUFnUCxRQUFBaFAsT0FDdkIsaUJBQW9CLFdBQUc7QUFBQSxjQUFBaVAsU0FBQWpQLE9BQ3ZCLGtCQUFvQixZQUFJO0FBQUEsY0FBQWtQLFlBQUFsUCxPQUN4QixpQkFBb0IsZUFBTztBQUFBLGNBQUFtUCxZQUFBblA7QUFBQUEsVUFBQXlELE1BY3ZDLFlBQUEyQixRQUFZO0FBQUEsTUFBVyx5Q0FDSjtBQUFBLE1BREksNEJBRUo7QUFBQSxNQUZJO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBUXBCO0FBQUEsb0JBRXlCO0FBQUEsTUFWTCxlQVNFO0FBQUEsVUFBQTFCLElBVEY7QUFBQSxNQUl6QjtBQUFBO0FBQUEsZ0JBQ0ssd0RBS3lCO0FBQUE7QUFBQSxjQUFBMEwsV0FBQTNGLE1BQUFoRztBQUFBQSxNQUluQyw0QkFDZ0I7QUFBQSxNQURoQjtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQVNPO0FBQUEsb0JBQTBDO0FBQUEsTUFUakQsZUFFcUM7QUFBQSxVQUFBN0MsUUFGckM7QUFBQSxNQUtFO0FBQUE7QUFBQSxnQkFDSyxrREFHMEM7QUFBQTtBQUFBLGNBQUF5TyxXQUFBbFAsR0FBQXNEO0FBQUFBLE1BTVMsNEJBQzFDO0FBQUEsTUFEMEM7QUFBQTtBQUFBO0FBQUEsY0FBQTdDLFFBQUE7QUFBQSxVQU94RDtBQUFBO0FBQUEsb0JBQ0ssOENBQ3FEO0FBQUE7QUFBQSxjQUFBQSxVQVRGLFFBRTFCO0FBQUE7QUFBQSxjQUFBQSxVQUYwQjtBQUFBLFVBSXhEO0FBQUE7QUFBQSxvQkFDSywrQ0FJcUQ7QUFBQTtBQUFBLE1BQXpDLHFEQUF5QztBQUFBO0FBQUEsY0FBQTBPLFlBQUFuUCxHQUU3QixPQUFZLGNBQVosV0FBWTtBQUFBLGNBQUFvUCxnQkFBQXBQLEdBQ1IsT0FBZ0IsY0FBaEIsZUFBZ0I7QUFBQTtBQUFBO0FBQUEsTUFXckQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUFBbUksYUErSXlCO0FBQUEsV0FBQWtILGFBQ3ZCO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBQUMsVUFlYztBQUFBLFdBQUFuSCxhQUNTO0FBQUEsV0FBQW9ILFVBQ0Q7QUFBQSxXQUFBcEwsWUFDTjtBQUFBLFVBQ2I7QUFBQTtBQUFBLFlBQUFxTCxZQUNtQztBQUFBLFlBQUFILGFBQ3BDO0FBQUE7QUFBQTtBQUFBLGNBQUFBLGFBRXNDLFNBQWY7QUFBQTtBQUFBO0FBQUEsY0FBQUEsYUFyS3pCO0FBQUE7QUFBQSxjQUFBbEgsY0FzQnVCO0FBQUEsVUFDcEIsbUJBQUFrSCxhQUFnQjtBQUFBLGNBQUFBLGFBQ2Q7QUFBQTtBQUFBO0FBQUEsY0FBQWxILGNBaUNrQiw0QkFBQWpILFlBQXFCO0FBQUEsVUFFekM7QUFBQTtBQUFBLFlBQUFzTyxZQUNEO0FBQUEsWUFBQUgsYUFDQTtBQUFBO0FBQUE7QUFBQSxjQUFBQSxhQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBQS9MLFFBM0JRLGlCQUFnQjtBQUFBLFdBQUE2RSxjQUNIO0FBQUEsVUFDcEI7QUFBQTtBQUFBLFlBQUFxSCxZQUNpQztBQUFBLFlBQUFILGFBQ2xDO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBQXBLLFVBR0U7QUFBQSxXQUFBa0QsY0FBaUM7QUFBQSxXQUFBN0UsUUFBQTtBQUFBLFdBQUErTCxhQUNuQztBQUFBO0FBQUE7QUFBQTtBQUFBLFdBQUFwSyxVQTJIdUI7QUFBQSxXQUFBbEYsV0FBOEI7QUFBQSxXQUFBMFAsV0FBQTtBQUFBLFdBQUF0SCxjQUNoQztBQUFBLFVBQ3BCO0FBQUE7QUFBQSxZQUFBcUgsWUFDb0M7QUFBQSxZQUFBSCxhQUNyQztBQUFBO0FBQUE7QUFBQSxjQUFBQSxhQUV1QyxTQUFmO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBQWxILGNBMUNIO0FBQUEsV0FBQWtILGFBQ3ZCO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBQUs7QUFBQUEsYUFsSUEsU0FBQXZIO0FBQUFBLGNBQ0ssK0RBRXlCO0FBQUE7QUFBQSxXQUFBQSxjQU9QO0FBQUEsV0FBQWxELFVBQ1g7QUFBQSxVQUFlLGtCQUFBb0ssYUFDZjtBQUFBLGNBQUE5TCxJQURlO0FBQUE7QUFBQSxXQUx0QjtBQUFBLGdCQUFBOEwsYUFDRTtBQUFBO0FBQUE7QUFBQSxlQUFBQSxhQUNBO0FBQUE7QUFBQTtBQUFBLFVBT0Y7QUFBQSxlQUFBQSxhQUVvQztBQUFBO0FBQUE7QUFBQTtBQUFBLFdBQUFBO0FBQUFBLGFBdlMzQztBQUFBO0FBQUE7QUFBQSxjQUFBbEgsY0E2WnlCO0FBQUEsVUFDcEIsbUJBQUFrSCxhQUFnQjtBQUFBLGNBQUFBLGFBQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUFBL0wsUUFqSEssaUJBQWdCO0FBQUEsV0FBQTZFLGNBQ0g7QUFBQSxVQUNwQjtBQUFBO0FBQUEsWUFBQXFILGFBQzRCO0FBQUEsWUFBQUgsYUFDN0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUFBcEssVUFHRTtBQUFBLFdBQUFrRCxjQUFpQztBQUFBLFdBQUE3RSxTQUFBO0FBQUEsV0FBQStMLGFBQ25DO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBQWxILGNBb0dxQjtBQUFBLFdBQUFrSCxhQUN2QjtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBQUFDLFlBWWM7QUFBQSxXQUFBQyxZQUNRO0FBQUEsV0FBQXBILGNBQ0M7QUFBQSxXQUFBaEUsY0FDUDtBQUFBLFVBQ2I7QUFBQTtBQUFBLFlBQUFxTCxhQUNpQztBQUFBLFlBQUFILGFBQ2xDO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBQUEsYUFFb0MsU0FBZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBQS9MLFFBbENiLGlCQUFnQjtBQUFBLFdBQUE2RSxhQUNIO0FBQUEsVUFDcEI7QUFBQTtBQUFBLFlBQUFxSCxZQUMwQjtBQUFBLFlBQUFILGFBQzNCO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBQXBLLFVBR0U7QUFBQSxXQUFBa0QsYUFBaUM7QUFBQSxXQUFBN0UsUUFBQTtBQUFBLFdBQUErTCxhQUNuQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBQWxILGFBZXFCO0FBQUEsV0FBQWtILGFBQ3ZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQWpGcUI7QUFBQSxlQUFBL0YsU0FBb0MsbUNBc2N0QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsd0JBQ2tCO0FBQUE7QUFBQSxvQkFDaEM7QUFBQTtBQUFBLFdBeGNrRTtBQUFBO0FBQUEsY0FBQW5CLGNBQ2hEO0FBQUE7QUFBQTtBQUFBLFdBMGNBO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0JBQUFqSCxVQUNoQjtBQUFBO0FBQUEsb0JBQUFBLFVBQXVCO0FBQUE7QUFBQTtBQUFBLG9DQUFBQSxVQUN2QjtBQUFBLFdBQXFCO0FBQUE7QUFBQSxVQTFjekI7QUFBQTtBQUFBLFlBQUFzTyxZQUNEO0FBQUEsWUFBQUgsYUFDQTtBQUFBO0FBQUE7QUFBQSxjQUFBQSxhQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUFBQSxhQXdHRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQWhJRTtBQUFBLGVBRHlEO0FBQUEsV0FBQXhPO0FBQUFBLGFBQS9DLG1DQUFpQztBQUFBLFdBQUFzSCxjQUV0QjtBQUFBLFVBQ3BCO0FBQUE7QUFBQSxZQUFBcUgsWUFDaUM7QUFBQSxZQUFBSCxhQUNsQztBQUFBO0FBQUE7QUFBQTtBQUFBLGVBR3dDO0FBQUEsV0FBQXBLLFVBQXRDLHFCQUFxQjtBQUFBLFdBQUFrRCxjQUF1QztBQUFBLFdBQUExRSxTQUFBO0FBQUEsV0FBQUgsUUFBQTtBQUFBLFdBQUErTCxhQUM5RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBQTVCLFVBd0Q4QjtBQUFBLFdBQUFDLFNBQWQ7QUFBQSxXQUFBRixTQUFkO0FBQUEsV0FBQWI7QUFBQUEsYUFzY047QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkFPTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FDUDtBQUFBLGdCQUFBN0osV0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9CQUFBNk0sT0FFWTtBQUFBO0FBQUEsb0JBQUFBLE9BREE7QUFBQTtBQUFBLG9CQUFBQSxPQUdBO0FBQUEsNEJBQUFBLE9BRUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQU5aO0FBQUE7QUFBQSxtQkFBQUEsT0FHWTtBQUFBO0FBQUEsbUJBQUFBLE9BRUE7QUFBQTtBQUFBLG1CQUFBQSxPQUVBO0FBQUE7QUFBQSxXQVBaO0FBQUEsZ0NBQUFBLE9BU2U7QUFBQTtBQUFBLG9DQUFBQSxPQURDO0FBQUEsV0FFVDtBQUFBO0FBQUE7QUFBQSxXQUFBdk8sUUFDUDtBQUFBLFdBQUErRyxjQXhkeUI7QUFBQSxVQUNwQjtBQUFBO0FBQUEsZ0JBS21DO0FBQUEsWUFBQWxELFVBQWxDLHFCQUFxQjtBQUFBLFlBQUFrRCxjQUFtQztBQUFBLFlBQUExRSxTQUFBO0FBQUEsWUFBQUgsUUFBQTtBQUFBLFlBQUErTCxhQUMxRDtBQUFBO0FBQUE7QUFBQSxjQUFBcEssUUEvSHdCO0FBQUEsVUFBVztBQUFBO0FBQUEsd0JBR2I7QUFBQTtBQUFBLGVBQUFsRSxPQUhhLGNBRWI7QUFBQTtBQUFBLFdBQUF5TyxZQXdITztBQUFBLFdBQUFILGFBQzdCO0FBQUE7QUFBQTtBQUFBLE1BckhKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkE2RXFCO0FBQUEsZ0JBQWY7QUFBQSxnQkFEbUQ7QUFBQSxZQUFBeE87QUFBQUEsY0FBckQsMkNBQXVDO0FBQUEsWUFBQXNILFdBRWxCO0FBQUEsV0FDcEI7QUFBQTtBQUFBLGFBQUFxSCxVQUNtQztBQUFBLGFBQUFILGFBQ3BDO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBR3dDO0FBQUEsWUFBQXBLLFVBQXRDLHFCQUFxQjtBQUFBLFlBQUFrRCxhQUF1QztBQUFBLFlBQUExRSxTQUFBO0FBQUEsWUFBQUgsUUFBQTtBQUFBLFlBQUErTCxhQUM5RDtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUkrQjtBQUFBLGdCQUFmO0FBQUEsZ0JBQWQ7QUFBQSxZQUFBeE87QUFBQUEsY0FERiwyQ0FBdUM7QUFBQSxZQUFBc0gsYUFFbEI7QUFBQSxXQUNwQjtBQUFBO0FBQUEsYUFBQXFILFlBQ3VDO0FBQUEsYUFBQUgsYUFDeEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFHd0M7QUFBQSxZQUFBcEssVUFBdEMscUJBQXFCO0FBQUEsWUFBQWtELGFBQXVDO0FBQUEsWUFBQTFFLFNBQUE7QUFBQSxZQUFBSCxRQUFBO0FBQUEsWUFBQStMLGFBQzlEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBSWlCO0FBQUEsWUFBZjtBQUFBLFlBRG1EO0FBQUEsUUFBQXhPO0FBQUFBLFVBQXJELDJDQUF1QztBQUFBLFFBQUFzSCxhQUVsQjtBQUFBLE9BQ3BCO0FBQUE7QUFBQSxTQUFBcUgsWUFDbUM7QUFBQSxTQUFBSCxhQUNwQztBQUFBO0FBQUE7QUFBQTtBQUFBLFlBR3dDO0FBQUEsUUFBQXBLLFVBQXRDLHFCQUFxQjtBQUFBLFFBQUFrRCxhQUF1QztBQUFBLFFBQUExRSxTQUFBO0FBQUEsUUFBQUgsUUFBQTtBQUFBLFFBQUErTCxhQUM5RDtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BQUFBO0FBQUFBLFNBeUVGO0FBQUE7QUFBQSxLQVFGO0FBQUEsY0FBNEIsa0JBQUE3QixTQUFBO0FBQUEsaUJBRTFCO0FBQUEsY0FDRixrQkFBQUUsU0FBQTtBQUFBLGlCQUNFO0FBQUEsY0FDRixtQkFBQUQsVUFBQTtBQUFBLGtCQUNFO0FBQUEsY0FDRix5QkFBcUI7QUFBQSxNQUFyQixNQUNFO0FBQUEsY0FDRiwwQkFBcUI7QUFBQSxNQUFyQjtBQUFBLGVBQ0U7QUFBQTtBQUFBO0FBQUEsVUFBQUQsU0FFRjtBQUFBLGlCQUFvQjtBQUFBO0FBQUEsYUFLcEIsaUJBQUE3TSxRQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUNFO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FFaUM7QUFBQTtBQUFBLE1BRTdCO0FBQUE7QUFBQSxLQUVOO0FBQUEsSUFBVTtBQUFBLGFBQUFpUCxlQUFBM1AsU0FBQWtOO0FBQUFBLEtBS1Ysd0JBQTBCO0FBQUEsU0FBQW5OLElBRWxCO0FBQUEsS0FBYTtBQUFBO0FBQUEsV0FBQThDLFdBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQU9qQiw2Q0FrQ2lEO0FBQUE7QUFBQSxlQUFBcUYsYUFoQzFCO0FBQUEsV0FDdkI7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQVZpQjtBQUFBO0FBQUEsVUFFakIsNkNBdUNpRDtBQUFBO0FBQUEsY0FBQUEsYUFyQzFCO0FBQUEsVUFDdkI7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUxpQjtBQUFBLFdBQUFBLGFBdUJNO0FBQUEsT0FDdkI7QUFBQTtBQUFBLE1BeEJpQjtBQUFBO0FBQUE7QUFBQSxjQUFBQSxhQWVNO0FBQUEsVUFDdkI7QUFBQTtBQUFBLFVBaUJTO0FBQUE7QUFBQSxzQkFBeUI7QUFBQSxlQUFBQSxhQUNYO0FBQUEsV0FDdkI7QUFBQTtBQUFBLGNBQUFBLGFBRXVCO0FBQUEsVUFDdkI7QUFBQTtBQUFBLGNBQUFBLGFBMUJ1QjtBQUFBLFVBQ3ZCO0FBQUE7QUFBQSxjQUFBQSxhQWF1QjtBQUFBLFVBQ3ZCO0FBQUE7QUFBQSxjQUFBbEksWUFUQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsNkJBdUR3QjtBQUFBLGlCQUEwQjtBQUFBO0FBQUEsWUFBQTRQLFlBQ2xDO0FBQUEsWUFBQTVLLFFBQ1Y7QUFBQTtBQUFBO0FBQUEsWUFBZTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFBQUEsVUFFSTtBQUFBLGFBQUF4RSxRQUErQjtBQUFBLGFBQUFxUCxZQUFBO0FBQUEsYUFBQUMsWUFDcEM7QUFBQSxhQUFBak4sYUFDVjtBQUFBLFlBQWU7QUFBQTtBQUFBO0FBQUEsZUFBQWQ7QUFBQUEsaUJBRVQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUNSO0FBQUE7QUFBQSxlQUFBOUQsbUJBQUE7QUFBQSxlQUFBdVIsV0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBeEssVUFFd0I7QUFBQSxjQUFBK0ssU0FBK0I7QUFBQSxjQUFBQyxZQUFBO0FBQUEsY0FBQUMsWUFDdkM7QUFBQSxhQUNiO0FBQUEsY0FBNEI7QUFBQTtBQUFBLGNBQUFsTztBQUFBQSxnQkFDdkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQUNSO0FBQUE7QUFBQSxjQUFBOUQsbUJBQUE7QUFBQSxjQUFBdVIsV0FBQTtBQUFBO0FBQUE7QUFBQSxZQUNLO0FBQUE7QUFBQSxXQUVOO0FBQUE7QUFBQSxnQkFBQXREO0FBQUFBLGVBQUFBLE1EM25GZjtBQUFBO0FBQUEsZ0JBQUFqTyxtQkFBQSxnQkFBQXVSLFdBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQXZSLG1CQUFBLGdCQUFBdVIsV0FBQTtBQUFBO0FBQUE7QUFBQSxjQUFBdEgsY0MrbkYyQjtBQUFBLFVBQ3ZCO0FBQUE7QUFBQSxjQUFBbEksWUFuRUk7QUFBQSxVQXdFSjtBQUFBO0FBQUEsWUFBQTRQLGNBRW9CO0FBQUEsWUFBQTVLLFVBQ1Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQWU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUFBLFVBRUc7QUFBQSxjQUFBa0wsT0FBK0I7QUFBQSxjQUFBTCxjQUFBO0FBQUEsY0FBQUMsY0FDckM7QUFBQSxhQUNiO0FBQUEsY0FBNEI7QUFBQTtBQUFBLGNBQUEvTjtBQUFBQSxnQkFDdkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQUNSO0FBQUE7QUFBQTtBQUFBLG9CQUNLO0FBQUE7QUFBQSxlQUFBaUQsVUFBQTtBQUFBO0FBQUEsZ0JBQUFrSDtBQUFBQSxlQUFBQSxRRC9vRmY7QUFBQTtBQUFBO0FBQUEsZUFBQWxILFVDaXBGUTtBQUFBO0FBQUEsVUFaSjtBQUFBO0FBQUEsWUFBQUEsVUFBQTtBQUFBLFlBQUEvRyxtQkFBQTtBQUFBLFlBQUF1UixhQUFBO0FBQUEsWUFBQXRILGNBZXlCO0FBQUEsV0FDdkI7QUFBQTtBQUFBLGNBQUFBLGNBRXVCO0FBQUEsVUFDdkI7QUFBQTtBQUFBLGNBQUFBLGFBcEd5QjtBQUFBLFVBQ3ZCO0FBQUE7QUFBQSxjQUFBQSxhQVV1QjtBQUFBLFVBQ3ZCO0FBQUE7QUFBQTtBQUFBLFNBQUFBLFdBUXVCO0FBQUEsS0FDdkI7QUFBQSxJQUFpRDtBQUFBLGFBQUFpSSxVQUFBQyxhQUFBcFEsU0FBQWtOO0FBQUFBLEtBS3JEO0FBQUEsOEJBQzRCO0FBQUEsTUFDcEI7QUFBQSxPQVlKO0FBQUEsVUFBQW1ELE1BVlU7QUFBQSxNQUNWLG1CQUF1QjtBQUFBO0FBQUEsT0FBQUM7QUFBQUEsU0FDVDtBQUFBO0FBQUEsT0FBQXBJLGFBQ1M7QUFBQSxPQUFBb0gsVUFDRDtBQUFBLE9BQUF0UixlQUN0QjtBQUFBLE9BQUF1UyxlQUNBO0FBQUEsV0FFQTtBQUFBO0FBQUE7QUFBQSxXQUFBckU7QUFBQUEsVUFBQUEsTUQxbEZSO0FBQUE7QUFBQTtBQUFBLE9BQUFoRSxXQzhsRjZCO0FBQUEsT0FBQXFJLGFBRXZCO0FBQUEsTUFFQTtBQUFBO0FBQUEsSUFBK0M7QUFBQSxhQUFBQyxlQUFBeFEsU0FBQWtOO0FBQUFBLEtBMERqRDtBQUFBLE1Bam5CQTtBQUFBLFNBQUFwTixXQW1uQmU7QUFBQSxjQUFBMlEsVUFBQTFRLEtBQUFBO0FBQUFBLE1BS2I7QUFBQSxXQUFBSyxJQUFBO0FBQUE7QUFBQSxRQUNFLDBCQUF5QjtBQUFBLGdCQUFlO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUN0QztBQUFBLGNBQUFzUSxvQkFBQTFRO0FBQUFBLE1BSUosb0RBRWdEO0FBQUE7QUFBQSxjQUFBMlEsdUJBQUExUCxTQUFBakIsV0FBQWtOO0FBQUFBLFVBQUFsTixVQVdoRDtBQUFBO0FBQUE7QUFBQSxRQTNvQkY7QUFBQSxXQUFBRCxJQTRvQlE7QUFBQSxPQUFhO0FBQUEscUJBRWpCO0FBQUEsZ0JBS0E7QUFBQTtBQUFBO0FBQUEsa0VBQWlEO0FBQUEsWUFBQWtCLFlBQWpEO0FBQUEsb0VBQWlEO0FBQUE7QUFBQSxPQTlCbkQ7QUFBQSxXQUFBakIsWUEyQmM7QUFBQTtBQUFBO0FBQUEsS0FHcUM7QUFBQSxjQUFBNFEsNEJBQUEzUCxTQUFBakIsV0FBQWtOLFNBQUFuTjtBQUFBQSxVQUFBQyxVQUluRCxXQUFBRCxJQUFBO0FBQUE7QUFBQTtBQUFBLFFBdnBCRjtBQUFBLFdBQUFBLE1Bd3BCUTtBQUFBO0FBQUE7QUFBQSxRQUFhO0FBQUE7QUFBQTtBQUFBLFVBbkNuQjtBQUFBLFVBcUNZO0FBQUE7QUFBQTtBQUFBLDRCQUZPO0FBQUEsUUFNTTtBQUFBLFNBekN6QjtBQUFBLGlCQTBDYTtBQUFBO0FBQUE7QUFBQSwyREFRdUM7QUFBQSxhQUFBa0IsWUFSdkM7QUFBQSw2REFRdUM7QUFBQTtBQUFBO0FBQUEsT0FMbEQsYUFBZ0I7QUFBQSxPQTdDbEI7QUFBQSxXQUFBakIsWUFpRFk7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUFBQSxZQVRWO0FBQUEsTUFjRjtBQUFBLE9BM3FCRjtBQUFBLFVBQUFELE1BNHFCUTtBQUFBLE1BQWE7QUFBQSxPQU1qQjtBQUFBLFFBbHJCSjtBQUFBLFdBQUFBLE1BbXJCZ0I7QUFBQSxPQUFpQiw2QkFJcEIscUNBaEJ5QztBQUFBLE9BYzlDO0FBQUEsZUFBYztBQUFBO0FBQUEsOEVBZGdDO0FBQUEsV0FBQWtCLFlBY2hDO0FBQUEsMkRBZGdDO0FBQUE7QUFBQSxNQUtqQztBQUFBLE9BdkRuQjtBQUFBO0FBQUEsT0EwRGM7QUFBQTtBQUFBLE1BV1o7QUFBQSxjQUFjO0FBQUE7QUFBQSw2RUFuQm9DO0FBQUEsVUFBQUEsWUFtQnBDO0FBQUEsMERBbkJvQztBQUFBO0FBQUEsY0FBQTJQLDBCQUFBNVEsU0FBQWtOLFNBQUFuTjtBQUFBQSxNQWhCcEQsT0Rsc0ZOO0FBQUEsZUNrc0ZNLG9EQWdCb0Q7QUFBQTtBQUFBLEtBc0J0RDtBQUFBLE1BN3JCQTtBQUFBLEtBK3JCUTtBQUFBLFVBQUFDLFlBQ0ssaUJBQUE2USxVQUViLEdBQUE3USxZQUFBO0FBQUE7QUFBQSxVQUFBNlEsVUFEVyxHQUFBN1EsWUFBQTtBQUFBLEtBNURUO0FBQUEsTUFyb0JGO0FBQUE7QUFBQSxNQUFBRCxJQXNvQlU7QUFBQSxNQUFBeVAsV0FDUjtBQUFBLE1BQUExUCxhQTREYTtBQUFBLFVBQ2YsVUFBMkI7QUFBQSxLQUEzQjtBQUFBLElBQStEO0FBQUEsYUFBQTZMLGFBQUEzTCxXQUFBa047QUFBQUEsU0FBQWxOLFVBSS9EO0FBQUE7QUFBQTtBQUFBLE9BeHNCQTtBQUFBLE1BeXNCRyx5Q0FBaUU7QUFBQSxVQUFBQSxZQUF4QztBQUFBO0FBQUE7QUFBQSxJQUErQztBQUFBLGFBQUE4USxlQUFBOVEsV0FBQWtOLFNBQUE1QztBQUFBQSxTQUFBdEssVUFLM0UsV0FBQXNLLE1BQUE7QUFBQTtBQUFBO0FBQUEsT0E5c0JBO0FBQUEsVUFBQXZLLElBK3NCTTtBQUFBLE1BQWEscUJBU1o7QUFBQSxVQUFBeUssVUFQTDtBQUFBLE1BQ0E7QUFBQSxlQUNFO0FBQUEsOERBS2U7QUFBQTtBQUFBLFVBQUF4SyxZQURmO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFDZTtBQUFBLGFBQUErUSxjQUFBL1EsU0FBQWtOO0FBQUFBLEtBS25CO0FBQUEsTUE3dEJBO0FBQUEsU0FBQWxJLFFBOHRCTTtBQUFBLEtBQWE7QUFBQSxxQkFDSCwwQ0FVRztBQUFBO0FBQUE7QUFBQSxNQVRWO0FBQUEsT0FodUJUO0FBQUEsVUFBQWpGLElBa3VCUTtBQUFBLE1BQWlCO0FBQUEsT0FLckIsd0RBRWU7QUFBQTtBQUFBLE9BQUFpRixVQUxHO0FBQUEsT0FBQTFCLElBQXNDO0FBQUEsT0FBQWtNLFdBQUE7QUFBQSxNQUN4RDtBQUFBO0FBQUEsS0FJRztBQUFBLElBQVk7QUFBQSxhQUFBd0IsWUFBQS9ELFdBQUFqTixTQUFBVztBQUFBQSxTQUFBdVAsT0FNUTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMEJBRU07QUFBQTtBQUFBLHNCQUNFLHlEQUFvQztBQUFBO0FBQUEsYUFBQWUscUJBQUFqUixXQUFBa04sU0FBQW5OO0FBQUFBLFNBQUFDLFVBS3ZFO0FBQUE7QUFBQTtBQUFBLE9BQ0U7QUFBQSxNQUdJO0FBQUEsT0FFSjtBQUFBLFFBN3ZCRjtBQUFBLE9BOHZCSyxnREFBcUQ7QUFBQSxXQUFBZ0YsUUFDMUM7QUFBQSxPQUFpQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBcUssVUFlYjtBQUFBLGNBQUFyUCxZQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFPQSw4REFPNkM7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQTNCN0M7QUFBQSxVQWx3Qk47QUFBQSxhQUFBZ0YsVUFtd0JrQjtBQUFBLFNBQWlCO0FBQUE7QUFBQSxXQUFBcUssWUFLYjtBQUFBLFdBQUFyUCxZQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FOMkI7QUFBQTtBQUFBLFdBQUFxUCxZQUViO0FBQUEsV0FBQXJQLFlBQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQUFBQSxZQUlLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBWG9CO0FBQUE7QUFBQSxVQUFBcVAsWUFtQmI7QUFBQSxVQUFBclAsWUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBcEIyQjtBQUFBLFNBMEIzQiwrREFJNkM7QUFBQTtBQUFBLFdBQUFBLFlBRjdDO0FBQUE7QUFBQTtBQUFBLGVBQUFBLFlBRUM7QUFBQTtBQUFBLElBQTRDO0FBQUEsYUFBQWtSLGlCQUFBOUQsU0FBQXBOLFNBQUF1TixRQUFBRSxRQUFBRCxTQUFBbkU7QUFBQUEsU0FBQWtFLE9BY25ELFFBQUFFLE9BQUEsUUFBQUQsUUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDBCQUc4QjtBQUFBLFNBSDlCLGlCQUdtRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFIbkU7QUFBQTtBQUFBLDJCQUU4QjtBQUFBLFVBRjlCLGlCQUVtRTtBQUFBO0FBQUE7QUFBQSxhQUFBM0ssYUFGbkU7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUltRTtBQUFBO0FBQUEsWUFIckM7QUFBQTtBQUFBLFlBQXFDO0FBQUE7QUFBQSxZQUtyQztBQUFBO0FBQUEsWUFFQTtBQUFBO0FBQUEsWUFKQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBSjlCO0FBQUEsYUFBQUEsYUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBS21FO0FBQUE7QUFBQSxhQUlyQztBQUFBO0FBQUEsYUFDQTtBQUFBO0FBQUEsYUFIQTtBQUFBO0FBQUEsYUFJQTtBQUFBO0FBQUEsYUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBQUFBLFdBTDlCO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FhdUIsc0JBQW1CO0FBQUE7QUFBQSxXQUNuQixzQkFBbUI7QUFBQTtBQUFBLFdBRm5CLHNCQUFtQjtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBSXhDO0FBQUEsWUFFSyx3REFjNkI7QUFBQSxXQWZoQztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BakJKO0FBQUE7QUFBQSxRQW9CRTtBQUFBLFNBR0ssc0RBUzZCO0FBQUEsUUFWaEM7QUFBQTtBQUFBO0FBQUEsUUFPRjtBQUFBLFNBRUssd0RBQzZCO0FBQUEsUUFGaEM7QUFBQTtBQUFBO0FBQUEsT0E5Qko7QUFBQSxRQWdDd0I7QUFBQSxPQVB0QjtBQUFBLFFBRUssd0RBSzZCO0FBQUEsT0FOaEM7QUFBQTtBQUFBO0FBQUEsSUFNZ0M7QUFBQSxhQUFBc08sa0JBQUEvRCxTQUFBcE4sU0FBQXFKLE1BQUErSDtBQUFBQTtBQUFBQSxNQUFBQztBQUFBQSxRQTRCckI7QUFBQSxLQUNiO0FBQUEsc0VBR2dDO0FBQUE7QUFBQSxJQUVqQywyQ0FBMkI7QUFBQTtBQUFBLFlBQUFDLHVCQUFBek4sS0FBQTlDO0FBQUFBLFFBQUFKLE1BUVo7QUFBQSxJQUNsQixZQUFZO0FBQUEsVUFBQXVMO0FBQUFBLFNBQUFBLE1EajZGZDtBQUFBO0FBQUEsYUNxNkZVO0FBQUEsS0FBdUI7QUFBQTtBQUFBO0FBQUEsWUFBQXFGLHdCQUFBMU4sS0FBQWpFO0FBQUFBO0FBQUFBLEtBQUFpRSxRQUlMO0FBQUEsS0FBQWxELE1BQUE7QUFBQSxLQUFBQSxRQUNSO0FBQUEsSUFDbEIsWUFBNEIsSUFBaEIsbUJBQWdCO0FBQUEsVUFBQXVMO0FBQUFBLFNBQUFBLE1EMzZGOUI7QUFBQTtBQUFBLE1DNjZGSSxrREFDOEQ7QUFBQSxLRDk2RmxFO0FBQUE7QUFBQSxHQzg2RmtFO0FBQUE7QUFBQSxJQUFBc0Y7QUFBQUEsTUQ5NkZsRSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE1MjI0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvcHJpbnRmLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBYYXZpZXIgTGVyb3kgYW5kIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxubGV0IGtmcHJpbnRmIGsgbyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYWNjIC0+IG91dHB1dF9hY2MgbyBhY2M7IGsgbykgRW5kX29mX2FjYyBmbXRcbmxldCBrYnByaW50ZiBrIGIgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZiAoZnVuIGFjYyAtPiBidWZwdXRfYWNjIGIgYWNjOyBrIGIpIEVuZF9vZl9hY2MgZm10XG5sZXQgaWtmcHJpbnRmIGsgb2MgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBvYyBmbXRcbmxldCBpa2JwcmludGYgPSBpa2ZwcmludGZcblxubGV0IGZwcmludGYgb2MgZm10ID0ga2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGJwcmludGYgYiBmbXQgPSBrYnByaW50ZiBpZ25vcmUgYiBmbXRcbmxldCBpZnByaW50ZiBvYyBmbXQgPSBpa2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGlicHJpbnRmIGIgZm10ID0gaWticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZG91dCBmbXRcbmxldCBlcHJpbnRmIGZtdCA9IGZwcmludGYgc3RkZXJyIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBrJyBhY2MgPVxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDY0IGluXG4gICAgc3RycHV0X2FjYyBidWYgYWNjO1xuICAgIGsgKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10XG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAtPiBzKSBmbXRcblxubGV0IGtwcmludGYgPSBrc3ByaW50ZlxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfQnVmZmVyIiwiQ2FtbGludGVybmFsRm9ybWF0IiwiU3RkbGliIiwia2ZwcmludGYiLCJrIiwibyIsInBhcmFtIiwiZm10IiwiYWNjIiwia2JwcmludGYiLCJiIiwiaWtmcHJpbnRmIiwib2MiLCJmcHJpbnRmIiwiYnByaW50ZiIsImlmcHJpbnRmIiwiaWJwcmludGYiLCJwcmludGYiLCJlcHJpbnRmIiwia3NwcmludGYiLCJidWYiLCJzcHJpbnRmIiwicyIsIlN0ZGxpYl9QcmludGYiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsWUFBQUMsU0FBQUMsR0FBQUMsR0FBQUM7QUFBQUEsUUFBQUMsTUNrQmE7QUFBQSxJQUNYO0FBQUE7QUFBQSxzQkFBQUM7QUFBQUEsY0FBd0I7QUFBQSxjQUFnQix1QkFBSztBQUFBO0FBQUE7QUFBQSxpQkFBZ0I7QUFBQTtBQUFBLFlBQUFDLFNBQUFMLEdBQUFNLEdBQUFKO0FBQUFBLFFBQUFDLE1BQ2xEO0FBQUEsSUFDWDtBQUFBO0FBQUEsc0JBQUFDO0FBQUFBLGNBQXdCO0FBQUEsY0FBZ0IsdUJBQUs7QUFBQTtBQUFBO0FBQUEsaUJBQWdCO0FBQUE7QUFBQSxZQUFBRyxVQUFBUCxHQUFBUSxJQUFBTjtBQUFBQSxRQUFBQyxNQUNqRDtBQUFBLElBQ1osbURBQXFCO0FBQUE7QUFBQSxZQUFBTSxRQUFBRCxJQUFBTDtBQUFBQSxJQUdGLDRCRDFCckIsb0JDMEIyQztBQUFBO0FBQUEsWUFBQU8sUUFBQUosR0FBQUgsS0FDdkIsNEJEM0JwQixtQkMyQnlDO0FBQUEsWUFBQVEsU0FBQUgsSUFBQUw7QUFBQUEsSUFDbkIsNkJENUJ0QixvQkM0QjZDO0FBQUE7QUFBQSxZQUFBUyxTQUFBTixHQUFBSDtBQUFBQSxJQUN4Qiw2QkQ3QnJCLG1CQzZCMkM7QUFBQTtBQUFBLFlBQUFVLE9BQUFWLEtBQzFCLCtCQUFrQjtBQUFBLFlBQUFXLFFBQUFYLEtBQ2pCLCtCQUFrQjtBQUFBLFlBQUFZLFNBQUFmLEdBQUFFO0FBQUFBLFFBQUFDLE1BRXZCO0FBQUEsYUFBQUgsSUFBQUk7QUFBQUEsU0FBQVksTUFFQztBQUFBLEtBQ1Y7QUFBQSxLQUNFLE9BQXFCLGNBQXJCLGlDQUFxQjtBQUFBO0FBQUEsSUFDekIsb0RBQTZCO0FBQUE7QUFBQSxZQUFBQyxRQUFBZCxLQUViLHlCQUFBZSxHQUFtQixTQUFDLE9BQUs7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1EeEMzQyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE1MzExLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvYXJnLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGtleSA9IHN0cmluZ1xudHlwZSBkb2MgPSBzdHJpbmdcbnR5cGUgdXNhZ2VfbXNnID0gc3RyaW5nXG50eXBlIGFub25fZnVuID0gKHN0cmluZyAtPiB1bml0KVxuXG50eXBlIHNwZWMgPVxuICB8IFVuaXQgb2YgKHVuaXQgLT4gdW5pdCkgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdW5pdCBhcmd1bWVudCAqKVxuICB8IEJvb2wgb2YgKGJvb2wgLT4gdW5pdCkgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBib29sIGFyZ3VtZW50ICopXG4gIHwgU2V0IG9mIGJvb2wgcmVmICAgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdHJ1ZSAqKVxuICB8IENsZWFyIG9mIGJvb2wgcmVmICAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIGZhbHNlICopXG4gIHwgU3RyaW5nIG9mIChzdHJpbmcgLT4gdW5pdCkgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IFNldF9zdHJpbmcgb2Ygc3RyaW5nIHJlZiAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBzdHJpbmcgYXJndW1lbnQgKilcbiAgfCBJbnQgb2YgKGludCAtPiB1bml0KSAgICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGFuIGludCBhcmd1bWVudCAqKVxuICB8IFNldF9pbnQgb2YgaW50IHJlZiAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBpbnQgYXJndW1lbnQgKilcbiAgfCBGbG9hdCBvZiAoZmxvYXQgLT4gdW5pdCkgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgZmxvYXQgYXJndW1lbnQgKilcbiAgfCBTZXRfZmxvYXQgb2YgZmxvYXQgcmVmICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgZmxvYXQgYXJndW1lbnQgKilcbiAgfCBUdXBsZSBvZiBzcGVjIGxpc3QgICAgICAgICAoKiBUYWtlIHNldmVyYWwgYXJndW1lbnRzIGFjY29yZGluZyB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjIGxpc3QgKilcbiAgfCBTeW1ib2wgb2Ygc3RyaW5nIGxpc3QgKiAoc3RyaW5nIC0+IHVuaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVGFrZSBvbmUgb2YgdGhlIHN5bWJvbHMgYXMgYXJndW1lbnQgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgc3ltYm9sLiAqKVxuICB8IFJlc3Qgb2YgKHN0cmluZyAtPiB1bml0KSAgICgqIFN0b3AgaW50ZXJwcmV0aW5nIGtleXdvcmRzIGFuZCBjYWxsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdpdGggZWFjaCByZW1haW5pbmcgYXJndW1lbnQgKilcbiAgfCBSZXN0X2FsbCBvZiAoc3RyaW5nIGxpc3QgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBTdG9wIGludGVycHJldGluZyBrZXl3b3JkcyBhbmQgY2FsbCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB3aXRoIGFsbCByZW1haW5pbmcgYXJndW1lbnRzLiAqKVxuICB8IEV4cGFuZCBvZiAoc3RyaW5nIC0+IHN0cmluZyBhcnJheSkgKCogSWYgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbW1wiLWZvb1wiOyBcImFyZ1wiXSBAIHJlc3RdIHdoZXJlIFwiZm9vXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHJlZ2lzdGVyZWQgYXMgW0V4cGFuZCBmXSwgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyBbZiBcImFyZ1wiIEAgcmVzdF0gYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQuIE9ubHkgYWxsb3dlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXS4gKilcblxuZXhjZXB0aW9uIEJhZCBvZiBzdHJpbmdcbmV4Y2VwdGlvbiBIZWxwIG9mIHN0cmluZ1xuXG50eXBlIGVycm9yID1cbiAgfCBVbmtub3duIG9mIHN0cmluZ1xuICB8IFdyb25nIG9mIHN0cmluZyAqIHN0cmluZyAqIHN0cmluZyAgKCogb3B0aW9uLCBhY3R1YWwsIGV4cGVjdGVkICopXG4gIHwgTWlzc2luZyBvZiBzdHJpbmdcbiAgfCBNZXNzYWdlIG9mIHN0cmluZ1xuXG5leGNlcHRpb24gU3RvcCBvZiBlcnJvciAoKiB1c2VkIGludGVybmFsbHkgKilcblxub3BlbiBQcmludGZcblxubGV0IHJlYyBhc3NvYzMgeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKHkxLCB5MiwgXykgOjogXyB3aGVuIHkxID0geCAtPiB5MlxuICB8IF8gOjogdCAtPiBhc3NvYzMgeCB0XG5cblxubGV0IHNwbGl0IHMgPVxuICBsZXQgaSA9IFN0cmluZy5pbmRleCBzICc9JyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIFN0cmluZy5zdWIgcyAwIGksIFN0cmluZy5zdWIgcyAoaSsxKSAobGVuLShpKzEpKVxuXG5cbmxldCBtYWtlX3N5bWxpc3QgcHJlZml4IHNlcCBzdWZmaXggbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiPG5vbmU+XCJcbiAgfCBoOjp0IC0+IChMaXN0LmZvbGRfbGVmdCAoZnVuIHggeSAtPiB4IF4gc2VwIF4geSkgKHByZWZpeCBeIGgpIHQpIF4gc3VmZml4XG5cblxubGV0IHByaW50X3NwZWMgYnVmIChrZXksIHNwZWMsIGRvYykgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGRvYyA+IDAgdGhlblxuICAgIG1hdGNoIHNwZWMgd2l0aFxuICAgIHwgU3ltYm9sIChsLCBfKSAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXMlc1xcblwiIGtleSAobWFrZV9zeW1saXN0IFwie1wiIFwifFwiIFwifVwiIGwpIGRvY1xuICAgIHwgXyAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXNcXG5cIiBrZXkgZG9jXG5cblxubGV0IGhlbHBfYWN0aW9uICgpID0gcmFpc2UgKFN0b3AgKFVua25vd24gXCItaGVscFwiKSlcblxubGV0IGFkZF9oZWxwIHNwZWNsaXN0ID1cbiAgbGV0IGFkZDEgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi1oZWxwXCIgc3BlY2xpc3QpOyBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICBbXCItaGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGFuZCBhZGQyID1cbiAgICB0cnkgaWdub3JlIChhc3NvYzMgXCItLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi0taGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGluXG4gIHNwZWNsaXN0IEAgKGFkZDEgQCBhZGQyKVxuXG5cbmxldCB1c2FnZV9iIGJ1ZiBzcGVjbGlzdCBlcnJtc2cgPVxuICBicHJpbnRmIGJ1ZiBcIiVzXFxuXCIgZXJybXNnO1xuICBMaXN0Lml0ZXIgKHByaW50X3NwZWMgYnVmKSAoYWRkX2hlbHAgc3BlY2xpc3QpXG5cblxubGV0IHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIHVzYWdlX2IgYiBzcGVjbGlzdCBlcnJtc2c7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cblxubGV0IHVzYWdlIHNwZWNsaXN0IGVycm1zZyA9XG4gIGVwcmludGYgXCIlc1wiICh1c2FnZV9zdHJpbmcgc3BlY2xpc3QgZXJybXNnKVxuXG5cbmxldCBjdXJyZW50ID0gcmVmIDBcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGJvb2xfb2Zfc3RyaW5nIHgpXG4gIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyB4KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBhbGxvd19leHBhbmQgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJybXNnID1cbiAgbGV0IGluaXRwb3MgPSAhY3VycmVudCBpblxuICBsZXQgY29udmVydF9lcnJvciBlcnJvciA9XG4gICAgKCogY29udmVydCBhbiBpbnRlcm5hbCBlcnJvciB0byBhIEJhZC9IZWxwIGV4Y2VwdGlvblxuICAgICAgICpvciogYWRkIHRoZSBwcm9ncmFtIG5hbWUgYXMgYSBwcmVmaXggYW5kIHRoZSB1c2FnZSBtZXNzYWdlIGFzIGEgc3VmZml4XG4gICAgICAgdG8gYW4gdXNlci1yYWlzZWQgQmFkIGV4Y2VwdGlvbi5cbiAgICAqKVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgICBsZXQgcHJvZ25hbWUgPVxuICAgICAgaWYgaW5pdHBvcyA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKGluaXRwb3MpIGVsc2UgXCIoPylcIiBpblxuICAgIGJlZ2luIG1hdGNoIGVycm9yIHdpdGhcbiAgICAgIHwgVW5rbm93biBcIi1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBcIi0taGVscFwiIC0+ICgpXG4gICAgICB8IFVua25vd24gcyAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB1bmtub3duIG9wdGlvbiAnJXMnLlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgTWlzc2luZyBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IG9wdGlvbiAnJXMnIG5lZWRzIGFuIGFyZ3VtZW50LlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgV3JvbmcgKG9wdCwgYXJnLCBleHBlY3RlZCkgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogd3JvbmcgYXJndW1lbnQgJyVzJzsgb3B0aW9uICclcycgZXhwZWN0cyAlcy5cXG5cIlxuICAgICAgICAgICAgICAgICAgcHJvZ25hbWUgYXJnIG9wdCBleHBlY3RlZFxuICAgICAgfCBNZXNzYWdlIHMgLT4gKCogdXNlciBlcnJvciBtZXNzYWdlICopXG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6ICVzLlxcblwiIHByb2duYW1lIHNcbiAgICBlbmQ7XG4gICAgdXNhZ2VfYiBiICFzcGVjbGlzdCBlcnJtc2c7XG4gICAgaWYgZXJyb3IgPSBVbmtub3duIFwiLWhlbHBcIiB8fCBlcnJvciA9IFVua25vd24gXCItLWhlbHBcIlxuICAgIHRoZW4gSGVscCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gICAgZWxzZSBCYWQgKEJ1ZmZlci5jb250ZW50cyBiKVxuICBpblxuICBpbmNyIGN1cnJlbnQ7XG4gIHdoaWxlICFjdXJyZW50IDwgKEFycmF5Lmxlbmd0aCAhYXJndikgZG9cbiAgICBiZWdpbiB0cnlcbiAgICAgIGxldCBzID0gIWFyZ3YuKCFjdXJyZW50KSBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCBzID49IDEgJiYgcy5bMF0gPSAnLScgdGhlbiBiZWdpblxuICAgICAgICBsZXQgYWN0aW9uLCBmb2xsb3cgPVxuICAgICAgICAgIHRyeSBhc3NvYzMgcyAhc3BlY2xpc3QsIE5vbmVcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IGtleXdvcmQsIGFyZyA9IHNwbGl0IHMgaW5cbiAgICAgICAgICAgIGFzc29jMyBrZXl3b3JkICFzcGVjbGlzdCwgU29tZSBhcmdcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiByYWlzZSAoU3RvcCAoVW5rbm93biBzKSlcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5vX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm5vIGFyZ3VtZW50XCIpKSkgaW5cbiAgICAgICAgbGV0IGdldF9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIGlmICFjdXJyZW50ICsgMSA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgICAgZWxzZSByYWlzZSAoU3RvcCAoTWlzc2luZyBzKSlcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IGFyZ1xuICAgICAgICBpblxuICAgICAgICBsZXQgY29uc3VtZV9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGluY3IgY3VycmVudFxuICAgICAgICAgIHwgU29tZSBfIC0+ICgpXG4gICAgICAgIGluXG4gICAgICAgIGxldCByZWMgdHJlYXRfYWN0aW9uID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbml0IGYgLT4gbm9fYXJnICgpOyBmICgpO1xuICAgICAgICB8IEJvb2wgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGJvb2xfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgYm9vbGVhblwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgcyAtPiBmIHNcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldCByIC0+IG5vX2FyZyAoKTsgciA6PSB0cnVlO1xuICAgICAgICB8IENsZWFyIHIgLT4gbm9fYXJnICgpOyByIDo9IGZhbHNlO1xuICAgICAgICB8IFN0cmluZyBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgZiBhcmc7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTeW1ib2wgKHN5bWIsIGYpIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgaWYgTGlzdC5tZW0gYXJnIHN5bWIgdGhlbiBiZWdpblxuICAgICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgICByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJvbmUgb2Y6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeIChtYWtlX3N5bWxpc3QgXCJcIiBcIiBcIiBcIlwiIHN5bWIpKSkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBTZXRfc3RyaW5nIHIgLT5cbiAgICAgICAgICAgIHIgOj0gZ2V0X2FyZyAoKTtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IEludCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2ludCByIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgRmxvYXQgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2Zsb2F0IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmbG9hdF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBmbG9hdFwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiByIDo9IHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFR1cGxlIHNwZWNzIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICBMaXN0Lml0ZXIgdHJlYXRfYWN0aW9uIHNwZWNzO1xuICAgICAgICB8IFJlc3QgZiAtPlxuICAgICAgICAgICAgbm9fYXJnICgpO1xuICAgICAgICAgICAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSAtIDEgZG9cbiAgICAgICAgICAgICAgZiAhYXJndi4oIWN1cnJlbnQgKyAxKTtcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICB8IFJlc3RfYWxsIGYgLT5cbiAgICAgICAgICAgIG5vX2FyZyAoKTtcbiAgICAgICAgICAgIGxldCBhY2MgPSByZWYgW10gaW5cbiAgICAgICAgICAgIHdoaWxlICFjdXJyZW50IDwgQXJyYXkubGVuZ3RoICFhcmd2IC0gMSBkb1xuICAgICAgICAgICAgICBhY2MgOj0gIWFyZ3YuKCFjdXJyZW50ICsgMSkgOjogIWFjYztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICAgICAgZiAoTGlzdC5yZXYgIWFjYylcbiAgICAgICAgfCBFeHBhbmQgZiAtPlxuICAgICAgICAgICAgaWYgbm90IGFsbG93X2V4cGFuZCB0aGVuXG4gICAgICAgICAgICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiQXJnLkV4cGFuZCBpcyBpcyBvbmx5IGFsbG93ZWQgd2l0aCBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJnLnBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXCIpO1xuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGxldCBuZXdhcmcgPSBmIGFyZyBpblxuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gQXJyYXkuc3ViICFhcmd2IDAgKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgIGFuZCBhZnRlciA9XG4gICAgICAgICAgICAgIEFycmF5LnN1YiAhYXJndiAoIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgKChBcnJheS5sZW5ndGggIWFyZ3YpIC0gIWN1cnJlbnQgLSAxKSBpblxuICAgICAgICAgICAgYXJndjo9IEFycmF5LmNvbmNhdCBbYmVmb3JlO25ld2FyZzthZnRlcl07XG4gICAgICAgIGluXG4gICAgICAgIHRyZWF0X2FjdGlvbiBhY3Rpb24gZW5kXG4gICAgICBlbHNlIGFub25mdW4gc1xuICAgIHdpdGggfCBCYWQgbSAtPiByYWlzZSAoY29udmVydF9lcnJvciAoTWVzc2FnZSBtKSk7XG4gICAgICAgICB8IFN0b3AgZSAtPiByYWlzZSAoY29udmVydF9lcnJvciBlKTtcbiAgICBlbmQ7XG4gICAgaW5jciBjdXJyZW50XG4gIGRvbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCB0cnVlIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZ1xuXG5sZXQgcGFyc2VfYXJndl9keW5hbWljID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGZhbHNlIGN1cnJlbnQgKHJlZiBhcmd2KSBzcGVjbGlzdCBhbm9uZnVuXG4gICAgZXJybXNnXG5cblxubGV0IHBhcnNlX2FyZ3YgPyhjdXJyZW50PWN1cnJlbnQpIGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hcmd2X2R5bmFtaWMgfmN1cnJlbnQ6Y3VycmVudCBhcmd2IChyZWYgc3BlY2xpc3QpIGFub25mdW4gZXJybXNnXG5cblxubGV0IHBhcnNlIGwgZiBtc2cgPVxuICB0cnlcbiAgICBwYXJzZV9hcmd2IFN5cy5hcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cblxubGV0IHBhcnNlX2R5bmFtaWMgbCBmIG1zZyA9XG4gIHRyeVxuICAgIHBhcnNlX2FyZ3ZfZHluYW1pYyBTeXMuYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5sZXQgcGFyc2VfZXhwYW5kIGwgZiBtc2cgPVxuICB0cnlcbiAgICBsZXQgYXJndiA9IHJlZiBTeXMuYXJndiBpblxuICAgIGxldCBzcGVjID0gcmVmIGwgaW5cbiAgICBsZXQgY3VycmVudCA9IHJlZiAoIWN1cnJlbnQpIGluXG4gICAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMgY3VycmVudCBhcmd2IHNwZWMgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cblxubGV0IHNlY29uZF93b3JkIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBuID1cbiAgICBpZiBuID49IGxlbiB0aGVuIGxlblxuICAgIGVsc2UgaWYgcy5bbl0gPSAnICcgdGhlbiBsb29wIChuKzEpXG4gICAgZWxzZSBuXG4gIGluXG4gIG1hdGNoIFN0cmluZy5pbmRleCBzICdcXHQnIHdpdGhcbiAgfCBuIC0+IGxvb3AgKG4rMSlcbiAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+XG4gICAgICBiZWdpbiBtYXRjaCBTdHJpbmcuaW5kZXggcyAnICcgd2l0aFxuICAgICAgfCBuIC0+IGxvb3AgKG4rMSlcbiAgICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiBsZW5cbiAgICAgIGVuZFxuXG5cbmxldCBtYXhfYXJnX2xlbiBjdXIgKGt3ZCwgc3BlYywgZG9jKSA9XG4gIG1hdGNoIHNwZWMgd2l0aFxuICB8IFN5bWJvbCBfIC0+IEludC5tYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZClcbiAgfCBfIC0+IEludC5tYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZCArIHNlY29uZF93b3JkIGRvYylcblxuXG5sZXQgcmVwbGFjZV9sZWFkaW5nX3RhYiBzID1cbiAgbGV0IHNlZW4gPSByZWYgZmFsc2UgaW5cbiAgU3RyaW5nLm1hcCAoZnVuY3Rpb24gJ1xcdCcgd2hlbiBub3QgIXNlZW4gLT4gc2VlbiA6PSB0cnVlOyAnICcgfCBjIC0+IGMpIHNcblxubGV0IGFkZF9wYWRkaW5nIGxlbiBrc2QgPVxuICBtYXRjaCBrc2Qgd2l0aFxuICB8IChfLCBfLCBcIlwiKSAtPlxuICAgICAgKCogRG8gbm90IHBhZCB1bmRvY3VtZW50ZWQgb3B0aW9ucywgc28gdGhhdCB0aGV5IHN0aWxsIGRvbid0IHNob3cgdXAgd2hlblxuICAgICAgICogcnVuIHRocm91Z2ggW3VzYWdlXSBvciBbcGFyc2VdLiAqKVxuICAgICAga3NkXG4gIHwgKGt3ZCwgKFN5bWJvbCBfIGFzIHNwZWMpLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgKChJbnQubWF4IDAgKGxlbiAtIGN1dGNvbCkpICsgMykgJyAnIGluXG4gICAgICAoa3dkLCBzcGVjLCBcIlxcblwiIF4gc3BhY2VzIF4gcmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpXG4gIHwgKGt3ZCwgc3BlYywgbXNnKSAtPlxuICAgICAgbGV0IGN1dGNvbCA9IHNlY29uZF93b3JkIG1zZyBpblxuICAgICAgbGV0IGt3ZF9sZW4gPSBTdHJpbmcubGVuZ3RoIGt3ZCBpblxuICAgICAgbGV0IGRpZmYgPSBsZW4gLSBrd2RfbGVuIC0gY3V0Y29sIGluXG4gICAgICBpZiBkaWZmIDw9IDAgdGhlblxuICAgICAgICAoa3dkLCBzcGVjLCByZXBsYWNlX2xlYWRpbmdfdGFiIG1zZylcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHNwYWNlcyA9IFN0cmluZy5tYWtlIGRpZmYgJyAnIGluXG4gICAgICAgIGxldCBwcmVmaXggPSBTdHJpbmcuc3ViIChyZXBsYWNlX2xlYWRpbmdfdGFiIG1zZykgMCBjdXRjb2wgaW5cbiAgICAgICAgbGV0IHN1ZmZpeCA9IFN0cmluZy5zdWIgbXNnIGN1dGNvbCAoU3RyaW5nLmxlbmd0aCBtc2cgLSBjdXRjb2wpIGluXG4gICAgICAgIChrd2QsIHNwZWMsIHByZWZpeCBeIHNwYWNlcyBeIHN1ZmZpeClcblxuXG5sZXQgYWxpZ24gPyhsaW1pdD1tYXhfaW50KSBzcGVjbGlzdCA9XG4gIGxldCBjb21wbGV0ZWQgPSBhZGRfaGVscCBzcGVjbGlzdCBpblxuICBsZXQgbGVuID0gTGlzdC5mb2xkX2xlZnQgbWF4X2FyZ19sZW4gMCBjb21wbGV0ZWQgaW5cbiAgbGV0IGxlbiA9IEludC5taW4gbGVuIGxpbWl0IGluXG4gIExpc3QubWFwIChhZGRfcGFkZGluZyBsZW4pIGNvbXBsZXRlZFxuXG5sZXQgdHJpbV9jciBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBpZiBsZW4gPiAwICYmIFN0cmluZy5nZXQgcyAobGVuIC0gMSkgPSAnXFxyJyB0aGVuXG4gICAgU3RyaW5nLnN1YiBzIDAgKGxlbiAtIDEpXG4gIGVsc2VcbiAgICBzXG5cbmxldCByZWFkX2F1eCB0cmltIHNlcCBmaWxlID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgbGV0IHdvcmRzID0gcmVmIFtdIGluXG4gIGxldCBzdGFzaCAoKSA9XG4gICAgbGV0IHdvcmQgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gICAgbGV0IHdvcmQgPSBpZiB0cmltIHRoZW4gdHJpbV9jciB3b3JkIGVsc2Ugd29yZCBpblxuICAgIHdvcmRzIDo9IHdvcmQgOjogIXdvcmRzO1xuICAgIEJ1ZmZlci5jbGVhciBidWZcbiAgaW5cbiAgYmVnaW5cbiAgICB0cnkgd2hpbGUgdHJ1ZSBkb1xuICAgICAgICBsZXQgYyA9IGlucHV0X2NoYXIgaWMgaW5cbiAgICAgICAgaWYgYyA9IHNlcCB0aGVuIHN0YXNoICgpIGVsc2UgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjXG4gICAgICBkb25lXG4gICAgd2l0aCBFbmRfb2ZfZmlsZSAtPiAoKVxuICBlbmQ7XG4gIGlmIEJ1ZmZlci5sZW5ndGggYnVmID4gMCB0aGVuIHN0YXNoICgpO1xuICBjbG9zZV9pbiBpYztcbiAgQXJyYXkub2ZfbGlzdCAoTGlzdC5yZXYgIXdvcmRzKVxuXG5sZXQgcmVhZF9hcmcgPSByZWFkX2F1eCB0cnVlICdcXG4nXG5cbmxldCByZWFkX2FyZzAgPSByZWFkX2F1eCBmYWxzZSAnXFx4MDAnXG5cbmxldCB3cml0ZV9hdXggc2VwIGZpbGUgYXJncyA9XG4gIGxldCBvYyA9IG9wZW5fb3V0X2JpbiBmaWxlIGluXG4gIEFycmF5Lml0ZXIgKGZ1biBzIC0+IGZwcmludGYgb2MgXCIlcyVjXCIgcyBzZXApIGFyZ3M7XG4gIGNsb3NlX291dCBvY1xuXG5sZXQgd3JpdGVfYXJnID0gd3JpdGVfYXV4ICdcXG4nXG5cbmxldCB3cml0ZV9hcmcwID0gd3JpdGVfYXV4ICdcXHgwMCdcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY3N0X0Rpc3BsYXlfdGhpc19saXN0X29mX29wdGlvIiwiY3N0X3MiLCJjc3RfaGVscCIsImNzdF9hX2Zsb2F0IiwiY3N0X2FuX2ludGVnZXIiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9lcXVhbCIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX3N5c19hcmd2IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsIlN0ZGxpYl9QcmludGYiLCJTdGRsaWJfQXJyYXkiLCJTdGRsaWJfQnVmZmVyIiwiU3RkbGliX0xpc3QiLCJTdGRsaWJfU3RyaW5nIiwiU3RkbGliX0ludCIsIkJhZCIsIkhlbHAiLCJTdG9wIiwiY3N0X25vbmUiLCJhc3NvYzMiLCJ4IiwibCIsIm1hdGNoIiwieTIiLCJ5MSIsInQiLCJtYWtlX3N5bWxpc3QiLCJwcmVmaXgiLCJzZXAiLCJzdWZmaXgiLCJoIiwieSIsImhlbHBfYWN0aW9uIiwicGFyYW0iLCJhZGRfaGVscCIsInNwZWNsaXN0IiwiYWRkMSIsImV4biIsImFkZDIiLCJ1c2FnZV9iIiwiYnVmIiwiZXJybXNnIiwiZG9jIiwic3BlYyIsImtleSIsInVzYWdlX3N0cmluZyIsImIiLCJ1c2FnZSIsImN1cnJlbnQiLCJjc3Rfbm9fYXJndW1lbnQiLCJjc3RfYV9ib29sZWFuIiwiY3N0X29uZV9vZiIsImNzdF9BcmdfRXhwYW5kX2lzX2lzX29ubHlfYWxsbyIsImR1bW15IiwiaW50X29mX3N0cmluZ19vcHQiLCJ0YWciLCJmbG9hdF9vZl9zdHJpbmdfb3B0IiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfIiwiYWxsb3dfZXhwYW5kIiwiYXJndiIsImFub25mdW4iLCJpbml0cG9zIiwiY29udmVydF9lcnJvciIsImVycm9yIiwicHJvZ25hbWUiLCJzIiwiZXhwZWN0ZWQiLCJhcmciLCJvcHQiLCJmb2xsb3ciLCJhY3Rpb24iLCJpIiwibGVuIiwia2V5d29yZCIsIm5vX2FyZyIsImdldF9hcmciLCJjb25zdW1lX2FyZyIsInRyZWF0X2FjdGlvbiIsInIiLCJzcGVjcyIsInN5bWIiLCJhY2MiLCJuZXdhcmciLCJiZWZvcmUiLCJhZnRlciIsIm0iLCJlIiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMiLCJwYXJzZV9hcmd2X2R5bmFtaWMiLCJzdGgiLCJwYXJzZV9hcmd2IiwicGFyc2UiLCJtc2ciLCJwYXJzZV9keW5hbWljIiwicGFyc2VfZXhwYW5kIiwic2Vjb25kX3dvcmQiLCJsb29wIiwibiIsIm1heF9hcmdfbGVuIiwiY3VyIiwia3dkIiwicmVwbGFjZV9sZWFkaW5nX3RhYiIsInNlZW4iLCJjIiwiYWxpZ24iLCJsaW1pdCIsImNvbXBsZXRlZCIsImtzZCIsImN1dGNvbCIsInNwYWNlcyIsImt3ZF9sZW4iLCJkaWZmIiwicmVhZF9hdXgiLCJ0cmltIiwiZmlsZSIsImljIiwid29yZHMiLCJzdGFzaCIsIndvcmQiLCJyZWFkX2FyZyIsInJlYWRfYXJnMCIsIndyaXRlX2F1eCIsImFyZ3MiLCJv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U0FDQTtBQUFBO0FBQUEsZ0JBQWM7QUFBQSxjQUNaO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFBQUEsU0FVQTtBQUFBLEtBQ0E7QUFBQSxLQUNBLHVDQUFnQjtBQUFBO0FBQUEsSUFFbEI7QUFBQTtBQUFBLFVBQUFmLElBRWM7QUFBQSxNQUNSLGNBQWdCLGVBQWM7QUFBQTtBQUFBO0FBQUEsVUFBQWxFO0FBQUFBLFNBQUFBLE1EOVl0QztBQUFBO0FBQUEsS0NrWksseUNBQTJCO0FBQUEsS0FDOUI7QUFBQSxhQUNjO0FBQUEsS0FBaUI7QUFBQTtBQUFBO0FBQUEsV0FFbEI7QUFBQSxZQUFBa0YsU0FBQTtBQUFBLFdBRXNCO0FBQUEsWUFBQUMsVUFBQSxHQUFyQjtBQUFBLFlBQUFDLFVBQUE3RixLQUFBc0YsTUFBQVE7QUFBQUEsUUFBQUMsS0FHTDtBQUFBLElBQ1Q7QUFBQTtBQUFBLGVBQUExRDtBQUFBQSxPQUFxQiw2REFBdUI7QUFBQTtBQUFBO0FBQUEsSUFBTSxnQ0FDdEM7QUFBQTtBQUFBLFdBRUU7QUFBQSxZQUFBMkQsVUFBQTtBQUFBLFdBRUM7QUFBQSxZQUFBQyxXQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFnQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEamFqQyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2MDE1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJnbG9iYWxfZGF0YSIsIkNhbWxpbnRlcm5hbEF0b21pYyIsIm1ha2UiLCJnZXQiLCJzZXQiLCJleGNoYW5nZSIsImNvbXBhcmVfYW5kX3NldCIsImZldGNoX2FuZF9hZGQiLCJpbmNyIiwiZGVjciIsIlN0ZGxpYl9BdG9taWMiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNjA0OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL3ByaW50ZXhjLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIFByaW50ZlxuXG50eXBlIHQgPSBleG4gPSAuLlxuXG5sZXQgcHJpbnRlcnMgPSBBdG9taWMubWFrZSBbXVxuXG5sZXQgbG9jZm10ID0gZm9ybWF0X29mX3N0cmluZyBcIkZpbGUgXFxcIiVzXFxcIiwgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZDogJXNcIlxuXG5sZXQgZmllbGQgeCBpID1cbiAgbGV0IGYgPSBPYmouZmllbGQgeCBpIGluXG4gIGlmIG5vdCAoT2JqLmlzX2Jsb2NrIGYpIHRoZW5cbiAgICBzcHJpbnRmIFwiJWRcIiAoT2JqLm1hZ2ljIGYgOiBpbnQpICAgICAgICAgICAoKiBjYW4gYWxzbyBiZSBhIGNoYXIgKilcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouc3RyaW5nX3RhZyB0aGVuXG4gICAgc3ByaW50ZiBcIiVTXCIgKE9iai5tYWdpYyBmIDogc3RyaW5nKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5kb3VibGVfdGFnIHRoZW5cbiAgICBzdHJpbmdfb2ZfZmxvYXQgKE9iai5tYWdpYyBmIDogZmxvYXQpXG4gIGVsc2VcbiAgICBcIl9cIlxuXG5sZXQgcmVjIG90aGVyX2ZpZWxkcyB4IGkgPVxuICBpZiBpID49IE9iai5zaXplIHggdGhlbiBcIlwiXG4gIGVsc2Ugc3ByaW50ZiBcIiwgJXMlc1wiIChmaWVsZCB4IGkpIChvdGhlcl9maWVsZHMgeCAoaSsxKSlcblxubGV0IGZpZWxkcyB4ID1cbiAgbWF0Y2ggT2JqLnNpemUgeCB3aXRoXG4gIHwgMCAtPiBcIlwiXG4gIHwgMSAtPiBcIlwiXG4gIHwgMiAtPiBzcHJpbnRmIFwiKCVzKVwiIChmaWVsZCB4IDEpXG4gIHwgXyAtPiBzcHJpbnRmIFwiKCVzJXMpXCIgKGZpZWxkIHggMSkgKG90aGVyX2ZpZWxkcyB4IDIpXG5cbmxldCB1c2VfcHJpbnRlcnMgeCA9XG4gIGxldCByZWMgY29udiA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAobWF0Y2ggaGQgeCB3aXRoXG4gICAgICAgICB8IE5vbmUgfCBleGNlcHRpb24gXyAtPiBjb252IHRsXG4gICAgICAgICB8IFNvbWUgcyAtPiBTb21lIHMpXG4gICAgfCBbXSAtPiBOb25lIGluXG4gIGNvbnYgKEF0b21pYy5nZXQgcHJpbnRlcnMpXG5cbmxldCB0b19zdHJpbmdfZGVmYXVsdCA9IGZ1bmN0aW9uXG4gIHwgT3V0X29mX21lbW9yeSAtPiBcIk91dCBvZiBtZW1vcnlcIlxuICB8IFN0YWNrX292ZXJmbG93IC0+IFwiU3RhY2sgb3ZlcmZsb3dcIlxuICB8IE1hdGNoX2ZhaWx1cmUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzUpIFwiUGF0dGVybiBtYXRjaGluZyBmYWlsZWRcIlxuICB8IEFzc2VydF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIkFzc2VydGlvbiBmYWlsZWRcIlxuICB8IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIlVuZGVmaW5lZCByZWN1cnNpdmUgbW9kdWxlXCJcbiAgfCB4IC0+XG4gICAgICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgICAgIGlmIE9iai50YWcgeCA8PiAwIHRoZW5cbiAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIHggMCkgOiBzdHJpbmcpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBjb25zdHJ1Y3RvciA9XG4gICAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIChPYmouZmllbGQgeCAwKSAwKSA6IHN0cmluZykgaW5cbiAgICAgICAgY29uc3RydWN0b3IgXiAoZmllbGRzIHgpXG5cbmxldCB0b19zdHJpbmcgZSA9XG4gIG1hdGNoIHVzZV9wcmludGVycyBlIHdpdGhcbiAgfCBTb21lIHMgLT4gc1xuICB8IE5vbmUgLT4gdG9fc3RyaW5nX2RlZmF1bHQgZVxuXG5sZXQgcHJpbnQgZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZXByaW50ZiBcIlVuY2F1Z2h0IGV4Y2VwdGlvbjogJXNcXG5cIiAodG9fc3RyaW5nIHgpO1xuICAgIGZsdXNoIHN0ZGVycjtcbiAgICByYWlzZSB4XG5cbmxldCBjYXRjaCBmY3QgYXJnID1cbiAgdHJ5XG4gICAgZmN0IGFyZ1xuICB3aXRoIHggLT5cbiAgICBmbHVzaCBzdGRvdXQ7XG4gICAgZXByaW50ZiBcIlVuY2F1Z2h0IGV4Y2VwdGlvbjogJXNcXG5cIiAodG9fc3RyaW5nIHgpO1xuICAgIGV4aXQgMlxuXG50eXBlIHJhd19iYWNrdHJhY2Vfc2xvdFxudHlwZSByYXdfYmFja3RyYWNlX2VudHJ5ID0gcHJpdmF0ZSBpbnRcbnR5cGUgcmF3X2JhY2t0cmFjZSA9IHJhd19iYWNrdHJhY2VfZW50cnkgYXJyYXlcblxubGV0IHJhd19iYWNrdHJhY2VfZW50cmllcyBidCA9IGJ0XG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlOlxuICB1bml0IC0+IHJhd19iYWNrdHJhY2UgPSBcImNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlXCJcblxuZXh0ZXJuYWwgcmFpc2Vfd2l0aF9iYWNrdHJhY2U6IGV4biAtPiByYXdfYmFja3RyYWNlIC0+ICdhXG4gID0gXCIlcmFpc2Vfd2l0aF9iYWNrdHJhY2VcIlxuXG50eXBlIGJhY2t0cmFjZV9zbG90ID1cbiAgfCBLbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSAgICA6IGJvb2w7XG4gICAgICBmaWxlbmFtZSAgICA6IHN0cmluZztcbiAgICAgIGxpbmVfbnVtYmVyIDogaW50O1xuICAgICAgc3RhcnRfY2hhciAgOiBpbnQ7XG4gICAgICBlbmRfY2hhciAgICA6IGludDtcbiAgICAgIGlzX2lubGluZSAgIDogYm9vbDtcbiAgICAgIGRlZm5hbWUgICAgIDogc3RyaW5nO1xuICAgIH1cbiAgfCBVbmtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlIDogYm9vbFxuICAgIH1cblxuKCogdG8gYXZvaWQgd2FybmluZyAqKVxubGV0IF8gPSBbS25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlOyBmaWxlbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfbnVtYmVyID0gMDsgc3RhcnRfY2hhciA9IDA7IGVuZF9jaGFyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfaW5saW5lID0gZmFsc2U7IGRlZm5hbWUgPSBcIlwiIH07XG4gICAgICAgICBVbmtub3duX2xvY2F0aW9uIHsgaXNfcmFpc2UgPSBmYWxzZSB9XVxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdDpcbiAgcmF3X2JhY2t0cmFjZV9zbG90IC0+IGJhY2t0cmFjZV9zbG90ID0gXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCJcblxuZXh0ZXJuYWwgY29udmVydF9yYXdfYmFja3RyYWNlOlxuICByYXdfYmFja3RyYWNlIC0+IGJhY2t0cmFjZV9zbG90IGFycmF5ID0gXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZVwiXG5cbmxldCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQgPVxuICB0cnkgU29tZSAoY29udmVydF9yYXdfYmFja3RyYWNlIGJ0KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgcG9zIHNsb3QgPVxuICBsZXQgaW5mbyBpc19yYWlzZSA9XG4gICAgaWYgaXNfcmFpc2UgdGhlblxuICAgICAgaWYgcG9zID0gMCB0aGVuIFwiUmFpc2VkIGF0XCIgZWxzZSBcIlJlLXJhaXNlZCBhdFwiXG4gICAgZWxzZVxuICAgICAgaWYgcG9zID0gMCB0aGVuIFwiUmFpc2VkIGJ5IHByaW1pdGl2ZSBvcGVyYXRpb24gYXRcIiBlbHNlIFwiQ2FsbGVkIGZyb21cIlxuICBpblxuICBtYXRjaCBzbG90IHdpdGhcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT5cbiAgICAgIGlmIGwuaXNfcmFpc2UgdGhlblxuICAgICAgICAoKiBjb21waWxlci1pbnNlcnRlZCByZS1yYWlzZSwgc2tpcHBlZCAqKSBOb25lXG4gICAgICBlbHNlXG4gICAgICAgIFNvbWUgKHNwcmludGYgXCIlcyB1bmtub3duIGxvY2F0aW9uXCIgKGluZm8gZmFsc2UpKVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT5cbiAgICAgIFNvbWUgKHNwcmludGYgXCIlcyAlcyBpbiBmaWxlIFxcXCIlc1xcXCIlcywgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZFwiXG4gICAgICAgICAgICAgIChpbmZvIGwuaXNfcmFpc2UpIGwuZGVmbmFtZSBsLmZpbGVuYW1lXG4gICAgICAgICAgICAgIChpZiBsLmlzX2lubGluZSB0aGVuIFwiIChpbmxpbmVkKVwiIGVsc2UgXCJcIilcbiAgICAgICAgICAgICAgbC5saW5lX251bWJlciBsLnN0YXJ0X2NoYXIgbC5lbmRfY2hhcilcblxubGV0IHByaW50X2V4Y2VwdGlvbl9iYWNrdHJhY2Ugb3V0Y2hhbiBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgIGZwcmludGYgb3V0Y2hhblxuICAgICAgICBcIihQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgY2Fubm90IHByaW50IHN0YWNrIGJhY2t0cmFjZSlcXG5cIlxuICB8IFNvbWUgYSAtPlxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBhIC0gMSBkb1xuICAgICAgICBtYXRjaCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgaSBhLihpKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIHN0ciAtPiBmcHJpbnRmIG91dGNoYW4gXCIlc1xcblwiIHN0clxuICAgICAgZG9uZVxuXG5sZXQgcHJpbnRfcmF3X2JhY2t0cmFjZSBvdXRjaGFuIHJhd19iYWNrdHJhY2UgPVxuICBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlKVxuXG4oKiBjb25mdXNpbmdseSBuYW1lZDogcHJpbnRzIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBwcmludF9iYWNrdHJhY2Ugb3V0Y2hhbiA9XG4gIHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiAoZ2V0X3Jhd19iYWNrdHJhY2UgKCkpXG5cbmxldCBiYWNrdHJhY2VfdG9fc3RyaW5nIGJhY2t0cmFjZSA9XG4gIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICBcIihQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgY2Fubm90IHByaW50IHN0YWNrIGJhY2t0cmFjZSlcXG5cIlxuICB8IFNvbWUgYSAtPlxuICAgICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDEwMjQgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gYnByaW50ZiBiIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmU7XG4gICAgICBCdWZmZXIuY29udGVudHMgYlxuXG5sZXQgcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgcmF3X2JhY2t0cmFjZSA9XG4gIGJhY2t0cmFjZV90b19zdHJpbmcgKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlKVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2UgPSBmdW5jdGlvblxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPiBsLmlzX3JhaXNlXG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmUgPSBmdW5jdGlvblxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19pbmxpbmVcbiAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gZmFsc2VcblxudHlwZSBsb2NhdGlvbiA9IHtcbiAgZmlsZW5hbWUgOiBzdHJpbmc7XG4gIGxpbmVfbnVtYmVyIDogaW50O1xuICBzdGFydF9jaGFyIDogaW50O1xuICBlbmRfY2hhciA6IGludDtcbn1cblxubGV0IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uID0gZnVuY3Rpb25cbiAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gTm9uZVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT5cbiAgICBTb21lIHtcbiAgICAgIGZpbGVuYW1lICAgID0gbC5maWxlbmFtZTtcbiAgICAgIGxpbmVfbnVtYmVyID0gbC5saW5lX251bWJlcjtcbiAgICAgIHN0YXJ0X2NoYXIgID0gbC5zdGFydF9jaGFyO1xuICAgICAgZW5kX2NoYXIgICAgPSBsLmVuZF9jaGFyO1xuICAgIH1cblxubGV0IGJhY2t0cmFjZV9zbG90X2RlZm5hbWUgPSBmdW5jdGlvblxuICB8IFVua25vd25fbG9jYXRpb24gX1xuICB8IEtub3duX2xvY2F0aW9uIHsgZGVmbmFtZSA9IFwiXCIgfSAtPiBOb25lXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBTb21lIGwuZGVmbmFtZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RzIHJhd19iYWNrdHJhY2UgPVxuICAoKiBUaGUgZG9jdW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGd1YXJhbnRlZXMgdGhhdCBTb21lIGlzXG4gICAgIHJldHVybmVkIG9ubHkgaWYgYSBwYXJ0IG9mIHRoZSB0cmFjZSBpcyB1c2FibGUuIFRoaXMgZ2l2ZXMgdXNcbiAgICAgYSBiaXQgbW9yZSB3b3JrIHRoYW4ganVzdCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UsIGJ1dCBpdCBtYWtlcyB0aGVcbiAgICAgQVBJIG1vcmUgdXNlci1mcmllbmRseSAtLSBvdGhlcndpc2UgbW9zdCB1c2VycyB3b3VsZCBoYXZlIHRvXG4gICAgIHJlaW1wbGVtZW50IHRoZSBcIlByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBzb3JyeVwiIGxvZ2ljXG4gICAgIHRoZW1zZWx2ZXMuICopXG4gIG1hdGNoIGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBiYWNrdHJhY2UgLT5cbiAgICAgIGxldCB1c2FibGVfc2xvdCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG4gICAgICAgIHwgS25vd25fbG9jYXRpb24gXyAtPiB0cnVlIGluXG4gICAgICBsZXQgcmVjIGV4aXN0c191c2FibGUgPSBmdW5jdGlvblxuICAgICAgICB8ICgtMSkgLT4gZmFsc2VcbiAgICAgICAgfCBpIC0+IHVzYWJsZV9zbG90IGJhY2t0cmFjZS4oaSkgfHwgZXhpc3RzX3VzYWJsZSAoaSAtIDEpIGluXG4gICAgICBpZiBleGlzdHNfdXNhYmxlIChBcnJheS5sZW5ndGggYmFja3RyYWNlIC0gMSlcbiAgICAgIHRoZW4gU29tZSBiYWNrdHJhY2VcbiAgICAgIGVsc2UgTm9uZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RzX29mX3Jhd19lbnRyeSBlbnRyeSA9XG4gIGJhY2t0cmFjZV9zbG90cyBbfCBlbnRyeSB8XVxuXG5tb2R1bGUgU2xvdCA9IHN0cnVjdFxuICB0eXBlIHQgPSBiYWNrdHJhY2Vfc2xvdFxuICBsZXQgZm9ybWF0ID0gZm9ybWF0X2JhY2t0cmFjZV9zbG90XG4gIGxldCBpc19yYWlzZSA9IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlXG4gIGxldCBpc19pbmxpbmUgPSBiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmVcbiAgbGV0IGxvY2F0aW9uID0gYmFja3RyYWNlX3Nsb3RfbG9jYXRpb25cbiAgbGV0IG5hbWUgPSBiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lXG5lbmRcblxubGV0IHJhd19iYWNrdHJhY2VfbGVuZ3RoIGJ0ID0gQXJyYXkubGVuZ3RoIGJ0XG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX3Nsb3QgOlxuICByYXdfYmFja3RyYWNlIC0+IGludCAtPiByYXdfYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XCJcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZV9zbG90IC0+IHJhd19iYWNrdHJhY2Vfc2xvdCBvcHRpb25cbiAgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcIlxuXG4oKiBjb25mdXNpbmdseSBuYW1lZDpcbiAgIHJldHVybnMgdGhlICpzdHJpbmcqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdsb2JhbCBjdXJyZW50IGJhY2t0cmFjZSAqKVxubGV0IGdldF9iYWNrdHJhY2UgKCkgPSByYXdfYmFja3RyYWNlX3RvX3N0cmluZyAoZ2V0X3Jhd19iYWNrdHJhY2UgKCkpXG5cbmV4dGVybmFsIHJlY29yZF9iYWNrdHJhY2U6IGJvb2wgLT4gdW5pdCA9IFwiY2FtbF9yZWNvcmRfYmFja3RyYWNlXCJcbmV4dGVybmFsIGJhY2t0cmFjZV9zdGF0dXM6IHVuaXQgLT4gYm9vbCA9IFwiY2FtbF9iYWNrdHJhY2Vfc3RhdHVzXCJcblxubGV0IHJlYyByZWdpc3Rlcl9wcmludGVyIGZuID1cbiAgbGV0IG9sZF9wcmludGVycyA9IEF0b21pYy5nZXQgcHJpbnRlcnMgaW5cbiAgbGV0IG5ld19wcmludGVycyA9IGZuIDo6IG9sZF9wcmludGVycyBpblxuICBsZXQgc3VjY2VzcyA9IEF0b21pYy5jb21wYXJlX2FuZF9zZXQgcHJpbnRlcnMgb2xkX3ByaW50ZXJzIG5ld19wcmludGVycyBpblxuICBpZiBub3Qgc3VjY2VzcyB0aGVuIHJlZ2lzdGVyX3ByaW50ZXIgZm5cblxuZXh0ZXJuYWwgZ2V0X2NhbGxzdGFjazogaW50IC0+IHJhd19iYWNrdHJhY2UgPSBcImNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrXCJcblxubGV0IGV4bl9zbG90IHggPVxuICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgaWYgT2JqLnRhZyB4ID0gMCB0aGVuIE9iai5maWVsZCB4IDAgZWxzZSB4XG5cbmxldCBleG5fc2xvdF9pZCB4ID1cbiAgbGV0IHNsb3QgPSBleG5fc2xvdCB4IGluXG4gIChPYmoub2JqIChPYmouZmllbGQgc2xvdCAxKSA6IGludClcblxubGV0IGV4bl9zbG90X25hbWUgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMCkgOiBzdHJpbmcpXG5cbmV4dGVybmFsIGdldF9kZWJ1Z19pbmZvX3N0YXR1cyA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzXCJcblxuKCogRGVzY3JpcHRpb25zIGZvciBlcnJvcnMgaW4gc3RhcnR1cC5oLiBTZWUgYWxzbyBiYWNrdHJhY2UuYyAqKVxubGV0IGVycm9ycyA9IFt8IFwiXCI7XG4gICgqIEZJTEVfTk9UX0ZPVU5EICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBub3QgZm91bmQpXCI7XG4gICgqIEJBRF9CWVRFQ09ERSAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgYXBwZWFycyB0byBiZSBjb3JydXB0KVwiO1xuICAoKiBXUk9OR19NQUdJQyAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgaGFzIHdyb25nIG1hZ2ljIG51bWJlcilcIjtcbiAgKCogTk9fRkRTICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBjYW5ub3QgYmUgb3BlbmVkO1xcbiBcXFxuICAgICAgLS0gdG9vIG1hbnkgb3BlbiBmaWxlcy4gVHJ5IHJ1bm5pbmcgd2l0aCBPQ0FNTFJVTlBBUkFNPWI9MilcIlxufF1cblxubGV0IGRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZXhuIHJhd19iYWNrdHJhY2UgPVxuICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgbGV0IHN0YXR1cyA9IGdldF9kZWJ1Z19pbmZvX3N0YXR1cyAoKSBpblxuICBpZiBzdGF0dXMgPCAwIHRoZW5cbiAgICBwcmVycl9lbmRsaW5lIGVycm9ycy4oYWJzIHN0YXR1cyk7XG4gIGZsdXNoIHN0ZGVyclxuXG5sZXQgdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgPSByZWYgZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlclxuXG5sZXQgc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGZuID0gdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgOj0gZm5cblxubGV0IGVtcHR5X2JhY2t0cmFjZSA6IHJhd19iYWNrdHJhY2UgPSBbfCB8XVxuXG5sZXQgdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpID1cbiAgdHJ5XG4gICAgZ2V0X3Jhd19iYWNrdHJhY2UgKClcbiAgd2l0aCBfICgqIE91dF9vZl9tZW1vcnk/ICopIC0+XG4gICAgZW1wdHlfYmFja3RyYWNlXG5cbmxldCBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJyBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgKCogR2V0IHRoZSBiYWNrdHJhY2Ugbm93LCBpbiBjYXNlIG9uZSBvZiB0aGUgW2F0X2V4aXRdIGZ1bmN0aW9uXG4gICAgICAgZGVzdHJveXMgaXQuICopXG4gICAgbGV0IHJhd19iYWNrdHJhY2UgPVxuICAgICAgaWYgZGVidWdnZXJfaW5fdXNlICgqIFNhbWUgdGVzdCBhcyBpbiBbcnVudGltZS9wcmludGV4Yy5jXSAqKSB0aGVuXG4gICAgICAgIGVtcHR5X2JhY2t0cmFjZVxuICAgICAgZWxzZVxuICAgICAgICB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKClcbiAgICBpblxuICAgICh0cnkgU3RkbGliLmRvX2F0X2V4aXQgKCkgd2l0aCBfIC0+ICgpKTtcbiAgICB0cnlcbiAgICAgICF1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBleG4gcmF3X2JhY2t0cmFjZVxuICAgIHdpdGggZXhuJyAtPlxuICAgICAgbGV0IHJhd19iYWNrdHJhY2UnID0gdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3IgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXI6IGV4Y2VwdGlvbiAlc1xcblwiXG4gICAgICAgICh0b19zdHJpbmcgZXhuJyk7XG4gICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlJztcbiAgICAgIGZsdXNoIHN0ZGVyclxuICB3aXRoXG4gICAgfCBPdXRfb2ZfbWVtb3J5IC0+XG4gICAgICAgIHByZXJyX2VuZGxpbmVcbiAgICAgICAgICBcIkZhdGFsIGVycm9yOiBvdXQgb2YgbWVtb3J5IGluIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyXCJcblxuKCogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgW2NhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXSBpblxuICAgW3J1bnRpbWUvcHJpbnRleGMuY10gd2hpY2ggZXhwZWN0cyBubyBleGNlcHRpb24gaXMgcmFpc2VkLiAqKVxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24gZXhuIGRlYnVnZ2VyX2luX3VzZSA9XG4gIHRyeVxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2VcbiAgd2l0aCBfIC0+XG4gICAgKCogVGhlcmUgaXMgbm90IG11Y2ggd2UgY2FuIGRvIGF0IHRoaXMgcG9pbnQgKilcbiAgICAoKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0ICgpID1cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQcmludGV4Yy5oYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uXCJcbiAgICBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9zIiwiY3N0X1Byb2dyYW1fbm90X2xpbmtlZF93aXRoX2dfIiwiY3N0X2NoYXJhY3RlcnMiLCJjc3RfRmF0YWxfZXJyb3JfZXhjZXB0aW9uIiwiY3N0X0ZhdGFsX2Vycm9yX2V4Y2VwdGlvbl9zIiwiY3N0X1VuY2F1Z2h0X2V4Y2VwdGlvbiIsImNzdF9VbmNhdWdodF9leGNlcHRpb25fcyIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmEiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX29ial90YWciLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDUiLCJhMiIsImEzIiwiYTQiLCJjYW1sX2NhbGw3IiwiYTUiLCJhNiIsImdsb2JhbF9kYXRhIiwicGFydGlhbCIsImxvY2ZtdCIsIlN0ZGxpYl9QcmludGYiLCJTdGRsaWJfQXRvbWljIiwiU3RkbGliIiwiU3RkbGliX0J1ZmZlciIsIlN0ZGxpYl9PYmoiLCJwcmludGVycyIsImNzdF9PdXRfb2ZfbWVtb3J5IiwiY3N0X1N0YWNrX292ZXJmbG93IiwiY3N0X1BhdHRlcm5fbWF0Y2hpbmdfZmFpbGVkIiwiY3N0X0Fzc2VydGlvbl9mYWlsZWQiLCJjc3RfVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUiLCJjc3RfUmFpc2VkX2F0IiwiY3N0X1JlX3JhaXNlZF9hdCIsImNzdF9SYWlzZWRfYnlfcHJpbWl0aXZlX29wZXJhdCIsImNzdF9DYWxsZWRfZnJvbSIsImNzdF9pbmxpbmVkIiwiZmllbGQiLCJ4IiwiaSIsIm90aGVyX2ZpZWxkcyIsInVzZV9wcmludGVycyIsInBhcmFtIiwidGwiLCJoZCIsInZhbCIsInMiLCJ0b19zdHJpbmdfZGVmYXVsdCIsInRhZyIsIm1hdGNoIiwiY2hhciIsImxpbmUiLCJmaWxlIiwiY29uc3RydWN0b3IiLCJ0b19zdHJpbmciLCJlIiwicHJpbnQiLCJmY3QiLCJhcmciLCJjYXRjaCQiLCJyYXdfYmFja3RyYWNlX2VudHJpZXMiLCJidCIsImNvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImZvcm1hdF9iYWNrdHJhY2Vfc2xvdCIsInBvcyIsInNsb3QiLCJpbmZvIiwiaXNfcmFpc2UiLCJwcmludF9yYXdfYmFja3RyYWNlIiwib3V0Y2hhbiIsInJhd19iYWNrdHJhY2UiLCJiYWNrdHJhY2UiLCJhIiwic3RyIiwicHJpbnRfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZV90b19zdHJpbmciLCJiIiwiYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2UiLCJiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmUiLCJiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiIsImJhY2t0cmFjZV9zbG90X2RlZm5hbWUiLCJiYWNrdHJhY2Vfc2xvdHMiLCJiYWNrdHJhY2Vfc2xvdHNfb2ZfcmF3X2VudHJ5IiwiZW50cnkiLCJyYXdfYmFja3RyYWNlX2xlbmd0aCIsImdldF9iYWNrdHJhY2UiLCJyZWdpc3Rlcl9wcmludGVyIiwiZm4iLCJvbGRfcHJpbnRlcnMiLCJuZXdfcHJpbnRlcnMiLCJzdWNjZXNzIiwiZXhuX3Nsb3QiLCJleG5fc2xvdF9pZCIsImV4bl9zbG90X25hbWUiLCJlcnJvcnMiLCJkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW4iLCJleG4iLCJzdGF0dXMiLCJ1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsInNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsImVtcHR5X2JhY2t0cmFjZSIsImNzdF9GYXRhbF9lcnJvcl9vdXRfb2ZfbWVtb3J5XyIsImhhbmRsZV91bmNhdWdodF9leGNlcHRpb24iLCJkZWJ1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QTtBQUFBLEdBQWdDO0FBQUE7QUFBQSxJQUFBYSxrQkF6UzNDO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsMEJBQUFOLE9BQUFPO0FBQUFBLElBZ1YzQjtBQUFBLEtBNUJBO0FBQUE7QUFBQSxPQUFBakM7QUFBQUEsU0FBQSxvQ0FMRTtBQUFBLE1BY0EsSUFBSyxpQ0FBQTBCO0FBQUFBLE1BQ0w7QUFBQTtBQUFBLFlBQ0U7QUFBQTtBQUFBO0FBQUEsWUFBQUE7QUFBQUE7QUFBQUEsUUFBQUEsUURsVk47QUFBQSxRQUFBMUIsa0JDa1VJO0FBQUEsWUFtQndDO0FBQUEsT0FBdEM7QUFBQSxPQUNBO0FBQUEsZUFFRTtBQUFBLE9BREY7QUFBQSxPQUVBO0FBQUEsZUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBQUEwQjtBQUFBQSxVQUFBQSxNRDFWTjtBQUFBO0FBQUEsY0M2VlE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUFBQSxLQVVKO0FBQUEsR0FBRTtBQUFBLEdBTUo7QUFBQTtBQUFBO0FBQUEsSUFBQVE7QUFBQUEsTUFDMkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQ5VzdCIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTY1MjcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9mdW4ubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGlkIDogJ2EgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5sZXQgY29uc3QgYyBfID0gY1xubGV0IGZsaXAgZiB4IHkgPSBmIHkgeFxubGV0IG5lZ2F0ZSBwIHYgPSBub3QgKHAgdilcblxuZXhjZXB0aW9uIEZpbmFsbHlfcmFpc2VkIG9mIGV4blxuXG5sZXQgKCkgPSBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIEBAIGZ1bmN0aW9uXG58IEZpbmFsbHlfcmFpc2VkIGV4biAtPiBTb21lIChcIkZ1bi5GaW5hbGx5X3JhaXNlZDogXCIgXiBQcmludGV4Yy50b19zdHJpbmcgZXhuKVxufCBfIC0+IE5vbmVcblxubGV0IHByb3RlY3QgfihmaW5hbGx5IDogdW5pdCAtPiB1bml0KSB3b3JrID1cbiAgbGV0IGZpbmFsbHlfbm9fZXhuICgpID1cbiAgICB0cnkgZmluYWxseSAoKSB3aXRoIGUgLT5cbiAgICAgIGxldCBidCA9IFByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBQcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSAoRmluYWxseV9yYWlzZWQgZSkgYnRcbiAgaW5cbiAgbWF0Y2ggd29yayAoKSB3aXRoXG4gIHwgcmVzdWx0IC0+IGZpbmFsbHlfbm9fZXhuICgpIDsgcmVzdWx0XG4gIHwgZXhjZXB0aW9uIHdvcmtfZXhuIC0+XG4gICAgICBsZXQgd29ya19idCA9IFByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBmaW5hbGx5X25vX2V4biAoKSA7XG4gICAgICBQcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSB3b3JrX2V4biB3b3JrX2J0XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9QcmludGV4YyIsIlN0ZGxpYiIsImNvbnN0JCIsImMiLCJwYXJhbSIsImZsaXAiLCJ4IiwieSIsIm5lZ2F0ZSIsInAiLCJ2IiwiRmluYWxseV9yYWlzZWQiLCJjc3RfRnVuX0ZpbmFsbHlfcmFpc2VkIiwidGFnIiwiZXhuIiwiZHVtbXkiLCJwcm90ZWN0IiwiZmluYWxseSQiLCJ3b3JrIiwiZmluYWxseV9ub19leG4iLCJlIiwiYnQiLCJyZXN1bHQiLCJ3b3JrX2V4biIsIndvcmtfYnQiLCJTdGRsaWJfRnVuIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsWUFBQUMsT0FBQUMsR0FBQUMsT0NnQmdCLFNBQUM7QUFBQSxZQUFBQyxLQUFBVixHQUFBVyxHQUFBQyxHQUNBLDBCQUFLO0FBQUEsWUFBQUMsT0FBQUMsR0FBQUMsR0FDRCwyQkFBSztBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTURsQjFCO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxHQ3NCUztBQUFBO0FBQUEsY0FBQVI7QUFBQUEsVUFBQVMsTUFBNkI7QUFBQSxpQ0FFL0I7QUFBQSxVQUFBQyxNQUYrQixjQUNpQjtBQUFBLE1BQTFCLDREQUFpRDtBQUFBLEtBQ25FO0FBQUEsT0FBQUMsUUFBQTtBQUFBLFlBQUFDLFFBQUFDLFVBQUFDO0FBQUFBLGFBQUFDLGVBQUFmO0FBQUFBLEtBSVAsSUFBSTtBQUFBLFdBQUFnQjtBQUFBQTtBQUFBQSxPQUFBQSxJRDVCUjtBQUFBLE9BQUFDLEtDNkJlO0FBQUEsT0FBQVAsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQW1EO0FBQUEsSUFFdkQsUUFBQVEsU0FBTTtBQUFBLFVBQUFDO0FBQUFBO0FBQUFBLE1BQUFBLFdEaENSO0FBQUEsTUFBQUMsVUNtQ29CO0FBQUEsS0FDZDtBQUFBLEtBQWlCO0FBQUE7QUFBQTtBQUFBLElBSFQ7QUFBQSxJQUFpQjtBQUFBLEdBSXFCO0FBQUEsT0FBQUMsYUFiekM7QUFBQTtBQUFBO0FBQUEsRUR4QlgiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNjU5OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL2djLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBKYWNxdWVzLUhlbnJpIEpvdXJkYW4sIHByb2pldCBHYWxsaXVtLCBJTlJJQSBQYXJpcyAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5Ni0yMDE2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgICAqKVxuKCogICAgIGV0IGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHN0YXQgPSB7XG4gIG1pbm9yX3dvcmRzIDogZmxvYXQ7XG4gIHByb21vdGVkX3dvcmRzIDogZmxvYXQ7XG4gIG1ham9yX3dvcmRzIDogZmxvYXQ7XG4gIG1pbm9yX2NvbGxlY3Rpb25zIDogaW50O1xuICBtYWpvcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgaGVhcF93b3JkcyA6IGludDtcbiAgaGVhcF9jaHVua3MgOiBpbnQ7XG4gIGxpdmVfd29yZHMgOiBpbnQ7XG4gIGxpdmVfYmxvY2tzIDogaW50O1xuICBmcmVlX3dvcmRzIDogaW50O1xuICBmcmVlX2Jsb2NrcyA6IGludDtcbiAgbGFyZ2VzdF9mcmVlIDogaW50O1xuICBmcmFnbWVudHMgOiBpbnQ7XG4gIGNvbXBhY3Rpb25zIDogaW50O1xuICB0b3BfaGVhcF93b3JkcyA6IGludDtcbiAgc3RhY2tfc2l6ZSA6IGludDtcbiAgZm9yY2VkX21ham9yX2NvbGxlY3Rpb25zOiBpbnQ7XG59XG5cbnR5cGUgY29udHJvbCA9IHtcbiAgbXV0YWJsZSBtaW5vcl9oZWFwX3NpemUgOiBpbnQ7XG4gIG11dGFibGUgbWFqb3JfaGVhcF9pbmNyZW1lbnQgOiBpbnQ7XG4gIG11dGFibGUgc3BhY2Vfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgdmVyYm9zZSA6IGludDtcbiAgbXV0YWJsZSBtYXhfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgc3RhY2tfbGltaXQgOiBpbnQ7XG4gIG11dGFibGUgYWxsb2NhdGlvbl9wb2xpY3kgOiBpbnQ7XG4gIHdpbmRvd19zaXplIDogaW50O1xuICBjdXN0b21fbWFqb3JfcmF0aW8gOiBpbnQ7XG4gIGN1c3RvbV9taW5vcl9yYXRpbyA6IGludDtcbiAgY3VzdG9tX21pbm9yX21heF9zaXplIDogaW50O1xufVxuXG5leHRlcm5hbCBzdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3N0YXRcIlxuZXh0ZXJuYWwgcXVpY2tfc3RhdCA6IHVuaXQgLT4gc3RhdCA9IFwiY2FtbF9nY19xdWlja19zdGF0XCJcbmV4dGVybmFsIGNvdW50ZXJzIDogdW5pdCAtPiAoZmxvYXQgKiBmbG9hdCAqIGZsb2F0KSA9IFwiY2FtbF9nY19jb3VudGVyc1wiXG5leHRlcm5hbCBtaW5vcl93b3JkcyA6IHVuaXQgLT4gKGZsb2F0IFtAdW5ib3hlZF0pXG4gID0gXCJjYW1sX2djX21pbm9yX3dvcmRzXCIgXCJjYW1sX2djX21pbm9yX3dvcmRzX3VuYm94ZWRcIlxuZXh0ZXJuYWwgZ2V0IDogdW5pdCAtPiBjb250cm9sID0gXCJjYW1sX2djX2dldFwiXG5leHRlcm5hbCBzZXQgOiBjb250cm9sIC0+IHVuaXQgPSBcImNhbWxfZ2Nfc2V0XCJcbmV4dGVybmFsIG1pbm9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21pbm9yXCJcbmV4dGVybmFsIG1ham9yX3NsaWNlIDogaW50IC0+IGludCA9IFwiY2FtbF9nY19tYWpvcl9zbGljZVwiXG5leHRlcm5hbCBtYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19tYWpvclwiXG5leHRlcm5hbCBmdWxsX21ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2Z1bGxfbWFqb3JcIlxuZXh0ZXJuYWwgY29tcGFjdCA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19jb21wYWN0aW9uXCJcbmV4dGVybmFsIGdldF9taW5vcl9mcmVlIDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21pbm9yX2ZyZWVcIlxuZXh0ZXJuYWwgZ2V0X2J1Y2tldCA6IGludCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2J1Y2tldFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBnZXRfY3JlZGl0IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2NyZWRpdFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBodWdlX2ZhbGxiYWNrX2NvdW50IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudFwiXG5leHRlcm5hbCBldmVudGxvZ19wYXVzZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9ldmVudGxvZ19wYXVzZVwiXG5leHRlcm5hbCBldmVudGxvZ19yZXN1bWUgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZXZlbnRsb2dfcmVzdW1lXCJcblxub3BlbiBQcmludGZcblxubGV0IHByaW50X3N0YXQgYyA9XG4gIGxldCBzdCA9IHN0YXQgKCkgaW5cbiAgZnByaW50ZiBjIFwibWlub3JfY29sbGVjdGlvbnM6ICAgICAgJWRcXG5cIiBzdC5taW5vcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwibWFqb3JfY29sbGVjdGlvbnM6ICAgICAgJWRcXG5cIiBzdC5tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiY29tcGFjdGlvbnM6ICAgICAgICAgICAgJWRcXG5cIiBzdC5jb21wYWN0aW9ucztcbiAgZnByaW50ZiBjIFwiZm9yY2VkX21ham9yX2NvbGxlY3Rpb25zOiAlZFxcblwiIHN0LmZvcmNlZF9tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGxldCBsMSA9IFN0cmluZy5sZW5ndGggKHNwcmludGYgXCIlLjBmXCIgc3QubWlub3Jfd29yZHMpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1pbm9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJwcm9tb3RlZF93b3JkczogJSouMGZcXG5cIiBsMSBzdC5wcm9tb3RlZF93b3JkcztcbiAgZnByaW50ZiBjIFwibWFqb3Jfd29yZHM6ICAgICUqLjBmXFxuXCIgbDEgc3QubWFqb3Jfd29yZHM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDIgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJWRcIiBzdC50b3BfaGVhcF93b3JkcykgaW5cbiAgZnByaW50ZiBjIFwidG9wX2hlYXBfd29yZHM6ICUqZFxcblwiIGwyIHN0LnRvcF9oZWFwX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJoZWFwX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwibGl2ZV93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmxpdmVfd29yZHM7XG4gIGZwcmludGYgYyBcImZyZWVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5mcmVlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJsYXJnZXN0X2ZyZWU6ICAgJSpkXFxuXCIgbDIgc3QubGFyZ2VzdF9mcmVlO1xuICBmcHJpbnRmIGMgXCJmcmFnbWVudHM6ICAgICAgJSpkXFxuXCIgbDIgc3QuZnJhZ21lbnRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgZnByaW50ZiBjIFwibGl2ZV9ibG9ja3M6ICVkXFxuXCIgc3QubGl2ZV9ibG9ja3M7XG4gIGZwcmludGYgYyBcImZyZWVfYmxvY2tzOiAlZFxcblwiIHN0LmZyZWVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJoZWFwX2NodW5rczogJWRcXG5cIiBzdC5oZWFwX2NodW5rc1xuXG5cbmxldCBhbGxvY2F0ZWRfYnl0ZXMgKCkgPVxuICBsZXQgKG1pLCBwcm8sIG1hKSA9IGNvdW50ZXJzICgpIGluXG4gIChtaSArLiBtYSAtLiBwcm8pICouIGZsb2F0X29mX2ludCAoU3lzLndvcmRfc2l6ZSAvIDgpXG5cblxuZXh0ZXJuYWwgZmluYWxpc2UgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWdpc3RlclwiXG5leHRlcm5hbCBmaW5hbGlzZV9sYXN0IDogKHVuaXQgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9XG4gIFwiY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZVwiXG5leHRlcm5hbCBmaW5hbGlzZV9yZWxlYXNlIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2ZpbmFsX3JlbGVhc2VcIlxuXG5cbnR5cGUgYWxhcm0gPSBib29sIHJlZlxudHlwZSBhbGFybV9yZWMgPSB7YWN0aXZlIDogYWxhcm07IGYgOiB1bml0IC0+IHVuaXR9XG5cbmxldCByZWMgY2FsbF9hbGFybSBhcmVjID1cbiAgaWYgIShhcmVjLmFjdGl2ZSkgdGhlbiBiZWdpblxuICAgIGZpbmFsaXNlIGNhbGxfYWxhcm0gYXJlYztcbiAgICBhcmVjLmYgKCk7XG4gIGVuZFxuXG5cbmxldCBjcmVhdGVfYWxhcm0gZiA9XG4gIGxldCBhcmVjID0geyBhY3RpdmUgPSByZWYgdHJ1ZTsgZiA9IGYgfSBpblxuICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gIGFyZWMuYWN0aXZlXG5cblxubGV0IGRlbGV0ZV9hbGFybSBhID0gYSA6PSBmYWxzZVxuXG5tb2R1bGUgTWVtcHJvZiA9XG4gIHN0cnVjdFxuICAgIHR5cGUgYWxsb2NhdGlvbl9zb3VyY2UgPSBOb3JtYWwgfCBNYXJzaGFsIHwgQ3VzdG9tXG4gICAgdHlwZSBhbGxvY2F0aW9uID1cbiAgICAgIHsgbl9zYW1wbGVzIDogaW50O1xuICAgICAgICBzaXplIDogaW50O1xuICAgICAgICBzb3VyY2UgOiBhbGxvY2F0aW9uX3NvdXJjZTtcbiAgICAgICAgY2FsbHN0YWNrIDogUHJpbnRleGMucmF3X2JhY2t0cmFjZSB9XG5cbiAgICB0eXBlICgnbWlub3IsICdtYWpvcikgdHJhY2tlciA9IHtcbiAgICAgIGFsbG9jX21pbm9yOiBhbGxvY2F0aW9uIC0+ICdtaW5vciBvcHRpb247XG4gICAgICBhbGxvY19tYWpvcjogYWxsb2NhdGlvbiAtPiAnbWFqb3Igb3B0aW9uO1xuICAgICAgcHJvbW90ZTogJ21pbm9yIC0+ICdtYWpvciBvcHRpb247XG4gICAgICBkZWFsbG9jX21pbm9yOiAnbWlub3IgLT4gdW5pdDtcbiAgICAgIGRlYWxsb2NfbWFqb3I6ICdtYWpvciAtPiB1bml0O1xuICAgIH1cblxuICAgIGxldCBudWxsX3RyYWNrZXIgPSB7XG4gICAgICBhbGxvY19taW5vciA9IChmdW4gXyAtPiBOb25lKTtcbiAgICAgIGFsbG9jX21ham9yID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgcHJvbW90ZSA9IChmdW4gXyAtPiBOb25lKTtcbiAgICAgIGRlYWxsb2NfbWlub3IgPSAoZnVuIF8gLT4gKCkpO1xuICAgICAgZGVhbGxvY19tYWpvciA9IChmdW4gXyAtPiAoKSk7XG4gICAgfVxuXG4gICAgZXh0ZXJuYWwgY19zdGFydCA6XG4gICAgICBmbG9hdCAtPiBpbnQgLT4gKCdtaW5vciwgJ21ham9yKSB0cmFja2VyIC0+IHVuaXRcbiAgICAgID0gXCJjYW1sX21lbXByb2Zfc3RhcnRcIlxuXG4gICAgbGV0IHN0YXJ0XG4gICAgICB+c2FtcGxpbmdfcmF0ZVxuICAgICAgPyhjYWxsc3RhY2tfc2l6ZSA9IG1heF9pbnQpXG4gICAgICB0cmFja2VyID1cbiAgICAgIGNfc3RhcnQgc2FtcGxpbmdfcmF0ZSBjYWxsc3RhY2tfc2l6ZSB0cmFja2VyXG5cbiAgICBleHRlcm5hbCBzdG9wIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX21lbXByb2Zfc3RvcFwiXG4gIGVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJTdGRsaWJfU3lzIiwiU3RkbGliX1ByaW50ZiIsInByaW50X3N0YXQiLCJjIiwic3QiLCJsMSIsImwyIiwiYWxsb2NhdGVkX2J5dGVzIiwicGFyYW0iLCJtYXRjaCIsIm1hIiwicHJvIiwibWkiLCJjcmVhdGVfYWxhcm0iLCJkZWxldGVfYWxhcm0iLCJhIiwibnVsbF90cmFja2VyIiwic3RhcnQiLCJzYW1wbGluZ19yYXRlIiwib3B0IiwidHJhY2tlciIsInN0aCIsImNhbGxzdGFja19zaXplIiwiU3RkbGliX0djIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFDO0FBQUFBLFFBQUFDLEtDd0VXLDZCQUNUO0FBQUE7QUFBQSxZQUNBO0FBQUE7QUFBQSxZQUNBO0FBQUE7QUFBQSxZQUNBO0FBQUE7QUFBQSxJQUNBO0FBQUE7QUFBQSxTQUN1QjtBQUFBLEtBQUFDLEtBQStCLHNCQUEvQjtBQUFBLFNBQ3ZCO0FBQUE7QUFBQSxZQUNBO0FBQUE7QUFBQSxZQUNBO0FBQUE7QUFBQSxJQUNBO0FBQUE7QUFBQSxTQUN1QjtBQUFBLEtBQUFDLEtBQWdDLHNCQUFoQztBQUFBLFNBQ3ZCO0FBQUE7QUFBQSxZQUNBO0FBQUE7QUFBQSxZQUNBO0FBQUE7QUFBQSxZQUNBO0FBQUE7QUFBQSxZQUNBO0FBQUE7QUFBQSxZQUNBO0FBQUE7QUFBQSxJQUNBO0FBQUEsWUFDQTtBQUFBO0FBQUEsWUFDQTtBQUFBO0FBQUEsWUFBNEM7QUFBQSw2REFDQTtBQUFBO0FBQUEsWUFBQUMsZ0JBQUFDO0FBQUFBO0FBQUFBLEtBQUFDLFFBSXhCO0FBQUEsS0FBQUMsS0FBVztBQUFBLEtBQUFDLE1BQUE7QUFBQSxLQUFBQyxLQUFBO0FBQUEsSUFDc0I7QUFBQTtBQUFBLFlBQUFDLGFBQUFuQixHQXFCN0IsY0FDYjtBQUFBLFlBQUFvQixhQUFBQyxHQUdRLG1CQUFVO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNRDNIL0I7QUFBQSxnQkFBQVIsT0MrSThCLFNBQUk7QUFBQSxnQkFBQUEsT0FDSixTQUFJO0FBQUEsZ0JBQUFBLE9BQ1IsU0FBSTtBQUFBLGdCQUFBQSxPQUNFLFNBQUU7QUFBQSxnQkFBQUEsT0FDRixTQUFFO0FBQUEsWUFBQVMsTUFBQUMsZUFBQUMsS0FBQUM7QUFBQUEsSUFXNUI7QUFBQSxTQUFBQyxNQUFBLFFBQUFDLGlCQUZtQjtBQUFBO0FBQUEsU0FBQUEsaUJBQUE7QUFBQSxJQUVuQix5RUFBNEM7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUQ5SmxEIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTY3NzYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9kaWdlc3QubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1lc3NhZ2UgZGlnZXN0IChNRDUpICopXG5cbnR5cGUgdCA9IHN0cmluZ1xuXG5sZXQgY29tcGFyZSA9IFN0cmluZy5jb21wYXJlXG5sZXQgZXF1YWwgPSBTdHJpbmcuZXF1YWxcblxuZXh0ZXJuYWwgdW5zYWZlX3N0cmluZzogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfc3RyaW5nXCJcbmV4dGVybmFsIGNoYW5uZWw6IGluX2NoYW5uZWwgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X2NoYW5cIlxuXG5sZXQgc3RyaW5nIHN0ciA9XG4gIHVuc2FmZV9zdHJpbmcgc3RyIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG5sZXQgYnl0ZXMgYiA9IHN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKVxuXG5sZXQgc3Vic3RyaW5nIHN0ciBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IFN0cmluZy5sZW5ndGggc3RyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3Quc3Vic3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfc3RyaW5nIHN0ciBvZnMgbGVuXG5cbmxldCBzdWJieXRlcyBiIG9mcyBsZW4gPSBzdWJzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYikgb2ZzIGxlblxuXG5sZXQgZmlsZSBmaWxlbmFtZSA9XG4gIGxldCBpYyA9IG9wZW5faW5fYmluIGZpbGVuYW1lIGluXG4gIG1hdGNoIGNoYW5uZWwgaWMgKC0xKSB3aXRoXG4gICAgfCBkIC0+IGNsb3NlX2luIGljOyBkXG4gICAgfCBleGNlcHRpb24gZSAtPiBjbG9zZV9pbiBpYzsgcmFpc2UgZVxuXG5sZXQgb3V0cHV0IGNoYW4gZGlnZXN0ID1cbiAgb3V0cHV0X3N0cmluZyBjaGFuIGRpZ2VzdFxuXG5sZXQgaW5wdXQgY2hhbiA9IHJlYWxseV9pbnB1dF9zdHJpbmcgY2hhbiAxNlxuXG5sZXQgY2hhcl9oZXggbiA9XG4gIENoYXIudW5zYWZlX2NociAobiArIGlmIG4gPCAxMCB0aGVuIENoYXIuY29kZSAnMCcgZWxzZSAoQ2hhci5jb2RlICdhJyAtIDEwKSlcblxubGV0IHRvX2hleCBkID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBkIDw+IDE2IHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QudG9faGV4XCI7XG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMzIgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgbGV0IHggPSBDaGFyLmNvZGUgZC5baV0gaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKSAoY2hhcl9oZXggKHggbHNyIDQpKTtcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKzEpIChjaGFyX2hleCAoeCBsYW5kIDB4MGYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcblxubGV0IGZyb21faGV4IHMgPVxuICBpZiBTdHJpbmcubGVuZ3RoIHMgPD4gMzIgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5mcm9tX2hleFwiO1xuICBsZXQgZGlnaXQgYyA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnMCcuLic5JyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnMCdcbiAgICB8ICdBJy4uJ0YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdBJyArIDEwXG4gICAgfCAnYScuLidmJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnYScgKyAxMFxuICAgIHwgXyAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkRpZ2VzdC5mcm9tX2hleFwiKVxuICBpblxuICBsZXQgYnl0ZSBpID0gZGlnaXQgcy5baV0gbHNsIDQgKyBkaWdpdCBzLltpKzFdIGluXG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMTYgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgQnl0ZXMuc2V0IHJlc3VsdCBpIChDaGFyLmNociAoYnl0ZSAoMiAqIGkpKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9EaWdlc3RfZnJvbV9oZXgiLCJjYW1sX2J5dGVzX3Vuc2FmZV9zZXQiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbWQ1X3N0cmluZyIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfc3RyaW5nX2dldCIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsIlN0ZGxpYl9DaGFyIiwiU3RkbGliX0J5dGVzIiwiU3RkbGliX1N0cmluZyIsImNvbXBhcmUiLCJlcXVhbCIsImNzdF9EaWdlc3Rfc3Vic3RyaW5nIiwiY3N0X0RpZ2VzdF90b19oZXgiLCJzdHJpbmciLCJzdHIiLCJieXRlcyIsImIiLCJzdWJzdHJpbmciLCJvZnMiLCJsZW4iLCJzdWJieXRlcyIsImZpbGUiLCJmaWxlbmFtZSIsImljIiwiZCIsImUiLCJvdXRwdXQiLCJjaGFuIiwiZGlnZXN0IiwiaW5wdXQiLCJjaGFyX2hleCIsIm4iLCJ0b19oZXgiLCJyZXN1bHQiLCJpIiwieCIsImZyb21faGV4IiwicyIsImRpZ2l0IiwiYyIsIlN0ZGxpYl9EaWdlc3QiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFoQixzQkFBQTtBQUFBLElBQUFBLHdCQUFBO0FBQUEsWUFBQWlCLE9BQUFDO0FBQUFBLElDMEJFLDBEQUF1QztBQUFBO0FBQUEsWUFBQUMsTUFBQUMsR0FFcEIsT0FBMEIsT0FBMUIsK0JBQTBCO0FBQUEsWUFBQUMsVUFBQUgsS0FBQUksS0FBQUM7QUFBQUEsSUFHN0M7QUFBQSxLQUVLLHFDQUF5QjtBQUFBLElBRHpCLGlEQUN5QjtBQUFBO0FBQUEsWUFBQUMsU0FBQUosR0FBQUUsS0FBQUM7QUFBQUEsSUFFRyxPQUEwQixVQUExQix5Q0FBa0M7QUFBQTtBQUFBLFlBQUFFLEtBQUFDO0FBQUFBLFFBQUFDLEtBRzFEO0FBQUEsSUFDVCxRQUFBQyxJQUFNO0FBQUEsVUFBQUM7QUFBQUEsU0FBQUEsSUR2Q1I7QUFBQSxLQ3lDcUI7QUFBQSxLQUFXO0FBQUE7QUFBQSxJQURyQjtBQUFBLElBQVc7QUFBQSxHQUNtQjtBQUFBLFlBQUFDLE9BQUFDLE1BQUFDLFFBR3ZDLDBDQUF5QjtBQUFBLFlBQUFDLE1BQUFGLE1BRVYsc0NBQTJCO0FBQUEsWUFBQUcsU0FBQUMsT0FBQSxJQUcxQyxvQ0FBNEU7QUFBQSxZQUFBQyxPQUFBUjtBQUFBQSxJQUc1RTtBQUFBLEtBQThCO0FBQUEsUUFBQVMsU0FDakIsdUJBQUFDLElBQ2I7QUFBQTtBQUFBLFNBQUFDLElBQ29CO0FBQUEsS0FDZ0MseUNBQXBCO0FBQUEsS0FDMEIsbURBQXhCO0FBQUEsYUFBd0I7QUFBQSxrQkFFMUQsMENBQTZCO0FBQUEsS0FGNkI7QUFBQTtBQUFBLEdBRTdCO0FBQUEsWUFBQUMsU0FBQUM7QUFBQUEsSUFHN0I7QUFBQSxLQUE4QjtBQUFBLGFBQUFDLE1BQUFDO0FBQUFBLEtBRTVCO0FBQUE7QUFBQSxtQkFHYztBQUFBO0FBQUEsc0JBREE7QUFBQTtBQUFBLGdDQURBO0FBQUEsS0FHUDtBQUFBO0FBQUEsSUFBMEM7QUFBQSxRQUFBTixTQUd0Qyx1QkFBQUMsSUFDYjtBQUFBO0FBQUE7QUFBQSxNQUFBQSxNQUNFO0FBQUEsVUFIK0IsTUFBTTtBQUFBLFVBQXBCLENBQU4sTUFBTTtBQUFBLEtBR2pCLGtDQUFtQjtBQUFBLGFBQXlCO0FBQUEsa0JBRTlDLDBDQUE2QjtBQUFBLEtBRmlCO0FBQUE7QUFBQSxHQUVqQjtBQUFBO0FBQUEsSUFBQU07QUFBQUEsTUQzRS9CIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTY4ODcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9yYW5kb20ubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuICAgVGhpcyBpcyBhIGxhZ2dlZC1GaWJvbmFjY2kgRig1NSwgMjQsICspIHdpdGggYSBtb2RpZmllZCBhZGRpdGlvblxuICAgZnVuY3Rpb24gdG8gZW5oYW5jZSB0aGUgbWl4aW5nIG9mIGJpdHMuXG4gICBJZiB3ZSB1c2Ugbm9ybWFsIGFkZGl0aW9uLCB0aGUgbG93LW9yZGVyIGJpdCBmYWlscyB0ZXN0cyAxIGFuZCA3XG4gICBvZiB0aGUgRGllaGFyZCB0ZXN0IHN1aXRlLCBhbmQgYml0cyAxIGFuZCAyIGFsc28gZmFpbCB0ZXN0IDcuXG4gICBJZiB3ZSB1c2UgbXVsdGlwbGljYXRpb24gYXMgc3VnZ2VzdGVkIGJ5IE1hcnNhZ2xpYSwgaXQgZG9lc24ndCBmYXJlXG4gICBtdWNoIGJldHRlci5cbiAgIEJ5IG1peGluZyB0aGUgYml0cyBvZiBvbmUgb2YgdGhlIG51bWJlcnMgYmVmb3JlIGFkZGl0aW9uIChYT1IgdGhlXG4gICA1IGhpZ2gtb3JkZXIgYml0cyBpbnRvIHRoZSBsb3ctb3JkZXIgYml0cyksIHdlIGdldCBhIGdlbmVyYXRvciB0aGF0XG4gICBwYXNzZXMgYWxsIHRoZSBEaWVoYXJkIHRlc3RzLlxuKilcblxuZXh0ZXJuYWwgcmFuZG9tX3NlZWQ6IHVuaXQgLT4gaW50IGFycmF5ID0gXCJjYW1sX3N5c19yYW5kb21fc2VlZFwiXG5cbm1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuXG4gIHR5cGUgdCA9IHsgc3QgOiBpbnQgYXJyYXk7IG11dGFibGUgaWR4IDogaW50IH1cblxuICBsZXQgbmV3X3N0YXRlICgpID0geyBzdCA9IEFycmF5Lm1ha2UgNTUgMDsgaWR4ID0gMCB9XG4gIGxldCBhc3NpZ24gc3QxIHN0MiA9XG4gICAgQXJyYXkuYmxpdCBzdDIuc3QgMCBzdDEuc3QgMCA1NTtcbiAgICBzdDEuaWR4IDwtIHN0Mi5pZHhcblxuXG4gIGxldCBmdWxsX2luaXQgcyBzZWVkID1cbiAgICBsZXQgY29tYmluZSBhY2N1IHggPSBEaWdlc3Quc3RyaW5nIChhY2N1IF4gSW50LnRvX3N0cmluZyB4KSBpblxuICAgIGxldCBleHRyYWN0IGQgPVxuICAgICAgQ2hhci5jb2RlIGQuWzBdICsgKENoYXIuY29kZSBkLlsxXSBsc2wgOCkgKyAoQ2hhci5jb2RlIGQuWzJdIGxzbCAxNilcbiAgICAgICsgKENoYXIuY29kZSBkLlszXSBsc2wgMjQpXG4gICAgaW5cbiAgICBsZXQgc2VlZCA9IGlmIEFycmF5Lmxlbmd0aCBzZWVkID0gMCB0aGVuIFt8IDAgfF0gZWxzZSBzZWVkIGluXG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGggc2VlZCBpblxuICAgIGZvciBpID0gMCB0byA1NCBkb1xuICAgICAgcy5zdC4oaSkgPC0gaTtcbiAgICBkb25lO1xuICAgIGxldCBhY2N1ID0gcmVmIFwieFwiIGluXG4gICAgZm9yIGkgPSAwIHRvIDU0ICsgSW50Lm1heCA1NSBsIGRvXG4gICAgICBsZXQgaiA9IGkgbW9kIDU1IGluXG4gICAgICBsZXQgayA9IGkgbW9kIGwgaW5cbiAgICAgIGFjY3UgOj0gY29tYmluZSAhYWNjdSBzZWVkLihrKTtcbiAgICAgIHMuc3QuKGopIDwtIChzLnN0LihqKSBseG9yIGV4dHJhY3QgIWFjY3UpIGxhbmQgMHgzRkZGRkZGRjsgICgqIFBSIzU1NzUgKilcbiAgICBkb25lO1xuICAgIHMuaWR4IDwtIDBcblxuXG4gIGxldCBtYWtlIHNlZWQgPVxuICAgIGxldCByZXN1bHQgPSBuZXdfc3RhdGUgKCkgaW5cbiAgICBmdWxsX2luaXQgcmVzdWx0IHNlZWQ7XG4gICAgcmVzdWx0XG5cblxuICBsZXQgbWFrZV9zZWxmX2luaXQgKCkgPSBtYWtlIChyYW5kb21fc2VlZCAoKSlcblxuICBsZXQgY29weSBzID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgYXNzaWduIHJlc3VsdCBzO1xuICAgIHJlc3VsdFxuXG5cbiAgKCogUmV0dXJucyAzMCByYW5kb20gYml0cyBhcyBhbiBpbnRlZ2VyIDAgPD0geCA8IDEwNzM3NDE4MjQgKilcbiAgbGV0IGJpdHMgcyA9XG4gICAgcy5pZHggPC0gKHMuaWR4ICsgMSkgbW9kIDU1O1xuICAgIGxldCBjdXJ2YWwgPSBzLnN0LihzLmlkeCkgaW5cbiAgICBsZXQgbmV3dmFsID0gcy5zdC4oKHMuaWR4ICsgMjQpIG1vZCA1NSlcbiAgICAgICAgICAgICAgICAgKyAoY3VydmFsIGx4b3IgKChjdXJ2YWwgbHNyIDI1KSBsYW5kIDB4MUYpKSBpblxuICAgIGxldCBuZXd2YWwzMCA9IG5ld3ZhbCBsYW5kIDB4M0ZGRkZGRkYgaW4gICgqIFBSIzU1NzUgKilcbiAgICBzLnN0LihzLmlkeCkgPC0gbmV3dmFsMzA7XG4gICAgbmV3dmFsMzBcblxuXG4gIGxldCByZWMgaW50YXV4IHMgbiA9XG4gICAgbGV0IHIgPSBiaXRzIHMgaW5cbiAgICBsZXQgdiA9IHIgbW9kIG4gaW5cbiAgICBpZiByIC0gdiA+IDB4M0ZGRkZGRkYgLSBuICsgMSB0aGVuIGludGF1eCBzIG4gZWxzZSB2XG5cbiAgbGV0IGludCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA+IDB4M0ZGRkZGRkYgfHwgYm91bmQgPD0gMFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50XCJcbiAgICBlbHNlIGludGF1eCBzIGJvdW5kXG5cbiAgbGV0IHJlYyBpbnQ2M2F1eCBzIG4gPVxuICAgIGxldCBtYXhfaW50XzMyID0gKDEgbHNsIDMwKSArIDB4M0ZGRkZGRkYgaW4gKCogMHg3RkZGRkZGRiAqKVxuICAgIGxldCBiMSA9IGJpdHMgcyBpblxuICAgIGxldCBiMiA9IGJpdHMgcyBpblxuICAgIGxldCAociwgbWF4X2ludCkgPVxuICAgICAgaWYgbiA8PSBtYXhfaW50XzMyIHRoZW5cbiAgICAgICAgKCogMzEgcmFuZG9tIGJpdHMgb24gYm90aCA2NC1iaXQgT0NhbWwgYW5kIEphdmFTY3JpcHQuXG4gICAgICAgICAgIFVzZSB1cHBlciAxNSBiaXRzIG9mIGIxIGFuZCAxNiBiaXRzIG9mIGIyLiAqKVxuICAgICAgICBsZXQgYnBvcyA9XG4gICAgICAgICAgKCgoYjIgbGFuZCAweDNGRkZDMDAwKSBsc2wgMSkgbG9yIChiMSBsc3IgMTUpKVxuICAgICAgICBpblxuICAgICAgICAgIChicG9zLCBtYXhfaW50XzMyKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgYjMgPSBiaXRzIHMgaW5cbiAgICAgICAgKCogNjIgcmFuZG9tIGJpdHMgb24gNjQtYml0IE9DYW1sOyB1bnJlYWNoYWJsZSBvbiBKYXZhU2NyaXB0LlxuICAgICAgICAgICBVc2UgdXBwZXIgMjAgYml0cyBvZiBiMSBhbmQgMjEgYml0cyBvZiBiMiBhbmQgYjMuICopXG4gICAgICAgIGxldCBicG9zID1cbiAgICAgICAgICAoKCgoYjMgbGFuZCAweDNGRkZGRTAwKSBsc2wgMTIpIGxvciAoYjIgbHNyIDkpKSBsc2wgMjApXG4gICAgICAgICAgICBsb3IgKGIxIGxzciAxMClcbiAgICAgICAgaW5cbiAgICAgICAgICAoYnBvcywgbWF4X2ludClcbiAgICBpblxuICAgIGxldCB2ID0gciBtb2QgbiBpblxuICAgIGlmIHIgLSB2ID4gbWF4X2ludCAtIG4gKyAxIHRoZW4gaW50NjNhdXggcyBuIGVsc2UgdlxuXG4gIGxldCBmdWxsX2ludCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiUmFuZG9tLmZ1bGxfaW50XCJcbiAgICBlbHNlIGlmIGJvdW5kID4gMHgzRkZGRkZGRiB0aGVuXG4gICAgICBpbnQ2M2F1eCBzIGJvdW5kXG4gICAgZWxzZVxuICAgICAgaW50YXV4IHMgYm91bmRcblxuXG4gIGxldCByZWMgaW50MzJhdXggcyBuID1cbiAgICBsZXQgYjEgPSBJbnQzMi5vZl9pbnQgKGJpdHMgcykgaW5cbiAgICBsZXQgYjIgPSBJbnQzMi5zaGlmdF9sZWZ0IChJbnQzMi5vZl9pbnQgKGJpdHMgcyBsYW5kIDEpKSAzMCBpblxuICAgIGxldCByID0gSW50MzIubG9nb3IgYjEgYjIgaW5cbiAgICBsZXQgdiA9IEludDMyLnJlbSByIG4gaW5cbiAgICBpZiBJbnQzMi5zdWIgciB2ID4gSW50MzIuYWRkIChJbnQzMi5zdWIgSW50MzIubWF4X2ludCBuKSAxbFxuICAgIHRoZW4gaW50MzJhdXggcyBuXG4gICAgZWxzZSB2XG5cbiAgbGV0IGludDMyIHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDBsXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQzMlwiXG4gICAgZWxzZSBpbnQzMmF1eCBzIGJvdW5kXG5cblxuICBsZXQgcmVjIGludDY0YXV4IHMgbiA9XG4gICAgbGV0IGIxID0gSW50NjQub2ZfaW50IChiaXRzIHMpIGluXG4gICAgbGV0IGIyID0gSW50NjQuc2hpZnRfbGVmdCAoSW50NjQub2ZfaW50IChiaXRzIHMpKSAzMCBpblxuICAgIGxldCBiMyA9IEludDY0LnNoaWZ0X2xlZnQgKEludDY0Lm9mX2ludCAoYml0cyBzIGxhbmQgNykpIDYwIGluXG4gICAgbGV0IHIgPSBJbnQ2NC5sb2dvciBiMSAoSW50NjQubG9nb3IgYjIgYjMpIGluXG4gICAgbGV0IHYgPSBJbnQ2NC5yZW0gciBuIGluXG4gICAgaWYgSW50NjQuc3ViIHIgdiA+IEludDY0LmFkZCAoSW50NjQuc3ViIEludDY0Lm1heF9pbnQgbikgMUxcbiAgICB0aGVuIGludDY0YXV4IHMgblxuICAgIGVsc2UgdlxuXG4gIGxldCBpbnQ2NCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwTFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50NjRcIlxuICAgIGVsc2UgaW50NjRhdXggcyBib3VuZFxuXG5cbiAgbGV0IG5hdGl2ZWludCA9XG4gICAgaWYgTmF0aXZlaW50LnNpemUgPSAzMlxuICAgIHRoZW4gZnVuIHMgYm91bmQgLT4gTmF0aXZlaW50Lm9mX2ludDMyIChpbnQzMiBzIChOYXRpdmVpbnQudG9faW50MzIgYm91bmQpKVxuICAgIGVsc2UgZnVuIHMgYm91bmQgLT4gSW50NjQudG9fbmF0aXZlaW50IChpbnQ2NCBzIChJbnQ2NC5vZl9uYXRpdmVpbnQgYm91bmQpKVxuXG5cbiAgKCogUmV0dXJucyBhIGZsb2F0IDAgPD0geCA8PSAxIHdpdGggYXQgbW9zdCA2MCBiaXRzIG9mIHByZWNpc2lvbi4gKilcbiAgbGV0IHJhd2Zsb2F0IHMgPVxuICAgIGxldCBzY2FsZSA9IDEwNzM3NDE4MjQuMCAgKCogMl4zMCAqKVxuICAgIGFuZCByMSA9IFN0ZGxpYi5mbG9hdCAoYml0cyBzKVxuICAgIGFuZCByMiA9IFN0ZGxpYi5mbG9hdCAoYml0cyBzKVxuICAgIGluIChyMSAvLiBzY2FsZSArLiByMikgLy4gc2NhbGVcblxuXG4gIGxldCBmbG9hdCBzIGJvdW5kID0gcmF3ZmxvYXQgcyAqLiBib3VuZFxuXG4gIGxldCBib29sIHMgPSAoYml0cyBzIGxhbmQgMSA9IDApXG5cbiAgbGV0IGJpdHMzMiBzID1cbiAgICBsZXQgYjEgPSBJbnQzMi4oc2hpZnRfcmlnaHRfbG9naWNhbCAob2ZfaW50IChiaXRzIHMpKSAxNCkgaW4gICgqIDE2IGJpdHMgKilcbiAgICBsZXQgYjIgPSBJbnQzMi4oc2hpZnRfcmlnaHRfbG9naWNhbCAob2ZfaW50IChiaXRzIHMpKSAxNCkgaW4gICgqIDE2IGJpdHMgKilcbiAgICBJbnQzMi4obG9nb3IgYjEgKHNoaWZ0X2xlZnQgYjIgMTYpKVxuXG4gIGxldCBiaXRzNjQgcyA9XG4gICAgbGV0IGIxID0gSW50NjQuKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKG9mX2ludCAoYml0cyBzKSkgOSkgaW4gICgqIDIxIGJpdHMgKilcbiAgICBsZXQgYjIgPSBJbnQ2NC4oc2hpZnRfcmlnaHRfbG9naWNhbCAob2ZfaW50IChiaXRzIHMpKSA5KSBpbiAgKCogMjEgYml0cyAqKVxuICAgIGxldCBiMyA9IEludDY0LihzaGlmdF9yaWdodF9sb2dpY2FsIChvZl9pbnQgKGJpdHMgcykpIDgpIGluICAoKiAyMiBiaXRzICopXG4gICAgSW50NjQuKGxvZ29yIGIxIChsb2dvciAoc2hpZnRfbGVmdCBiMiAyMSkgKHNoaWZ0X2xlZnQgYjMgNDIpKSlcblxuICBsZXQgbmF0aXZlYml0cyA9XG4gICAgaWYgTmF0aXZlaW50LnNpemUgPSAzMlxuICAgIHRoZW4gZnVuIHMgLT4gTmF0aXZlaW50Lm9mX2ludDMyIChiaXRzMzIgcylcbiAgICBlbHNlIGZ1biBzIC0+IEludDY0LnRvX25hdGl2ZWludCAoYml0czY0IHMpXG5cbmVuZFxuXG4oKiBUaGlzIGlzIHRoZSBzdGF0ZSB5b3UgZ2V0IHdpdGggW2luaXQgMjcxODI4MThdIGFuZCB0aGVuIGFwcGx5aW5nXG4gICB0aGUgXCJsYW5kIDB4M0ZGRkZGRkZcIiBmaWx0ZXIgdG8gdGhlbS4gIFNlZSAjNTU3NSwgIzU3OTMsICM1OTc3LiAqKVxubGV0IGRlZmF1bHQgPSB7XG4gIFN0YXRlLnN0ID0gW3xcbiAgICAgIDB4M2FlMjUyMmI7IDB4MWQ4ZDQ2MzQ7IDB4MTViNGZhZDA7IDB4MThiMTRhY2U7IDB4MTJmOGEzYzQ7IDB4M2IwODZjNDc7XG4gICAgICAweDE2ZDQ2N2Q2OyAweDEwMWQ5MWM3OyAweDMyMWRmMTc3OyAweDAxNzZjMTkzOyAweDFmZjcyYmYxOyAweDFlODg5MTA5O1xuICAgICAgMHgwYjQ2NGIxODsgMHgyYjg2Yjk3YzsgMHgwODkxZGE0ODsgMHgwMzEzNzQ2MzsgMHgwODVhYzVhMTsgMHgxNWQ2MWYyZjtcbiAgICAgIDB4M2JjZWQzNTk7IDB4MjljMWMxMzI7IDB4M2E4Njc2NmU7IDB4MzY2ZDhjODY7IDB4MWY1YjYyMjI7IDB4M2NlMWI1OWY7XG4gICAgICAweDJlYmY3OGUxOyAweDI3Y2QxYjg2OyAweDI1OGYzZGMzOyAweDM4OWE4MTk0OyAweDAyZTRjNDRjOyAweDE4YzQzZjdkO1xuICAgICAgMHgwZjZlNTM0ZjsgMHgxZTdkZjM1OTsgMHgwNTVkMGI3ZTsgMHgxMGU4NGU3ZTsgMHgxMjYxOThlNDsgMHgwZTc3MjJjYjtcbiAgICAgIDB4MWNiZWRlMjg7IDB4MzM5MWI5NjQ7IDB4M2Q0MGU5MmE7IDB4MGM1OTkzM2Q7IDB4MGI4Y2QwYjc7IDB4MjRlZmZmMWM7XG4gICAgICAweDI4MDNmZGFhOyAweDA4ZWJjNzJlOyAweDBmNTIyZTMyOyAweDA1Mzk4ZWRjOyAweDIxNDRhMDRjOyAweDBhZWYzY2JkO1xuICAgICAgMHgwMWFkNDcxOTsgMHgzNWI5M2NkNjsgMHgyYTU1OWQ0ZjsgMHgxZTZmZDc2ODsgMHgyNmUyN2YzNjsgMHgxODZmMThjMztcbiAgICAgIDB4MmZiZjk2N2E7XG4gICAgfF07XG4gIFN0YXRlLmlkeCA9IDA7XG59XG5cbmxldCBiaXRzICgpID0gU3RhdGUuYml0cyBkZWZhdWx0XG5sZXQgaW50IGJvdW5kID0gU3RhdGUuaW50IGRlZmF1bHQgYm91bmRcbmxldCBmdWxsX2ludCBib3VuZCA9IFN0YXRlLmZ1bGxfaW50IGRlZmF1bHQgYm91bmRcbmxldCBpbnQzMiBib3VuZCA9IFN0YXRlLmludDMyIGRlZmF1bHQgYm91bmRcbmxldCBuYXRpdmVpbnQgYm91bmQgPSBTdGF0ZS5uYXRpdmVpbnQgZGVmYXVsdCBib3VuZFxubGV0IGludDY0IGJvdW5kID0gU3RhdGUuaW50NjQgZGVmYXVsdCBib3VuZFxubGV0IGZsb2F0IHNjYWxlID0gU3RhdGUuZmxvYXQgZGVmYXVsdCBzY2FsZVxubGV0IGJvb2wgKCkgPSBTdGF0ZS5ib29sIGRlZmF1bHRcbmxldCBiaXRzMzIgKCkgPSBTdGF0ZS5iaXRzMzIgZGVmYXVsdFxubGV0IGJpdHM2NCAoKSA9IFN0YXRlLmJpdHM2NCBkZWZhdWx0XG5sZXQgbmF0aXZlYml0cyAoKSA9IFN0YXRlLm5hdGl2ZWJpdHMgZGVmYXVsdFxuXG5sZXQgZnVsbF9pbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBzZWVkXG5sZXQgaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IGRlZmF1bHQgW3wgc2VlZCB8XVxubGV0IHNlbGZfaW5pdCAoKSA9IGZ1bGxfaW5pdCAocmFuZG9tX3NlZWQoKSlcblxuKCogTWFuaXB1bGF0aW5nIHRoZSBjdXJyZW50IHN0YXRlLiAqKVxuXG5sZXQgZ2V0X3N0YXRlICgpID0gU3RhdGUuY29weSBkZWZhdWx0XG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gZGVmYXVsdCBzXG5cbigqKioqKioqKioqKioqKioqKioqKlxuXG4oKiBUZXN0IGZ1bmN0aW9ucy4gIE5vdCBpbmNsdWRlZCBpbiB0aGUgbGlicmFyeS5cbiAgIFRoZSBbY2hpc3F1YXJlXSBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIHdpdGggbiA+IDEwci5cbiAgIEl0IHJldHVybnMgYSB0cmlwbGUgKGxvdywgYWN0dWFsLCBoaWdoKS5cbiAgIElmIGxvdyA8PSBhY3R1YWwgPD0gaGlnaCwgdGhlIFtnXSBmdW5jdGlvbiBwYXNzZWQgdGhlIHRlc3QsXG4gICBvdGhlcndpc2UgaXQgZmFpbGVkLlxuXG4gIFNvbWUgcmVzdWx0czpcblxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCA1MDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMDAgMTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAyOTk3OTI2NDM7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMTQxNDIxMzY7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZiAxMDI0OyBjaGlzcXVhcmUgZGlmZiAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmIDEwMDsgY2hpc3F1YXJlIGRpZmYgMTAwMDAwIDEwMFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmMiAxMDI0OyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuaW5pdCAxNDE0MjEzNjsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG5pbml0IDI5OTc5MjY0MzsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG4tIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDkzNi43NTQ0NDY3OTY2MzI0NjUsIDk5Ny41LCAxMDYzLjI0NTU1MzIwMzM2NzU0KVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODkuNzQwMDAwMDAwMDA1MjM4NywgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg0ODU4LjU3ODY0Mzc2MjY5LCA1MDQ1LjUsIDUxNDEuNDIxMzU2MjM3MzEpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPVxuKDkzNi43NTQ0NDY3OTY2MzI0NjUsIDk0NC44MDU5OTk5OTk5ODIzMDUsIDEwNjMuMjQ1NTUzMjAzMzY3NTQpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTAxOS4xOTc0NDAwMDAwMDM1NSwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA1OS4zMTc3NjAwMDAwMDUzNiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTAzOS45ODQ2Mzk5OTk5OTUxMiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA1NC4zODIwNzk5OTk5OTU3NywgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA5MC4wOTYwMDAwMDAwMDUsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA3Ni43ODcyMDAwMDAwMDYxMiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4NS4xNzYwMDAwMDAwMDY3NTIxLCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODUuMjE2MDAwMDAwMDAwMzQ5MiwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDgwLjYyMjAwMDAwMDAwMzAyNjgsIDEyMC4pXG5cbiopXG5cbigqIFJldHVybiB0aGUgc3VtIG9mIHRoZSBzcXVhcmVzIG9mIHZbaTAsaTFbICopXG5sZXQgcmVjIHN1bXNxIHYgaTAgaTEgPVxuICBpZiBpMCA+PSBpMSB0aGVuIDAuMFxuICBlbHNlIGlmIGkxID0gaTAgKyAxIHRoZW4gU3RkbGliLmZsb2F0IHYuKGkwKSAqLiBTdGRsaWIuZmxvYXQgdi4oaTApXG4gIGVsc2Ugc3Vtc3EgdiBpMCAoKGkwK2kxKS8yKSArLiBzdW1zcSB2ICgoaTAraTEpLzIpIGkxXG5cblxubGV0IGNoaXNxdWFyZSBnIG4gciA9XG4gIGlmIG4gPD0gMTAgKiByIHRoZW4gaW52YWxpZF9hcmcgXCJjaGlzcXVhcmVcIjtcbiAgbGV0IGYgPSBBcnJheS5tYWtlIHIgMCBpblxuICBmb3IgaSA9IDEgdG8gbiBkb1xuICAgIGxldCB0ID0gZyByIGluXG4gICAgZi4odCkgPC0gZi4odCkgKyAxXG4gIGRvbmU7XG4gIGxldCB0ID0gc3Vtc3EgZiAwIHJcbiAgYW5kIHIgPSBTdGRsaWIuZmxvYXQgclxuICBhbmQgbiA9IFN0ZGxpYi5mbG9hdCBuIGluXG4gIGxldCBzciA9IDIuMCAqLiBzcXJ0IHIgaW5cbiAgKHIgLS4gc3IsICAgKHIgKi4gdCAvLiBuKSAtLiBuLCAgIHIgKy4gc3IpXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBsaW5lYXIgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb20gbnVtYmVycy5cbiopXG5sZXQgc3QgPSByZWYgMFxubGV0IGluaXRfZGlmZiByID0gc3QgOj0gaW50IHJcbmxldCBkaWZmIHIgPVxuICBsZXQgeDEgPSAhc3RcbiAgYW5kIHgyID0gaW50IHJcbiAgaW5cbiAgc3QgOj0geDI7XG4gIGlmIHgxID49IHgyIHRoZW5cbiAgICB4MSAtIHgyXG4gIGVsc2VcbiAgICByICsgeDEgLSB4MlxuXG5cbmxldCBzdDEgPSByZWYgMFxuYW5kIHN0MiA9IHJlZiAwXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBxdWFkcmF0aWMgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb21cbiAgIG51bWJlcnMuXG4qKVxubGV0IGluaXRfZGlmZjIgciA9IHN0MSA6PSBpbnQgcjsgc3QyIDo9IGludCByXG5sZXQgZGlmZjIgciA9XG4gIGxldCB4MSA9ICFzdDFcbiAgYW5kIHgyID0gIXN0MlxuICBhbmQgeDMgPSBpbnQgclxuICBpblxuICBzdDEgOj0geDI7XG4gIHN0MiA6PSB4MztcbiAgKHgzIC0geDIgLSB4MiArIHgxICsgMipyKSBtb2QgclxuXG5cbioqKioqKioqKioqKioqKioqKioqKVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9ncmVhdGVydGhhbiIsImNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIiwiY2FtbF9pbnQ2NF9vZl9pbnQzMiIsImNhbWxfaW50NjRfb3IiLCJjYW1sX2ludDY0X3NoaWZ0X2xlZnQiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmUiLCJjYW1sX2ludDY0X3N1YiIsImNhbWxfaW50NjRfdG9faW50MzIiLCJjYW1sX2xlc3NlcXVhbCIsImNhbWxfbW9kIiwiY2FtbF9zdHJpbmdfZ2V0IiwiY2FtbF9zeXNfcmFuZG9tX3NlZWQiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsIlN0ZGxpYl9JbnQzMiIsIlN0ZGxpYl9JbnQ2NCIsIlN0ZGxpYl9JbnQiLCJTdGRsaWJfRGlnZXN0IiwiU3RkbGliX0FycmF5IiwiU3RkbGliX05hdGl2ZWludCIsImNzdF94IiwiY3N0X1JhbmRvbV9pbnQiLCJjc3RfUmFuZG9tX2Z1bGxfaW50IiwiY3N0X1JhbmRvbV9pbnQzMiIsImNzdF9SYW5kb21faW50NjQiLCJuZXdfc3RhdGUiLCJwYXJhbSIsImFzc2lnbiIsInN0MSIsInN0MiIsImZ1bGxfaW5pdCIsInMiLCJzZWVkIiwibCIsImkiLCJhY2N1IiwiaiIsImsiLCJ4IiwiZCIsIm1ha2UiLCJyZXN1bHQiLCJtYWtlX3NlbGZfaW5pdCIsImNvcHkiLCJiaXRzIiwiY3VydmFsIiwibmV3dmFsIiwibmV3dmFsMzAiLCJpbnRhdXgiLCJuIiwiciIsInYiLCJpbnQiLCJib3VuZCIsImZ1bGxfaW50IiwiYjEiLCJiMiIsIm1heF9pbnRfMzIiLCJicG9zIiwibWF4X2ludCIsImIzIiwiaW50MzIiLCJpbnQ2NCIsIm5hdGl2ZWludCIsImZsb2F0IiwicjEiLCJyMiIsImJvb2wiLCJiaXRzMzIiLCJiaXRzNjQiLCJuYXRpdmViaXRzIiwiZGVmYXVsdCQiLCJzY2FsZSIsImluaXQiLCJzZWxmX2luaXQiLCJnZXRfc3RhdGUiLCJzZXRfc3RhdGUiLCJTdGRsaWJfUmFuZG9tIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLFlBQUFDLFVBQUFDLE9DaUM0Qiw0Q0FBZSxDQUFXO0FBQUEsWUFBQUMsT0FBQUMsS0FBQUM7QUFBQUEsSUFFbEQ7QUFBQSxJQUErQjtBQUFBO0FBQUEsR0FDYjtBQUFBLFlBQUFDLFVBQUFDLEdBQUFDO0FBQUFBO0FBQUFBLEtBQUFBLFNBU2xCO0FBQUEsS0FBQUMsSUFDQTtBQUFBLEtBQUFDLE1BQ0E7QUFBQTtBQUFBLEtBQ0U7QUFBQSxhQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFBQyxPQUVmO0FBQUEsU0FDa0I7QUFBQSxTQUFZO0FBQUE7QUFBQSxTQUFBRCxJQUFBO0FBQUE7QUFBQTtBQUFBLE9BQUFFLElBQzVCO0FBQUEsT0FBQUMsSUFDQTtBQUFBLE9BQUFDLElBQ3NCO0FBQUEsT0FBQUgsU0FBUTtBQUFBLFdBZFc7QUFBQSxXQUFSO0FBQUEsTUFBd0I7QUFBQTtBQUFBLE9BQUFJLElBZXpEO0FBQUEsV0FaYTtBQUFBLFdBRDBDO0FBQUEsV0FBMUI7QUFBQSxXQUFuQjtBQUFBLFdBYUc7QUFBQSxNQUFiO0FBQUEsY0FBeUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRTNEO0FBQUE7QUFBQSxHQUFVO0FBQUEsWUFBQUMsS0FBQVI7QUFBQUEsUUFBQVMsU0FJRztBQUFBLElBQ2I7QUFBQSxJQUFxQjtBQUFBLEdBQ2Y7QUFBQSxZQUFBQyxlQUFBaEIsT0FHcUIsT0FBZ0IsS0FBaEIsd0JBQWdCO0FBQUEsWUFBQWlCLEtBQUFaO0FBQUFBLFFBQUFVLFNBRzlCO0FBQUEsSUFDYjtBQUFBLElBQWU7QUFBQSxHQUNUO0FBQUEsWUFBQUcsS0FBQWI7QUFBQUEsSUFLTjtBQUFBO0FBQUEsU0FDQTtBQUFBLEtBQUFjLFNBQWE7QUFBQSxTQUNiO0FBQUEsS0FBQUM7QUFBQUEsT0FBYTtBQUFBO0FBQUEsS0FBQUMsV0FFYjtBQUFBLFNBQ0E7QUFBQTtBQUFBLElBQXdCO0FBQUEsR0FDaEI7QUFBQSxZQUFBQyxPQUFBakIsR0FBQWtCO0FBQUFBLElBSUE7QUFBQSxTQUFBQyxJQUFBLFNBQUFDLElBQ1I7QUFBQSxLQUNBLGtEQUFtRDtBQUFBO0FBQUEsR0FBQztBQUFBLFlBQUFDLElBQUFyQixHQUFBc0I7QUFBQUEsSUFHcEQscUNBRUssdUJBQWM7QUFBQSxJQURkLDJDQUNjO0FBQUE7QUFBQSxZQUFBQyxTQUFBdkIsR0FBQXNCO0FBQUFBLElBNEJuQixlQUNFLGdEQUljO0FBQUEsSUFIWCx3QkFHSCx1QkFBYztBQUFBLElBSFg7QUFBQSxTQUFBRSxLQTFCSSxTQUFBQyxLQUNBLFNBQUFDLGFBQ1Q7QUFBQTtBQUFBO0FBQUEsT0FBQUMsT0FJSTtBQUFBLE9BQUFDLFVBR0U7QUFBQSxPQUFBVCxJQUFBO0FBQUE7QUFBQTtBQUFBLE9BQUFVLEtBRU87QUFBQSxPQUFBVixNQUdUO0FBQUEsT0FBQVMsWUFBQTtBQUFBLE9BQUFBLFVBTUo7QUFBQSxPQUFBVCxJQUFBO0FBQUEsU0FBQUMsSUFBQTtBQUFBLEtBQ0EsbURBQWtEO0FBQUE7QUFBQSxHQVFsQztBQUFBLFlBQUFVLE1BQUE5QixHQUFBc0I7QUFBQUEsSUFhYjtBQUFBLEtBQ0UsNkNBQ2dCO0FBQUEsSUFGUDtBQUFBO0FBQUEsTUFBQUUsS0FUUTtBQUFBLE1BQUFDLEtBQ21CO0FBQUEsTUFBQU4sSUFDakM7QUFBQSxNQUFBQyxJQUNBO0FBQUEsS0FDTDtBQUFBLE1BRUU7QUFBQTtBQUFBLEdBS2dCO0FBQUEsWUFBQVcsTUFBQS9CLEdBQUFzQjtBQUFBQSxJQWNsQjtBQUFBLEtBQ0UsNkNBQ2dCO0FBQUEsSUFGUDtBQUFBO0FBQUEsTUFBQUUsS0FWTCxvQkFBYTtBQUFBLE1BQUFDLEtBQ2Isc0JBQWlCLG9CQUFjO0FBQUEsTUFBQUksS0FDL0Isc0JBQWlCLG9CQUFlO0FBQUEsTUFBQVYsSUFDakMsa0JBQWU7QUFBQSxNQUFBQyxJQUNmO0FBQUEsS0FDTDtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBQWdCLHVCQUFVO0FBQUEsTUFFeEI7QUFBQTtBQUFBLEdBS2dCO0FBQUE7QUFBQTtBQUFBLE1EN0p6QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQVk7QUFBQUEsTUFBQTtBQUFBLGtCQUFBaEMsR0FBQXNCLE9Da0syQyxzQkFBb0M7QUFBQTtBQUFBLFNBQUF0QixHQUFBc0I7QUFBQUEsU0FDM0IsT0FBNUIsb0JBQW1CLFNBQVMsNEJBQTJCO0FBQUE7QUFBQSxZQUFBVyxNQUFBakMsR0FBQXNCO0FBQUFBLFFBQUFZLEtBTXJELFNBQUFDLEtBQ0E7QUFBQSxJQUllO0FBQUE7QUFBQSxZQUFBQyxLQUFBcEMsR0FFekIsa0NBQU0sQ0FBWTtBQUFBLFlBQUFxQyxPQUFBckM7QUFBQUEsUUFBQXdCLEtBR2Msb0JBQUFDLEtBQ0E7QUFBQSxJQUNWO0FBQUEsR0FBQztBQUFBLFlBQUFhLE9BQUF0QztBQUFBQTtBQUFBQSxLQUFBd0IsS0FHbkIsK0JBQW9CLG9CQUFRO0FBQUEsS0FBQUMsS0FDNUIsK0JBQW9CLG9CQUFRO0FBQUEsS0FBQUksS0FDNUIsK0JBQW9CLG9CQUFRO0FBQUEsSUFDckIsT0FBaEI7QUFBQTtBQUFBLGFBQVM7QUFBQSxlQUFPLCtCQUFtQiwrQkFBb0I7QUFBQTtBQUFBO0FBQUEsSUFBQVU7QUFBQUEsTUQzTGxFO0FBQUEsa0JBQUF2QyxHQytMcUMsZ0JBQVU7QUFBQSxrQkFBQUEsR0FDVixPQUFuQixvQkFBbUIsVUFBVTtBQUFBLElBQUF3QyxXRGhNL0M7QUFBQSxZQUFBM0IsT0FBQWxCLE9Dc05jLHFCQUFrQjtBQUFBLFlBQUEwQixNQUFBQyxPQUNoQiwyQkFBdUI7QUFBQSxZQUFBQyxXQUFBRCxPQUNsQixnQ0FBNEI7QUFBQSxZQUFBUSxRQUFBUixPQUMvQiw2QkFBeUI7QUFBQSxZQUFBVSxZQUFBVixPQUNyQixpQ0FBNkI7QUFBQSxZQUFBUyxRQUFBVCxPQUNqQyw2QkFBeUI7QUFBQSxZQUFBVyxRQUFBUSxPQUN6Qiw2QkFBeUI7QUFBQSxZQUFBTCxPQUFBekMsT0FDN0IscUJBQWtCO0FBQUEsWUFBQTBDLFNBQUExQyxPQUNoQix1QkFBb0I7QUFBQSxZQUFBMkMsU0FBQTNDLE9BQ3BCLHVCQUFvQjtBQUFBLFlBQUE0QyxhQUFBNUMsT0FDaEIsMkJBQXdCO0FBQUEsWUFBQUksWUFBQUUsTUFFdkIsZ0NBQTRCO0FBQUEsWUFBQXlDLEtBQUF6QyxNQUNqQyxxQ0FBa0M7QUFBQSxZQUFBMEMsVUFBQWhEO0FBQUFBLFFBQUFNLE9BQ3JCO0FBQUEsSUFGUixnQ0FFdUI7QUFBQTtBQUFBLFlBQUEyQyxVQUFBakQsT0FJekIscUJBQWtCO0FBQUEsWUFBQWtELFVBQUE3QyxHQUNuQiwwQkFBc0I7QUFBQTtBQUFBLElBQUE4QztBQUFBQSxNRHpPeEMiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNzIwNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL2hhc2h0YmwubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEhhc2ggdGFibGVzICopXG5cbigqIFdlIGRvIGR5bmFtaWMgaGFzaGluZywgYW5kIHJlc2l6ZSB0aGUgdGFibGUgYW5kIHJlaGFzaCB0aGUgZWxlbWVudHNcbiAgIHdoZW4gYnVja2V0cyBiZWNvbWUgdG9vIGxvbmcuICopXG5cbnR5cGUgKCdhLCAnYikgdCA9XG4gIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICBtdXRhYmxlIGRhdGE6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgIHNlZWQ6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAoKiBmb3IgcmFuZG9taXphdGlvbiAqKVxuICAgIG11dGFibGUgaW5pdGlhbF9zaXplOiBpbnQ7ICAgICAgICAgICAgICAgICgqIGluaXRpYWwgYXJyYXkgc2l6ZSAqKVxuICB9XG5cbmFuZCAoJ2EsICdiKSBidWNrZXRsaXN0ID1cbiAgICBFbXB0eVxuICB8IENvbnMgb2YgeyBtdXRhYmxlIGtleTogJ2E7XG4gICAgICAgICAgICAgIG11dGFibGUgZGF0YTogJ2I7XG4gICAgICAgICAgICAgIG11dGFibGUgbmV4dDogKCdhLCAnYikgYnVja2V0bGlzdCB9XG5cbigqIFRoZSBzaWduIG9mIGluaXRpYWxfc2l6ZSBlbmNvZGVzIHRoZSBmYWN0IHRoYXQgYSB0cmF2ZXJzYWwgaXNcbiAgIG9uZ29pbmcgb3Igbm90LlxuXG4gICBUaGlzIGRpc2FibGVzIHRoZSBlZmZpY2llbnQgaW4gcGxhY2UgaW1wbGVtZW50YXRpb24gb2YgcmVzaXppbmcuXG4qKVxuXG5sZXQgb25nb2luZ190cmF2ZXJzYWwgaCA9XG4gIE9iai5zaXplIChPYmoucmVwciBoKSA8IDQgKCogY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBoYXNoIHRhYmxlcyAqKVxuICB8fCBoLmluaXRpYWxfc2l6ZSA8IDBcblxubGV0IGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaCA9XG4gIGguaW5pdGlhbF9zaXplIDwtIC0gaC5pbml0aWFsX3NpemVcblxuKCogVG8gcGljayByYW5kb20gc2VlZHMgaWYgcmVxdWVzdGVkICopXG5cbmxldCByYW5kb21pemVkX2RlZmF1bHQgPVxuICBsZXQgcGFyYW1zID1cbiAgICB0cnkgU3lzLmdldGVudiBcIk9DQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiQ0FNTFJVTlBBUkFNXCIgd2l0aCBOb3RfZm91bmQgLT4gXCJcIiBpblxuICBTdHJpbmcuY29udGFpbnMgcGFyYW1zICdSJ1xuXG5sZXQgcmFuZG9taXplZCA9IHJlZiByYW5kb21pemVkX2RlZmF1bHRcblxubGV0IHJhbmRvbWl6ZSAoKSA9IHJhbmRvbWl6ZWQgOj0gdHJ1ZVxubGV0IGlzX3JhbmRvbWl6ZWQgKCkgPSAhcmFuZG9taXplZFxuXG5sZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCgpKVxuXG4oKiBGdW5jdGlvbnMgd2hpY2ggYXBwZWFyIGJlZm9yZSB0aGUgZnVuY3RvcmlhbCBpbnRlcmZhY2UgbXVzdCBlaXRoZXIgYmVcbiAgIGluZGVwZW5kZW50IG9mIHRoZSBoYXNoIGZ1bmN0aW9uIG9yIHRha2UgaXQgYXMgYSBwYXJhbWV0ZXIgKHNlZSAjMjIwMiBhbmRcbiAgIGNvZGUgYmVsb3cgdGhlIGZ1bmN0b3IgZGVmaW5pdGlvbnMuICopXG5cbigqIENyZWF0aW5nIGEgZnJlc2gsIGVtcHR5IHRhYmxlICopXG5cbmxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICBpZiB4ID49IG4gdGhlbiB4XG4gIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG5sZXQgY3JlYXRlID8ocmFuZG9tID0gIXJhbmRvbWl6ZWQpIGluaXRpYWxfc2l6ZSA9XG4gIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgeyBpbml0aWFsX3NpemUgPSBzOyBzaXplID0gMDsgc2VlZCA9IHNlZWQ7IGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHkgfVxuXG5sZXQgY2xlYXIgaCA9XG4gIGlmIGguc2l6ZSA+IDAgdGhlbiBiZWdpblxuICAgIGguc2l6ZSA8LSAwO1xuICAgIEFycmF5LmZpbGwgaC5kYXRhIDAgKEFycmF5Lmxlbmd0aCBoLmRhdGEpIEVtcHR5XG4gIGVuZFxuXG5sZXQgcmVzZXQgaCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA8IDQgKCogY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBoYXNoIHRhYmxlcyAqKVxuICAgIHx8IGxlbiA9IGFicyBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgY2xlYXIgaFxuICBlbHNlIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgaC5kYXRhIDwtIEFycmF5Lm1ha2UgKGFicyBoLmluaXRpYWxfc2l6ZSkgRW1wdHlcbiAgZW5kXG5cbmxldCBjb3B5X2J1Y2tldGxpc3QgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IEVtcHR5XG4gIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgbGV0IHJlYyBsb29wIHByZWMgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICB8IENvbnMgcHJlYyAtPiAgcHJlYy5uZXh0IDwtIHJcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGxvb3AgciBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICBsb29wIHIgbmV4dDtcbiAgICAgIHJcblxubGV0IGNvcHkgaCA9IHsgaCB3aXRoIGRhdGEgPSBBcnJheS5tYXAgY29weV9idWNrZXRsaXN0IGguZGF0YSB9XG5cbmxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG5sZXQgaW5zZXJ0X2FsbF9idWNrZXRzIGluZGV4ZnVuIGlucGxhY2Ugb2RhdGEgbmRhdGEgPVxuICBsZXQgbnNpemUgPSBBcnJheS5sZW5ndGggbmRhdGEgaW5cbiAgbGV0IG5kYXRhX3RhaWwgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gIGxldCByZWMgaW5zZXJ0X2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBhcyBjZWxsIC0+XG4gICAgICAgIGxldCBjZWxsID1cbiAgICAgICAgICBpZiBpbnBsYWNlIHRoZW4gY2VsbFxuICAgICAgICAgIGVsc2UgQ29ucyB7a2V5OyBkYXRhOyBuZXh0ID0gRW1wdHl9XG4gICAgICAgIGluXG4gICAgICAgIGxldCBuaWR4ID0gaW5kZXhmdW4ga2V5IGluXG4gICAgICAgIGJlZ2luIG1hdGNoIG5kYXRhX3RhaWwuKG5pZHgpIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBuZGF0YS4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgfCBDb25zIHRhaWwgLT4gdGFpbC5uZXh0IDwtIGNlbGw7XG4gICAgICAgIGVuZDtcbiAgICAgICAgbmRhdGFfdGFpbC4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgaW5zZXJ0X2J1Y2tldCBuZXh0XG4gIGluXG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggb2RhdGEgLSAxIGRvXG4gICAgaW5zZXJ0X2J1Y2tldCBvZGF0YS4oaSlcbiAgZG9uZTtcbiAgaWYgaW5wbGFjZSB0aGVuXG4gICAgZm9yIGkgPSAwIHRvIG5zaXplIC0gMSBkb1xuICAgICAgbWF0Y2ggbmRhdGFfdGFpbC4oaSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgfCBDb25zIHRhaWwgLT4gdGFpbC5uZXh0IDwtIEVtcHR5XG4gICAgZG9uZVxuXG5sZXQgcmVzaXplIGluZGV4ZnVuIGggPVxuICBsZXQgb2RhdGEgPSBoLmRhdGEgaW5cbiAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBsZXQgbmRhdGEgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgbGV0IGlucGxhY2UgPSBub3QgKG9uZ29pbmdfdHJhdmVyc2FsIGgpIGluXG4gICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAgICAoKiBzbyB0aGF0IGluZGV4ZnVuIHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICBpbnNlcnRfYWxsX2J1Y2tldHMgKGluZGV4ZnVuIGgpIGlucGxhY2Ugb2RhdGEgbmRhdGFcbiAgZW5kXG5cbmxldCBpdGVyIGYgaCA9XG4gIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+XG4gICAgICAgICgpXG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZiBrZXkgZGF0YTsgZG9fYnVja2V0IG5leHQgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZG9fYnVja2V0IGQuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gRW1wdHlcbiAgICAgIGVuZFxuICB8IChDb25zICh7a2V5OyBkYXRhOyBuZXh0fSBhcyBjKSkgYXMgc2xvdCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggZiBrZXkgZGF0YSB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHByZWMgbmV4dFxuICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gc2xvdFxuICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBzbG90XG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIGMuZGF0YSA8LSBkYXRhO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgc2xvdCBuZXh0XG4gICAgICBlbmRcblxubGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICBsZXQgZCA9IGguZGF0YSBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBFbXB0eSBoLmRhdGEuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGhcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbmxldCBmb2xkIGYgaCBpbml0ID1cbiAgbGV0IHJlYyBkb19idWNrZXQgYiBhY2N1ID1cbiAgICBtYXRjaCBiIHdpdGhcbiAgICAgIEVtcHR5IC0+XG4gICAgICAgIGFjY3VcbiAgICB8IENvbnN7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBkb19idWNrZXQgbmV4dCAoZiBrZXkgZGF0YSBhY2N1KSBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICBsZXQgYWNjdSA9IHJlZiBpbml0IGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgYWNjdSA6PSBkb19idWNrZXQgZC4oaSkgIWFjY3VcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICAhYWNjdVxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxudHlwZSBzdGF0aXN0aWNzID0ge1xuICBudW1fYmluZGluZ3M6IGludDtcbiAgbnVtX2J1Y2tldHM6IGludDtcbiAgbWF4X2J1Y2tldF9sZW5ndGg6IGludDtcbiAgYnVja2V0X2hpc3RvZ3JhbTogaW50IGFycmF5XG59XG5cbmxldCByZWMgYnVja2V0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhY2N1XG4gIHwgQ29uc3tuZXh0fSAtPiBidWNrZXRfbGVuZ3RoIChhY2N1ICsgMSkgbmV4dFxuXG5sZXQgc3RhdHMgaCA9XG4gIGxldCBtYmwgPVxuICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBJbnQubWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICBBcnJheS5pdGVyXG4gICAgKGZ1biBiIC0+XG4gICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGggMCBiIGluXG4gICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICBoLmRhdGE7XG4gIHsgbnVtX2JpbmRpbmdzID0gaC5zaXplO1xuICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHRibCA9XG4gICgqIGNhcHR1cmUgY3VycmVudCBhcnJheSwgc28gdGhhdCBldmVuIGlmIHRoZSB0YWJsZSBpcyByZXNpemVkIHdlXG4gICAgIGtlZXAgaXRlcmF0aW5nIG9uIHRoZSBzYW1lIGFycmF5ICopXG4gIGxldCB0YmxfZGF0YSA9IHRibC5kYXRhIGluXG4gICgqIHN0YXRlOiBpbmRleCAqIG5leHQgYnVja2V0IHRvIHRyYXZlcnNlICopXG4gIGxldCByZWMgYXV4IGkgYnVjayAoKSA9IG1hdGNoIGJ1Y2sgd2l0aFxuICAgIHwgRW1wdHkgLT5cbiAgICAgICAgaWYgaSA9IEFycmF5Lmxlbmd0aCB0YmxfZGF0YVxuICAgICAgICB0aGVuIFNlcS5OaWxcbiAgICAgICAgZWxzZSBhdXgoaSsxKSB0YmxfZGF0YS4oaSkgKClcbiAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgU2VxLkNvbnMgKChrZXksIGRhdGEpLCBhdXggaSBuZXh0KVxuICBpblxuICBhdXggMCBFbXB0eVxuXG5sZXQgdG9fc2VxX2tleXMgbSA9IFNlcS5tYXAgZnN0ICh0b19zZXEgbSlcblxubGV0IHRvX3NlcV92YWx1ZXMgbSA9IFNlcS5tYXAgc25kICh0b19zZXEgbSlcblxuKCogRnVuY3RvcmlhbCBpbnRlcmZhY2UgKilcblxubW9kdWxlIHR5cGUgSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFNlZWRlZEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IGludCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAhJ2EgdFxuICAgIHZhbCBjcmVhdGU6IGludCAtPiAnYSB0XG4gICAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIGNvcHk6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQ6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgcmVtb3ZlOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gICAgdmFsIGZpbmQ6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGw6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2U6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGg6ICdhIHQgLT4gaW50XG4gICAgdmFsIHN0YXRzOiAnYSB0IC0+IHN0YXRpc3RpY3NcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9rZXlzIDogXyB0IC0+IGtleSBTZXEudFxuICAgIHZhbCB0b19zZXFfdmFsdWVzIDogJ2EgdCAtPiAnYSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFNlZWRlZFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgISdhIHRcbiAgICB2YWwgY3JlYXRlIDogP3JhbmRvbTpib29sIC0+IGludCAtPiAnYSB0XG4gICAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgYWRkIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmUgOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gICAgdmFsIGZpbmQgOiAnYSB0IC0+IGtleSAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfYWxsIDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXIgOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2U6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZCA6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIE1ha2VTZWVkZWQoSDogU2VlZGVkSGFzaGVkVHlwZSk6IChTZWVkZWRTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgdHlwZSBrZXkgPSBILnRcbiAgICB0eXBlICdhIGhhc2h0YmwgPSAoa2V5LCAnYSkgdFxuICAgIHR5cGUgJ2EgdCA9ICdhIGhhc2h0YmxcbiAgICBsZXQgY3JlYXRlID0gY3JlYXRlXG4gICAgbGV0IGNsZWFyID0gY2xlYXJcbiAgICBsZXQgcmVzZXQgPSByZXNldFxuICAgIGxldCBjb3B5ID0gY29weVxuXG4gICAgbGV0IGtleV9pbmRleCBoIGtleSA9XG4gICAgICAoSC5oYXNoIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuXG4gICAgbGV0IGFkZCBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgaCBpIGtleSBwcmVjID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAoKVxuICAgICAgfCAoQ29ucyB7a2V5PWs7IG5leHR9KSBhcyBjIC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxuICAgIGxldCByZW1vdmUgaCBrZXkgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIGQzIGVsc2UgZmluZF9yZWMga2V5IG5leHQzXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbiAgICBsZXQgZmluZF9vcHQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIFtdXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE9ZDsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiBkIDo6IGZpbmRfaW5fYnVja2V0IG5leHRcbiAgICAgICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgICAgIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IHJlYyByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBDb25zICh7a2V5PWs7IG5leHR9IGFzIHNsb3QpIC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgICAgIGVsc2UgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbmV4dFxuXG4gICAgbGV0IHJlcGxhY2UgaCBrZXkgZGF0YSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gICAgICBpZiByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBsIHRoZW4gYmVnaW5cbiAgICAgICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcbiAgICAgIGVuZFxuXG4gICAgbGV0IG1lbSBoIGtleSA9XG4gICAgICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICAgICAgSC5lcXVhbCBrIGtleSB8fCBtZW1faW5fYnVja2V0IG5leHQgaW5cbiAgICAgIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbiAgICBsZXQgYWRkX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbiAgICBsZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiByZXBsYWNlIHRibCBrIHYpIGlcblxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuXG4gICAgbGV0IGl0ZXIgPSBpdGVyXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSA9IGZpbHRlcl9tYXBfaW5wbGFjZVxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgc3RhdHMgPSBzdGF0c1xuICAgIGxldCB0b19zZXEgPSB0b19zZXFcbiAgICBsZXQgdG9fc2VxX2tleXMgPSB0b19zZXFfa2V5c1xuICAgIGxldCB0b19zZXFfdmFsdWVzID0gdG9fc2VxX3ZhbHVlc1xuICBlbmRcblxubW9kdWxlIE1ha2UoSDogSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG4oKiBQb2x5bW9ycGhpYyBoYXNoIGZ1bmN0aW9uLWJhc2VkIHRhYmxlcyAqKVxuKCogQ29kZSBpbmNsdWRlZCBiZWxvdyB0aGUgZnVuY3RvcmlhbCBpbnRlcmZhY2UgdG8gZ3VhcmQgYWdhaW5zdCBhY2NpZGVudGFsXG4gICB1c2UgLSBzZWUgIzIyMDIgKilcblxuZXh0ZXJuYWwgc2VlZGVkX2hhc2hfcGFyYW0gOlxuICBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiBpbnQgPSBcImNhbWxfaGFzaFwiIFtAQG5vYWxsb2NdXG5cbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG5sZXQgaGFzaF9wYXJhbSBuMSBuMiB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gbjEgbjIgMCB4XG5sZXQgc2VlZGVkX2hhc2ggc2VlZCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIHNlZWQgeFxuXG5sZXQga2V5X2luZGV4IGgga2V5ID1cbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDRcbiAgdGhlbiAoc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuICBlbHNlIGludmFsaWRfYXJnIFwiSGFzaHRibDogdW5zdXBwb3J0ZWQgaGFzaCB0YWJsZSBmb3JtYXRcIlxuXG5sZXQgYWRkIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbmxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICAoKVxuICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgIGVuZFxuICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbmxldCByZW1vdmUgaCBrZXkgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG5sZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG5sZXQgZmluZCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrMSA9IDAgdGhlbiBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMiA9IDAgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgaWYgY29tcGFyZSBrZXkgazMgPSAwIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxubGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgTm9uZVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG5sZXQgZmluZF9vcHQgaCBrZXkgPVxuICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG5sZXQgZmluZF9hbGwgaCBrZXkgPVxuICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgW11cbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gZGF0YSA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbmxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gIGVuZFxuXG5sZXQgbWVtIGgga2V5ID1cbiAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgY29tcGFyZSBrIGtleSA9IDAgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCBhZGRfc2VxIHRibCBpID1cbiAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG5sZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gIHJlcGxhY2Vfc2VxIHRibCBpO1xuICB0YmxcblxubGV0IHJlYnVpbGQgPyhyYW5kb20gPSAhcmFuZG9taXplZCkgaCA9XG4gIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiAoQXJyYXkubGVuZ3RoIGguZGF0YSkgaW5cbiAgbGV0IHNlZWQgPVxuICAgIGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpXG4gICAgZWxzZSBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNCB0aGVuIGguc2VlZFxuICAgIGVsc2UgMCBpblxuICBsZXQgaCcgPSB7XG4gICAgc2l6ZSA9IGguc2l6ZTtcbiAgICBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5O1xuICAgIHNlZWQgPSBzZWVkO1xuICAgIGluaXRpYWxfc2l6ZSA9IGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSA0IHRoZW4gaC5pbml0aWFsX3NpemUgZWxzZSBzXG4gIH0gaW5cbiAgaW5zZXJ0X2FsbF9idWNrZXRzIChrZXlfaW5kZXggaCcpIGZhbHNlIGguZGF0YSBoJy5kYXRhO1xuICBoJ1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9jb21wYXJlIiwiY2FtbF9oYXNoIiwiY2FtbF9tYWtlX3ZlY3QiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX29ial90YWciLCJjYW1sX3N5c19nZXRlbnYiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiY3N0IiwiU3RkbGliX1N5cyIsIlN0ZGxpYiIsIkNhbWxpbnRlcm5hbExhenkiLCJTdGRsaWJfUmFuZG9tIiwiU3RkbGliX1NlcSIsIlN0ZGxpYl9JbnQiLCJTdGRsaWJfQXJyYXkiLCJTdGRsaWJfU3RyaW5nIiwib25nb2luZ190cmF2ZXJzYWwiLCJoIiwiZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCIsImNzdF9IYXNodGJsX3Vuc3VwcG9ydGVkX2hhc2hfdCIsInBhcmFtcyIsImV4biIsInJhbmRvbWl6ZWRfZGVmYXVsdCIsInJhbmRvbWl6ZWQiLCJyYW5kb21pemUiLCJwYXJhbSIsImlzX3JhbmRvbWl6ZWQiLCJwcm5nIiwicG93ZXJfMl9hYm92ZSIsIngiLCJuIiwiY3JlYXRlIiwib3B0IiwiaW5pdGlhbF9zaXplIiwic3RoIiwicmFuZG9tIiwicyIsInNlZWQiLCJjbGVhciIsInJlc2V0IiwibGVuIiwiY29weV9idWNrZXRsaXN0Iiwia2V5IiwiZGF0YSIsIm5leHQiLCJwcmVjIiwiY29weSIsImxlbmd0aCIsImluc2VydF9hbGxfYnVja2V0cyIsImluZGV4ZnVuIiwiaW5wbGFjZSIsIm9kYXRhIiwibmRhdGEiLCJuc2l6ZSIsIm5kYXRhX3RhaWwiLCJpIiwiY2VsbCIsIm5pZHgiLCJtYXRjaCIsInJlc2l6ZSIsIm9zaXplIiwiaXRlciIsIm9sZF90cmF2IiwiZCIsImZpbHRlcl9tYXBfaW5wbGFjZSIsInNsb3QiLCJmb2xkIiwiaW5pdCIsImFjY3UiLCJiIiwiYnVja2V0X2xlbmd0aCIsInN0YXRzIiwibWJsIiwibSIsImhpc3RvIiwibCIsInRvX3NlcSIsInRibCIsInRibF9kYXRhIiwiYXV4IiwiYnVjayIsInRvX3NlcV9rZXlzIiwidG9fc2VxX3ZhbHVlcyIsIk1ha2VTZWVkZWQiLCJIIiwia2V5X2luZGV4IiwiYWRkIiwiYnVja2V0IiwicmVtb3ZlIiwiayIsImZpbmQiLCJrMSIsImQxIiwibmV4dDEiLCJrMiIsImQyIiwibmV4dDIiLCJrMyIsImQzIiwibmV4dDMiLCJmaW5kX29wdCIsImZpbmRfYWxsIiwiZmluZF9pbl9idWNrZXQiLCJyZXBsYWNlIiwibWVtIiwiYWRkX3NlcSIsInYiLCJyZXBsYWNlX3NlcSIsIm9mX3NlcSIsIk1ha2UiLCJlcXVhbCIsImhhc2giLCJpbmNsdWRlIiwic3oiLCJoYXNoX3BhcmFtIiwibjEiLCJuMiIsInNlZWRlZF9oYXNoIiwicmVidWlsZCIsIlN0ZGxpYl9IYXNodGJsIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQTtBQUFBLE9BQUFDLGdCQUFBO0FBQUEsWUFBQUMsa0JBQUFDO0FBQUFBLFFBQUEsSUN3Q0U7QUFBQTtBQUFBLEdBQ3FCO0FBQUEsWUFBQUMsdUJBQUFELEdBR3JCLDRCQUFrQztBQUFBO0FBQUEsSUFBQUUsaUNENUNwQztBQUFBLGVDa0RRLGtDQUFBQyxTQUFBO0FBQUEsU0FBQUM7QUFBQUEsUUFBQUEsTURsRFI7QUFBQTtBQUFBLGdCQ21EUSxpQ0FBQUQsU0FBQTtBQUFBLFVBQUFDO0FBQUFBLFNBQUFBLFFEbkRSO0FBQUE7QUFBQSxTQUFBRCxTQUFBO0FB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UyxVQUFBakIsSUFBQTtBQUFBLGNBQWMscUJBQVk7QUFBQTtBQUFBLGVBQUU7QUFBQTtBQUFBLFlBQUFrQixZQUFBOUIsS0FBQXRCO0FBQUFBLElBR3JDO0FBQUE7QUFBQSxzQkFBQTlCO0FBQUFBLGtCQUFBaUYsSUFBUyxVQUFBakIsSUFBQTtBQUFBLGNBQWMseUJBQWdCO0FBQUE7QUFBQSxlQUFFO0FBQUE7QUFBQSxZQUFBbUIsT0FBQXJEO0FBQUFBLFFBQUFzQixNQUcvQjtBQUFBLElBQ1Y7QUFBQSxJQUFpQjtBQUFBLEdBQ2Q7QUFBQSxZQUFBeUMsUUFBQXRGLEtBQUFmO0FBQUFBLElBR0gsWUFBQWlCLE1BQUEsUUFBQUMsU0FEcUIsY0FBQUEsU0FBQTtBQUFBLFFBQUFDLElBQ2I7QUFBQSxJQUNSO0FBQUE7QUFBQSxVQUNpQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFBQUMsT0FBQTtBQUFBO0FBQUEsU0FBQUEsT0FDVjtBQUFBO0FBQUEsU0FFUDtBQUFBLEtBQUFwQixNQUVTO0FBQUEsSUFJVDtBQUFBLGtCQUFtQjtBQUFBLElBQW1DO0FBQUEsR0FDcEQ7QUFBQTtBQUFBLElBQUFzRztBQUFBQSxNQWprQndCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURwRDVCIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTgwMTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC93ZWFrLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogV2VhayBhcnJheSBvcGVyYXRpb25zICopXG5cbnR5cGUgISdhIHRcblxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+ICdhIHQgPSBcImNhbWxfd2Vha19jcmVhdGVcIlxuXG5sZXQgY3JlYXRlIGwgPVxuICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IE9iai5FcGhlbWVyb24ubWF4X2VwaGVfbGVuZ3RoKSB0aGVuXG4gICAgaW52YWxpZF9hcmcoXCJXZWFrLmNyZWF0ZVwiKTtcbiAgY3JlYXRlIGxcblxuKCoqIG51bWJlciBvZiBhZGRpdGlvbmFsIHZhbHVlcyBpbiBhIHdlYWsgcG9pbnRlciAqKVxubGV0IGFkZGl0aW9uYWxfdmFsdWVzID0gMlxuXG5sZXQgbGVuZ3RoIHggPSBPYmouc2l6ZShPYmoucmVwciB4KSAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbmxldCByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gbXNnID1cbiAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgaW52YWxpZF9hcmcobXNnKVxuXG5leHRlcm5hbCBzZXQnIDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9rZXlcIlxuZXh0ZXJuYWwgdW5zZXQgOiAnYSB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfa2V5XCJcbmxldCBzZXQgZSBvIHggPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLnNldFwiO1xuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHVuc2V0IGUgb1xuICB8IFNvbWUgeCAtPiBzZXQnIGUgbyB4XG5cbmV4dGVybmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldFwiXG5sZXQgZ2V0IGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuZ2V0XCI7XG4gIGdldCBlIG9cblxuZXh0ZXJuYWwgZ2V0X2NvcHkgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRfY29weVwiXG5sZXQgZ2V0X2NvcHkgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5nZXRfY29weVwiO1xuICBnZXRfY29weSBlIG9cblxuZXh0ZXJuYWwgY2hlY2sgOiAnYSB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX3dlYWtfY2hlY2tcIlxubGV0IGNoZWNrIGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuY2hlY2tcIjtcbiAgY2hlY2sgZSBvXG5cbmV4dGVybmFsIGJsaXQgOiAnYSB0IC0+IGludCAtPiAnYSB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF93ZWFrX2JsaXRcIlxuXG4oKiBibGl0OiBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuICopXG5sZXQgYmxpdCBlMSBvMSBlMiBvMiBsID1cbiAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICB8fCBvMiA8IDAgfHwgbzIgPiBsZW5ndGggZTIgLSBsXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJXZWFrLmJsaXRcIlxuICBlbHNlIGlmIGwgPD4gMCB0aGVuIGJsaXQgZTEgbzEgZTIgbzIgbFxuXG5sZXQgZmlsbCBhciBvZnMgbGVuIHggPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGFyIC0gbGVuXG4gIHRoZW4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJXZWFrLmZpbGxcIilcbiAgZWxzZSBiZWdpblxuICAgIGZvciBpID0gb2ZzIHRvIChvZnMgKyBsZW4gLSAxKSBkb1xuICAgICAgc2V0IGFyIGkgeFxuICAgIGRvbmVcbiAgZW5kXG5cblxuKCoqIFdlYWsgaGFzaCB0YWJsZXMgKilcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIGRhdGFcbiAgdHlwZSB0XG4gIHZhbCBjcmVhdGUgOiBpbnQgLT4gdFxuICB2YWwgY2xlYXIgOiB0IC0+IHVuaXRcbiAgdmFsIG1lcmdlIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGFkZCA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCByZW1vdmUgOiB0IC0+IGRhdGEgLT4gdW5pdFxuICB2YWwgZmluZCA6IHQgLT4gZGF0YSAtPiBkYXRhXG4gIHZhbCBmaW5kX29wdCA6IHQgLT4gZGF0YSAtPiBkYXRhIG9wdGlvblxuICB2YWwgZmluZF9hbGwgOiB0IC0+IGRhdGEgLT4gZGF0YSBsaXN0XG4gIHZhbCBtZW0gOiB0IC0+IGRhdGEgLT4gYm9vbFxuICB2YWwgaXRlciA6IChkYXRhIC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICB2YWwgZm9sZCA6IChkYXRhIC0+ICdhIC0+ICdhKSAtPiB0IC0+ICdhIC0+ICdhXG4gIHZhbCBjb3VudCA6IHQgLT4gaW50XG4gIHZhbCBzdGF0cyA6IHQgLT4gaW50ICogaW50ICogaW50ICogaW50ICogaW50ICogaW50XG5lbmRcblxubW9kdWxlIE1ha2UgKEggOiBIYXNodGJsLkhhc2hlZFR5cGUpIDogKFMgd2l0aCB0eXBlIGRhdGEgPSBILnQpID0gc3RydWN0XG5cbiAgdHlwZSAnYSB3ZWFrX3QgPSAnYSB0XG4gIGxldCB3ZWFrX2NyZWF0ZSA9IGNyZWF0ZVxuICBsZXQgZW1wdHlidWNrZXQgPSB3ZWFrX2NyZWF0ZSAwXG5cbiAgdHlwZSBkYXRhID0gSC50XG5cbiAgdHlwZSB0ID0ge1xuICAgIG11dGFibGUgdGFibGUgOiBkYXRhIHdlYWtfdCBhcnJheTtcbiAgICBtdXRhYmxlIGhhc2hlcyA6IGludCBhcnJheSBhcnJheTtcbiAgICBtdXRhYmxlIGxpbWl0IDogaW50OyAgICAgICAgICAgICAgICgqIGJ1Y2tldCBzaXplIGxpbWl0ICopXG4gICAgbXV0YWJsZSBvdmVyc2l6ZSA6IGludDsgICAgICAgICAgICAoKiBudW1iZXIgb2Ygb3ZlcnNpemUgYnVja2V0cyAqKVxuICAgIG11dGFibGUgcm92ZXIgOiBpbnQ7ICAgICAgICAgICAgICAgKCogZm9yIGludGVybmFsIGJvb2trZWVwaW5nICopXG4gIH1cblxuICBsZXQgZ2V0X2luZGV4IHQgaCA9IChoIGxhbmQgbWF4X2ludCkgbW9kIChBcnJheS5sZW5ndGggdC50YWJsZSlcblxuICBsZXQgbGltaXQgPSA3XG4gIGxldCBvdmVyX2xpbWl0ID0gMlxuXG4gIGxldCBjcmVhdGUgc3ogPVxuICAgIGxldCBzeiA9IGlmIHN6IDwgNyB0aGVuIDcgZWxzZSBzeiBpblxuICAgIGxldCBzeiA9IGlmIHN6ID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBTeXMubWF4X2FycmF5X2xlbmd0aCBlbHNlIHN6IGluXG4gICAge1xuICAgICAgdGFibGUgPSBBcnJheS5tYWtlIHN6IGVtcHR5YnVja2V0O1xuICAgICAgaGFzaGVzID0gQXJyYXkubWFrZSBzeiBbfCB8XTtcbiAgICAgIGxpbWl0ID0gbGltaXQ7XG4gICAgICBvdmVyc2l6ZSA9IDA7XG4gICAgICByb3ZlciA9IDA7XG4gICAgfVxuXG4gIGxldCBjbGVhciB0ID1cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxIGRvXG4gICAgICB0LnRhYmxlLihpKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgIHQuaGFzaGVzLihpKSA8LSBbfCB8XTtcbiAgICBkb25lO1xuICAgIHQubGltaXQgPC0gbGltaXQ7XG4gICAgdC5vdmVyc2l6ZSA8LSAwXG5cblxuICBsZXQgZm9sZCBmIHQgaW5pdCA9XG4gICAgbGV0IHJlYyBmb2xkX2J1Y2tldCBpIGIgYWNjdSA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gYWNjdSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IGZvbGRfYnVja2V0IChpKzEpIGIgKGYgdiBhY2N1KVxuICAgICAgfCBOb25lIC0+IGZvbGRfYnVja2V0IChpKzEpIGIgYWNjdVxuICAgIGluXG4gICAgQXJyYXkuZm9sZF9yaWdodCAoZm9sZF9idWNrZXQgMCkgdC50YWJsZSBpbml0XG5cblxuICBsZXQgaXRlciBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBiID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiAoKSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IGYgdjsgaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgICAgfCBOb25lIC0+IGl0ZXJfYnVja2V0IChpKzEpIGJcbiAgICBpblxuICAgIEFycmF5Lml0ZXIgKGl0ZXJfYnVja2V0IDApIHQudGFibGVcblxuXG4gIGxldCBpdGVyX3dlYWsgZiB0ID1cbiAgICBsZXQgcmVjIGl0ZXJfYnVja2V0IGkgaiBiID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiAoKSBlbHNlXG4gICAgICBtYXRjaCBjaGVjayBiIGkgd2l0aFxuICAgICAgfCB0cnVlIC0+IGYgYiB0Lmhhc2hlcy4oaikgaTsgaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgICB8IGZhbHNlIC0+IGl0ZXJfYnVja2V0IChpKzEpIGogYlxuICAgIGluXG4gICAgQXJyYXkuaXRlcmkgKGl0ZXJfYnVja2V0IDApIHQudGFibGVcblxuXG4gIGxldCByZWMgY291bnRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gYWNjdSBlbHNlXG4gICAgY291bnRfYnVja2V0IChpKzEpIGIgKGFjY3UgKyAoaWYgY2hlY2sgYiBpIHRoZW4gMSBlbHNlIDApKVxuXG5cbiAgbGV0IGNvdW50IHQgPVxuICAgIEFycmF5LmZvbGRfcmlnaHQgKGNvdW50X2J1Y2tldCAwKSB0LnRhYmxlIDBcblxuXG4gIGxldCBuZXh0X3N6IG4gPSBJbnQubWluICgzICogbiAvIDIgKyAzKSBTeXMubWF4X2FycmF5X2xlbmd0aFxuICBsZXQgcHJldl9zeiBuID0gKChuIC0gMykgKiAyICsgMikgLyAzXG5cbiAgbGV0IHRlc3Rfc2hyaW5rX2J1Y2tldCB0ID1cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4odC5yb3ZlcikgaW5cbiAgICBsZXQgaGJ1Y2tldCA9IHQuaGFzaGVzLih0LnJvdmVyKSBpblxuICAgIGxldCBsZW4gPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHByZXZfbGVuID0gcHJldl9zeiBsZW4gaW5cbiAgICBsZXQgbGl2ZSA9IGNvdW50X2J1Y2tldCAwIGJ1Y2tldCAwIGluXG4gICAgaWYgbGl2ZSA8PSBwcmV2X2xlbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgcmVjIGxvb3AgaSBqID1cbiAgICAgICAgaWYgaiA+PSBwcmV2X2xlbiB0aGVuIGJlZ2luXG4gICAgICAgICAgaWYgY2hlY2sgYnVja2V0IGkgdGhlbiBsb29wIChpICsgMSkgalxuICAgICAgICAgIGVsc2UgaWYgY2hlY2sgYnVja2V0IGogdGhlbiBiZWdpblxuICAgICAgICAgICAgYmxpdCBidWNrZXQgaiBidWNrZXQgaSAxO1xuICAgICAgICAgICAgaGJ1Y2tldC4oaSkgPC0gaGJ1Y2tldC4oaik7XG4gICAgICAgICAgICBsb29wIChpICsgMSkgKGogLSAxKTtcbiAgICAgICAgICBlbmQgZWxzZSBsb29wIGkgKGogLSAxKTtcbiAgICAgICAgZW5kO1xuICAgICAgaW5cbiAgICAgIGxvb3AgMCAobGVuZ3RoIGJ1Y2tldCAtIDEpO1xuICAgICAgaWYgcHJldl9sZW4gPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgdC50YWJsZS4odC5yb3ZlcikgPC0gZW1wdHlidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLih0LnJvdmVyKSA8LSBbfCB8XTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBuZXdidWNrZXQgPSB3ZWFrX2NyZWF0ZSBwcmV2X2xlbiBpblxuICAgICAgICBibGl0IGJ1Y2tldCAwIG5ld2J1Y2tldCAwIHByZXZfbGVuO1xuICAgICAgICB0LnRhYmxlLih0LnJvdmVyKSA8LSBuZXdidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLih0LnJvdmVyKSA8LSBBcnJheS5zdWIgaGJ1Y2tldCAwIHByZXZfbGVuXG4gICAgICBlbmQ7XG4gICAgICBpZiBsZW4gPiB0LmxpbWl0ICYmIHByZXZfbGVuIDw9IHQubGltaXQgdGhlbiB0Lm92ZXJzaXplIDwtIHQub3ZlcnNpemUgLSAxO1xuICAgIGVuZDtcbiAgICB0LnJvdmVyIDwtICh0LnJvdmVyICsgMSkgbW9kIChBcnJheS5sZW5ndGggdC50YWJsZSlcblxuXG4gIGxldCByZWMgcmVzaXplIHQgPVxuICAgIGxldCBvbGRsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBuZXdsZW4gPSBuZXh0X3N6IG9sZGxlbiBpblxuICAgIGlmIG5ld2xlbiA+IG9sZGxlbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgbmV3dCA9IGNyZWF0ZSBuZXdsZW4gaW5cbiAgICAgIGxldCBhZGRfd2VhayBvYiBvaCBvaSA9XG4gICAgICAgIGxldCBzZXR0ZXIgbmIgbmkgXyA9IGJsaXQgb2Igb2kgbmIgbmkgMSBpblxuICAgICAgICBsZXQgaCA9IG9oLihvaSkgaW5cbiAgICAgICAgYWRkX2F1eCBuZXd0IHNldHRlciBOb25lIGggKGdldF9pbmRleCBuZXd0IGgpO1xuICAgICAgaW5cbiAgICAgIGl0ZXJfd2VhayBhZGRfd2VhayB0O1xuICAgICAgdC50YWJsZSA8LSBuZXd0LnRhYmxlO1xuICAgICAgdC5oYXNoZXMgPC0gbmV3dC5oYXNoZXM7XG4gICAgICB0LmxpbWl0IDwtIG5ld3QubGltaXQ7XG4gICAgICB0Lm92ZXJzaXplIDwtIG5ld3Qub3ZlcnNpemU7XG4gICAgICB0LnJvdmVyIDwtIHQucm92ZXIgbW9kIEFycmF5Lmxlbmd0aCBuZXd0LnRhYmxlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICB0LmxpbWl0IDwtIG1heF9pbnQ7ICAgICAgICAgICAgICgqIG1heGltdW0gc2l6ZSBhbHJlYWR5IHJlYWNoZWQgKilcbiAgICAgIHQub3ZlcnNpemUgPC0gMDtcbiAgICBlbmRcblxuICBhbmQgYWRkX2F1eCB0IHNldHRlciBkIGggaW5kZXggPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IG5ld3N6ID1cbiAgICAgICAgICBJbnQubWluICgzICogc3ogLyAyICsgMykgKFN5cy5tYXhfYXJyYXlfbGVuZ3RoIC0gYWRkaXRpb25hbF92YWx1ZXMpXG4gICAgICAgIGluXG4gICAgICAgIGlmIG5ld3N6IDw9IHN6IHRoZW4gZmFpbHdpdGggXCJXZWFrLk1ha2U6IGhhc2ggYnVja2V0IGNhbm5vdCBncm93IG1vcmVcIjtcbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIG5ld3N6IGluXG4gICAgICAgIGxldCBuZXdoYXNoZXMgPSBBcnJheS5tYWtlIG5ld3N6IDAgaW5cbiAgICAgICAgYmxpdCBidWNrZXQgMCBuZXdidWNrZXQgMCBzejtcbiAgICAgICAgQXJyYXkuYmxpdCBoYXNoZXMgMCBuZXdoYXNoZXMgMCBzejtcbiAgICAgICAgc2V0dGVyIG5ld2J1Y2tldCBzeiBkO1xuICAgICAgICBuZXdoYXNoZXMuKHN6KSA8LSBoO1xuICAgICAgICB0LnRhYmxlLihpbmRleCkgPC0gbmV3YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4oaW5kZXgpIDwtIG5ld2hhc2hlcztcbiAgICAgICAgaWYgc3ogPD0gdC5saW1pdCAmJiBuZXdzeiA+IHQubGltaXQgdGhlbiBiZWdpblxuICAgICAgICAgIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSArIDE7XG4gICAgICAgICAgZm9yIF9pID0gMCB0byBvdmVyX2xpbWl0IGRvIHRlc3Rfc2hyaW5rX2J1Y2tldCB0IGRvbmU7XG4gICAgICAgIGVuZDtcbiAgICAgICAgaWYgdC5vdmVyc2l6ZSA+IEFycmF5Lmxlbmd0aCB0LnRhYmxlIC8gb3Zlcl9saW1pdCB0aGVuIHJlc2l6ZSB0O1xuICAgICAgZW5kIGVsc2UgaWYgY2hlY2sgYnVja2V0IGkgdGhlbiBiZWdpblxuICAgICAgICBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldHRlciBidWNrZXQgaSBkO1xuICAgICAgICBoYXNoZXMuKGkpIDwtIGg7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBhZGQgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIChnZXRfaW5kZXggdCBoKVxuXG5cbiAgbGV0IGZpbmRfb3IgdCBkIGlmbm90Zm91bmQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBpZm5vdGZvdW5kIGggaW5kZXhcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gdlxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IG1lcmdlIHQgZCA9XG4gICAgZmluZF9vciB0IGQgKGZ1biBoIGluZGV4IC0+IGFkZF9hdXggdCBzZXQgKFNvbWUgZCkgaCBpbmRleDsgZClcblxuXG4gIGxldCBmaW5kIHQgZCA9IGZpbmRfb3IgdCBkIChmdW4gX2ggX2luZGV4IC0+IHJhaXNlIE5vdF9mb3VuZClcblxuICBsZXQgZmluZF9vcHQgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gTm9uZVxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgXyBhcyB2IC0+IHZcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBmaW5kX3NoYWRvdyB0IGQgaWZmb3VuZCBpZm5vdGZvdW5kID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gaWZub3Rmb3VuZFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZCAtPiBpZmZvdW5kIGJ1Y2tldCBpXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgcmVtb3ZlIHQgZCA9IGZpbmRfc2hhZG93IHQgZCAoZnVuIHcgaSAtPiBzZXQgdyBpIE5vbmUpICgpXG5cblxuICBsZXQgbWVtIHQgZCA9IGZpbmRfc2hhZG93IHQgZCAoZnVuIF93IF9pIC0+IHRydWUpIGZhbHNlXG5cblxuICBsZXQgZmluZF9hbGwgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSBhY2N1ID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBhY2N1XG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IGxvb3AgKGkgKyAxKSAodiA6OiBhY2N1KVxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpIGFjY3VcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpIGFjY3VcbiAgICBpblxuICAgIGxvb3AgMCBbXVxuXG5cbiAgbGV0IHN0YXRzIHQgPVxuICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBsZW5zID0gQXJyYXkubWFwIGxlbmd0aCB0LnRhYmxlIGluXG4gICAgQXJyYXkuc29ydCBjb21wYXJlIGxlbnM7XG4gICAgbGV0IHRvdGxlbiA9IEFycmF5LmZvbGRfbGVmdCAoICsgKSAwIGxlbnMgaW5cbiAgICAobGVuLCBjb3VudCB0LCB0b3RsZW4sIGxlbnMuKDApLCBsZW5zLihsZW4vMiksIGxlbnMuKGxlbi0xKSlcblxuXG5lbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfbWFrZV92ZWN0IiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tb2QiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJTdGRsaWJfU3lzIiwiU3RkbGliX0ludCIsIlN0ZGxpYl9BcnJheSIsIlN0ZGxpYl9PYmoiLCJjc3RfV2Vha19jcmVhdGUiLCJjc3RfV2Vha19zZXQiLCJjc3RfV2Vha19nZXQiLCJjc3RfV2Vha19nZXRfY29weSIsImNzdF9XZWFrX2NoZWNrIiwiY3N0X1dlYWtfYmxpdCIsImNzdF9XZWFrX2ZpbGwiLCJjc3RfV2Vha19NYWtlX2hhc2hfYnVja2V0X2Nhbm4iLCJjcmVhdGUiLCJsIiwibGVuZ3RoIiwieCIsInJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IiwiZSIsIm8iLCJtc2ciLCJzZXQiLCJnZXQiLCJnZXRfY29weSIsImNoZWNrIiwiYmxpdCIsImUxIiwibzEiLCJlMiIsIm8yIiwiZmlsbCIsImFyIiwib2ZzIiwibGVuIiwiaSIsIk1ha2UiLCJIIiwiZW1wdHlidWNrZXQiLCJnZXRfaW5kZXgiLCJ0IiwiaCIsImxpbWl0Iiwic3oiLCJjbGVhciIsImZvbGQiLCJpbml0IiwiYiIsImFjY3UiLCJtYXRjaCIsInYiLCJpdGVyIiwiaXRlcl93ZWFrIiwiaiIsImNvdW50X2J1Y2tldCIsImNvdW50IiwicmVzaXplIiwib2xkbGVuIiwibmV3bGVuIiwibmV3dCIsImFkZF93ZWFrIiwib2IiLCJvaCIsIm9pIiwic2V0dGVyIiwibmIiLCJuaSIsInBhcmFtIiwiYWRkX2F1eCIsImQiLCJpbmRleCIsImJ1Y2tldCIsImhhc2hlcyIsImxvb3AiLCJuZXdzeiIsIm5ld2J1Y2tldCIsIm5ld2hhc2hlcyIsImhidWNrZXQiLCJwcmV2X2xlbiIsImxpdmUiLCJhZGQiLCJmaW5kX29yIiwiaWZub3Rmb3VuZCIsIm1lcmdlIiwiZmluZCIsImZpbmRfb3B0IiwiZmluZF9zaGFkb3ciLCJpZmZvdW5kIiwicmVtb3ZlIiwidyIsIm1lbSIsImZpbmRfYWxsIiwic3RhdHMiLCJsZW5zIiwidG90bGVuIiwiU3RkbGliX1dlYWsiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxZQUFBQyxPQUFBQztBQUFBQSxRQUFBLElDc0JFO0FBQUEsY0FDRTtBQUFBLElBQ0Ysa0NBQVE7QUFBQTtBQUFBLFlBQUFDLE9BQUFDLEdBS0ssd0JBQXdDO0FBQUEsWUFBQUMsd0JBQUFDLEdBQUFDLEdBQUFDO0FBQUFBLFFBQUEsSUFHckQsNEJBQXNCLDJCQUF0QjtBQUFBLGVBQ0UsNkJBQWdCO0FBQUE7QUFBQSxZQUFBQyxJQUFBSCxHQUFBQyxHQUFBSDtBQUFBQSxJQUtsQjtBQUFBLElBQXNDLFFBRTVCLHdDQUNZO0FBQUEsUUFBQUEsTUFIZ0I7QUFBQSxJQUcxQiwyQ0FBVTtBQUFBO0FBQUEsWUFBQU0sSUFBQUosR0FBQUM7QUFBQUEsSUFJdEI7QUFBQSxJQUNBLHNDQUFPO0FBQUE7QUFBQSxZQUFBSSxTQUFBTCxHQUFBQztBQUFBQSxJQUlQO0FBQUEsSUFDQSwyQ0FBWTtBQUFBO0FBQUEsWUFBQUssTUFBQU4sR0FBQUM7QUFBQUEsSUFJWjtBQUFBLElBQ0Esd0NBQVM7QUFBQTtBQUFBLFlBQUFNLEtBQUFDLElBQUFDLElBQUFDLElBQUFDLElBQUFmO0FBQUFBLElBTVQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUEyQix5Q0FDTjtBQUFBO0FBQUEsVUFFaEI7QUFBQSxjQUFlO0FBQUEsS0FBZjtBQUFBO0FBQUEsSUFEQSwwQ0FDaUM7QUFBQTtBQUFBLFlBQUFnQixLQUFBQyxJQUFBQyxLQUFBQyxLQUFBakI7QUFBQUEsSUFHdEMsNEJBQStCO0FBQUEsYUFFMUI7QUFBQTtBQUFBLFVBQUFrQixJQUFBO0FBQUEsY0FFRCx1QkFBVTtBQUFBO0FBQUEsS0FGVDtBQUFBO0FBQUEsSUFEQTtBQUFBLEdBS0Y7QUFBQSxZQUFBQyxLQUFBQztBQUFBQSxRQUFBQyxjQTJCZTtBQUFBLGFBQUFDLFVBQUFDLEdBQUFDO0FBQUFBLEtBWUUsZ0RBQTJDO0FBQUE7QUFBQSxRQUFBQyxRQVpoQztBQUFBLGFBQUE1QixTQUFBNkI7QUFBQUE7QUFBQUEsTUFBQUEsT0FrQjdCO0FBQUEsTUFBQUEsT0FDQTtBQUFBLEtBRVU7QUFBQTtBQUFBLGFBQ0M7QUFBQTtBQUFBO0FBQUEsZUFEd0I7QUFBQSxJQUtsQztBQUFBLGFBQUFDLE1BQUFKO0FBQUFBLFNBQUEsSUFHRDtBQUFBO0FBQUEsVUFBQUwsSUFBQTtBQUFBO0FBQUEsT0FDRTtBQUFBLE9BQ0E7QUFBQSxlQUFxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FFdkI7QUFBQSxLQUNBO0FBQUE7QUFBQSxJQUFlO0FBQUEsYUFBQVUsS0FBQW5ELEdBQUE4QyxHQUFBTTtBQUFBQSxTQUFBWCxJQVVFO0FBQUEsS0FBZTtBQUFBO0FBQUEsdUJBQUFZLEdBQUFDO0FBQUFBLG1CQUFBYixNQUFmLEdBQUFhLE9BQUE7QUFBQTtBQUFBLGdCQUxQLHFCQUFjO0FBQUEsb0JBQUFDLFFBQ2hCO0FBQUEsZ0JBQU87QUFBQTtBQUFBLGtCQUFBQyxJQUFBO0FBQUEsa0JBQUFGLFNBQ21CO0FBQUEsa0JBQUFiLE1BQVU7QUFBQTtBQUFBO0FBQUE7QUFBQSx5QkFBQUEsTUFDaEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFFaUM7QUFBQTtBQUFBLGFBQUFnQixLQUFBekQsR0FBQThDO0FBQUFBLFNBQUFMLElBVWxDO0FBQUEsS0FBZTtBQUFBO0FBQUEsdUJBQUFZO0FBQUFBLG1CQUFBWixNQUFmO0FBQUE7QUFBQSxnQkFMRCxxQkFBYztBQUFBLG9CQUFBYyxRQUNoQjtBQUFBLGdCQUFPO0FBQUEscUJBQUFDLElBQUE7QUFBQSxpQkFDRDtBQUFBLHFCQUFBZixNQUFHO0FBQUE7QUFBQTtBQUFBLHlCQUFBQSxNQUNMO0FBQUE7QUFBQTtBQUFBLG1CQUVzQjtBQUFBO0FBQUEsYUFBQWlCLFVBQUExRCxHQUFBOEM7QUFBQUEsU0FBQUwsSUFVdEI7QUFBQSxLQUFlO0FBQUE7QUFBQSx1QkFBQWtCLEdBQUFOO0FBQUFBLG1CQUFBWixNQUFmO0FBQUE7QUFBQSxnQkFMRixxQkFBYztBQUFBLGdCQUNoQjtBQUFBLGlCQUNJLGlCQUFJO0FBQUEscUJBQUFBLE1BQWM7QUFBQTtBQUFBO0FBQUEseUJBQUFBLE1BQ2pCO0FBQUE7QUFBQTtBQUFBLG1CQUVzQjtBQUFBO0FBQUEsYUFBQW1CLGFBQUFuQixLQUFBWSxHQUFBQztBQUFBQSxTQUFBYixJQUkzQixLQUFBYSxPQUFBO0FBQUE7QUFBQSx5QkFBYztBQUFBLGNBQ1cscUJBQUFBLFNBQVMsY0FBQWIsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQWdCO0FBQUEsYUFBQW9CLE1BQUFmO0FBQUFBLFNBQUEsSUFJekM7QUFBQSxLQUFnQjtBQUFBLG1DQUFoQix3Q0FBMEI7QUFBQTtBQUFBLGFBQUFnQixPQUFBaEI7QUFBQUE7QUFBQUEsTUFBQWlCLFNBdUMzQztBQUFBLE1BQUFDO0FBQUFBLFFBcENjO0FBQUE7QUFBQSxLQXNDZDtBQUFBO0FBQUEsT0FBQUMsT0FDYTtBQUFBLE9BQUFDO0FBQUFBLFNBQ1gsU0FBQUMsSUFBQUMsSUFBQUM7QUFBQUEsbUJBQUFDLE9BQUFDLElBQUFDLElBQUFDLE9BQ3VCLDhCQUFrQjtBQUFBLGNBQUExQixJQUMvQjtBQUFBLFVBQ21CLE9BQWtCLDRCQUFsQixtQkFBbUI7QUFBQTtBQUFBLE1BRWhEO0FBQUEsTUFBb0I7QUFBQSxNQUVwQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBQUE7QUFBQSxLQUNPO0FBQUEsS0FFUDtBQUFBO0FBQUEsSUFDQztBQUFBLGFBQUEyQixRQUFBNUIsR0FBQXdCLFFBQUFLLEdBQUE1QixHQUFBNkI7QUFBQUE7QUFBQUEsTUFBQUMsU0FHVTtBQUFBLE1BQUFDLFNBQ0E7QUFBQSxNQUFBN0IsS0FDSjtBQUFBLGNBQUE4QixLQUFBdEM7QUFBQUEsVUFBQUEsTUFFUDtBQUFBO0FBQUE7QUFBQSxPQWtCWTtBQUFBLFFBR1Y7QUFBQSxRQUNBO0FBQUEsUUFBZTtBQUFBO0FBQUEsV0FBQUEsTUFKZTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BQUF1QztBQUFBQSxTQWhCNUI7QUFBQTtBQUFBLE1BRUYsZ0JBQW9CO0FBQUEsVUFBQUMsY0FDSixlQUFBQyxZQUNBO0FBQUEsTUFDaEI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLGNBQTZCO0FBQUE7QUFBQSxPQUNZO0FBQUEsV0FBQXpDLE1BRXZDO0FBQUE7QUFBQTtBQUFBLGFBeEVOO0FBQUEsU0FBQW9DLFdBQWE7QUFBQSxhQUNiO0FBQUEsU0FBQU0sVUFBYztBQUFBLFNBQUEzQyxNQUNKO0FBQUEsU0FBQTRDLFdBTEk7QUFBQSxTQUFBQyxPQU9IO0FBQUEsUUFDWDtBQUFBLGFBQUExQixNQVdVLDBCQUFBbEIsSUFBUixHQUFBa0IsSUFBQTtBQUFBO0FBQUEsVUFURTtBQUFBLFVBQ0s7QUFBQSxlQUFBbEIsTUFBb0I7QUFBQTtBQUFBO0FBQUEsa0JBQ2Y7QUFBQSxXQUNOO0FBQUEsbUJBQ2U7QUFBQSxXQUFmO0FBQUEsZUFBQWtCLE1BQTBCLFdBQUFsQixNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBQUFrQixNQUVuQjtBQUFBO0FBQUEsU0FHYTtBQUFBLGtCQUNMO0FBQUEsVUFDbkI7QUFBQSxrQkFBZ0M7QUFBQSxVQUNoQztBQUFBO0FBQUE7QUFBQSxjQUFBc0IsWUFFZ0I7QUFBQSxVQUNoQjtBQUFBLGtCQUFrQztBQUFBLFVBQ2xDO0FBQUEsa0JBQ3NCLHNEQUE0QjtBQUFBLFVBQWxEO0FBQUE7QUFBQSxpQkFFRjtBQUFBLGVBQTZDO0FBQUE7QUFBQSxRQUUvQztBQUFBLGdCQTRDc0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBRWxEO0FBQUEsaUJBQXVELGFBTXREO0FBQUE7QUFBQSxLQUVMLGNBQU07QUFBQTtBQUFBLGFBQUFLLElBQUF4QyxHQUFBNkI7QUFBQUEsU0FBQTVCLElBSUU7QUFBQSxLQUNpQixPQUFlLDJCQUFmLGdCQUFlO0FBQUE7QUFBQSxhQUFBd0MsUUFBQXpDLEdBQUE2QixHQUFBYTtBQUFBQTtBQUFBQSxNQUFBekMsSUFJaEM7QUFBQSxNQUFBNkIsUUFDSTtBQUFBLE1BQUFDLFNBQ0M7QUFBQSxNQUFBQyxTQUNBO0FBQUEsTUFBQTdCLEtBQ0o7QUFBQSxNQUFBUixJQWFUO0FBQUE7QUFBQSxNQVhFLFlBQWdCLHVDQVdaO0FBQUEsTUFWUTtBQUFBLFdBQUFjLFFBQ0o7QUFBQSxPQUFpQjtBQUFBLFlBQUFDLElBQUE7QUFBQSxRQUNUO0FBQUEsYUFBQUQsVUFDSTtBQUFBLFNBQVksZ0JBQUFDLE1BQUEsWUFDWjtBQUFBLGFBQUFmLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBQUFBLE1BRVQ7QUFBQTtBQUFBO0FBQUEsZUFBQUEsTUFDQTtBQUFBO0FBQUEsSUFFTDtBQUFBLGFBQUFnRCxNQUFBM0MsR0FBQTZCO0FBQUFBLEtBSU47QUFBQTtBQUFBO0FBQUEsdUJBQUE1QixHQUFBNkIsT0FBNEIsbUNBQThCLFNBQUcsRUFBQztBQUFBO0FBQUEsYUFBQWMsS0FBQTVDLEdBQUE2QjtBQUFBQSxLQUdqRDtBQUFBO0FBQUE7QUFBQSx1QkFBQTVCLEdBQUE2QjtBQUFBQSxlQUE4QjtBQUFBLGNBQWUsRUFBQztBQUFBO0FBQUEsYUFBQWUsU0FBQTdDLEdBQUE2QjtBQUFBQTtBQUFBQSxNQUFBNUIsSUFHbkQ7QUFBQSxNQUFBNkIsUUFDSTtBQUFBLE1BQUFDLFNBQ0M7QUFBQSxNQUFBQyxTQUNBO0FBQUEsTUFBQTdCLEtBQ0o7QUFBQSxNQUFBUixJQWFUO0FBQUE7QUFBQSxNQVhFLFlBQWdCO0FBQUEsTUFDSjtBQUFBLFdBQUFjLFFBQ0o7QUFBQSxPQUFpQjtBQUFBLFlBQUFDLElBQUE7QUFBQSxRQUNUO0FBQUEsYUFBQUEsTUFDSTtBQUFBLFNBQVksUUFDUDtBQUFBLGFBQUFmLE1BQ1A7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBQUFBLE1BRVQ7QUFBQTtBQUFBO0FBQUEsZUFBQUEsTUFDQTtBQUFBO0FBQUEsSUFFTDtBQUFBLGFBQUFtRCxZQUFBOUMsR0FBQTZCLEdBQUFrQixTQUFBTDtBQUFBQTtBQUFBQSxNQUFBekMsSUFJRTtBQUFBLE1BQUE2QixRQUNJO0FBQUEsTUFBQUMsU0FDQztBQUFBLE1BQUFDLFNBQ0E7QUFBQSxNQUFBN0IsS0FDSjtBQUFBLE1BQUFSLElBU1Q7QUFBQTtBQUFBLE1BUEUsWUFBZ0I7QUFBQSxNQUNKO0FBQUEsV0FBQWMsUUFDSjtBQUFBLE9BQWlCO0FBQUEsWUFBQUMsSUFBQTtBQUFBLFFBQ1QsMkJBQWUscUNBSTNCO0FBQUE7QUFBQSxXQUFBZixNQUhLO0FBQUE7QUFBQTtBQUFBLGVBQUFBLE1BQ0E7QUFBQTtBQUFBLElBRUw7QUFBQSxhQUFBcUQsT0FBQWhELEdBQUE2QjtBQUFBQSxLQUdTLGtDQUFBb0IsR0FBQXRELEdBQTRCLG1CQUFZLE1BQUk7QUFBQTtBQUFBLGFBQUF1RCxJQUFBbEQsR0FBQTZCO0FBQUFBLEtBRy9DLGtDQUFBb0IsR0FBQXRELEdBQThCLFNBQUksS0FBTztBQUFBO0FBQUEsYUFBQXdELFNBQUFuRCxHQUFBNkI7QUFBQUE7QUFBQUEsTUFBQTVCLElBSTdDO0FBQUEsTUFBQTZCLFFBQ0k7QUFBQSxNQUFBQyxTQUNDO0FBQUEsTUFBQUMsU0FDQTtBQUFBLE1BQUE3QixLQUNKO0FBQUEsTUFBQVIsSUFhVDtBQUFBLE1BQUFhLE9BQUE7QUFBQTtBQUFBLE1BWEUsWUFBZ0I7QUFBQSxNQUNKO0FBQUEsV0FBQUMsUUFDSjtBQUFBLE9BQWlCO0FBQUEsWUFBQUMsSUFBQTtBQUFBLFFBQ1Q7QUFBQSxhQUFBRCxVQUNJO0FBQUEsU0FBWTtBQUFBLGNBQUFDLE1BQUEsWUFBQUYsU0FDWixnQkFBQWIsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBQUEsTUFFVDtBQUFBO0FBQUE7QUFBQSxlQUFBQSxNQUNBO0FBQUE7QUFBQSxJQUVGO0FBQUEsYUFBQXlELE1BQUFwRDtBQUFBQTtBQUFBQSxNQUFBTixNQUlUO0FBQUEsTUFBQTJELE9BQ1c7QUFBQSxLQUNYO0FBQUE7QUFBQSxNQUFBQztBQUFBQSxRQUNhO0FBQUEsK0JEL1dqQjtBQUFBLFVDZ1hJO0FBQUEsVUFBMkQ7QUFBQSxVQUFaO0FBQUEsVUFBZDtBQUFBLFVBQVY7QUFBQSxLQUFqQiwwQ0FBTztBQUFBLElBQStDO0FBQUEsSUEzUS9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTURyR2pDIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTg1MDQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9mb3JtYXQubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEEgcHJldHR5LXByaW50aW5nIGZhY2lsaXR5IGFuZCBkZWZpbml0aW9uIG9mIGZvcm1hdHRlcnMgZm9yICdwYXJhbGxlbCdcbiAgIChpLmUuIHVucmVsYXRlZCBvciBpbmRlcGVuZGVudCkgcHJldHR5LXByaW50aW5nIG9uIG11bHRpcGxlIG91dCBjaGFubmVscy4gKilcblxuKCpcbiAgIFRoZSBwcmV0dHktcHJpbnRpbmcgZW5naW5lIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiopXG5cbmxldCBpZCB4ID0geFxuXG4oKiBBIGRldm90ZWQgdHlwZSBmb3Igc2l6ZXMgdG8gYXZvaWQgY29uZnVzaW9uXG4gICBiZXR3ZWVuIHNpemVzIGFuZCBtZXJlIGludGVnZXJzLiAqKVxubW9kdWxlIFNpemUgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHRvX2ludCA6IHQgLT4gaW50XG4gIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICB2YWwgemVybyA6IHRcbiAgdmFsIHVua25vd24gOiB0XG4gIHZhbCBpc19rbm93biA6IHQgLT4gYm9vbFxuZW5kICA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgdG9faW50ID0gaWRcbiAgbGV0IG9mX2ludCA9IGlkXG4gIGxldCB6ZXJvID0gMFxuICBsZXQgdW5rbm93biA9IC0xXG4gIGxldCBpc19rbm93biBuID0gbiA+PSAwXG5lbmRcblxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgYm94ZXMgZGVmaW5pdGlvbjpcbiAgIGEgcHJldHR5LXByaW50aW5nIGJveCBpcyBlaXRoZXJcbiAgIC0gaGJveDogaG9yaXpvbnRhbCBib3ggKG5vIGxpbmUgc3BsaXR0aW5nKVxuICAgLSB2Ym94OiB2ZXJ0aWNhbCBib3ggKGV2ZXJ5IGJyZWFrIGhpbnQgc3BsaXRzIHRoZSBsaW5lKVxuICAgLSBodmJveDogaG9yaXpvbnRhbC92ZXJ0aWNhbCBib3hcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIGJveCBpZiBpdCBmaXRzIG9uXG4gICAgICB0aGUgY3VycmVudCBsaW5lLCBvdGhlcndpc2UgdGhlIGJveCBiZWhhdmVzIGFzIGEgdmVydGljYWwgYm94KVxuICAgLSBob3Zib3g6IGhvcml6b250YWwgb3IgdmVydGljYWwgY29tcGFjdGluZyBib3hcbiAgICAgKHRoZSBib3ggaXMgY29tcGFjdGluZyBtYXRlcmlhbCwgcHJpbnRpbmcgYXMgbXVjaCBtYXRlcmlhbCBhcyBwb3NzaWJsZVxuICAgICAgb24gZXZlcnkgbGluZXMpXG4gICAtIGJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveCB3aXRoIGVuaGFuY2VkIGJveCBzdHJ1Y3R1cmVcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGJveCBidXQgYnJlYWsgaGludHMgc3BsaXRcbiAgICAgIHRoZSBsaW5lIGlmIHNwbGl0dGluZyB3b3VsZCBtb3ZlIHRvIHRoZSBsZWZ0KVxuKilcbnR5cGUgYm94X3R5cGUgPSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHNcblxuXG4oKiBUaGUgcHJldHR5LXByaW50aW5nIHRva2VucyBkZWZpbml0aW9uOlxuICAgYXJlIGVpdGhlciB0ZXh0IHRvIHByaW50IG9yIHByZXR0eSBwcmludGluZ1xuICAgZWxlbWVudHMgdGhhdCBkcml2ZSBpbmRlbnRhdGlvbiBhbmQgbGluZSBzcGxpdHRpbmcuICopXG50eXBlIHBwX3Rva2VuID1cbiAgfCBQcF90ZXh0IG9mIHN0cmluZyAgICAgICAgICAoKiBub3JtYWwgdGV4dCAqKVxuICB8IFBwX2JyZWFrIG9mIHsgICAgICAgICAgICAgICgqIGNvbXBsZXRlIGJyZWFrICopXG4gICAgICBmaXRzOiBzdHJpbmcgKiBpbnQgKiBzdHJpbmc7ICAgKCogbGluZSBpcyBub3Qgc3BsaXQgKilcbiAgICAgIGJyZWFrczogc3RyaW5nICogaW50ICogc3RyaW5nOyAoKiBsaW5lIGlzIHNwbGl0ICopXG4gICAgfVxuICB8IFBwX3RicmVhayBvZiBpbnQgKiBpbnQgICAgICgqIGdvIHRvIG5leHQgdGFidWxhdGlvbiAqKVxuICB8IFBwX3N0YWIgICAgICAgICAgICAgICAgICAgICgqIHNldCBhIHRhYnVsYXRpb24gKilcbiAgfCBQcF9iZWdpbiBvZiBpbnQgKiBib3hfdHlwZSAoKiBiZWdpbm5pbmcgb2YgYSBib3ggKilcbiAgfCBQcF9lbmQgICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSBib3ggKilcbiAgfCBQcF90YmVnaW4gb2YgdGJveCAgICAgICAgICAoKiBiZWdpbm5pbmcgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX3RlbmQgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfbmV3bGluZSAgICAgICAgICAgICAgICAgKCogdG8gZm9yY2UgYSBuZXdsaW5lIGluc2lkZSBhIGJveCAqKVxuICB8IFBwX2lmX25ld2xpbmUgICAgICAgICAgICAgICgqIHRvIGRvIHNvbWV0aGluZyBvbmx5IGlmIHRoaXMgdmVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgaGFzIGJlZW4gYnJva2VuICopXG4gIHwgUHBfb3Blbl90YWcgb2Ygc3RhZyAgICAgICAgICgqIG9wZW5pbmcgYSB0YWcgbmFtZSAqKVxuICB8IFBwX2Nsb3NlX3RhZyAgICAgICAgICAgICAgICgqIGNsb3NpbmcgdGhlIG1vc3QgcmVjZW50bHkgb3BlbiB0YWcgKilcblxuYW5kIHN0YWcgPSAuLlxuXG5hbmQgdGJveCA9IFBwX3Rib3ggb2YgaW50IGxpc3QgcmVmICAoKiBUYWJ1bGF0aW9uIGJveCAqKVxuXG50eXBlIHRhZyA9IHN0cmluZ1xudHlwZSBzdGFnICs9IFN0cmluZ190YWcgb2YgdGFnXG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlOlxuICAgcHJldHR5LXByaW50aW5nIG1hdGVyaWFsIGlzIG5vdCB3cml0dGVuIGluIHRoZSBvdXRwdXQgYXMgc29vbiBhcyBlbWl0dGVkO1xuICAgaW5zdGVhZCwgdGhlIG1hdGVyaWFsIGlzIHNpbXBseSByZWNvcmRlZCBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUsXG4gICB1bnRpbCB0aGUgZW5jbG9zaW5nIGJveCBoYXMgYSBrbm93biBjb21wdXRlZCBzaXplIGFuZCBwcm9wZXIgc3BsaXR0aW5nXG4gICBkZWNpc2lvbnMgY2FuIGJlIG1hZGUuXG5cbiAgIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBjb250YWlucyBmb3JtYXR0aW5nIGVsZW1lbnRzIHRvIGJlIHByaW50ZWQuXG4gICBFYWNoIGZvcm1hdHRpbmcgZWxlbWVudCBpcyBhIHR1cGxlIChzaXplLCB0b2tlbiwgbGVuZ3RoKSwgd2hlcmVcbiAgIC0gbGVuZ3RoIGlzIHRoZSBkZWNsYXJlZCBsZW5ndGggb2YgdGhlIHRva2VuLFxuICAgLSBzaXplIGlzIGVmZmVjdGl2ZSBzaXplIG9mIHRoZSB0b2tlbiB3aGVuIGl0IGlzIHByaW50ZWRcbiAgICAgKHNpemUgaXMgc2V0IHdoZW4gdGhlIHNpemUgb2YgdGhlIGJveCBpcyBrbm93biwgc28gdGhhdCBzaXplIG9mIGJyZWFrXG4gICAgICBoaW50cyBhcmUgZGVmaW5pdGl2ZSkuICopXG50eXBlIHBwX3F1ZXVlX2VsZW0gPSB7XG4gIG11dGFibGUgc2l6ZSA6IFNpemUudDtcbiAgdG9rZW4gOiBwcF90b2tlbjtcbiAgbGVuZ3RoIDogaW50O1xufVxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9xdWV1ZSA9IHBwX3F1ZXVlX2VsZW0gUXVldWUudFxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjazogc2Nhbm5pbmcgZWxlbWVudCBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9zY2FuX2VsZW0gPSB7XG4gIGxlZnRfdG90YWwgOiBpbnQ7ICgqIFZhbHVlIG9mIHBwX2xlZnRfdG90YWwgd2hlbiB0aGUgZWxlbWVudCB3YXMgZW5xdWV1ZWQuICopXG4gIHF1ZXVlX2VsZW0gOiBwcF9xdWV1ZV9lbGVtXG59XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOlxuICAgdGhlIGZvcm1hdHRpbmcgc3RhY2sgY29udGFpbnMgdGhlIGRlc2NyaXB0aW9uIG9mIGFsbCB0aGUgY3VycmVudGx5IGFjdGl2ZVxuICAgYm94ZXM7IHRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrIGlzIHVzZWQgdG8gc3BsaXQgdGhlIGxpbmVzXG4gICB3aGlsZSBwcmludGluZyB0b2tlbnMuICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOiBmb3JtYXR0aW5nIHN0YWNrIGVsZW1lbnQgZGVmaW5pdGlvbi5cbiAgIEVhY2ggc3RhY2sgZWxlbWVudCBkZXNjcmliZXMgYSBwcmV0dHktcHJpbnRpbmcgYm94LiAqKVxudHlwZSBwcF9mb3JtYXRfZWxlbSA9IHsgYm94X3R5cGUgOiBib3hfdHlwZTsgd2lkdGggOiBpbnQgfVxuXG4oKiBUaGUgZm9ybWF0dGVyIGRlZmluaXRpb24uXG4gICBFYWNoIGZvcm1hdHRlciB2YWx1ZSBpcyBhIHByZXR0eS1wcmludGVyIGluc3RhbmNlIHdpdGggYWxsIGl0c1xuICAgbWFjaGluZXJ5LiAqKVxudHlwZSBmb3JtYXR0ZXIgPSB7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcbiAgcHBfc2Nhbl9zdGFjayA6IHBwX3NjYW5fZWxlbSBTdGFjay50O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjay4gKilcbiAgcHBfZm9ybWF0X3N0YWNrIDogcHBfZm9ybWF0X2VsZW0gU3RhY2sudDtcbiAgcHBfdGJveF9zdGFjayA6IHRib3ggU3RhY2sudDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHNlbWFudGljcyB0YWcgc3RhY2suICopXG4gIHBwX3RhZ19zdGFjayA6IHN0YWcgU3RhY2sudDtcbiAgcHBfbWFya19zdGFjayA6IHN0YWcgU3RhY2sudDtcbiAgKCogVmFsdWUgb2YgcmlnaHQgbWFyZ2luLiAqKVxuICBtdXRhYmxlIHBwX21hcmdpbiA6IGludDtcbiAgKCogTWluaW1hbCBzcGFjZSBsZWZ0IGJlZm9yZSBtYXJnaW4sIHdoZW4gb3BlbmluZyBhIGJveC4gKilcbiAgbXV0YWJsZSBwcF9taW5fc3BhY2VfbGVmdCA6IGludDtcbiAgKCogTWF4aW11bSB2YWx1ZSBvZiBpbmRlbnRhdGlvbjpcbiAgICAgbm8gYm94IGNhbiBiZSBvcGVuZWQgZnVydGhlci4gKilcbiAgbXV0YWJsZSBwcF9tYXhfaW5kZW50IDogaW50O1xuICAoKiBTcGFjZSByZW1haW5pbmcgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbiAgbXV0YWJsZSBwcF9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBDdXJyZW50IHZhbHVlIG9mIGluZGVudGF0aW9uLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJlbnRfaW5kZW50IDogaW50O1xuICAoKiBUcnVlIHdoZW4gdGhlIGxpbmUgaGFzIGJlZW4gYnJva2VuIGJ5IHRoZSBwcmV0dHktcHJpbnRlci4gKilcbiAgbXV0YWJsZSBwcF9pc19uZXdfbGluZSA6IGJvb2w7XG4gICgqIFRvdGFsIHdpZHRoIG9mIHRva2VucyBhbHJlYWR5IHByaW50ZWQuICopXG4gIG11dGFibGUgcHBfbGVmdF90b3RhbCA6IGludDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGV2ZXIgcHV0IGluIHF1ZXVlLiAqKVxuICBtdXRhYmxlIHBwX3JpZ2h0X3RvdGFsIDogaW50O1xuICAoKiBDdXJyZW50IG51bWJlciBvZiBvcGVuIGJveGVzLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJfZGVwdGggOiBpbnQ7XG4gICgqIE1heGltdW0gbnVtYmVyIG9mIGJveGVzIHdoaWNoIGNhbiBiZSBzaW11bHRhbmVvdXNseSBvcGVuLiAqKVxuICBtdXRhYmxlIHBwX21heF9ib3hlcyA6IGludDtcbiAgKCogRWxsaXBzaXMgc3RyaW5nLiAqKVxuICBtdXRhYmxlIHBwX2VsbGlwc2lzIDogc3RyaW5nO1xuICAoKiBPdXRwdXQgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gICgqIEZsdXNoaW5nIGZ1bmN0aW9uLiAqKVxuICBtdXRhYmxlIHBwX291dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfbmV3bGluZSA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGJyZWFrIGhpbnRzIHNwYWNlcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG4gIG11dGFibGUgcHBfb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xuICAoKiBBcmUgdGFncyBwcmludGVkID8gKilcbiAgbXV0YWJsZSBwcF9wcmludF90YWdzIDogYm9vbDtcbiAgKCogQXJlIHRhZ3MgbWFya2VkID8gKilcbiAgbXV0YWJsZSBwcF9tYXJrX3RhZ3MgOiBib29sO1xuICAoKiBGaW5kIG9wZW5pbmcgYW5kIGNsb3NpbmcgbWFya2VycyBvZiB0YWdzLiAqKVxuICBtdXRhYmxlIHBwX21hcmtfb3Blbl90YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbXV0YWJsZSBwcF9tYXJrX2Nsb3NlX3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX3ByaW50X29wZW5fdGFnIDogc3RhZyAtPiB1bml0O1xuICBtdXRhYmxlIHBwX3ByaW50X2Nsb3NlX3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxuICBwcF9xdWV1ZSA6IHBwX3F1ZXVlO1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgc3BlY2lmaWMgdGFnIGhhbmRsaW5nIGZ1bmN0aW9ucy4gKilcbnR5cGUgZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fc3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3N0YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgcHJpbnRfb3Blbl9zdGFnIDogc3RhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV9zdGFnIDogc3RhZyAtPiB1bml0O1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb25zIHRvIG91dHB1dCBtYXRlcmlhbC4gKilcbnR5cGUgZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPSB7XG4gIG91dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICBvdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICBvdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gIG91dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbn1cblxuXG4oKlxuXG4gIEF1eGlsaWFyaWVzIGFuZCBiYXNpYyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEVudGVyIGEgdG9rZW4gaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2VucXVldWUgc3RhdGUgdG9rZW4gPVxuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBzdGF0ZS5wcF9yaWdodF90b3RhbCArIHRva2VuLmxlbmd0aDtcbiAgUXVldWUuYWRkIHRva2VuIHN0YXRlLnBwX3F1ZXVlXG5cblxubGV0IHBwX2NsZWFyX3F1ZXVlIHN0YXRlID1cbiAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSAxOyBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSAxO1xuICBRdWV1ZS5jbGVhciBzdGF0ZS5wcF9xdWV1ZVxuXG5cbigqIFBwX2luZmluaXR5OiBsYXJnZSB2YWx1ZSBmb3IgZGVmYXVsdCB0b2tlbnMgc2l6ZS5cblxuICAgUHBfaW5maW5pdHkgaXMgZG9jdW1lbnRlZCBhcyBiZWluZyBncmVhdGVyIHRoYW4gMWUxMDsgdG8gYXZvaWRcbiAgIGNvbmZ1c2lvbiBhYm91dCB0aGUgd29yZCAnZ3JlYXRlcicsIHdlIGNob29zZSBwcF9pbmZpbml0eSBncmVhdGVyXG4gICB0aGFuIDFlMTAgKyAxOyBmb3IgY29ycmVjdCBoYW5kbGluZyBvZiB0ZXN0cyBpbiB0aGUgYWxnb3JpdGhtLFxuICAgcHBfaW5maW5pdHkgbXVzdCBiZSBldmVuIG9uZSBtb3JlIHRoYW4gMWUxMCArIDE7IGxldCdzIHN0YW5kIG9uIHRoZVxuICAgc2FmZSBzaWRlIGJ5IGNob29zaW5nIDEuZTEwKzEwLlxuXG4gICBQcF9pbmZpbml0eSBjb3VsZCBwcm9iYWJseSBiZSAxMDczNzQxODIzIHRoYXQgaXMgMl4zMCAtIDEsIHRoYXQgaXNcbiAgIHRoZSBtaW5pbWFsIHVwcGVyIGJvdW5kIGZvciBpbnRlZ2Vyczsgbm93IHRoYXQgbWF4X2ludCBpcyBkZWZpbmVkLFxuICAgdGhpcyBsaW1pdCBjb3VsZCBhbHNvIGJlIGRlZmluZWQgYXMgbWF4X2ludCAtIDEuXG5cbiAgIEhvd2V2ZXIsIGJlZm9yZSBzZXR0aW5nIHBwX2luZmluaXR5IHRvIHNvbWV0aGluZyBhcm91bmQgbWF4X2ludCwgd2VcbiAgIG11c3QgY2FyZWZ1bGx5IGRvdWJsZS1jaGVjayBhbGwgdGhlIGludGVnZXIgYXJpdGhtZXRpYyBvcGVyYXRpb25zXG4gICB0aGF0IGludm9sdmUgcHBfaW5maW5pdHksIHNpbmNlIGFueSBvdmVyZmxvdyB3b3VsZCB3cmVjayBoYXZvYyB0aGVcbiAgIHByZXR0eS1wcmludGluZyBhbGdvcml0aG0ncyBpbnZhcmlhbnRzLiBHaXZlbiB0aGF0IHRoaXMgYXJpdGhtZXRpY1xuICAgY29ycmVjdG5lc3MgY2hlY2sgaXMgZGlmZmljdWx0IGFuZCBlcnJvciBwcm9uZSBhbmQgZ2l2ZW4gdGhhdCAxZTEwXG4gICArIDEgaXMgaW4gcHJhY3RpY2UgbGFyZ2UgZW5vdWdoLCB0aGVyZSBpcyBubyBuZWVkIHRvIGF0dGVtcHQgdG8gc2V0XG4gICBwcF9pbmZpbml0eSB0byB0aGUgdGhlb3JldGljYWxseSBtYXhpbXVtIGxpbWl0LiBJdCBpcyBub3Qgd29ydGggdGhlXG4gICBidXJkZW4gISAqKVxubGV0IHBwX2luZmluaXR5ID0gMTAwMDAwMDAxMFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIGZvciB0aGUgZm9ybWF0dGVyLiAqKVxubGV0IHBwX291dHB1dF9zdHJpbmcgc3RhdGUgcyA9IHN0YXRlLnBwX291dF9zdHJpbmcgcyAwIChTdHJpbmcubGVuZ3RoIHMpXG5hbmQgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgPSBzdGF0ZS5wcF9vdXRfbmV3bGluZSAoKVxuYW5kIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9zcGFjZXMgblxuYW5kIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9pbmRlbnQgblxuXG4oKiBGb3JtYXQgYSB0ZXh0dWFsIHRva2VuICopXG5sZXQgZm9ybWF0X3BwX3RleHQgc3RhdGUgc2l6ZSB0ZXh0ID1cbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gc2l6ZTtcbiAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSB0ZXh0O1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSBmYWxzZVxuXG4oKiBGb3JtYXQgYSBzdHJpbmcgYnkgaXRzIGxlbmd0aCwgaWYgbm90IGVtcHR5ICopXG5sZXQgZm9ybWF0X3N0cmluZyBzdGF0ZSBzID1cbiAgaWYgcyA8PiBcIlwiIHRoZW4gZm9ybWF0X3BwX3RleHQgc3RhdGUgKFN0cmluZy5sZW5ndGggcykgc1xuXG4oKiBUbyBmb3JtYXQgYSBicmVhaywgaW5kZW50aW5nIGEgbmV3IGxpbmUuICopXG5sZXQgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKGJlZm9yZSwgb2Zmc2V0LCBhZnRlcikgd2lkdGggPVxuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGJlZm9yZTtcbiAgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIHRydWU7XG4gIGxldCBpbmRlbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZnNldCBpblxuICAoKiBEb24ndCBpbmRlbnQgbW9yZSB0aGFuIHBwX21heF9pbmRlbnQuICopXG4gIGxldCByZWFsX2luZGVudCA9IEludC5taW4gc3RhdGUucHBfbWF4X2luZGVudCBpbmRlbnQgaW5cbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gcmVhbF9pbmRlbnQ7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfY3VycmVudF9pbmRlbnQ7XG4gIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgc3RhdGUucHBfY3VycmVudF9pbmRlbnQ7XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYWZ0ZXJcblxuXG4oKiBUbyBmb3JjZSBhIGxpbmUgYnJlYWsgaW5zaWRlIGEgYm94OiBubyBvZmZzZXQgaXMgYWRkZWQuICopXG5sZXQgYnJlYWtfbGluZSBzdGF0ZSB3aWR0aCA9IGJyZWFrX25ld19saW5lIHN0YXRlIChcIlwiLCAwLCBcIlwiKSB3aWR0aFxuXG4oKiBUbyBmb3JtYXQgYSBicmVhayB0aGF0IGZpdHMgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbmxldCBicmVha19zYW1lX2xpbmUgc3RhdGUgKGJlZm9yZSwgd2lkdGgsIGFmdGVyKSA9XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYmVmb3JlO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSB3aWR0aDtcbiAgcHBfb3V0cHV0X3NwYWNlcyBzdGF0ZSB3aWR0aDtcbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBhZnRlclxuXG5cbigqIFRvIGluZGVudCBubyBtb3JlIHRoYW4gcHBfbWF4X2luZGVudCwgaWYgb25lIHRyaWVzIHRvIG9wZW4gYSBib3hcbiAgIGJleW9uZCBwcF9tYXhfaW5kZW50LCB0aGVuIHRoZSBib3ggaXMgcmVqZWN0ZWQgb24gdGhlIGxlZnRcbiAgIGJ5IHNpbXVsYXRpbmcgYSBicmVhay4gKilcbmxldCBwcF9mb3JjZV9icmVha19saW5lIHN0YXRlID1cbiAgbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICB8IE5vbmUgLT4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGVcbiAgfCBTb21lIHsgYm94X3R5cGU7IHdpZHRoIH0gLT5cbiAgICBpZiB3aWR0aCA+IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlblxuICAgICAgbWF0Y2ggYm94X3R5cGUgd2l0aFxuICAgICAgfCBQcF9maXRzIHwgUHBfaGJveCAtPiAoKVxuICAgICAgfCBQcF92Ym94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggLT4gYnJlYWtfbGluZSBzdGF0ZSB3aWR0aFxuXG5cbigqIFRvIHNraXAgYSB0b2tlbiwgaWYgdGhlIHByZXZpb3VzIGxpbmUgaGFzIGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3NraXBfdG9rZW4gc3RhdGUgPVxuICBtYXRjaCBRdWV1ZS50YWtlX29wdCBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBwcmludF9pZl9uZXdsaW5lIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHByaW50aW5nIGNvbW1hbmQgKilcbiAgfCBTb21lIHsgc2l6ZTsgbGVuZ3RoOyBfIH0gLT5cbiAgICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIHN0YXRlLnBwX2xlZnRfdG90YWwgLSBsZW5ndGg7XG4gICAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0ICsgU2l6ZS50b19pbnQgc2l6ZVxuXG5cbigqXG5cbiAgVGhlIG1haW4gcHJldHR5IHByaW50aW5nIGZ1bmN0aW9ucy5cblxuKilcblxuKCogRm9ybWF0dGluZyBhIHRva2VuIHdpdGggYSBnaXZlbiBzaXplLiAqKVxubGV0IGZvcm1hdF9wcF90b2tlbiBzdGF0ZSBzaXplID0gZnVuY3Rpb25cblxuICB8IFBwX3RleHQgcyAtPlxuICAgIGZvcm1hdF9wcF90ZXh0IHN0YXRlIHNpemUgc1xuXG4gIHwgUHBfYmVnaW4gKG9mZiwgdHkpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBpZiBpbnNlcnRpb25fcG9pbnQgPiBzdGF0ZS5wcF9tYXhfaW5kZW50IHRoZW5cbiAgICAgICgqIGNhbiBub3Qgb3BlbiBhIGJveCByaWdodCB0aGVyZS4gKilcbiAgICAgIGJlZ2luIHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgZW5kO1xuICAgIGxldCB3aWR0aCA9IHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBvZmYgaW5cbiAgICBsZXQgYm94X3R5cGUgPVxuICAgICAgbWF0Y2ggdHkgd2l0aFxuICAgICAgfCBQcF92Ym94IC0+IFBwX3Zib3hcbiAgICAgIHwgUHBfaGJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0cyAtPlxuICAgICAgICBpZiBzaXplID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuIHR5IGVsc2UgUHBfZml0cyBpblxuICAgIFN0YWNrLnB1c2ggeyBib3hfdHlwZTsgd2lkdGggfSBzdGF0ZS5wcF9mb3JtYXRfc3RhY2tcblxuICB8IFBwX2VuZCAtPlxuICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHw+IGlnbm9yZVxuXG4gIHwgUHBfdGJlZ2luIChQcF90Ym94IF8gYXMgdGJveCkgLT5cbiAgICBTdGFjay5wdXNoIHRib3ggc3RhdGUucHBfdGJveF9zdGFja1xuXG4gIHwgUHBfdGVuZCAtPlxuICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB8PiBpZ25vcmVcblxuICB8IFBwX3N0YWIgLT5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIHwgU29tZSAoUHBfdGJveCB0YWJzKSAtPlxuICAgICAgbGV0IHJlYyBhZGRfdGFiIG4gPSBmdW5jdGlvblxuICAgICAgICB8IFtdIC0+IFtuXVxuICAgICAgICB8IHggOjogbCBhcyBscyAtPiBpZiBuIDwgeCB0aGVuIG4gOjogbHMgZWxzZSB4IDo6IGFkZF90YWIgbiBsIGluXG4gICAgICB0YWJzIDo9IGFkZF90YWIgKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQpICF0YWJzXG4gICAgZW5kXG5cbiAgfCBQcF90YnJlYWsgKG4sIG9mZikgLT5cbiAgICBsZXQgaW5zZXJ0aW9uX3BvaW50ID0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCBpblxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgfCBTb21lIChQcF90Ym94IHRhYnMpIC0+XG4gICAgICBsZXQgdGFiID1cbiAgICAgICAgbWF0Y2ggIXRhYnMgd2l0aFxuICAgICAgICB8IFtdIC0+IGluc2VydGlvbl9wb2ludFxuICAgICAgICB8IGZpcnN0IDo6IF8gLT5cbiAgICAgICAgICBsZXQgcmVjIGZpbmQgPSBmdW5jdGlvblxuICAgICAgICAgICAgfCBoZWFkIDo6IHRhaWwgLT5cbiAgICAgICAgICAgICAgaWYgaGVhZCA+PSBpbnNlcnRpb25fcG9pbnQgdGhlbiBoZWFkIGVsc2UgZmluZCB0YWlsXG4gICAgICAgICAgICB8IFtdIC0+IGZpcnN0IGluXG4gICAgICAgICAgZmluZCAhdGFicyBpblxuICAgICAgbGV0IG9mZnNldCA9IHRhYiAtIGluc2VydGlvbl9wb2ludCBpblxuICAgICAgaWYgb2Zmc2V0ID49IDBcbiAgICAgIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIChcIlwiLCBvZmZzZXQgKyBuLCBcIlwiKVxuICAgICAgZWxzZSBicmVha19uZXdfbGluZSBzdGF0ZSAoXCJcIiwgdGFiICsgb2ZmLCBcIlwiKSBzdGF0ZS5wcF9tYXJnaW5cbiAgICBlbmRcblxuICB8IFBwX25ld2xpbmUgLT5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+IHBwX291dHB1dF9uZXdsaW5lIHN0YXRlICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIHwgU29tZSB7IHdpZHRoOyBffSAtPiBicmVha19saW5lIHN0YXRlIHdpZHRoXG4gICAgZW5kXG5cbiAgfCBQcF9pZl9uZXdsaW5lIC0+XG4gICAgaWYgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgIT0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgIHRoZW4gcHBfc2tpcF90b2tlbiBzdGF0ZVxuXG4gIHwgUHBfYnJlYWsgeyBmaXRzOyBicmVha3MgfSAtPlxuICAgIGxldCBiZWZvcmUsIG9mZiwgXyA9IGJyZWFrcyBpblxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiBib3guICopXG4gICAgfCBTb21lIHsgYm94X3R5cGU7IHdpZHRoIH0gLT5cbiAgICAgIGJlZ2luIG1hdGNoIGJveF90eXBlIHdpdGhcbiAgICAgIHwgUHBfaG92Ym94IC0+XG4gICAgICAgIGlmIHNpemUgKyBTdHJpbmcubGVuZ3RoIGJlZm9yZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF9ib3ggLT5cbiAgICAgICAgKCogSGF2ZSB0aGUgbGluZSBqdXN0IGJlZW4gYnJva2VuIGhlcmUgPyAqKVxuICAgICAgICBpZiBzdGF0ZS5wcF9pc19uZXdfbGluZSB0aGVuIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzIGVsc2VcbiAgICAgICAgaWYgc2l6ZSArIFN0cmluZy5sZW5ndGggYmVmb3JlID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoIGVsc2VcbiAgICAgICAgKCogYnJlYWsgdGhlIGxpbmUgaGVyZSBsZWFkcyB0byBuZXcgaW5kZW50YXRpb24gPyAqKVxuICAgICAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA+IHN0YXRlLnBwX21hcmdpbiAtIHdpZHRoICsgb2ZmXG4gICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICAgIGVsc2UgYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfaHZib3ggLT4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICB8IFBwX2ZpdHMgLT4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfdmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgIHwgUHBfaGJveCAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgIHwgUHBfb3Blbl90YWcgdGFnX25hbWUgLT5cbiAgICAgbGV0IG1hcmtlciA9IHN0YXRlLnBwX21hcmtfb3Blbl90YWcgdGFnX25hbWUgaW5cbiAgICAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBtYXJrZXI7XG4gICAgIFN0YWNrLnB1c2ggdGFnX25hbWUgc3RhdGUucHBfbWFya19zdGFja1xuXG4gICB8IFBwX2Nsb3NlX3RhZyAtPlxuICAgICBiZWdpbiBtYXRjaCBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX21hcmtfc3RhY2sgd2l0aFxuICAgICB8IE5vbmUgLT4gKCkgKCogTm8gbW9yZSB0YWcgdG8gY2xvc2UuICopXG4gICAgIHwgU29tZSB0YWdfbmFtZSAtPlxuICAgICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyB0YWdfbmFtZSBpblxuICAgICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyXG4gICAgIGVuZFxuXG5cbigqIFByaW50IGlmIHRva2VuIHNpemUgaXMga25vd24gZWxzZSBwcmludGluZyBpcyBkZWxheWVkLlxuICAgUHJpbnRpbmcgaXMgZGVsYXllZCB3aGVuIHRoZSB0ZXh0IHdhaXRpbmcgaW4gdGhlIHF1ZXVlIHJlcXVpcmVzXG4gICBtb3JlIHJvb20gdG8gZm9ybWF0IHRoYW4gZXhpc3RzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgcmVjIGFkdmFuY2VfbGVmdCBzdGF0ZSA9XG4gIG1hdGNoIFF1ZXVlLnBlZWtfb3B0IHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIE5vIHRva2VucyB0byBwcmludCAqKVxuICB8IFNvbWUgeyBzaXplOyB0b2tlbjsgbGVuZ3RoIH0gLT5cbiAgICBsZXQgcGVuZGluZ19jb3VudCA9IHN0YXRlLnBwX3JpZ2h0X3RvdGFsIC0gc3RhdGUucHBfbGVmdF90b3RhbCBpblxuICAgIGlmIFNpemUuaXNfa25vd24gc2l6ZSB8fCBwZW5kaW5nX2NvdW50ID49IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlbiBiZWdpblxuICAgICAgUXVldWUudGFrZSBzdGF0ZS5wcF9xdWV1ZSB8PiBpZ25vcmU7ICgqIE5vdCBlbXB0eTogd2UgcGVlayBpbnRvIGl0ICopXG4gICAgICBsZXQgc2l6ZSA9IGlmIFNpemUuaXNfa25vd24gc2l6ZSB0aGVuIFNpemUudG9faW50IHNpemUgZWxzZSBwcF9pbmZpbml0eSBpblxuICAgICAgZm9ybWF0X3BwX3Rva2VuIHN0YXRlIHNpemUgdG9rZW47XG4gICAgICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIGxlbmd0aCArIHN0YXRlLnBwX2xlZnRfdG90YWw7XG4gICAgICAoYWR2YW5jZV9sZWZ0IFtAdGFpbGNhbGxdKSBzdGF0ZVxuICAgIGVuZFxuXG5cbigqIFRvIGVucXVldWUgYSB0b2tlbiA6IHRyeSB0byBhZHZhbmNlLiAqKVxubGV0IGVucXVldWVfYWR2YW5jZSBzdGF0ZSB0b2sgPSBwcF9lbnF1ZXVlIHN0YXRlIHRvazsgYWR2YW5jZV9sZWZ0IHN0YXRlXG5cblxuKCogVG8gZW5xdWV1ZSBzdHJpbmdzLiAqKVxubGV0IGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgcyA9XG4gIGVucXVldWVfYWR2YW5jZSBzdGF0ZSB7IHNpemU7IHRva2VuID0gUHBfdGV4dCBzOyBsZW5ndGggPSBTaXplLnRvX2ludCBzaXplIH1cblxuXG5sZXQgZW5xdWV1ZV9zdHJpbmcgc3RhdGUgcyA9XG4gIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIChTaXplLm9mX2ludCAoU3RyaW5nLmxlbmd0aCBzKSkgc1xuXG5cbigqIFJvdXRpbmVzIGZvciBzY2FuIHN0YWNrXG4gICBkZXRlcm1pbmUgc2l6ZSBvZiBib3hlcy4gKilcblxuKCogVGhlIHNjYW5fc3RhY2sgaXMgbmV2ZXIgZW1wdHkuICopXG5sZXQgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHN0YWNrID1cbiAgU3RhY2suY2xlYXIgc3RhY2s7XG4gIGxldCBxdWV1ZV9lbGVtID0geyBzaXplID0gU2l6ZS51bmtub3duOyB0b2tlbiA9IFBwX3RleHQgXCJcIjsgbGVuZ3RoID0gMCB9IGluXG4gIFN0YWNrLnB1c2ggeyBsZWZ0X3RvdGFsID0gLTE7IHF1ZXVlX2VsZW0gfSBzdGFja1xuXG4oKiBTZXR0aW5nIHRoZSBzaXplIG9mIGJveGVzIG9uIHNjYW4gc3RhY2s6XG4gICBpZiB0eSA9IHRydWUgdGhlbiBzaXplIG9mIGJyZWFrIGlzIHNldCBlbHNlIHNpemUgb2YgYm94IGlzIHNldDtcbiAgIGluIGVhY2ggY2FzZSBwcF9zY2FuX3N0YWNrIGlzIHBvcHBlZC5cblxuICAgTm90ZTpcbiAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gc2NhbiBzdGFjayBpcyBleGhhdXN0aXZlLCBzaW5jZSBzY2FuX3N0YWNrIGlzIG5ldmVyXG4gICBlbXB0eS5cbiAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gdG9rZW4gaW4gc2NhbiBzdGFjayBpcyBhbHNvIGV4aGF1c3RpdmUsXG4gICBzaW5jZSBzY2FuX3B1c2ggaXMgdXNlZCBvbiBicmVha3MgYW5kIG9wZW5pbmcgb2YgYm94ZXMuICopXG5sZXQgc2V0X3NpemUgc3RhdGUgdHkgPVxuICBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogc2Nhbl9zdGFjayBpcyBuZXZlciBlbXB0eS4gKilcbiAgfCBTb21lIHsgbGVmdF90b3RhbDsgcXVldWVfZWxlbSB9IC0+XG4gICAgbGV0IHNpemUgPSBTaXplLnRvX2ludCBxdWV1ZV9lbGVtLnNpemUgaW5cbiAgICAoKiB0ZXN0IGlmIHNjYW4gc3RhY2sgY29udGFpbnMgYW55IGRhdGEgdGhhdCBpcyBub3Qgb2Jzb2xldGUuICopXG4gICAgaWYgbGVmdF90b3RhbCA8IHN0YXRlLnBwX2xlZnRfdG90YWwgdGhlblxuICAgICAgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHN0YXRlLnBwX3NjYW5fc3RhY2tcbiAgICBlbHNlXG4gICAgICBtYXRjaCBxdWV1ZV9lbGVtLnRva2VuIHdpdGhcbiAgICAgIHwgUHBfYnJlYWsgXyB8IFBwX3RicmVhayAoXywgXykgLT5cbiAgICAgICAgaWYgdHkgdGhlbiBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uc2l6ZSA8LSBTaXplLm9mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgfD4gaWdub3JlXG4gICAgICAgIGVuZFxuICAgICAgfCBQcF9iZWdpbiAoXywgXykgLT5cbiAgICAgICAgaWYgbm90IHR5IHRoZW4gYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLnNpemUgPC0gU2l6ZS5vZl9pbnQgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgc2l6ZSk7XG4gICAgICAgICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHw+IGlnbm9yZVxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfdGV4dCBfIHwgUHBfc3RhYiB8IFBwX3RiZWdpbiBfIHwgUHBfdGVuZCB8IFBwX2VuZFxuICAgICAgfCBQcF9uZXdsaW5lIHwgUHBfaWZfbmV3bGluZSB8IFBwX29wZW5fdGFnIF8gfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgICAgKCkgKCogc2Nhbl9wdXNoIGlzIG9ubHkgdXNlZCBmb3IgYnJlYWtzIGFuZCBib3hlcy4gKilcblxuXG4oKiBQdXNoIGEgdG9rZW4gb24gcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suXG4gICBJZiBiIGlzIHRydWUgc2V0X3NpemUgaXMgY2FsbGVkLiAqKVxubGV0IHNjYW5fcHVzaCBzdGF0ZSBiIHRva2VuID1cbiAgcHBfZW5xdWV1ZSBzdGF0ZSB0b2tlbjtcbiAgaWYgYiB0aGVuIHNldF9zaXplIHN0YXRlIHRydWU7XG4gIGxldCBlbGVtID0geyBsZWZ0X3RvdGFsID0gc3RhdGUucHBfcmlnaHRfdG90YWw7IHF1ZXVlX2VsZW0gPSB0b2tlbiB9IGluXG4gIFN0YWNrLnB1c2ggZWxlbSBzdGF0ZS5wcF9zY2FuX3N0YWNrXG5cblxuKCogVG8gb3BlbiBhIG5ldyBib3ggOlxuICAgdGhlIHVzZXIgbWF5IHNldCB0aGUgZGVwdGggYm91bmQgcHBfbWF4X2JveGVzXG4gICBhbnkgdGV4dCBuZXN0ZWQgZGVlcGVyIGlzIHByaW50ZWQgYXMgdGhlIGVsbGlwc2lzIHN0cmluZy4gKilcbmxldCBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IGJyX3R5ID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF9iZWdpbiAoaW5kZW50LCBicl90eSk7IGxlbmd0aCA9IDAgfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSBmYWxzZSBlbGVtIGVsc2VcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nIHN0YXRlIHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVGhlIGJveCB3aGljaCBpcyBhbHdheXMgb3Blbi4gKilcbmxldCBwcF9vcGVuX3N5c19ib3ggc3RhdGUgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9ob3Zib3hcblxuKCogQ2xvc2UgYSBib3gsIHNldHRpbmcgc2l6ZXMgb2YgaXRzIHN1YiBib3hlcy4gKilcbmxldCBwcF9jbG9zZV9ib3ggc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSB0aGVuXG4gIGJlZ2luXG4gICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgYmVnaW5cbiAgICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2VuZDsgbGVuZ3RoID0gMCB9O1xuICAgICAgc2V0X3NpemUgc3RhdGUgdHJ1ZTsgc2V0X3NpemUgc3RhdGUgZmFsc2VcbiAgICBlbmQ7XG4gICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMTtcbiAgZW5kXG5cblxuKCogT3BlbiBhIHRhZywgcHVzaGluZyBpdCBvbiB0aGUgdGFnIHN0YWNrLiAqKVxubGV0IHBwX29wZW5fc3RhZyBzdGF0ZSB0YWdfbmFtZSA9XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICBiZWdpblxuICAgIFN0YWNrLnB1c2ggdGFnX25hbWUgc3RhdGUucHBfdGFnX3N0YWNrO1xuICAgIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIHRhZ19uYW1lXG4gIGVuZDtcbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBsZXQgdG9rZW4gPSBQcF9vcGVuX3RhZyB0YWdfbmFtZSBpblxuICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbjsgbGVuZ3RoID0gMCB9XG5cblxuKCogQ2xvc2UgYSB0YWcsIHBvcHBpbmcgaXQgZnJvbSB0aGUgdGFnIHN0YWNrLiAqKVxubGV0IHBwX2Nsb3NlX3N0YWcgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9tYXJrX3RhZ3MgdGhlblxuICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2Nsb3NlX3RhZzsgbGVuZ3RoID0gMCB9O1xuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgICBtYXRjaCBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3RhZ19zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgIHwgU29tZSB0YWdfbmFtZSAtPlxuICAgICAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIHRhZ19uYW1lXG5cbmxldCBwcF9vcGVuX3RhZyBzdGF0ZSBzID0gcHBfb3Blbl9zdGFnIHN0YXRlIChTdHJpbmdfdGFnIHMpXG5sZXQgcHBfY2xvc2VfdGFnIHN0YXRlICgpID0gcHBfY2xvc2Vfc3RhZyBzdGF0ZSAoKVxuXG5sZXQgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYiA9IHN0YXRlLnBwX3ByaW50X3RhZ3MgPC0gYlxubGV0IHBwX3NldF9tYXJrX3RhZ3Mgc3RhdGUgYiA9IHN0YXRlLnBwX21hcmtfdGFncyA8LSBiXG5sZXQgcHBfZ2V0X3ByaW50X3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9wcmludF90YWdzXG5sZXQgcHBfZ2V0X21hcmtfdGFncyBzdGF0ZSAoKSA9IHN0YXRlLnBwX21hcmtfdGFnc1xubGV0IHBwX3NldF90YWdzIHN0YXRlIGIgPVxuICBwcF9zZXRfcHJpbnRfdGFncyBzdGF0ZSBiOyBwcF9zZXRfbWFya190YWdzIHN0YXRlIGJcblxuXG4oKiBIYW5kbGluZyB0YWcgaGFuZGxpbmcgZnVuY3Rpb25zOiBnZXQvc2V0IGZ1bmN0aW9ucy4gKilcbmxldCBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0YXRlICgpID0ge1xuICBtYXJrX29wZW5fc3RhZyA9IHN0YXRlLnBwX21hcmtfb3Blbl90YWc7XG4gIG1hcmtfY2xvc2Vfc3RhZyA9IHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnO1xuICBwcmludF9vcGVuX3N0YWcgPSBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZztcbiAgcHJpbnRfY2xvc2Vfc3RhZyA9IHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZztcbn1cblxuXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGF0ZSB7XG4gICAgIG1hcmtfb3Blbl9zdGFnID0gbW90O1xuICAgICBtYXJrX2Nsb3NlX3N0YWcgPSBtY3Q7XG4gICAgIHByaW50X29wZW5fc3RhZyA9IHBvdDtcbiAgICAgcHJpbnRfY2xvc2Vfc3RhZyA9IHBjdDtcbiAgfSA9XG4gIHN0YXRlLnBwX21hcmtfb3Blbl90YWcgPC0gbW90O1xuICBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyA8LSBtY3Q7XG4gIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIDwtIHBvdDtcbiAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIDwtIHBjdFxuXG5cbigqIEluaXRpYWxpemUgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfcmluaXQgc3RhdGUgPVxuICBwcF9jbGVhcl9xdWV1ZSBzdGF0ZTtcbiAgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHN0YXRlLnBwX3NjYW5fc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX2Zvcm1hdF9zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfdGJveF9zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfdGFnX3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF9tYXJrX3N0YWNrO1xuICBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA8LSAwO1xuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIDA7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfbWFyZ2luO1xuICBwcF9vcGVuX3N5c19ib3ggc3RhdGVcblxubGV0IGNsZWFyX3RhZ19zdGFjayBzdGF0ZSA9XG4gIFN0YWNrLml0ZXIgKGZ1biBfIC0+IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSkgc3RhdGUucHBfdGFnX3N0YWNrXG5cblxuKCogRmx1c2hpbmcgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG5sZXQgcHBfZmx1c2hfcXVldWUgc3RhdGUgYiA9XG4gIGNsZWFyX3RhZ19zdGFjayBzdGF0ZTtcbiAgd2hpbGUgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgZG9cbiAgICBwcF9jbG9zZV9ib3ggc3RhdGUgKClcbiAgZG9uZTtcbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gcHBfaW5maW5pdHk7XG4gIGFkdmFuY2VfbGVmdCBzdGF0ZTtcbiAgaWYgYiB0aGVuIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBwcF9yaW5pdCBzdGF0ZVxuXG4oKlxuXG4gIFByb2NlZHVyZXMgdG8gZm9ybWF0IHZhbHVlcyBhbmQgdXNlIGJveGVzLlxuXG4qKVxuXG4oKiBUbyBmb3JtYXQgYSBzdHJpbmcuICopXG5sZXQgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSBzaXplIHMgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzXG4gIHRoZW4gZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzXG5cblxubGV0IHBwX3ByaW50X2FzIHN0YXRlIGlzaXplIHMgPVxuICBwcF9wcmludF9hc19zaXplIHN0YXRlIChTaXplLm9mX2ludCBpc2l6ZSkgc1xuXG5cbmxldCBwcF9wcmludF9zdHJpbmcgc3RhdGUgcyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIChTdHJpbmcubGVuZ3RoIHMpIHNcblxubGV0IHBwX3ByaW50X2J5dGVzIHN0YXRlIHMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAoQnl0ZXMubGVuZ3RoIHMpIChCeXRlcy50b19zdHJpbmcgcylcblxuKCogVG8gZm9ybWF0IGFuIGludGVnZXIuICopXG5sZXQgcHBfcHJpbnRfaW50IHN0YXRlIGkgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKEludC50b19zdHJpbmcgaSlcblxuKCogVG8gZm9ybWF0IGEgZmxvYXQuICopXG5sZXQgcHBfcHJpbnRfZmxvYXQgc3RhdGUgZiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Zsb2F0IGYpXG5cbigqIFRvIGZvcm1hdCBhIGJvb2xlYW4uICopXG5sZXQgcHBfcHJpbnRfYm9vbCBzdGF0ZSBiID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfYm9vbCBiKVxuXG4oKiBUbyBmb3JtYXQgYSBjaGFyLiAqKVxubGV0IHBwX3ByaW50X2NoYXIgc3RhdGUgYyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIDEgKFN0cmluZy5tYWtlIDEgYylcblxuXG4oKiBPcGVuaW5nIGJveGVzLiAqKVxubGV0IHBwX29wZW5faGJveCBzdGF0ZSAoKSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hib3hcbmFuZCBwcF9vcGVuX3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF92Ym94XG5cbmFuZCBwcF9vcGVuX2h2Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfaHZib3hcbmFuZCBwcF9vcGVuX2hvdmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2hvdmJveFxuYW5kIHBwX29wZW5fYm94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfYm94XG5cblxuKCogUHJpbnRpbmcgcXVldWVkIHRleHQuXG5cbiAgIFtwcF9wcmludF9mbHVzaF0gcHJpbnRzIGFsbCBwZW5kaW5nIGl0ZW1zIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhbmRcbiAgIHRoZW4gZmx1c2hlcyB0aGUgbG93IGxldmVsIG91dHB1dCBkZXZpY2Ugb2YgdGhlIGZvcm1hdHRlciB0byBhY3R1YWxseVxuICAgZGlzcGxheSBwcmludGluZyBtYXRlcmlhbC5cblxuICAgW3BwX3ByaW50X25ld2xpbmVdIGJlaGF2ZXMgYXMgW3BwX3ByaW50X2ZsdXNoXSBhZnRlciBwcmludGluZyBhbiBhZGRpdGlvbmFsXG4gICBuZXcgbGluZS4gKilcbmxldCBwcF9wcmludF9uZXdsaW5lIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgdHJ1ZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5hbmQgcHBfcHJpbnRfZmx1c2ggc3RhdGUgKCkgPVxuICBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSBmYWxzZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5cblxuKCogVG8gZ2V0IGEgbmV3bGluZSB3aGVuIG9uZSBkb2VzIG5vdCB3YW50IHRvIGNsb3NlIHRoZSBjdXJyZW50IGJveC4gKilcbmxldCBwcF9mb3JjZV9uZXdsaW5lIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBUbyBmb3JtYXQgc29tZXRoaW5nLCBvbmx5IGluIGNhc2UgdGhlIGxpbmUgaGFzIGp1c3QgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfcHJpbnRfaWZfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZVxuICAgICAgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2lmX25ld2xpbmU7IGxlbmd0aCA9IDAgfVxuXG5cbigqIEdlbmVyYWxpemVkIGJyZWFrIGhpbnQgdGhhdCBhbGxvd3MgcHJpbnRpbmcgc3RyaW5ncyBiZWZvcmUvYWZ0ZXJcbiAgIHNhbWUtbGluZSBvZmZzZXQgKHdpZHRoKSBvciBuZXctbGluZSBvZmZzZXQgKilcbmxldCBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGUgfmZpdHMgfmJyZWFrcyA9XG4gIGxldCBiZWZvcmUsIHdpZHRoLCBhZnRlciA9IGZpdHMgaW5cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgdG9rZW4gPSBQcF9icmVhayB7IGZpdHM7IGJyZWFrcyB9IGluXG4gICAgbGV0IGxlbmd0aCA9IFN0cmluZy5sZW5ndGggYmVmb3JlICsgd2lkdGggKyBTdHJpbmcubGVuZ3RoIGFmdGVyIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuOyBsZW5ndGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuKCogUHJpbnRpbmcgYnJlYWsgaGludHM6XG4gICBBIGJyZWFrIGhpbnQgaW5kaWNhdGVzIHdoZXJlIGEgYm94IG1heSBiZSBicm9rZW4uXG4gICBJZiBsaW5lIGlzIGJyb2tlbiB0aGVuIG9mZnNldCBpcyBhZGRlZCB0byB0aGUgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnRcbiAgIGJveCBlbHNlICh0aGUgdmFsdWUgb2YpIHdpZHRoIGJsYW5rcyBhcmUgcHJpbnRlZC4gKilcbmxldCBwcF9wcmludF9icmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGVcbiAgICB+Zml0czooXCJcIiwgd2lkdGgsIFwiXCIpIH5icmVha3M6KFwiXCIsIG9mZnNldCwgXCJcIilcblxuXG4oKiBQcmludCBhIHNwYWNlIDpcbiAgIGEgc3BhY2UgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIGEgc2luZ2xlIHNwYWNlIGlmIHRoZSBicmVhayBkb2VzIG5vdFxuICAgc3BsaXQgdGhlIGxpbmU7XG4gICBhIGN1dCBpcyBhIGJyZWFrIGhpbnQgdGhhdCBwcmludHMgbm90aGluZyBpZiB0aGUgYnJlYWsgZG9lcyBub3Qgc3BsaXQgdGhlXG4gICBsaW5lLiAqKVxubGV0IHBwX3ByaW50X3NwYWNlIHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMSAwXG5hbmQgcHBfcHJpbnRfY3V0IHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMCAwXG5cblxuKCogVGFidWxhdGlvbiBib3hlcy4gKilcbmxldCBwcF9vcGVuX3Rib3ggc3RhdGUgKCkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUuemVybyBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RiZWdpbiAoUHBfdGJveCAocmVmIFtdKSk7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCogQ2xvc2UgYSB0YWJ1bGF0aW9uIGJveC4gKilcbmxldCBwcF9jbG9zZV90Ym94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3RlbmQ7IGxlbmd0aCA9IDAgfSBpblxuICAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbTtcbiAgICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMVxuICBlbmRcblxuXG4oKiBQcmludCBhIHRhYnVsYXRpb24gYnJlYWsuICopXG5sZXQgcHBfcHJpbnRfdGJyZWFrIHN0YXRlIHdpZHRoIG9mZnNldCA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfdGJyZWFrICh3aWR0aCwgb2Zmc2V0KTsgbGVuZ3RoID0gd2lkdGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuXG5sZXQgcHBfcHJpbnRfdGFiIHN0YXRlICgpID0gcHBfcHJpbnRfdGJyZWFrIHN0YXRlIDAgMFxuXG5sZXQgcHBfc2V0X3RhYiBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3N0YWI7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGNvbnRyb2wgdGhlIHByZXR0eS1wcmludGVyc1xuXG4qKVxuXG4oKiBTZXRfbWF4X2JveGVzLiAqKVxubGV0IHBwX3NldF9tYXhfYm94ZXMgc3RhdGUgbiA9IGlmIG4gPiAxIHRoZW4gc3RhdGUucHBfbWF4X2JveGVzIDwtIG5cblxuKCogVG8ga25vdyB0aGUgY3VycmVudCBtYXhpbXVtIG51bWJlciBvZiBib3hlcyBhbGxvd2VkLiAqKVxubGV0IHBwX2dldF9tYXhfYm94ZXMgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxubGV0IHBwX292ZXJfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuXG4oKiBFbGxpcHNpcy4gKilcbmxldCBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSBzID0gc3RhdGUucHBfZWxsaXBzaXMgPC0gc1xuYW5kIHBwX2dldF9lbGxpcHNpc190ZXh0IHN0YXRlICgpID0gc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUbyBzZXQgdGhlIG1hcmdpbiBvZiBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9saW1pdCBuID1cbiAgaWYgbiA8IHBwX2luZmluaXR5IHRoZW4gbiBlbHNlIHByZWQgcHBfaW5maW5pdHlcblxuXG4oKiBJbnRlcm5hbCBwcmV0dHktcHJpbnRlciBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X21pbl9zcGFjZV9sZWZ0IHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0IDwtIG47XG4gICAgc3RhdGUucHBfbWF4X2luZGVudCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9yaW5pdCBzdGF0ZVxuXG5cbigqIEluaXRpYWxseSwgd2UgaGF2ZSA6XG4gICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQsIGFuZFxuICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbi4gKilcbmxldCBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuID1cbiAgaWYgbiA+IDEgdGhlblxuICAgIHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSAoc3RhdGUucHBfbWFyZ2luIC0gbilcblxuXG5sZXQgcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfaW5kZW50XG5cbmxldCBwcF9zZXRfbWFyZ2luIHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21hcmdpbiA8LSBuO1xuICAgIGxldCBuZXdfbWF4X2luZGVudCA9XG4gICAgICAoKiBUcnkgdG8gbWFpbnRhaW4gbWF4X2luZGVudCB0byBpdHMgYWN0dWFsIHZhbHVlLiAqKVxuICAgICAgaWYgc3RhdGUucHBfbWF4X2luZGVudCA8PSBzdGF0ZS5wcF9tYXJnaW5cbiAgICAgIHRoZW4gc3RhdGUucHBfbWF4X2luZGVudCBlbHNlXG4gICAgICAoKiBJZiBwb3NzaWJsZSBtYWludGFpbiBwcF9taW5fc3BhY2VfbGVmdCB0byBpdHMgYWN0dWFsIHZhbHVlLFxuICAgICAgICAgaWYgdGhpcyBsZWFkcyB0byBhIHRvbyBzbWFsbCBtYXhfaW5kZW50LCB0YWtlIGhhbGYgb2YgdGhlXG4gICAgICAgICBuZXcgbWFyZ2luLCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gMS4gKilcbiAgICAgICBJbnQubWF4IChJbnQubWF4IChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdClcbiAgICAgICAgICAgICAgICAoc3RhdGUucHBfbWFyZ2luIC8gMikpIDEgaW5cbiAgICAoKiBSZWJ1aWxkIGludmFyaWFudHMuICopXG4gICAgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbmV3X21heF9pbmRlbnRcblxuXG4oKiogR2VvbWV0cnkgZnVuY3Rpb25zIGFuZCB0eXBlcyAqKVxudHlwZSBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDppbnQ7IG1hcmdpbjogaW50fVxuXG5sZXQgdmFsaWRhdGVfZ2VvbWV0cnkge21hcmdpbjsgbWF4X2luZGVudH0gPVxuICBpZiBtYXhfaW5kZW50IDwgMiB0aGVuXG4gICAgRXJyb3IgXCJtYXhfaW5kZW50IDwgMlwiXG4gIGVsc2UgaWYgbWFyZ2luIDw9IG1heF9pbmRlbnQgdGhlblxuICAgIEVycm9yIFwibWFyZ2luIDw9IG1heF9pbmRlbnRcIlxuICBlbHNlIE9rICgpXG5cbmxldCBjaGVja19nZW9tZXRyeSBnZW9tZXRyeSA9XG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBPayAoKSAtPiB0cnVlXG4gIHwgRXJyb3IgXyAtPiBmYWxzZVxuXG5sZXQgcHBfZ2V0X21hcmdpbiBzdGF0ZSAoKSA9IHN0YXRlLnBwX21hcmdpblxuXG5sZXQgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUge21hcmdpbjsgbWF4X2luZGVudH0gPVxuICBwcF9zZXRfbWFyZ2luIHN0YXRlIG1hcmdpbjtcbiAgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbWF4X2luZGVudDtcbiAgKClcblxubGV0IHBwX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgbGV0IGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OyBtYXJnaW4gfSBpblxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgRXJyb3IgbXNnIC0+XG4gICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgKFwiRm9ybWF0LnBwX3NldF9nZW9tZXRyeTogXCIgXiBtc2cpKVxuICB8IE9rICgpIC0+XG4gICAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgZ2VvbWV0cnlcblxubGV0IHBwX3NhZmVfc2V0X2dlb21ldHJ5IHN0YXRlIH5tYXhfaW5kZW50IH5tYXJnaW4gPVxuICBsZXQgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ7IG1hcmdpbiB9IGluXG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBFcnJvciBfbXNnIC0+XG4gICAgICgpXG4gIHwgT2sgKCkgLT5cbiAgICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSBnZW9tZXRyeVxuXG5sZXQgcHBfZ2V0X2dlb21ldHJ5IHN0YXRlICgpID1cbiAgeyBtYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0YXRlICgpOyBtYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgfVxuXG5sZXQgcHBfdXBkYXRlX2dlb21ldHJ5IHN0YXRlIHVwZGF0ZSA9XG4gIGxldCBnZW9tZXRyeSA9IHBwX2dldF9nZW9tZXRyeSBzdGF0ZSAoKSBpblxuICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSAodXBkYXRlIGdlb21ldHJ5KVxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgIG91dF9zdHJpbmcgPSBmO1xuICAgICAgb3V0X2ZsdXNoID0gZztcbiAgICAgIG91dF9uZXdsaW5lID0gaDtcbiAgICAgIG91dF9zcGFjZXMgPSBpO1xuICAgICAgb3V0X2luZGVudCA9IGo7XG4gICAgfSA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjtcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGc7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGg7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gaTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBqXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG91dF9zdHJpbmcgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nO1xuICBvdXRfZmx1c2ggPSBzdGF0ZS5wcF9vdXRfZmx1c2g7XG4gIG91dF9uZXdsaW5lID0gc3RhdGUucHBfb3V0X25ld2xpbmU7XG4gIG91dF9zcGFjZXMgPSBzdGF0ZS5wcF9vdXRfc3BhY2VzO1xuICBvdXRfaW5kZW50ID0gc3RhdGUucHBfb3V0X2luZGVudDtcbn1cblxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIHN0cmluZyBvdXRwdXQgYW5kIGZsdXNoIGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmOyBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZ1xuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaClcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfbmV3bGluZSBzdGF0ZSAoKSA9IHN0YXRlLnBwX291dF9zdHJpbmcgXCJcXG5cIiAwICAxXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBzcGFjZXMuICopXG5sZXQgYmxhbmtfbGluZSA9IFN0cmluZy5tYWtlIDgwICcgJ1xubGV0IHJlYyBkaXNwbGF5X2JsYW5rcyBzdGF0ZSBuID1cbiAgaWYgbiA+IDAgdGhlblxuICBpZiBuIDw9IDgwIHRoZW4gc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgbiBlbHNlXG4gIGJlZ2luXG4gICAgc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgODA7XG4gICAgZGlzcGxheV9ibGFua3Mgc3RhdGUgKG4gLSA4MClcbiAgZW5kXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X2luZGVudCA9IGRpc3BsYXlfYmxhbmtzXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucyBhcyBwcmludGluZyB0byBhIGdpdmVuXG4gICBbUGVydmFzaXZlLm91dF9jaGFubmVsXSB2YWx1ZS4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0YXRlIG9jID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBvdXRwdXRfc3Vic3RyaW5nIG9jO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gKGZ1biAoKSAtPiBmbHVzaCBvYyk7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGRpc3BsYXlfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBzdGF0ZVxuXG4oKlxuXG4gIERlZmluaW5nIHNwZWNpZmljIGZvcm1hdHRlcnNcblxuKilcblxubGV0IGRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPFwiIF4gcyBeIFwiPlwiXG4gIHwgXyAtPiBcIlwiXG5sZXQgZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPC9cIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxuXG5sZXQgZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyA9IGlnbm9yZVxubGV0IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnID0gaWdub3JlXG5cbigqIEJ1aWxkaW5nIGEgZm9ybWF0dGVyIGdpdmVuIGl0cyBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLlxuICAgT3RoZXIgZmllbGRzIGdldCByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWVzLiAqKVxubGV0IHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgaiA9XG4gICgqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBmb3JtYXR0ZXIgY29udGFpbnMgYSBkdW1teSBib3guICopXG4gIGxldCBwcF9xdWV1ZSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICBsZXQgc3lzX3RvayA9XG4gICAgeyBzaXplID0gU2l6ZS51bmtub3duOyB0b2tlbiA9IFBwX2JlZ2luICgwLCBQcF9ob3Zib3gpOyBsZW5ndGggPSAwIH0gaW5cbiAgUXVldWUuYWRkIHN5c190b2sgcHBfcXVldWU7XG4gIGxldCBzY2FuX3N0YWNrID0gU3RhY2suY3JlYXRlICgpIGluXG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzY2FuX3N0YWNrO1xuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IDE7IHF1ZXVlX2VsZW0gPSBzeXNfdG9rIH0gc2Nhbl9zdGFjaztcbiAgbGV0IHBwX21hcmdpbiA9IDc4XG4gIGFuZCBwcF9taW5fc3BhY2VfbGVmdCA9IDEwIGluXG4gIHtcbiAgICBwcF9zY2FuX3N0YWNrID0gc2Nhbl9zdGFjaztcbiAgICBwcF9mb3JtYXRfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGJveF9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF90YWdfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFya19zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF9tYXJnaW4gPSBwcF9tYXJnaW47XG4gICAgcHBfbWluX3NwYWNlX2xlZnQgPSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbjtcbiAgICBwcF9jdXJyZW50X2luZGVudCA9IDA7XG4gICAgcHBfaXNfbmV3X2xpbmUgPSB0cnVlO1xuICAgIHBwX2xlZnRfdG90YWwgPSAxO1xuICAgIHBwX3JpZ2h0X3RvdGFsID0gMTtcbiAgICBwcF9jdXJyX2RlcHRoID0gMTtcbiAgICBwcF9tYXhfYm94ZXMgPSBtYXhfaW50O1xuICAgIHBwX2VsbGlwc2lzID0gXCIuXCI7XG4gICAgcHBfb3V0X3N0cmluZyA9IGY7XG4gICAgcHBfb3V0X2ZsdXNoID0gZztcbiAgICBwcF9vdXRfbmV3bGluZSA9IGg7XG4gICAgcHBfb3V0X3NwYWNlcyA9IGk7XG4gICAgcHBfb3V0X2luZGVudCA9IGo7XG4gICAgcHBfcHJpbnRfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfb3Blbl90YWcgPSBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWc7XG4gICAgcHBfbWFya19jbG9zZV90YWcgPSBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnO1xuICAgIHBwX3ByaW50X29wZW5fdGFnID0gZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZztcbiAgICBwcF9wcmludF9jbG9zZV90YWcgPSBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZztcbiAgICBwcF9xdWV1ZSA9IHBwX3F1ZXVlO1xuICB9XG5cblxuKCogQnVpbGQgYSBmb3JtYXR0ZXIgb3V0IG9mIGl0cyBvdXQgZnVuY3Rpb25zLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIG91dF9mdW5zID1cbiAgcHBfbWFrZV9mb3JtYXR0ZXJcbiAgICBvdXRfZnVucy5vdXRfc3RyaW5nXG4gICAgb3V0X2Z1bnMub3V0X2ZsdXNoXG4gICAgb3V0X2Z1bnMub3V0X25ld2xpbmVcbiAgICBvdXRfZnVucy5vdXRfc3BhY2VzXG4gICAgb3V0X2Z1bnMub3V0X2luZGVudFxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd2l0aCBkZWZhdWx0IGZ1bmN0aW9ucyB0byBvdXRwdXQgc3BhY2VzLFxuICBpbmRlbnRhdGlvbiwgYW5kIG5ldyBsaW5lcy4gKilcbmxldCBtYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggPVxuICBsZXQgcHBmID0gcHBfbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoIGlnbm9yZSBpZ25vcmUgaWdub3JlIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgcHBmXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9jaGFubmVsIG9jID1cbiAgbWFrZV9mb3JtYXR0ZXIgKG91dHB1dF9zdWJzdHJpbmcgb2MpIChmdW4gKCkgLT4gZmx1c2ggb2MpXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW0J1ZmZlci50XSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgPVxuICBtYWtlX2Zvcm1hdHRlciAoQnVmZmVyLmFkZF9zdWJzdHJpbmcgYikgaWdub3JlXG5cblxuKCogQWxsb2NhdGluZyBidWZmZXIgZm9yIHByZXR0eS1wcmludGluZyBwdXJwb3Nlcy5cbiAgIERlZmF1bHQgYnVmZmVyIHNpemUgaXMgcHBfYnVmZmVyX3NpemUgb3IgNTEyLlxuKilcbmxldCBwcF9idWZmZXJfc2l6ZSA9IDUxMlxubGV0IHBwX21ha2VfYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZVxuXG4oKiBUaGUgc3RhbmRhcmQgKHNoYXJlZCkgYnVmZmVyLiAqKVxubGV0IHN0ZGJ1ZiA9IHBwX21ha2VfYnVmZmVyICgpXG5cbigqIFByZWRlZmluZWQgZm9ybWF0dGVycyBzdGFuZGFyZCBmb3JtYXR0ZXIgdG8gcHJpbnRcbiAgIHRvIFtTdGRsaWIuc3Rkb3V0XSwgW1N0ZGxpYi5zdGRlcnJdLCBhbmQgeyFzdGRidWZ9LiAqKVxubGV0IHN0ZF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZG91dFxuYW5kIGVycl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZGVyclxuYW5kIHN0cl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIHN0ZGJ1ZlxuXG5cbigqIFtmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGZdIGZsdXNoZXMgZm9ybWF0dGVyIFtwcGZdLFxuICAgdGhlbiByZXR1cm5zIHRoZSBjb250ZW50cyBvZiBidWZmZXIgW2J1Zl0gdGhhdCBpcyByZXNldC5cbiAgIEZvcm1hdHRlciBbcHBmXSBpcyBzdXBwb3NlZCB0byBwcmludCB0byBidWZmZXIgW2J1Zl0sIG90aGVyd2lzZSB0aGlzXG4gICBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IHVzZWZ1bC4gKilcbmxldCBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGYgPVxuICBwcF9mbHVzaF9xdWV1ZSBwcGYgZmFsc2U7XG4gIGxldCBzID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZiBpblxuICBCdWZmZXIucmVzZXQgYnVmO1xuICBzXG5cblxuKCogRmx1c2ggW3N0cl9mb3JtYXR0ZXJdIGFuZCBnZXQgdGhlIGNvbnRlbnRzIG9mIFtzdGRidWZdLiAqKVxubGV0IGZsdXNoX3N0cl9mb3JtYXR0ZXIgKCkgPSBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIHN0ZGJ1ZiBzdHJfZm9ybWF0dGVyXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZ1xuKilcblxuKCpcbiAgU3ltYm9saWMgcHJldHR5LXByaW50aW5nIGlzIHByZXR0eS1wcmludGluZyB3aXRoIG5vIGxvdyBsZXZlbCBvdXRwdXQuXG5cbiAgV2hlbiB1c2luZyBhIHN5bWJvbGljIGZvcm1hdHRlciwgYWxsIHJlZ3VsYXIgcHJldHR5LXByaW50aW5nIGFjdGl2aXRpZXNcbiAgb2NjdXIgYnV0IG91dHB1dCBtYXRlcmlhbCBpcyBzeW1ib2xpYyBhbmQgc3RvcmVkIGluIGEgYnVmZmVyIG9mIG91dHB1dFxuICBpdGVtcy4gQXQgdGhlIGVuZCBvZiBwcmV0dHktcHJpbnRpbmcsIGZsdXNoaW5nIHRoZSBvdXRwdXQgYnVmZmVyIGFsbG93c1xuICBwb3N0LXByb2Nlc3Npbmcgb2Ygc3ltYm9saWMgb3V0cHV0IGJlZm9yZSBsb3cgbGV2ZWwgb3V0cHV0IG9wZXJhdGlvbnMuXG4qKVxuXG50eXBlIHN5bWJvbGljX291dHB1dF9pdGVtID1cbiAgfCBPdXRwdXRfZmx1c2hcbiAgfCBPdXRwdXRfbmV3bGluZVxuICB8IE91dHB1dF9zdHJpbmcgb2Ygc3RyaW5nXG4gIHwgT3V0cHV0X3NwYWNlcyBvZiBpbnRcbiAgfCBPdXRwdXRfaW5kZW50IG9mIGludFxuXG50eXBlIHN5bWJvbGljX291dHB1dF9idWZmZXIgPSB7XG4gIG11dGFibGUgc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDogc3ltYm9saWNfb3V0cHV0X2l0ZW0gbGlzdDtcbn1cblxubGV0IG1ha2Vfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciAoKSA9XG4gIHsgc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzID0gW10gfVxuXG5sZXQgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIFtdXG5cbmxldCBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBMaXN0LnJldiBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzXG5cbmxldCBmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIGxldCBpdGVtcyA9IGdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiBpblxuICBjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYjtcbiAgaXRlbXNcblxubGV0IGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgaXRlbSA9XG4gIHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHMgPC0gaXRlbSA6OiBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzXG5cbmxldCBmb3JtYXR0ZXJfb2Zfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgc3ltYm9saWNfZmx1c2ggc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9mbHVzaFxuICBhbmQgc3ltYm9saWNfbmV3bGluZSBzb2IgKCkgPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgT3V0cHV0X25ld2xpbmVcbiAgYW5kIHN5bWJvbGljX3N0cmluZyBzb2IgcyBpIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9zdHJpbmcgKFN0cmluZy5zdWIgcyBpIG4pKVxuICBhbmQgc3ltYm9saWNfc3BhY2VzIHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3BhY2VzIG4pXG4gIGFuZCBzeW1ib2xpY19pbmRlbnQgc29iIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9pbmRlbnQgbikgaW5cblxuICBsZXQgZiA9IHN5bWJvbGljX3N0cmluZyBzb2JcbiAgYW5kIGcgPSBzeW1ib2xpY19mbHVzaCBzb2JcbiAgYW5kIGggPSBzeW1ib2xpY19uZXdsaW5lIHNvYlxuICBhbmQgaSA9IHN5bWJvbGljX3NwYWNlcyBzb2JcbiAgYW5kIGogPSBzeW1ib2xpY19pbmRlbnQgc29iIGluXG4gIHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgalxuXG4oKlxuXG4gIEJhc2ljIGZ1bmN0aW9ucyBvbiB0aGUgJ3N0YW5kYXJkJyBmb3JtYXR0ZXJcbiAgKHRoZSBmb3JtYXR0ZXIgdGhhdCBwcmludHMgdG8gW1N0ZGxpYi5zdGRvdXRdKS5cblxuKilcblxubGV0IG9wZW5faGJveCA9IHBwX29wZW5faGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl92Ym94ID0gcHBfb3Blbl92Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2h2Ym94ID0gcHBfb3Blbl9odmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9ob3Zib3ggPSBwcF9vcGVuX2hvdmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9ib3ggPSBwcF9vcGVuX2JveCBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfYm94ID0gcHBfY2xvc2VfYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3RhZyA9IHBwX29wZW5fdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV90YWcgPSBwcF9jbG9zZV90YWcgc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fc3RhZyA9IHBwX29wZW5fc3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2Vfc3RhZyA9IHBwX2Nsb3NlX3N0YWcgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2FzID0gcHBfcHJpbnRfYXMgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3N0cmluZyA9IHBwX3ByaW50X3N0cmluZyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYnl0ZXMgPSBwcF9wcmludF9ieXRlcyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfaW50ID0gcHBfcHJpbnRfaW50IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9mbG9hdCA9IHBwX3ByaW50X2Zsb2F0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9jaGFyID0gcHBfcHJpbnRfY2hhciBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYm9vbCA9IHBwX3ByaW50X2Jvb2wgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2JyZWFrID0gcHBfcHJpbnRfYnJlYWsgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2N1dCA9IHBwX3ByaW50X2N1dCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfc3BhY2UgPSBwcF9wcmludF9zcGFjZSBzdGRfZm9ybWF0dGVyXG5hbmQgZm9yY2VfbmV3bGluZSA9IHBwX2ZvcmNlX25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2ZsdXNoID0gcHBfcHJpbnRfZmx1c2ggc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X25ld2xpbmUgPSBwcF9wcmludF9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9pZl9uZXdsaW5lID0gcHBfcHJpbnRfaWZfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5cbmFuZCBvcGVuX3Rib3ggPSBwcF9vcGVuX3Rib3ggc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3Rib3ggPSBwcF9jbG9zZV90Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF90YnJlYWsgPSBwcF9wcmludF90YnJlYWsgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X3RhYiA9IHBwX3NldF90YWIgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3RhYiA9IHBwX3ByaW50X3RhYiBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWFyZ2luID0gcHBfc2V0X21hcmdpbiBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21hcmdpbiA9IHBwX2dldF9tYXJnaW4gc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21heF9pbmRlbnQgPSBwcF9zZXRfbWF4X2luZGVudCBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21heF9pbmRlbnQgPSBwcF9nZXRfbWF4X2luZGVudCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZ2VvbWV0cnkgPSBwcF9zZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIHNhZmVfc2V0X2dlb21ldHJ5ID0gcHBfc2FmZV9zZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9nZW9tZXRyeSA9IHBwX2dldF9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5hbmQgdXBkYXRlX2dlb21ldHJ5ID0gcHBfdXBkYXRlX2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXhfYm94ZXMgPSBwcF9zZXRfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWF4X2JveGVzID0gcHBfZ2V0X21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5hbmQgb3Zlcl9tYXhfYm94ZXMgPSBwcF9vdmVyX21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZWxsaXBzaXNfdGV4dCA9IHBwX3NldF9lbGxpcHNpc190ZXh0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZWxsaXBzaXNfdGV4dCA9IHBwX2dldF9lbGxpcHNpc190ZXh0IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X3ByaW50X3RhZ3MgPVxuICBwcF9zZXRfcHJpbnRfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X3ByaW50X3RhZ3MgPVxuICBwcF9nZXRfcHJpbnRfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X21hcmtfdGFncyA9XG4gIHBwX3NldF9tYXJrX3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXJrX3RhZ3MgPVxuICBwcF9nZXRfbWFya190YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfdGFncyA9XG4gIHBwX3NldF90YWdzIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBDb252ZW5pZW5jZSBmdW5jdGlvbnMgKilcblxuKCogVG8gZm9ybWF0IGEgbGlzdCAqKVxubGV0IHJlYyBwcF9wcmludF9saXN0ID8ocHBfc2VwID0gcHBfcHJpbnRfY3V0KSBwcF92IHBwZiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKClcbiAgfCBbdl0gLT4gcHBfdiBwcGYgdlxuICB8IHYgOjogdnMgLT5cbiAgICBwcF92IHBwZiB2O1xuICAgIHBwX3NlcCBwcGYgKCk7XG4gICAgcHBfcHJpbnRfbGlzdCB+cHBfc2VwIHBwX3YgcHBmIHZzXG5cbigqIFRvIGZvcm1hdCBhIHNlcXVlbmNlICopXG5sZXQgcmVjIHBwX3ByaW50X3NlcV9pbiB+cHBfc2VwIHBwX3YgcHBmIHNlcSA9XG4gIG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgU2VxLk5pbCAtPiAoKVxuICB8IFNlcS5Db25zICh2LCBzZXEpIC0+XG4gICAgcHBfc2VwIHBwZiAoKTtcbiAgICBwcF92IHBwZiB2O1xuICAgIHBwX3ByaW50X3NlcV9pbiB+cHBfc2VwIHBwX3YgcHBmIHNlcVxuXG5sZXQgcHBfcHJpbnRfc2VxID8ocHBfc2VwID0gcHBfcHJpbnRfY3V0KSBwcF92IHBwZiBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IFNlcS5OaWwgLT4gKClcbiAgfCBTZXEuQ29ucyAodiwgc2VxKSAtPlxuICAgIHBwX3YgcHBmIHY7XG4gICAgcHBfcHJpbnRfc2VxX2luIH5wcF9zZXAgcHBfdiBwcGYgc2VxXG5cbigqIFRvIGZvcm1hdCBmcmVlLWZsb3dpbmcgdGV4dCAqKVxubGV0IHBwX3ByaW50X3RleHQgcHBmIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBsZWZ0ID0gcmVmIDAgaW5cbiAgbGV0IHJpZ2h0ID0gcmVmIDAgaW5cbiAgbGV0IGZsdXNoICgpID1cbiAgICBwcF9wcmludF9zdHJpbmcgcHBmIChTdHJpbmcuc3ViIHMgIWxlZnQgKCFyaWdodCAtICFsZWZ0KSk7XG4gICAgaW5jciByaWdodDsgbGVmdCA6PSAhcmlnaHQ7XG4gIGluXG4gIHdoaWxlICghcmlnaHQgPD4gbGVuKSBkb1xuICAgIG1hdGNoIHMuWyFyaWdodF0gd2l0aFxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBmbHVzaCAoKTtcbiAgICAgICAgcHBfZm9yY2VfbmV3bGluZSBwcGYgKClcbiAgICAgIHwgJyAnIC0+XG4gICAgICAgIGZsdXNoICgpOyBwcF9wcmludF9zcGFjZSBwcGYgKClcbiAgICAgICgqIHRoZXJlIGlzIG5vIHNwZWNpZmljIHN1cHBvcnQgZm9yICdcXHQnXG4gICAgICAgICBhcyBpdCBpcyB1bmNsZWFyIHdoYXQgYSByaWdodCBzZW1hbnRpY3Mgd291bGQgYmUgKilcbiAgICAgIHwgXyAtPiBpbmNyIHJpZ2h0XG4gIGRvbmU7XG4gIGlmICFsZWZ0IDw+IGxlbiB0aGVuIGZsdXNoICgpXG5cbmxldCBwcF9wcmludF9vcHRpb24gPyhub25lID0gZnVuIF8gKCkgLT4gKCkpIHBwX3YgcHBmID0gZnVuY3Rpb25cbnwgTm9uZSAtPiBub25lIHBwZiAoKVxufCBTb21lIHYgLT4gcHBfdiBwcGYgdlxuXG5sZXQgcHBfcHJpbnRfcmVzdWx0IH5vayB+ZXJyb3IgcHBmID0gZnVuY3Rpb25cbnwgT2sgdiAtPiBvayBwcGYgdlxufCBFcnJvciBlIC0+IGVycm9yIHBwZiBlXG5cbmxldCBwcF9wcmludF9laXRoZXIgfmxlZnQgfnJpZ2h0IHBwZiA9IGZ1bmN0aW9uXG58IEVpdGhlci5MZWZ0IGwgLT4gbGVmdCBwcGYgbFxufCBFaXRoZXIuUmlnaHQgciAtPiByaWdodCBwcGYgclxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5sZXQgY29tcHV0ZV90YWcgb3V0cHV0IHRhZ19hY2MgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxNiBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBidWYgaW5cbiAgb3V0cHV0IHBwZiB0YWdfYWNjO1xuICBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIGxldCBsZW4gPSBCdWZmZXIubGVuZ3RoIGJ1ZiBpblxuICBpZiBsZW4gPCAyIHRoZW4gQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICBlbHNlIEJ1ZmZlci5zdWIgYnVmIDEgKGxlbiAtIDIpXG5cbiAoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBEZWZpbmluZyBjb250aW51YXRpb25zIHRvIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMgb2ZcbiAgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLlxuXG4gICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxuKCogSW50ZXJwcmV0IGEgZm9ybWF0dGluZyBlbnRpdHkgb24gYSBmb3JtYXR0ZXIuICopXG5sZXQgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmbXRpbmdfbGl0ID0gbWF0Y2ggZm10aW5nX2xpdCB3aXRoXG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAtPiBwcF9jbG9zZV9ib3ggcHBmICgpXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAtPiBwcF9jbG9zZV90YWcgcHBmICgpXG4gIHwgQnJlYWsgKF8sIHdpZHRoLCBvZmZzZXQpICAtPiBwcF9wcmludF9icmVhayBwcGYgd2lkdGggb2Zmc2V0XG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9mbHVzaCBwcGYgKClcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgIC0+IHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9wcmludF9uZXdsaW5lIHBwZiAoKVxuICB8IE1hZ2ljX3NpemUgKF8sIF8pICAgICAgICAgLT4gKClcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICdAJ1xuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJyUnXG4gIHwgU2Nhbl9pbmRpYyBjICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCc7IHBwX3ByaW50X2NoYXIgcHBmIGNcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogRGlmZmVyIGZyb20gUHJpbnRmLm91dHB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mIGZvcm1hdHRpbmcuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBwcGYgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoU3RyaW5nLm1ha2UgMSBjKTtcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGYpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGY7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX29wZW5fc3RhZyBwcGYgKFN0cmluZ190YWcgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJykpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgZiBwcGY7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogRGlmZmVyIGZyb20gUHJpbnRmLmJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mIGZvcm1hdHRpbmcuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi4gKilcbmxldCByZWMgc3RycHV0X2FjYyBwcGYgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoU3RyaW5nLm1ha2UgMSBjKTtcbiAgfCBBY2NfZGVsYXkgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIChmICgpKTtcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGYpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGY7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX29wZW5fc3RhZyBwcGYgKFN0cmluZ190YWcgKGNvbXB1dGVfdGFnIHN0cnB1dF9hY2MgYWNjJykpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiAoZiAoKSk7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKlxuXG4gIERlZmluaW5nIFtmcHJpbnRmXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtmcHJpbnRmXS5cblxuKilcblxubGV0IGtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBvdXRwdXRfYWNjIHBwZiBhY2M7IGsgcHBmKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmFuZCBpa2ZwcmludGYgayBwcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBwcGYgZm10XG5cbmxldCBpZnByaW50ZiBfcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGlnbm9yZSAoKSBmbXRcblxubGV0IGZwcmludGYgcHBmID0ga2ZwcmludGYgaWdub3JlIHBwZlxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZF9mb3JtYXR0ZXIgZm10XG5sZXQgZXByaW50ZiBmbXQgPSBmcHJpbnRmIGVycl9mb3JtYXR0ZXIgZm10XG5cbmxldCBrZHByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBrIChmdW4gcHBmIC0+IG91dHB1dF9hY2MgcHBmIGFjYykpXG4gICAgRW5kX29mX2FjYyBmbXRcblxubGV0IGRwcmludGYgZm10ID0ga2RwcmludGYgKGZ1biBpIC0+IGkpIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPVxuICAgIHN0cnB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgaWQgZm10XG5cbmxldCBrYXNwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPVxuICAgIG91dHB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IGFzcHJpbnRmIGZtdCA9IGthc3ByaW50ZiBpZCBmbXRcblxuKCogRmx1c2hpbmcgc3RhbmRhcmQgZm9ybWF0dGVycyBhdCBlbmQgb2YgZXhlY3V0aW9uLiAqKVxuXG5sZXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyAoKSA9XG4gIHBwX3ByaW50X2ZsdXNoIHN0ZF9mb3JtYXR0ZXIgKCk7XG4gIHBwX3ByaW50X2ZsdXNoIGVycl9mb3JtYXR0ZXIgKClcblxubGV0ICgpID0gYXRfZXhpdCBmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzXG5cbigqXG5cbiAgRGVwcmVjYXRlZCBzdHVmZi5cblxuKilcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGVcbiAgICB+b3V0OmYgfmZsdXNoOmcgfm5ld2xpbmU6aCB+c3BhY2VzOmkgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGlcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgKCkgPVxuICAoc3RhdGUucHBfb3V0X3N0cmluZywgc3RhdGUucHBfb3V0X2ZsdXNoLFxuICAgc3RhdGUucHBfb3V0X25ld2xpbmUsIHN0YXRlLnBwX291dF9zcGFjZXMpXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5cbigqIERlcHJlY2F0ZWQgOiBlcnJvciBwcm9uZSBmdW5jdGlvbiwgZG8gbm90IHVzZSBpdC5cbiAgIFRoaXMgZnVuY3Rpb24gaXMgbmVpdGhlciBjb21wb3NpdGlvbmFsIG5vciBpbmNyZW1lbnRhbCwgc2luY2UgaXQgZmx1c2hlc1xuICAgdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGF0IGVhY2ggY2FsbC5cbiAgIFRvIGdldCB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5LCBkZWZpbmUgYSBmb3JtYXR0ZXIgb2YgeW91ciBvd24gd3JpdGluZyB0b1xuICAgdGhlIGJ1ZmZlciBhcmd1bWVudCwgYXMgaW5cbiAgIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGJcbiAgIHRoZW4gdXNlIHshZnByaW50ZiBwcGZ9IGFzIHVzdWFsLiAqKVxubGV0IGJwcmludGYgYiAoRm9ybWF0IChmbXQsIF8pIDogKCdhLCBmb3JtYXR0ZXIsIHVuaXQpIGZvcm1hdCkgPVxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIGFjYyA9IG91dHB1dF9hY2MgcHBmIGFjYzsgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuXG4oKiBEZXByZWNhdGVkIDogYWxpYXMgZm9yIGtzcHJpbnRmLiAqKVxubGV0IGtwcmludGYgPSBrc3ByaW50ZlxuXG5cblxuKCogRGVwcmVjYXRlZCB0YWcgZnVuY3Rpb25zICopXG5cbnR5cGUgZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPSB7XG4gIG1hcmtfb3Blbl90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIHByaW50X29wZW5fdGFnIDogdGFnIC0+IHVuaXQ7XG4gIHByaW50X2Nsb3NlX3RhZyA6IHRhZyAtPiB1bml0O1xufVxuXG5cbmxldCBwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fdGFnID0gbW90O1xuICAgICBtYXJrX2Nsb3NlX3RhZyA9IG1jdDtcbiAgICAgcHJpbnRfb3Blbl90YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3RhZyA9IHBjdDtcbiAgIH0gPVxuICBsZXQgc3RyaW5naWZ5IGYgZSA9IGZ1bmN0aW9uIFN0cmluZ190YWcgcyAtPiBmIHMgfCBfIC0+IGUgaW5cbiAgc3RhdGUucHBfbWFya19vcGVuX3RhZyA8LSBzdHJpbmdpZnkgbW90IFwiXCI7XG4gIHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIDwtIHN0cmluZ2lmeSBtY3QgXCJcIjtcbiAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgPC0gc3RyaW5naWZ5IHBvdCAoKTtcbiAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIDwtIHN0cmluZ2lmeSBwY3QgKClcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBmbXQgKCkgPVxuICBsZXQgZnVucyA9IHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgZm10ICgpIGluXG4gIGxldCBtYXJrX29wZW5fdGFnIHMgPSBmdW5zLm1hcmtfb3Blbl9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIGxldCBtYXJrX2Nsb3NlX3RhZyBzID0gZnVucy5tYXJrX2Nsb3NlX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAgbGV0IHByaW50X29wZW5fdGFnIHMgPSBmdW5zLnByaW50X29wZW5fc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICBsZXQgcHJpbnRfY2xvc2VfdGFnIHMgPSBmdW5zLnByaW50X2Nsb3NlX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAge21hcmtfb3Blbl90YWc7IG1hcmtfY2xvc2VfdGFnOyBwcmludF9vcGVuX3RhZzsgcHJpbnRfY2xvc2VfdGFnfVxuXG5sZXQgc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9RdWV1ZSIsIkNhbWxpbnRlcm5hbEZvcm1hdCIsIlN0ZGxpYiIsIlN0ZGxpYl9TdHJpbmciLCJTdGRsaWJfQnVmZmVyIiwiU3RkbGliX0xpc3QiLCJTdGRsaWJfU3RhY2siLCJTdGRsaWJfSW50IiwiU3RkbGliX0J5dGVzIiwiaWQiLCJ4IiwiemVybyIsInVua25vd24iLCJTdHJpbmdfdGFnIiwicHBfZW5xdWV1ZSIsInN0YXRlIiwidG9rZW4iLCJwcF9pbmZpbml0eSIsImNzdF9Gb3JtYXRfcHBfc2V0X2dlb21ldHJ5IiwicHBfb3V0cHV0X3N0cmluZyIsInMiLCJwcF9vdXRwdXRfbmV3bGluZSIsImZvcm1hdF9wcF90ZXh0Iiwic2l6ZSIsInRleHQiLCJmb3JtYXRfc3RyaW5nIiwiYnJlYWtfbmV3X2xpbmUiLCJwYXJhbSIsIndpZHRoIiwiYWZ0ZXIiLCJvZmZzZXQiLCJiZWZvcmUiLCJpbmRlbnQiLCJyZWFsX2luZGVudCIsIm4iLCJicmVha19zYW1lX2xpbmUiLCJmb3JtYXRfcHBfdG9rZW4iLCJtYXRjaCIsInRhYnMiLCJhZGRfdGFiIiwibHMiLCJsIiwibGVuZ3RoIiwidGFnX25hbWUiLCJtYXJrZXIiLCJicmVha3MiLCJmaXRzIiwib2ZmIiwiYm94X3R5cGUiLCJpbnNlcnRpb25fcG9pbnQiLCJmaXJzdCIsInRhYiIsInRhaWwiLCJoZWFkIiwidHkiLCJ0Ym94IiwiYWR2YW5jZV9sZWZ0IiwicGVuZGluZ19jb3VudCIsImVucXVldWVfYWR2YW5jZSIsInRvayIsImVucXVldWVfc3RyaW5nX2FzIiwiaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIiwic3RhY2siLCJxdWV1ZV9lbGVtIiwic2V0X3NpemUiLCJsZWZ0X3RvdGFsIiwic2Nhbl9wdXNoIiwiYiIsImVsZW0iLCJwcF9vcGVuX2JveF9nZW4iLCJicl90eSIsInBwX2Nsb3NlX2JveCIsInBwX29wZW5fc3RhZyIsInBwX2Nsb3NlX3N0YWciLCJwcF9vcGVuX3RhZyIsInBwX2Nsb3NlX3RhZyIsInBwX3NldF9wcmludF90YWdzIiwicHBfc2V0X21hcmtfdGFncyIsInBwX2dldF9wcmludF90YWdzIiwicHBfZ2V0X21hcmtfdGFncyIsInBwX3NldF90YWdzIiwicHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9uIiwicHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9uIiwicGN0IiwicG90IiwibWN0IiwibW90IiwicHBfcmluaXQiLCJwcF9mbHVzaF9xdWV1ZSIsInBwX3ByaW50X2FzX3NpemUiLCJwcF9wcmludF9hcyIsImlzaXplIiwicHBfcHJpbnRfc3RyaW5nIiwicHBfcHJpbnRfYnl0ZXMiLCJwcF9wcmludF9pbnQiLCJpIiwicHBfcHJpbnRfZmxvYXQiLCJwcF9wcmludF9ib29sIiwicHBfcHJpbnRfY2hhciIsImMiLCJwcF9vcGVuX2hib3giLCJwcF9vcGVuX3Zib3giLCJwcF9vcGVuX2h2Ym94IiwicHBfb3Blbl9ob3Zib3giLCJwcF9vcGVuX2JveCIsInBwX3ByaW50X25ld2xpbmUiLCJwcF9wcmludF9mbHVzaCIsInBwX2ZvcmNlX25ld2xpbmUiLCJwcF9wcmludF9pZl9uZXdsaW5lIiwicHBfcHJpbnRfY3VzdG9tX2JyZWFrIiwicHBfcHJpbnRfYnJlYWsiLCJwcF9wcmludF9zcGFjZSIsInBwX3ByaW50X2N1dCIsInBwX29wZW5fdGJveCIsInBwX2Nsb3NlX3Rib3giLCJwcF9wcmludF90YnJlYWsiLCJwcF9wcmludF90YWIiLCJwcF9zZXRfdGFiIiwicHBfc2V0X21heF9ib3hlcyIsInBwX2dldF9tYXhfYm94ZXMiLCJwcF9vdmVyX21heF9ib3hlcyIsInBwX3NldF9lbGxpcHNpc190ZXh0IiwicHBfZ2V0X2VsbGlwc2lzX3RleHQiLCJwcF9saW1pdCIsInBwX3NldF9tYXhfaW5kZW50IiwicHBfZ2V0X21heF9pbmRlbnQiLCJwcF9zZXRfbWFyZ2luIiwibmV3X21heF9pbmRlbnQiLCJ2YWxpZGF0ZV9nZW9tZXRyeSIsIm1hcmdpbiIsIm1heF9pbmRlbnQiLCJjaGVja19nZW9tZXRyeSIsImdlb21ldHJ5IiwicHBfZ2V0X21hcmdpbiIsInBwX3NldF9mdWxsX2dlb21ldHJ5IiwicHBfc2V0X2dlb21ldHJ5IiwibXNnIiwicHBfc2FmZV9zZXRfZ2VvbWV0cnkiLCJwcF9nZXRfZ2VvbWV0cnkiLCJwcF91cGRhdGVfZ2VvbWV0cnkiLCJ1cGRhdGUiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJqIiwiaCIsImciLCJwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGkiLCJwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGkiLCJkaXNwbGF5X25ld2xpbmUiLCJibGFua19saW5lIiwiZGlzcGxheV9ibGFua3MiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwib2MiLCJkZWZhdWx0X3BwX21hcmtfb3Blbl90YWciLCJ0YWciLCJkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnIiwiZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnIiwicHBfbWFrZV9mb3JtYXR0ZXIiLCJwcF9xdWV1ZSIsInN5c190b2siLCJzY2FuX3N0YWNrIiwicHBfbWFyZ2luIiwiZm9ybWF0dGVyX29mX291dF9mdW5jdGlvbnMiLCJvdXRfZnVucyIsIm1ha2VfZm9ybWF0dGVyIiwib3V0cHV0IiwiZmx1c2giLCJwcGYiLCJmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwiLCJmb3JtYXR0ZXJfb2ZfYnVmZmVyIiwicHBfYnVmZmVyX3NpemUiLCJwcF9tYWtlX2J1ZmZlciIsInN0ZGJ1ZiIsInN0ZF9mb3JtYXR0ZXIiLCJlcnJfZm9ybWF0dGVyIiwic3RyX2Zvcm1hdHRlciIsImZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIiLCJidWYiLCJmbHVzaF9zdHJfZm9ybWF0dGVyIiwibWFrZV9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsInNvYiIsImdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsIml0ZW1zIiwiYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIiwiaXRlbSIsImZvcm1hdHRlcl9vZl9zeW1ib2xpY19vdXRwdXRfYiIsIm9wZW5faGJveCIsIm9wZW5fdmJveCIsIm9wZW5faHZib3giLCJvcGVuX2hvdmJveCIsIm9wZW5fYm94IiwiY2xvc2VfYm94Iiwib3Blbl90YWciLCJjbG9zZV90YWciLCJvcGVuX3N0YWciLCJjbG9zZV9zdGFnIiwicHJpbnRfYXMiLCJwcmludF9zdHJpbmciLCJwcmludF9ieXRlcyIsInByaW50X2ludCIsInByaW50X2Zsb2F0IiwicHJpbnRfY2hhciIsInByaW50X2Jvb2wiLCJwcmludF9icmVhayIsInByaW50X2N1dCIsInByaW50X3NwYWNlIiwiZm9yY2VfbmV3bGluZSIsInByaW50X2ZsdXNoIiwicHJpbnRfbmV3bGluZSIsInByaW50X2lmX25ld2xpbmUiLCJvcGVuX3Rib3giLCJjbG9zZV90Ym94IiwicHJpbnRfdGJyZWFrIiwic2V0X3RhYiIsInByaW50X3RhYiIsInNldF9tYXJnaW4iLCJnZXRfbWFyZ2luIiwic2V0X21heF9pbmRlbnQiLCJnZXRfbWF4X2luZGVudCIsInNldF9nZW9tZXRyeSIsInNhZmVfc2V0X2dlb21ldHJ5IiwiZ2V0X2dlb21ldHJ5IiwidXBkYXRlX2dlb21ldHJ5Iiwic2V0X21heF9ib3hlcyIsImdldF9tYXhfYm94ZXMiLCJvdmVyX21heF9ib3hlcyIsInNldF9lbGxpcHNpc190ZXh0IiwiZ2V0X2VsbGlwc2lzX3RleHQiLCJzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwic2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJzZXRfcHJpbnRfdGFncyIsImdldF9wcmludF90YWdzIiwic2V0X21hcmtfdGFncyIsImdldF9tYXJrX3RhZ3MiLCJzZXRfdGFncyIsInBwX3ByaW50X2xpc3QiLCJvcHQiLCJwcF92Iiwic3RoIiwicHBfc2VwIiwidiIsInZzIiwicHBfcHJpbnRfc2VxIiwic2VxIiwicHBfcHJpbnRfdGV4dCIsImxlbiIsImxlZnQiLCJyaWdodCIsInBwX3ByaW50X29wdGlvbiIsIm5vbmUiLCJwcF9wcmludF9yZXN1bHQiLCJvayIsImVycm9yIiwiZSIsInBwX3ByaW50X2VpdGhlciIsInIiLCJjb21wdXRlX3RhZyIsInRhZ19hY2MiLCJvdXRwdXRfZm9ybWF0dGluZ19saXQiLCJmbXRpbmdfbGl0Iiwib3V0cHV0X2FjYyIsImFjYyIsInAiLCJidHkiLCJzdHJwdXRfYWNjIiwia2ZwcmludGYiLCJrIiwiZm10IiwiaWtmcHJpbnRmIiwiaWZwcmludGYiLCJmcHJpbnRmIiwicHJpbnRmIiwiZXByaW50ZiIsImtkcHJpbnRmIiwiZHByaW50ZiIsImtzcHJpbnRmIiwic3ByaW50ZiIsImthc3ByaW50ZiIsImFzcHJpbnRmIiwiZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyIsInBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdSIsInBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdSIsInNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdCIsImdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdCIsImJwcmludGYiLCJwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJzdHJpbmdpZnkiLCJwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJmdW5zIiwibWFya19vcGVuX3RhZyIsIm1hcmtfY2xvc2VfdGFnIiwicHJpbnRfb3Blbl90YWciLCJwcmludF9jbG9zZV90YWciLCJzZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJTdGRsaWJfRm9ybWF0Il0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNB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LE1BQTRDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQ3OEM5QyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5OTM4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvc2NhbmYubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG4oKiBhbGlhcyB0byBhdm9pZCB3YXJuaW5nIGZvciBhbWJpZ3VpdHkgYmV0d2VlblxuICAgU3RkbGliLmZvcm1hdDZcbiAgIGFuZCBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxuXG4gICAodGhlIGZvcm1lciBpcyBpbiBmYWN0IGFuIGFsaWFzIGZvciB0aGUgbGF0dGVyLFxuICAgIGJ1dCB0aGUgYW1iaWd1aXR5IHdhcm5pbmcgZG9lc24ndCBjYXJlKVxuKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgU3RkbGliLmZvcm1hdDZcblxuXG4oKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3Igc2Nhbm5lcnMuICopXG5cbigqIFNjYW5uaW5nIGJ1ZmZlcnMuICopXG5tb2R1bGUgdHlwZSBTQ0FOTklORyA9IHNpZ1xuXG4gIHR5cGUgaW5fY2hhbm5lbFxuXG4gIHR5cGUgc2NhbmJ1ZiA9IGluX2NoYW5uZWxcblxuICB0eXBlIGZpbGVfbmFtZSA9IHN0cmluZ1xuXG4gIHZhbCBzdGRpbiA6IGluX2NoYW5uZWxcbiAgKCogVGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0uXG4gICAgIFtzdGRpYl0gaXMgZXF1aXZhbGVudCB0byBbU2Nhbm5pbmcuZnJvbV9jaGFubmVsIFN0ZGxpYi5zdGRpbl0uICopXG5cbiAgdmFsIHN0ZGliIDogaW5fY2hhbm5lbFxuICAoKiBBbiBhbGlhcyBmb3IgW1NjYW5mLnN0ZGluXSwgdGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb21cbiAgICAgW1N0ZGxpYi5zdGRpbl0uICopXG5cbiAgdmFsIG5leHRfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBbU2Nhbm5pbmcubmV4dF9jaGFyIGliXSBhZHZhbmNlIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIuXG4gICAgIElmIG5vIG1vcmUgY2hhcmFjdGVyIGNhbiBiZSByZWFkLCBzZXRzIGEgZW5kIG9mIGZpbGUgY29uZGl0aW9uIGFuZFxuICAgICByZXR1cm5zICdcXDAwMCcuICopXG5cbiAgdmFsIGludmFsaWRhdGVfY3VycmVudF9jaGFyIDogc2NhbmJ1ZiAtPiB1bml0XG4gICgqIFtTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYl0gbWFyayB0aGUgY3VycmVudF9jaGFyIGFzIGFscmVhZHlcbiAgICAgc2Nhbm5lZC4gKilcblxuICB2YWwgcGVla19jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5wZWVrX2NoYXIgaWJdIHJldHVybnMgdGhlIGN1cnJlbnQgY2hhciBhdmFpbGFibGUgaW5cbiAgICAgdGhlIGJ1ZmZlciBvciByZWFkcyBvbmUgaWYgbmVjZXNzYXJ5ICh3aGVuIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpc1xuICAgICBhbHJlYWR5IHNjYW5uZWQpLlxuICAgICBJZiBubyBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYW4gZW5kIG9mIGZpbGUgY29uZGl0aW9uIGFuZFxuICAgICByZXR1cm5zICdcXDAwMCcuICopXG5cbiAgdmFsIGNoZWNrZWRfcGVla19jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFNhbWUgYXMgW1NjYW5uaW5nLnBlZWtfY2hhcl0gYWJvdmUgYnV0IGFsd2F5cyByZXR1cm5zIGEgdmFsaWQgY2hhciBvclxuICAgICBmYWlsczogaW5zdGVhZCBvZiByZXR1cm5pbmcgYSBudWxsIGNoYXIgd2hlbiB0aGUgcmVhZGluZyBtZXRob2Qgb2YgdGhlXG4gICAgIGlucHV0IGJ1ZmZlciBoYXMgcmVhY2hlZCBhbiBlbmQgb2YgZmlsZSwgdGhlIGZ1bmN0aW9uIHJhaXNlcyBleGNlcHRpb25cbiAgICAgW0VuZF9vZl9maWxlXS4gKilcblxuICB2YWwgc3RvcmVfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGNoYXIgLT4gaW50XG4gICgqIFtTY2FubmluZy5zdG9yZV9jaGFyIGxpbSBpYiBjXSBhZGRzIFtjXSB0byB0aGUgdG9rZW4gYnVmZmVyXG4gICAgIG9mIHRoZSBzY2FubmluZyBidWZmZXIgW2liXS4gSXQgYWxzbyBhZHZhbmNlcyB0aGUgc2Nhbm5pbmcgYnVmZmVyIGZvclxuICAgICBvbmUgY2hhcmFjdGVyIGFuZCByZXR1cm5zIFtsaW0gLSAxXSwgaW5kaWNhdGluZyB0aGUgbmV3IGxpbWl0IGZvciB0aGVcbiAgICAgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IHRva2VuLiAqKVxuXG4gIHZhbCBza2lwX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnNraXBfY2hhciBsaW0gaWJdIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLiAqKVxuXG4gIHZhbCBpZ25vcmVfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuaWdub3JlX2NoYXIgaWIgbGltXSBpZ25vcmVzIHRoZSBjdXJyZW50IGNoYXJhY3RlciBhbmRcbiAgICAgZGVjcmVtZW50cyB0aGUgbGltaXQuICopXG5cbiAgdmFsIHRva2VuIDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLnRva2VuIGliXSByZXR1cm5zIHRoZSBzdHJpbmcgc3RvcmVkIGludG8gdGhlIHRva2VuXG4gICAgIGJ1ZmZlciBvZiB0aGUgc2Nhbm5pbmcgYnVmZmVyOiBpdCByZXR1cm5zIHRoZSB0b2tlbiBtYXRjaGVkIGJ5IHRoZVxuICAgICBmb3JtYXQuICopXG5cbiAgdmFsIHJlc2V0X3Rva2VuIDogc2NhbmJ1ZiAtPiB1bml0XG4gICgqIFtTY2FubmluZy5yZXNldF90b2tlbiBpYl0gcmVzZXRzIHRoZSB0b2tlbiBidWZmZXIgb2ZcbiAgICAgdGhlIGdpdmVuIHNjYW5uaW5nIGJ1ZmZlci4gKilcblxuICB2YWwgY2hhcl9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5jaGFyX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICAgICByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIGxpbmVfY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcubGluZV9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIG5ldyBsaW5lXG4gICAgIGNoYXJhY3RlcnMgcmVhZCBzbyBmYXIgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCB0b2tlbl9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy50b2tlbl9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIHRva2VucyByZWFkXG4gICAgIHNvIGZhciBmcm9tIFtpYl0uICopXG5cbiAgdmFsIGVvZiA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuZW9mIGliXSByZXR1cm5zIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIGVuZF9vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgZW5kIG9mIGlucHV0IGNvbmRpdGlvblxuICAgICBvZiB0aGUgZ2l2ZW4gYnVmZmVyIChpZiBubyBjaGFyIGhhcyBldmVyIGJlZW4gcmVhZCwgYW4gYXR0ZW1wdCB0b1xuICAgICByZWFkIG9uZSBpcyBwZXJmb3JtZWQpLiAqKVxuXG4gIHZhbCBiZWdpbm5pbmdfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmJlZ2lubmluZ19vZl9pbnB1dCBpYl0gdGVzdHMgdGhlIGJlZ2lubmluZyBvZiBpbnB1dFxuICAgICBjb25kaXRpb24gb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbmFtZV9vZl9pbnB1dCA6IHNjYW5idWYgLT4gc3RyaW5nXG4gICgqIFtTY2FubmluZy5uYW1lX29mX2lucHV0IGliXSByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjaGFyYWN0ZXJcbiAgICAgc291cmNlIGZvciBpbnB1dCBidWZmZXIgW2liXS4gKilcblxuICB2YWwgb3Blbl9pbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBvcGVuX2luX2JpbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGUgOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9maWxlX2JpbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX3N0cmluZyA6IHN0cmluZyAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2Z1bmN0aW9uIDogKHVuaXQgLT4gY2hhcikgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9jaGFubmVsIDogU3RkbGliLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuXG4gIHZhbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdFxuXG4gIHZhbCBtZW1vX2Zyb21fY2hhbm5lbCA6IFN0ZGxpYi5pbl9jaGFubmVsIC0+IGluX2NoYW5uZWxcbiAgKCogT2Jzb2xldGUuICopXG5cbmVuZFxuXG5cbm1vZHVsZSBTY2FubmluZyA6IFNDQU5OSU5HID0gc3RydWN0XG5cbiAgKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIHNjYW5mLiAqKVxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdHlwZSBpbl9jaGFubmVsX25hbWUgPVxuICAgIHwgRnJvbV9jaGFubmVsIG9mIFN0ZGxpYi5pbl9jaGFubmVsXG4gICAgfCBGcm9tX2ZpbGUgb2YgZmlsZV9uYW1lICogU3RkbGliLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZnVuY3Rpb25cbiAgICB8IEZyb21fc3RyaW5nXG5cblxuICB0eXBlIGluX2NoYW5uZWwgPSB7XG4gICAgbXV0YWJsZSBpY19lb2YgOiBib29sO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyIDogY2hhcjtcbiAgICBtdXRhYmxlIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jaGFyX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfbGluZV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX3Rva2VuX2NvdW50IDogaW50O1xuICAgIGljX2dldF9uZXh0X2NoYXIgOiB1bml0IC0+IGNoYXI7XG4gICAgaWNfdG9rZW5fYnVmZmVyIDogQnVmZmVyLnQ7XG4gICAgaWNfaW5wdXRfbmFtZSA6IGluX2NoYW5uZWxfbmFtZTtcbiAgfVxuXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIGxldCBudWxsX2NoYXIgPSAnXFwwMDAnXG5cbiAgKCogUmVhZHMgYSBuZXcgY2hhcmFjdGVyIGZyb20gaW5wdXQgYnVmZmVyLlxuICAgICBOZXh0X2NoYXIgbmV2ZXIgZmFpbHMsIGV2ZW4gaW4gY2FzZSBvZiBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IHRoZW4gc2ltcGx5IHNldHMgdGhlIGVuZCBvZiBmaWxlIGNvbmRpdGlvbi4gKilcbiAgbGV0IG5leHRfY2hhciBpYiA9XG4gICAgdHJ5XG4gICAgICBsZXQgYyA9IGliLmljX2dldF9uZXh0X2NoYXIgKCkgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIHRydWU7XG4gICAgICBpYi5pY19jaGFyX2NvdW50IDwtIHN1Y2MgaWIuaWNfY2hhcl9jb3VudDtcbiAgICAgIGlmIGMgPSAnXFxuJyB0aGVuIGliLmljX2xpbmVfY291bnQgPC0gc3VjYyBpYi5pY19saW5lX2NvdW50O1xuICAgICAgYyB3aXRoXG4gICAgfCBFbmRfb2ZfZmlsZSAtPlxuICAgICAgbGV0IGMgPSBudWxsX2NoYXIgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIGZhbHNlO1xuICAgICAgaWIuaWNfZW9mIDwtIHRydWU7XG4gICAgICBjXG5cblxuICBsZXQgcGVla19jaGFyIGliID1cbiAgICBpZiBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWRcbiAgICB0aGVuIGliLmljX2N1cnJlbnRfY2hhclxuICAgIGVsc2UgbmV4dF9jaGFyIGliXG5cblxuICAoKiBSZXR1cm5zIGEgdmFsaWQgY3VycmVudCBjaGFyIGZvciB0aGUgaW5wdXQgYnVmZmVyLiBJbiBwYXJ0aWN1bGFyXG4gICAgIG5vIGlycmVsZXZhbnQgbnVsbCBjaGFyYWN0ZXIgKGFzIHNldCBieSBbbmV4dF9jaGFyXSBpbiBjYXNlIG9mIGVuZFxuICAgICBvZiBpbnB1dCkgaXMgcmV0dXJuZWQsIHNpbmNlIFtFbmRfb2ZfZmlsZV0gaXMgcmFpc2VkIHdoZW5cbiAgICAgW25leHRfY2hhcl0gc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uIHdoaWxlIHRyeWluZyB0byByZWFkIGFcbiAgICAgbmV3IGNoYXJhY3Rlci4gKilcbiAgbGV0IGNoZWNrZWRfcGVla19jaGFyIGliID1cbiAgICBsZXQgYyA9IHBlZWtfY2hhciBpYiBpblxuICAgIGlmIGliLmljX2VvZiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlO1xuICAgIGNcblxuXG4gIGxldCBlbmRfb2ZfaW5wdXQgaWIgPVxuICAgIGlnbm9yZSAocGVla19jaGFyIGliKTtcbiAgICBpYi5pY19lb2ZcblxuXG4gIGxldCBlb2YgaWIgPSBpYi5pY19lb2ZcblxuICBsZXQgYmVnaW5uaW5nX29mX2lucHV0IGliID0gaWIuaWNfY2hhcl9jb3VudCA9IDBcblxuICBsZXQgbmFtZV9vZl9pbnB1dCBpYiA9XG4gICAgbWF0Y2ggaWIuaWNfaW5wdXRfbmFtZSB3aXRoXG4gICAgfCBGcm9tX2NoYW5uZWwgX2ljIC0+IFwidW5uYW1lZCBTdGRsaWIgaW5wdXQgY2hhbm5lbFwiXG4gICAgfCBGcm9tX2ZpbGUgKGZuYW1lLCBfaWMpIC0+IGZuYW1lXG4gICAgfCBGcm9tX2Z1bmN0aW9uIC0+IFwidW5uYW1lZCBmdW5jdGlvblwiXG4gICAgfCBGcm9tX3N0cmluZyAtPiBcInVubmFtZWQgY2hhcmFjdGVyIHN0cmluZ1wiXG5cblxuICBsZXQgY2hhcl9jb3VudCBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jaGFyX2NvdW50IC0gMVxuICAgIGVsc2UgaWIuaWNfY2hhcl9jb3VudFxuXG5cbiAgbGV0IGxpbmVfY291bnQgaWIgPSBpYi5pY19saW5lX2NvdW50XG5cbiAgbGV0IHJlc2V0X3Rva2VuIGliID0gQnVmZmVyLnJlc2V0IGliLmljX3Rva2VuX2J1ZmZlclxuXG4gIGxldCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiA9IGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZVxuXG4gIGxldCB0b2tlbiBpYiA9XG4gICAgbGV0IHRva2VuX2J1ZmZlciA9IGliLmljX3Rva2VuX2J1ZmZlciBpblxuICAgIGxldCB0b2sgPSBCdWZmZXIuY29udGVudHMgdG9rZW5fYnVmZmVyIGluXG4gICAgQnVmZmVyLmNsZWFyIHRva2VuX2J1ZmZlcjtcbiAgICBpYi5pY190b2tlbl9jb3VudCA8LSBzdWNjIGliLmljX3Rva2VuX2NvdW50O1xuICAgIHRva1xuXG5cbiAgbGV0IHRva2VuX2NvdW50IGliID0gaWIuaWNfdG9rZW5fY291bnRcblxuICBsZXQgc2tpcF9jaGFyIHdpZHRoIGliID1cbiAgICBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjtcbiAgICB3aWR0aFxuXG5cbiAgbGV0IGlnbm9yZV9jaGFyIHdpZHRoIGliID0gc2tpcF9jaGFyICh3aWR0aCAtIDEpIGliXG5cbiAgbGV0IHN0b3JlX2NoYXIgd2lkdGggaWIgYyA9XG4gICAgQnVmZmVyLmFkZF9jaGFyIGliLmljX3Rva2VuX2J1ZmZlciBjO1xuICAgIGlnbm9yZV9jaGFyIHdpZHRoIGliXG5cblxuICBsZXQgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSA9IDEwMjRcblxuICBsZXQgY3JlYXRlIGluYW1lIG5leHQgPSB7XG4gICAgaWNfZW9mID0gZmFsc2U7XG4gICAgaWNfY3VycmVudF9jaGFyID0gbnVsbF9jaGFyO1xuICAgIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA9IGZhbHNlO1xuICAgIGljX2NoYXJfY291bnQgPSAwO1xuICAgIGljX2xpbmVfY291bnQgPSAwO1xuICAgIGljX3Rva2VuX2NvdW50ID0gMDtcbiAgICBpY19nZXRfbmV4dF9jaGFyID0gbmV4dDtcbiAgICBpY190b2tlbl9idWZmZXIgPSBCdWZmZXIuY3JlYXRlIGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemU7XG4gICAgaWNfaW5wdXRfbmFtZSA9IGluYW1lO1xuICB9XG5cblxuICBsZXQgZnJvbV9zdHJpbmcgcyA9XG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA+PSBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlXG4gICAgICBsZXQgYyA9IHMuWyFpXSBpblxuICAgICAgaW5jciBpO1xuICAgICAgYyBpblxuICAgIGNyZWF0ZSBGcm9tX3N0cmluZyBuZXh0XG5cblxuICBsZXQgZnJvbV9mdW5jdGlvbiA9IGNyZWF0ZSBGcm9tX2Z1bmN0aW9uXG5cbiAgKCogU2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsLiAqKVxuXG4gICgqIFBvc2l0aW9uIG9mIHRoZSBwcm9ibGVtOlxuXG4gICAgIFdlIGNhbm5vdCBwcmV2ZW50IHRoZSBzY2FubmluZyBtZWNoYW5pc20gdG8gdXNlIG9uZSBsb29rYWhlYWQgY2hhcmFjdGVyLFxuICAgICBpZiBuZWVkZWQgYnkgdGhlIHNlbWFudGljcyBvZiB0aGUgZm9ybWF0IHN0cmluZyBzcGVjaWZpY2F0aW9ucyAoZS5nLiBhXG4gICAgIHRyYWlsaW5nICdza2lwIHNwYWNlJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBmb3JtYXQgc3RyaW5nKTsgaW4gdGhpcyBjYXNlLFxuICAgICB0aGUgbWFuZGF0b3J5IGxvb2thaGVhZCBjaGFyYWN0ZXIgaXMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgaW5wdXQgYW5kIG5vdFxuICAgICB1c2VkIHRvIHJldHVybiB0aGUgdG9rZW4gcmVhZC4gSXQgaXMgdGh1cyBtYW5kYXRvcnkgdG8gYmUgYWJsZSB0byBzdG9yZVxuICAgICBhbiB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBzb21ld2hlcmUgdG8gZ2V0IGl0IGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgb2YgdGhlIG5leHQgc2Nhbi5cblxuICAgICBUbyBjaXJjdW12ZW50IHRoaXMgcHJvYmxlbSwgYWxsIHRoZSBzY2FubmluZyBmdW5jdGlvbnMgZ2V0IGEgbG93IGxldmVsXG4gICAgIGlucHV0IGJ1ZmZlciBhcmd1bWVudCB3aGVyZSB0aGV5IHN0b3JlIHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyIHdoZW5cbiAgICAgbmVlZGVkOyBhZGRpdGlvbmFsbHksIHRoZSBpbnB1dCBidWZmZXIgaXMgdGhlIG9ubHkgc291cmNlIG9mIGNoYXJhY3RlciBvZlxuICAgICBhIHNjYW5uZXIuIFRoZSBbc2NhbmJ1Zl0gaW5wdXQgYnVmZmVycyBhcmUgZGVmaW5lZCBpbiBtb2R1bGUgeyFTY2FubmluZ30uXG5cbiAgICAgTm93IHdlIHVuZGVyc3RhbmQgdGhhdCBpdCBpcyBleHRyZW1lbHkgaW1wb3J0YW50IHRoYXQgcmVsYXRlZCBhbmRcbiAgICAgc3VjY2Vzc2l2ZSBjYWxscyB0byBzY2FubmVycyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBzYW1lIGlucHV0IGJ1ZmZlci5cbiAgICAgSW4gZWZmZWN0LCBpZiBhIHNjYW5uZXIgW3NjYW4xXSBpcyByZWFkaW5nIGZyb20gW2liMV0gYW5kIHN0b3JlcyBhblxuICAgICB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBbYzFdIGludG8gaXRzIGlucHV0IGJ1ZmZlciBbaWIxXSwgdGhlblxuICAgICBhbm90aGVyIHNjYW5uZXIgW3NjYW4yXSBub3QgcmVhZGluZyBmcm9tIHRoZSBzYW1lIGJ1ZmZlciBbaWIxXSB3aWxsIG1pc3NcbiAgICAgdGhlIGNoYXJhY3RlciBbYzFdLCBzZWVtaW5nbHkgdmFuaXNoZWQgaW4gdGhlIGFpciBmcm9tIHRoZSBwb2ludCBvZiB2aWV3XG4gICAgIG9mIFtzY2FuMl0uXG5cbiAgICAgVGhpcyBtZWNoYW5pc20gd29ya3MgcGVyZmVjdGx5IHRvIHJlYWQgZnJvbSBzdHJpbmdzLCBmcm9tIGZpbGVzLCBhbmQgZnJvbVxuICAgICBmdW5jdGlvbnMsIHNpbmNlIGluIHRob3NlIGNhc2VzLCBhbGxvY2F0aW5nIHR3byBidWZmZXJzIHJlYWRpbmcgZnJvbSB0aGVcbiAgICAgc2FtZSBzb3VyY2UgaXMgdW5uYXR1cmFsLlxuXG4gICAgIFN0aWxsLCB0aGVyZSBpcyBhIGRpZmZpY3VsdHkgaW4gdGhlIGNhc2Ugb2Ygc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dFxuICAgICBjaGFubmVsLiBJbiBlZmZlY3QsIHdoZW4gc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsIFtpY10sIHRoaXMgY2hhbm5lbFxuICAgICBtYXkgbm90IGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB3aXRoaW4gdGhpcyBsaWJyYXJ5LiBIZW5jZSwgaXQgbWF5IGJlXG4gICAgIHNoYXJlZCAodHdvIGZ1bmN0aW9ucyBvZiB0aGUgdXNlcidzIHByb2dyYW0gbWF5IHN1Y2Nlc3NpdmVseSByZWFkIGZyb21cbiAgICAgW2ljXSkuIFRoaXMgaXMgaGlnaGx5IGVycm9yIHByb25lIHNpbmNlLCBvbmUgb2YgdGhlIGZ1bmN0aW9uIG1heSBzZWVrIHRoZVxuICAgICBpbnB1dCBjaGFubmVsLCB3aGlsZSB0aGUgb3RoZXIgZnVuY3Rpb24gaGFzIHN0aWxsIGFuIHVudXNlZCBsb29rYWhlYWRcbiAgICAgY2hhcmFjdGVyIGluIGl0cyBpbnB1dCBidWZmZXIuIEluIGNvbmNsdXNpb24sIHlvdSBzaG91bGQgbmV2ZXIgbWl4IGRpcmVjdFxuICAgICBsb3cgbGV2ZWwgcmVhZGluZyBhbmQgaGlnaCBsZXZlbCBzY2FubmluZyBmcm9tIHRoZSBzYW1lIGlucHV0IGNoYW5uZWwuXG5cbiAgKilcblxuICAoKiBQZXJmb3JtIGJ1ZmZlcml6ZWQgaW5wdXQgdG8gaW1wcm92ZSBlZmZpY2llbmN5LiAqKVxuICBsZXQgZmlsZV9idWZmZXJfc2l6ZSA9IHJlZiAxMDI0XG5cbiAgKCogVGhlIHNjYW5uZXIgY2xvc2VzIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dC4gKilcbiAgbGV0IHNjYW5fY2xvc2VfYXRfZW5kIGljID0gU3RkbGliLmNsb3NlX2luIGljOyByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gICgqIFRoZSBzY2FubmVyIGRvZXMgbm90IGNsb3NlIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dDpcbiAgICAgaXQganVzdCByYWlzZXMgW0VuZF9vZl9maWxlXS4gKilcbiAgbGV0IHNjYW5fcmFpc2VfYXRfZW5kIF9pYyA9IHJhaXNlIEVuZF9vZl9maWxlXG5cbiAgbGV0IGZyb21faWMgc2Nhbl9jbG9zZV9pYyBpbmFtZSBpYyA9XG4gICAgbGV0IGxlbiA9ICFmaWxlX2J1ZmZlcl9zaXplIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGxpbSA9IHJlZiAwIGluXG4gICAgbGV0IGVvZiA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBuZXh0ICgpID1cbiAgICAgIGlmICFpIDwgIWxpbSB0aGVuIGJlZ2luIGxldCBjID0gQnl0ZXMuZ2V0IGJ1ZiAhaSBpbiBpbmNyIGk7IGMgZW5kIGVsc2VcbiAgICAgIGlmICFlb2YgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlIGJlZ2luXG4gICAgICAgIGxpbSA6PSBpbnB1dCBpYyBidWYgMCBsZW47XG4gICAgICAgIGlmICFsaW0gPSAwIHRoZW4gYmVnaW4gZW9mIDo9IHRydWU7IHNjYW5fY2xvc2VfaWMgaWMgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICBpIDo9IDE7XG4gICAgICAgICAgQnl0ZXMuZ2V0IGJ1ZiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kIGluXG4gICAgY3JlYXRlIGluYW1lIG5leHRcblxuXG4gIGxldCBmcm9tX2ljX2Nsb3NlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9jbG9zZV9hdF9lbmRcbiAgbGV0IGZyb21faWNfcmFpc2VfYXRfZW5kID0gZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG4gICgqIFRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLlxuICAgICBPbmUgY291bGQgdHJ5IHRvIGRlZmluZSBbc3RkaWJdIGFzIGEgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgYSBjaGFyYWN0ZXJcbiAgICAgYXQgYSB0aW1lIChubyBidWZmZXJpemF0aW9uIGF0IGFsbCksIGJ1dCB1bmZvcnR1bmF0ZWx5IHRoZSB0b3AtbGV2ZWxcbiAgICAgaW50ZXJhY3Rpb24gd291bGQgYmUgd3JvbmcuIFRoaXMgaXMgZHVlIHRvIHNvbWUga2luZCBvZlxuICAgICAncmFjZSBjb25kaXRpb24nIHdoZW4gcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLFxuICAgICBzaW5jZSB0aGUgaW50ZXJhY3RpdmUgY29tcGlsZXIgYW5kIFtTY2FuZi5zY2FuZl0gd2lsbCBzaW11bHRhbmVvdXNseVxuICAgICByZWFkIHRoZSBtYXRlcmlhbCB0aGV5IG5lZWQgZnJvbSBbU3RkbGliLnN0ZGluXTsgdGhlbiwgY29uZnVzaW9uXG4gICAgIHdpbGwgcmVzdWx0IGZyb20gd2hhdCBzaG91bGQgYmUgcmVhZCBieSB0aGUgdG9wLWxldmVsIGFuZCB3aGF0IHNob3VsZCBiZVxuICAgICByZWFkIGJ5IFtTY2FuZi5zY2FuZl0uXG4gICAgIFRoaXMgaXMgZXZlbiBtb3JlIGNvbXBsaWNhdGVkIGJ5IHRoZSBvbmUgY2hhcmFjdGVyIGxvb2thaGVhZCB0aGF0XG4gICAgIFtTY2FuZi5zY2FuZl0gaXMgc29tZXRpbWVzIG9ibGlnZWQgdG8gbWFpbnRhaW46IHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyXG4gICAgIHdpbGwgYmUgYXZhaWxhYmxlIGZvciB0aGUgbmV4dCBbU2NhbmYuc2NhbmZdIGVudHJ5LCBzZWVtaW5nbHkgY29taW5nIGZyb21cbiAgICAgbm93aGVyZS5cbiAgICAgQWxzbyBubyBbRW5kX29mX2ZpbGVdIGlzIHJhaXNlZCB3aGVuIHJlYWRpbmcgZnJvbSBzdGRpbjogaWYgbm90IGVub3VnaFxuICAgICBjaGFyYWN0ZXJzIGhhdmUgYmVlbiByZWFkLCB3ZSBzaW1wbHkgYXNrIHRvIHJlYWQgbW9yZS4gKilcbiAgbGV0IHN0ZGluID1cbiAgICBmcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG4gICAgICAoRnJvbV9maWxlIChcIi1cIiwgU3RkbGliLnN0ZGluKSkgU3RkbGliLnN0ZGluXG5cblxuICBsZXQgc3RkaWIgPSBzdGRpblxuXG4gIGxldCBvcGVuX2luX2ZpbGUgb3Blbl9pbiBmbmFtZSA9XG4gICAgbWF0Y2ggZm5hbWUgd2l0aFxuICAgIHwgXCItXCIgLT4gc3RkaW5cbiAgICB8IGZuYW1lIC0+XG4gICAgICBsZXQgaWMgPSBvcGVuX2luIGZuYW1lIGluXG4gICAgICBmcm9tX2ljX2Nsb3NlX2F0X2VuZCAoRnJvbV9maWxlIChmbmFtZSwgaWMpKSBpY1xuXG5cbiAgbGV0IG9wZW5faW4gPSBvcGVuX2luX2ZpbGUgU3RkbGliLm9wZW5faW5cbiAgbGV0IG9wZW5faW5fYmluID0gb3Blbl9pbl9maWxlIFN0ZGxpYi5vcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2ZpbGUgPSBvcGVuX2luXG4gIGxldCBmcm9tX2ZpbGVfYmluID0gb3Blbl9pbl9iaW5cblxuICBsZXQgZnJvbV9jaGFubmVsIGljID1cbiAgICBmcm9tX2ljX3JhaXNlX2F0X2VuZCAoRnJvbV9jaGFubmVsIGljKSBpY1xuXG5cbiAgbGV0IGNsb3NlX2luIGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBpYyAtPlxuICAgICAgU3RkbGliLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2ZpbGUgKF9mbmFtZSwgaWMpIC0+IFN0ZGxpYi5jbG9zZV9pbiBpY1xuICAgIHwgRnJvbV9mdW5jdGlvbiB8IEZyb21fc3RyaW5nIC0+ICgpXG5cblxuICAoKlxuICAgICBPYnNvbGV0ZTogYSBtZW1vIFtmcm9tX2NoYW5uZWxdIHZlcnNpb24gdG8gYnVpbGQgYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF1cbiAgICAgc2Nhbm5pbmcgYnVmZmVyIG91dCBvZiBhIFtTdGRsaWIuaW5fY2hhbm5lbF0uXG4gICAgIFRoaXMgZnVuY3Rpb24gd2FzIHVzZWQgdG8gdHJ5IHRvIHByZXNlcnZlIHRoZSBzY2FubmluZ1xuICAgICBzZW1hbnRpY3MgZm9yIHRoZSAobm93IG9ic29sZXRlKSBmdW5jdGlvbiBbZnNjYW5mXS5cbiAgICAgR2l2ZW4gdGhhdCBhbGwgc2Nhbm5lciBtdXN0IHJlYWQgZnJvbSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBzY2FubmluZ1xuICAgICBidWZmZXIsIFtmc2NhbmZdIG11c3QgcmVhZCBmcm9tIG9uZSFcbiAgICAgTW9yZSBwcmVjaXNlbHksIGdpdmVuIFtpY10sIGFsbCBzdWNjZXNzaXZlIGNhbGxzIFtmc2NhbmYgaWNdIG11c3QgcmVhZFxuICAgICBmcm9tIHRoZSBzYW1lIHNjYW5uaW5nIGJ1ZmZlci5cbiAgICAgVGhpcyBvYmxpZ2VkIHRoaXMgbGlicmFyeSB0byBhbGxvY2F0ZWQgc2Nhbm5pbmcgYnVmZmVycyB0aGF0IHdlcmVcbiAgICAgbm90IHByb3Blcmx5IGdhcmJhZ2UgY29sbGVjdGFibGUsIGhlbmNlIGxlYWRpbmcgdG8gbWVtb3J5IGxlYWtzLlxuICAgICBJZiB5b3UgbmVlZCB0byByZWFkIGZyb20gYSBbU3RkbGliLmluX2NoYW5uZWxdIGlucHV0IGNoYW5uZWxcbiAgICAgW2ljXSwgc2ltcGx5IGRlZmluZSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBmb3JtYXR0ZWQgaW5wdXQgY2hhbm5lbCBhcyBpblxuICAgICBbbGV0IGliID0gU2Nhbm5pbmcuZnJvbV9jaGFubmVsIGljXSwgdGhlbiB1c2UgW1NjYW5mLmJzY2FuZiBpYl0gYXMgdXN1YWwuXG4gICopXG4gIGxldCBtZW1vX2Zyb21faWMgPVxuICAgIGxldCBtZW1vID0gcmVmIFtdIGluXG4gICAgKGZ1biBzY2FuX2Nsb3NlX2ljIGljIC0+XG4gICAgIHRyeSBMaXN0LmFzc3EgaWMgIW1lbW8gd2l0aFxuICAgICB8IE5vdF9mb3VuZCAtPlxuICAgICAgIGxldCBpYiA9XG4gICAgICAgICBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgKEZyb21fY2hhbm5lbCBpYykgaWMgaW5cbiAgICAgICBtZW1vIDo9IChpYywgaWIpIDo6ICFtZW1vO1xuICAgICAgIGliKVxuXG5cbiAgKCogT2Jzb2xldGU6IHNlZSB7IW1lbW9fZnJvbV9pY30gYWJvdmUuICopXG4gIGxldCBtZW1vX2Zyb21fY2hhbm5lbCA9IG1lbW9fZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG5lbmRcblxuXG4oKiBGb3JtYXR0ZWQgaW5wdXQgZnVuY3Rpb25zLiAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgc2Nhbm5lciA9XG4gICAgICgnYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgJ2IsICdjLCAnYSAtPiAnZCwgJ2QpIGZvcm1hdDYgLT4gJ2NcblxuXG4oKiBSZXBvcnRpbmcgZXJyb3JzLiAqKVxuZXhjZXB0aW9uIFNjYW5fZmFpbHVyZSBvZiBzdHJpbmdcblxubGV0IGJhZF9pbnB1dCBzID0gcmFpc2UgKFNjYW5fZmFpbHVyZSBzKVxuXG5sZXQgYmFkX2lucHV0X2VzY2FwZSBjID1cbiAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImlsbGVnYWwgZXNjYXBlIGNoYXJhY3RlciAlQ1wiIGMpXG5cblxubGV0IGJhZF90b2tlbl9sZW5ndGggbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICB0aGUgc3BlY2lmaWVkIGxlbmd0aCB3YXMgdG9vIHNob3J0IGZvciB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHByZW1hdHVyZSBlbmQgb2YgZmlsZSBvY2N1cnJlZCBiZWZvcmUgZW5kIG9mIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJubyBkb3Qgb3IgZXhwb25lbnQgcGFydCBmb3VuZCBpbiBmbG9hdCB0b2tlblwiXG5cblxubGV0IGJhZF9oZXhfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJub3QgYSB2YWxpZCBmbG9hdCBpbiBoZXhhZGVjaW1hbCBub3RhdGlvblwiXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSA9XG4gIFByaW50Zi5zcHJpbnRmIFwibG9va2luZyBmb3IgJUMsIGZvdW5kICVDXCIgYyBjaVxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaSA9XG4gIGJhZF9pbnB1dCAoY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpKVxuXG5cbmxldCByZWMgc2tpcF93aGl0ZXMgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlbiBiZWdpblxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+XG4gICAgICBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgc2tpcF93aGl0ZXMgaWJcbiAgICB8IF8gLT4gKClcbiAgZW5kXG5cblxuKCogQ2hlY2tpbmcgdGhhdCBbY10gaXMgaW5kZWVkIGluIHRoZSBpbnB1dCwgdGhlbiBza2lwcyBpdC5cbiAgIEluIHRoaXMgY2FzZSwgdGhlIGNoYXJhY3RlciBbY10gaGFzIGJlZW4gZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlXG4gICBmb3JtYXQgYXMgYmVpbmcgbWFuZGF0b3J5IGluIHRoZSBpbnB1dDsgaGVuY2Ugd2Ugc2hvdWxkIGZhaWwgd2l0aFxuICAgW0VuZF9vZl9maWxlXSBpbiBjYXNlIG9mIGVuZF9vZl9pbnB1dC5cbiAgIChSZW1lbWJlciB0aGF0IFtTY2FuX2ZhaWx1cmVdIGlzIHJhaXNlZCBvbmx5IHdoZW4gKHdlIGNhbiBwcm92ZSBieVxuICAgZXZpZGVuY2UpIHRoYXQgdGhlIGlucHV0IGRvZXMgbm90IG1hdGNoIHRoZSBmb3JtYXQgc3RyaW5nIGdpdmVuLiBXZSBtdXN0XG4gICB0aHVzIGRpZmZlcmVudGlhdGUgW0VuZF9vZl9maWxlXSBhcyBhbiBlcnJvciBkdWUgdG8gbGFjayBvZiBpbnB1dCwgYW5kXG4gICBbU2Nhbl9mYWlsdXJlXSB3aGljaCBpcyBkdWUgdG8gcHJvdmFibHkgd3JvbmcgaW5wdXQuIEkgYW0gbm90IHN1cmUgdGhpcyBpc1xuICAgd29ydGggdGhlIGJ1cmRlbjogaXQgaXMgY29tcGxleCBhbmQgc29tZWhvdyBzdWJsaW1pbmFsOyBzaG91bGQgYmUgY2xlYXJlclxuICAgdG8gZmFpbCB3aXRoIFNjYW5fZmFpbHVyZSBcIk5vdCBlbm91Z2ggaW5wdXQgdG8gY29tcGxldGUgc2Nhbm5pbmdcIiEpXG5cbiAgIFRoYXQncyB3aHksIHdhaXRpbmcgZm9yIGEgYmV0dGVyIHNvbHV0aW9uLCB3ZSB1c2UgY2hlY2tlZF9wZWVrX2NoYXIgaGVyZS5cbiAgIFdlIGFyZSBhbHNvIGNhcmVmdWwgdG8gdHJlYXQgXCJcXHJcXG5cIiBpbiB0aGUgaW5wdXQgYXMgYW4gZW5kIG9mIGxpbmUgbWFya2VyOlxuICAgaXQgYWx3YXlzIG1hdGNoZXMgYSAnXFxuJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBpbnB1dCBmb3JtYXQgc3RyaW5nLiAqKVxubGV0IHJlYyBjaGVja19jaGFyIGliIGMgPVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnICcgLT4gc2tpcF93aGl0ZXMgaWJcbiAgfCAnXFxuJyAtPiBjaGVja19uZXdsaW5lIGliXG4gIHwgYyAtPiBjaGVja190aGlzX2NoYXIgaWIgY1xuXG5hbmQgY2hlY2tfdGhpc19jaGFyIGliIGMgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBjaSA9IGMgdGhlbiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiBlbHNlXG4gIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cbmFuZCBjaGVja19uZXdsaW5lIGliID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggY2kgd2l0aFxuICB8ICdcXG4nIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gIHwgJ1xccicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IGNoZWNrX3RoaXNfY2hhciBpYiAnXFxuJ1xuICB8IF8gLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXG4nIGNpXG5cblxuKCogRXh0cmFjdGluZyB0b2tlbnMgZnJvbSB0aGUgb3V0cHV0IHRva2VuIGJ1ZmZlci4gKilcblxubGV0IHRva2VuX2NoYXIgaWIgPSAoU2Nhbm5pbmcudG9rZW4gaWIpLlswXVxuXG5sZXQgdG9rZW5fc3RyaW5nID0gU2Nhbm5pbmcudG9rZW5cblxubGV0IHRva2VuX2Jvb2wgaWIgPVxuICBtYXRjaCBTY2FubmluZy50b2tlbiBpYiB3aXRoXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IHMgLT4gYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImludmFsaWQgYm9vbGVhbiAnJXMnXCIgcylcblxuXG4oKiBUaGUgdHlwZSBvZiBpbnRlZ2VyIGNvbnZlcnNpb25zLiAqKVxudHlwZSBpbnRlZ2VyX2NvbnZlcnNpb24gPVxuICB8IEJfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBiaW5hcnkgY29udmVyc2lvbiAqKVxuICB8IERfY29udmVyc2lvbiAoKiBTaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgSV9jb252ZXJzaW9uICgqIFNpZ25lZCBpbnRlZ2VyIGNvbnZlcnNpb24gKilcbiAgfCBPX2NvbnZlcnNpb24gKCogVW5zaWduZWQgb2N0YWwgY29udmVyc2lvbiAqKVxuICB8IFVfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBYX2NvbnZlcnNpb24gKCogVW5zaWduZWQgaGV4YWRlY2ltYWwgY29udmVyc2lvbiAqKVxuXG5cbmxldCBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciA9IGZ1bmN0aW9uXG4gIHwgJ2InIC0+IEJfY29udmVyc2lvblxuICB8ICdkJyAtPiBEX2NvbnZlcnNpb25cbiAgfCAnaScgLT4gSV9jb252ZXJzaW9uXG4gIHwgJ28nIC0+IE9fY29udmVyc2lvblxuICB8ICd1JyAtPiBVX2NvbnZlcnNpb25cbiAgfCAneCcgfCAnWCcgLT4gWF9jb252ZXJzaW9uXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuXG4oKiBFeHRyYWN0IGFuIGludGVnZXIgbGl0ZXJhbCB0b2tlbi5cbiAgIFNpbmNlIHRoZSBmdW5jdGlvbnMgU3RkbGliLippbnQqX29mX3N0cmluZyBkbyBub3QgYWNjZXB0IGEgbGVhZGluZyArLFxuICAgd2Ugc2tpcCBpdCBpZiBuZWNlc3NhcnkuICopXG5sZXQgdG9rZW5faW50X2xpdGVyYWwgY29udiBpYiA9XG4gIGxldCB0b2sgPVxuICAgIG1hdGNoIGNvbnYgd2l0aFxuICAgIHwgRF9jb252ZXJzaW9uIHwgSV9jb252ZXJzaW9uIC0+IFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBVX2NvbnZlcnNpb24gLT4gXCIwdVwiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IE9fY29udmVyc2lvbiAtPiBcIjBvXCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgWF9jb252ZXJzaW9uIC0+IFwiMHhcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBCX2NvbnZlcnNpb24gLT4gXCIwYlwiIF4gU2Nhbm5pbmcudG9rZW4gaWIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHRvayBpblxuICBpZiBsID0gMCB8fCB0b2suWzBdIDw+ICcrJyB0aGVuIHRvayBlbHNlIFN0cmluZy5zdWIgdG9rIDEgKGwgLSAxKVxuXG5cbigqIEFsbCB0aGUgZnVuY3Rpb25zIHRoYXQgY29udmVydCBhIHN0cmluZyB0byBhIG51bWJlciByYWlzZSB0aGUgZXhjZXB0aW9uXG4gICBGYWlsdXJlIHdoZW4gdGhlIGNvbnZlcnNpb24gaXMgbm90IHBvc3NpYmxlLlxuICAgVGhpcyBleGNlcHRpb24gaXMgdGhlbiB0cmFwcGVkIGluIFtrc2NhbmZdLiAqKVxubGV0IHRva2VuX2ludCBjb252IGliID0gaW50X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxubGV0IHRva2VuX2Zsb2F0IGliID0gZmxvYXRfb2Zfc3RyaW5nIChTY2FubmluZy50b2tlbiBpYilcblxuKCogVG8gc2NhbiBuYXRpdmUgaW50cywgaW50MzIgYW5kIGludDY0IGludGVnZXJzLlxuICAgV2UgY2Fubm90IGFjY2VzcyB0byBjb252ZXJzaW9ucyB0by9mcm9tIHN0cmluZ3MgZm9yIHRob3NlIHR5cGVzLFxuICAgTmF0aXZlaW50Lm9mX3N0cmluZywgSW50MzIub2Zfc3RyaW5nLCBhbmQgSW50NjQub2Zfc3RyaW5nLFxuICAgc2luY2UgdGhvc2UgbW9kdWxlcyBhcmUgbm90IGF2YWlsYWJsZSB0byBbU2NhbmZdLlxuICAgSG93ZXZlciwgd2UgY2FuIGJpbmQgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZyBwcmltaXRpdmVzIHRoYXQgYXJlXG4gICBhdmFpbGFibGUgaW4gdGhlIHJ1bnRpbWUuICopXG5leHRlcm5hbCBuYXRpdmVpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50MzJfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDY0X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuXG5cbmxldCB0b2tlbl9uYXRpdmVpbnQgY29udiBpYiA9IG5hdGl2ZWludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50MzIgY29udiBpYiA9IGludDMyX29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcbmxldCB0b2tlbl9pbnQ2NCBjb252IGliID0gaW50NjRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxuXG4oKiBTY2FubmluZyBudW1iZXJzLiAqKVxuXG4oKiBEaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHN1cHBvc2UgdGhhdCBvbmUgY2hhcmFjdGVyIGhhcyBiZWVuIGNoZWNrZWQgYW5kXG4gICBpcyBhdmFpbGFibGUsIHNpbmNlIHRoZXkgcmV0dXJuIGF0IGVuZCBvZiBmaWxlIHdpdGggdGhlIGN1cnJlbnRseSBmb3VuZFxuICAgdG9rZW4gc2VsZWN0ZWQuXG5cbiAgIFB1dCBpdCBpbiBhbm90aGVyIHdheSwgdGhlIGRpZ2l0cyBzY2FubmluZyBmdW5jdGlvbnMgc2NhbiBmb3IgYSBwb3NzaWJseVxuICAgZW1wdHkgc2VxdWVuY2Ugb2YgZGlnaXRzLCAoaGVuY2UsIGEgc3VjY2Vzc2Z1bCBzY2FubmluZyBmcm9tIG9uZSBvZiB0aG9zZVxuICAgZnVuY3Rpb25zIGRvZXMgbm90IGltcGx5IHRoYXQgdGhlIHRva2VuIGlzIGEgd2VsbC1mb3JtZWQgbnVtYmVyOiB0byBnZXQgYVxuICAgdHJ1ZSBudW1iZXIsIGl0IGlzIG1hbmRhdG9yeSB0byBjaGVjayB0aGF0IGF0IGxlYXN0IG9uZSB2YWxpZCBkaWdpdCBpc1xuICAgYXZhaWxhYmxlIGJlZm9yZSBjYWxsaW5nIG9uZSBvZiB0aGUgZGlnaXQgc2Nhbm5pbmcgZnVuY3Rpb25zKS4gKilcblxuKCogVGhlIGRlY2ltYWwgY2FzZSBpcyB0cmVhdGVkIGVzcGVjaWFsbHkgZm9yIG9wdGltaXphdGlvbiBwdXJwb3Nlcy4gKilcbmxldCByZWMgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCAnXycgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbmxldCBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1cyB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkZWNpbWFsIGRpZ2l0c1wiIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCBjIC0+XG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImNoYXJhY3RlciAlQyBpcyBub3QgYSBkZWNpbWFsIGRpZ2l0XCIgYylcblxuXG4oKiBUbyBzY2FuIG51bWJlcnMgZnJvbSBvdGhlciBiYXNlcywgd2UgdXNlIGEgcHJlZGljYXRlIGFyZ3VtZW50IHRvXG4gICBzY2FuIGRpZ2l0cy4gKilcbmxldCBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBzY2FuX2RpZ2l0cyB3aWR0aCBpYiA9XG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgYyB3aGVuIGRpZ2l0cCBjIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgIHNjYW5fZGlnaXRzIHdpZHRoIGliXG4gICAgfCAnXycgLT5cbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgXyAtPiB3aWR0aCBpblxuICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2RpZ2l0X3BsdXMgYmFzaXMgZGlnaXRwIHdpZHRoIGliID1cbiAgKCogRW5zdXJlIHdlIGhhdmUgZ290IGVub3VnaCB3aWR0aCBsZWZ0LFxuICAgICBhbmQgcmVhZCBhdCBsZWFzdCBvbmUgZGlnaXQuICopXG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgaWYgZGlnaXRwIGMgdGhlblxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGlnaXRfc3RhciBkaWdpdHAgd2lkdGggaWJcbiAgZWxzZVxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgdmFsaWQgJXMgZGlnaXRcIiBjIGJhc2lzKVxuXG5cbmxldCBpc19iaW5hcnlfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnMScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9iaW5hcnlfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwiYmluYXJ5XCIgaXNfYmluYXJ5X2RpZ2l0XG5cbmxldCBpc19vY3RhbF9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc3JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX29jdGFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcIm9jdGFsXCIgaXNfb2N0YWxfZGlnaXRcblxubGV0IGlzX2hleGFfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX2hleGFkZWNpbWFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImhleGFkZWNpbWFsXCIgaXNfaGV4YV9kaWdpdFxuXG4oKiBTY2FuIGEgZGVjaW1hbCBpbnRlZ2VyLiAqKVxubGV0IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgPSBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1c1xuXG5sZXQgc2Nhbl9zaWduIHdpZHRoIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnKycgLT4gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjXG4gIHwgJy0nIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG5cblxuKCogU2NhbiBhbiB1bnNpZ25lZCBpbnRlZ2VyIHRoYXQgY291bGQgYmUgZ2l2ZW4gaW4gYW55IChjb21tb24pIGJhc2lzLlxuICAgSWYgZGlnaXRzIGFyZSBwcmVmaXhlZCBieSBvbmUgb2YgMHgsIDBYLCAwbywgb3IgMGIsIHRoZSBudW1iZXIgaXNcbiAgIGFzc3VtZWQgdG8gYmUgd3JpdHRlbiByZXNwZWN0aXZlbHkgaW4gaGV4YWRlY2ltYWwsIGhleGFkZWNpbWFsLFxuICAgb2N0YWwsIG9yIGJpbmFyeS4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBiZWdpbiBtYXRjaCBjIHdpdGhcbiAgICB8ICd4JyB8ICdYJyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ28nIC0+IHNjYW5fb2N0YWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCAnYicgLT4gc2Nhbl9iaW5hcnlfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCBfIC0+IHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliIGVuZFxuICB8IF8gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2ludF9jb252ZXJzaW9uIGNvbnYgd2lkdGggaWIgPVxuICBtYXRjaCBjb252IHdpdGhcbiAgfCBCX2NvbnZlcnNpb24gLT4gc2Nhbl9iaW5hcnlfaW50IHdpZHRoIGliXG4gIHwgRF9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBJX2NvbnZlcnNpb24gLT4gc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWJcbiAgfCBPX2NvbnZlcnNpb24gLT4gc2Nhbl9vY3RhbF9pbnQgd2lkdGggaWJcbiAgfCBVX2NvbnZlcnNpb24gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICB8IFhfY29udmVyc2lvbiAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW5uaW5nIGZsb2F0aW5nIHBvaW50IG51bWJlcnMuICopXG5cbigqIEZyYWN0aW9uYWwgcGFydCBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlZHVjZWQgdG8gMCBkaWdpdHMuICopXG5sZXQgc2Nhbl9mcmFjdGlvbmFsX3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogRXhwIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnZScgfCAnRScgYXMgYyAtPlxuICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogU2NhbiB0aGUgaW50ZWdlciBwYXJ0IG9mIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLCAobm90IHVzaW5nIHRoZVxuICAgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uIHNpbmNlIHRoZSBpbnRlZ2VyIHBhcnQgY2FuIGJlIGVtcHR5KTpcbiAgIGFuIG9wdGlvbmFsIHNpZ24sIGZvbGxvd2VkIGJ5IGEgcG9zc2libHkgZW1wdHkgc2VxdWVuY2Ugb2YgZGVjaW1hbFxuICAgZGlnaXRzIChlLmcuIC0uMSkuICopXG5sZXQgc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcblxuXG4oKlxuICAgRm9yIHRoZSB0aW1lIGJlaW5nIHdlIGhhdmUgKGFzIGZvdW5kIGluIHNjYW5mLm1saSk6XG4gICB0aGUgZmllbGQgd2lkdGggaXMgY29tcG9zZWQgb2YgYW4gb3B0aW9uYWwgaW50ZWdlciBsaXRlcmFsXG4gICBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsIHdpZHRoIG9mIHRoZSB0b2tlbiB0byByZWFkLlxuICAgVW5mb3J0dW5hdGVseSwgdGhlIHR5cGUtY2hlY2tlciBsZXQgdGhlIHVzZXIgd3JpdGUgYW4gb3B0aW9uYWwgcHJlY2lzaW9uLFxuICAgc2luY2UgdGhpcyBpcyB2YWxpZCBmb3IgcHJpbnRmIGZvcm1hdCBzdHJpbmdzLlxuXG4gICBUaHVzLCB0aGUgbmV4dCBzdGVwIGZvciBTY2FuZiBpcyB0byBzdXBwb3J0IGEgZnVsbCB3aWR0aCBhbmQgcHJlY2lzaW9uXG4gICBpbmRpY2F0aW9uLCBtb3JlIG9yIGxlc3Mgc2ltaWxhciB0byB0aGUgb25lIGZvciBwcmludGYsIHBvc3NpYmx5IGV4dGVuZGVkXG4gICB0byB0aGUgc3BlY2lmaWNhdGlvbiBvZiBhIFttYXgsIG1pbl0gcmFuZ2UgZm9yIHRoZSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZFxuICAgZm9yIHN0cmluZ3MuIFNvbWV0aGluZyBsaWtlIHRoZSBmb2xsb3dpbmcgc3BlYyBmb3Igc2NhbmYubWxpOlxuXG4gICBUaGUgb3B0aW9uYWwgW3dpZHRoXSBpcyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG1heGltYWxcbiAgIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLiBGb3IgaW5zdGFuY2UsIFslNmRdIHJlYWRzIGFuIGludGVnZXIsXG4gICBoYXZpbmcgYXQgbW9zdCA2IGNoYXJhY3RlcnMuXG5cbiAgIFRoZSBvcHRpb25hbCBbcHJlY2lzaW9uXSBpcyBhIGRvdCBbLl0gZm9sbG93ZWQgYnkgYW4gaW50ZWdlcjpcblxuICAgLSBpbiB0aGUgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGNvbnZlcnNpb25zIChbJWZdLCBbJWVdLCBbJWddLCBbJUZdLCBbJUVdLFxuICAgYW5kIFslRl0gY29udmVyc2lvbnMsIHRoZSBbcHJlY2lzaW9uXSBpbmRpY2F0ZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mXG4gICBkaWdpdHMgdGhhdCBtYXkgZm9sbG93IHRoZSBkZWNpbWFsIHBvaW50LiBGb3IgaW5zdGFuY2UsIFslLjRmXSByZWFkcyBhXG4gICBbZmxvYXRdIHdpdGggYXQgbW9zdCA0IGZyYWN0aW9uYWwgZGlnaXRzLFxuXG4gICAtIGluIHRoZSBzdHJpbmcgY29udmVyc2lvbnMgKFslc10sIFslU10sIFslXFxbIHJhbmdlIFxcXV0pLCBhbmQgaW4gdGhlXG4gICBpbnRlZ2VyIG51bWJlciBjb252ZXJzaW9ucyAoWyVpXSwgWyVkXSwgWyV1XSwgWyV4XSwgWyVvXSwgYW5kIHRoZWlyXG4gICBbaW50MzJdLCBbaW50NjRdLCBhbmQgW25hdGl2ZV9pbnRdIGNvcnJlc3BvbmRlbnQpLCB0aGUgW3ByZWNpc2lvbl1cbiAgIGluZGljYXRlcyB0aGUgcmVxdWlyZWQgbWluaW11bSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZCxcblxuICAgLSBvbiBhbGwgb3RoZXIgY29udmVyc2lvbnMsIHRoZSB3aWR0aCBhbmQgcHJlY2lzaW9uIHNwZWNpZnkgdGhlIFttYXgsIG1pbl1cbiAgIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWQuXG4qKVxubGV0IHNjYW5fZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGgsIHByZWNpc2lvbiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnLicgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBsZXQgcHJlY2lzaW9uID0gSW50Lm1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIpIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cbiAgfCBfIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cblxuXG5sZXQgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgZXJyb3Igc3RyID1cbiAgbGV0IGxvd2VyY2FzZSBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICdBJyAuLiAnWicgLT5cbiAgICAgIGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ0EnICsgaW50X29mX2NoYXIgJ2EnKVxuICAgIHwgXyAtPiBjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGggPSByZWYgd2lkdGggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIGxvd2VyY2FzZSBjIDw+IGxvd2VyY2FzZSBzdHIuW2ldIHRoZW4gZXJyb3IgKCk7XG4gICAgaWYgIXdpZHRoID0gMCB0aGVuIGVycm9yICgpO1xuICAgIHdpZHRoIDo9IFNjYW5uaW5nLnN0b3JlX2NoYXIgIXdpZHRoIGliIGM7XG4gIGRvbmU7XG4gICF3aWR0aFxuXG5cbmxldCBzY2FuX2hleF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBsZXQgd2lkdGggPSBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwieFwiIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IEludC5taW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgICAgd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgcHJlY2lzaW9uIGliKVxuICAgICAgICAgIClcbiAgICAgICAgICB8IF8gLT4gd2lkdGggaW5cbiAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgIHwgJ3AnIHwgJ1AnIGFzIGMgLT5cbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gICAgICAgICAgfCBfIC0+IHdpZHRoXG4gIClcbiAgfCAnbicgfCAnTicgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJhblwiXG4gIHwgJ2knIHwgJ0knIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwibmZpbml0eVwiXG4gIHwgXyAtPiBiYWRfaGV4X2Zsb2F0ICgpXG5cblxubGV0IHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcuJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICgqIFRoZSBlZmZlY3RpdmUgd2lkdGggYXZhaWxhYmxlIGZvciBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IGlzXG4gICAgICAgdGhlIG1pbmltdW0gb2YgZGVjbGFyZWQgcHJlY2lzaW9uIGFuZCB3aWR0aCBsZWZ0LiAqKVxuICAgIGxldCBwcmVjaXNpb24gPSBJbnQubWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICgqIEFmdGVyIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgd2l0aCBbcHJlY2lzaW9uXSBwcm92aXNpb25hbCB3aWR0aCxcbiAgICAgICBbd2lkdGhfcHJlY2lzaW9uXSBpcyBsZWZ0LiAqKVxuICAgIGxldCB3aWR0aF9wcmVjaXNpb24gPSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIgaW5cbiAgICAoKiBIZW5jZSwgc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCB0b29rIGV4YWN0bHlcbiAgICAgICBbcHJlY2lzaW9uIC0gd2lkdGhfcHJlY2lzaW9uXSBjaGFycy4gKilcbiAgICBsZXQgZnJhY193aWR0aCA9IHByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbiBpblxuICAgICgqIEFuZCBuZXcgcHJvdmlzaW9uYWwgd2lkdGggaXMgW3dpZHRoIC0gd2lkdGhfcHJlY2lzaW9uLiAqKVxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gZnJhY193aWR0aCBpblxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8ICdlJyB8ICdFJyAtPlxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8IF8gLT4gYmFkX2Zsb2F0ICgpXG5cblxubGV0IHNjYW5fY2FtbF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPiAoXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ3gnIHwgJ1gnIGFzIGMgLT4gKFxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWIgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IEludC5taW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgKVxuICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gYmFkX2Zsb2F0ICgpIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICB8IF8gLT4gd2lkdGhcbiAgICApXG4gICAgfCBfIC0+XG4gICAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbiAgKVxuICB8ICcxJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliXG4oKiBTcGVjaWFsIGNhc2Ugb2YgbmFuIGFuZCBpbmZpbml0eTpcbiAgfCAnaScgLT5cbiAgfCAnbicgLT5cbiopXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG4oKiBTY2FuIGEgcmVndWxhciBzdHJpbmc6XG4gICBzdG9wcyB3aGVuIGVuY291bnRlcmluZyBhIHNwYWNlLCBpZiBubyBzY2FubmluZyBpbmRpY2F0aW9uIGhhcyBiZWVuIGdpdmVuO1xuICAgb3RoZXJ3aXNlLCBzdG9wcyB3aGVuIGVuY291bnRlcmluZyB0aGUgY2hhcmFjdGVycyBpbiB0aGUgc2Nhbm5pbmdcbiAgIGluZGljYXRpb24gW3N0cF0uXG4gICBJdCBhbHNvIHN0b3BzIGF0IGVuZCBvZiBmaWxlIG9yIHdoZW4gdGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgaGFzXG4gICBiZWVuIHJlYWQuICopXG5sZXQgc2Nhbl9zdHJpbmcgc3RwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBsb29wIHdpZHRoID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICBtYXRjaCBzdHAgd2l0aFxuICAgICAgfCBTb21lIGMnIHdoZW4gYyA9IGMnIC0+IFNjYW5uaW5nLnNraXBfY2hhciB3aWR0aCBpYlxuICAgICAgfCBTb21lIF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpblxuICBsb29wIHdpZHRoXG5cblxuKCogU2NhbiBhIGNoYXI6IHBlZWsgc3RyaWN0bHkgb25lIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQsIHdoYXRzb2V2ZXIuICopXG5sZXQgc2Nhbl9jaGFyIHdpZHRoIGliID1cbiAgKCogVGhlIGNhc2Ugd2lkdGggPSAwIGNvdWxkIG5vdCBoYXBwZW4gaGVyZSwgc2luY2UgaXQgaXMgdGVzdGVkIGJlZm9yZVxuICAgICBjYWxsaW5nIHNjYW5fY2hhciwgaW4gdGhlIG1haW4gc2Nhbm5pbmcgZnVuY3Rpb24uXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImEgY2hhcmFjdGVyXCIgZWxzZSAqKVxuICBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIChTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYilcblxuXG5sZXQgY2hhcl9mb3JfYmFja3NsYXNoID0gZnVuY3Rpb25cbiAgfCAnbicgLT4gJ1xcMDEwJ1xuICB8ICdyJyAtPiAnXFwwMTMnXG4gIHwgJ2InIC0+ICdcXDAwOCdcbiAgfCAndCcgLT4gJ1xcMDA5J1xuICB8IGMgLT4gY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYyA9IGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCdcblxubGV0IGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxMDAgKiBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzAgK1xuICAgICAxMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICAgZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICBcImJhZCBjaGFyYWN0ZXIgZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlYyVjXCIgYzAgYzEgYzIpIGVsc2VcbiAgY2hhcl9vZl9pbnQgY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBoZXhhZGVjaW1hbCBkaWdpdCBjaGFyYWN0ZXIuICopXG5sZXQgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID1cbiAgbGV0IGQgPSBpbnRfb2ZfY2hhciBjIGluXG4gICgqIENvdWxkIGFsc28gYmU6XG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnOScgdGhlbiBkIC0gaW50X29mX2NoYXIgJzAnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdGJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdBJyBlbHNlXG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnZicgdGhlbiAxMCArIGQgLSBpbnRfb2ZfY2hhciAnYScgZWxzZSBhc3NlcnQgZmFsc2VcbiAgKilcbiAgaWYgZCA+PSBpbnRfb2ZfY2hhciAnYScgdGhlblxuICAgIGQgLSA4NyAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnYScgKikgZWxzZVxuICBpZiBkID49IGludF9vZl9jaGFyICdBJyB0aGVuXG4gICAgZCAtIDU1ICAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKikgZWxzZVxuICAgIGQgLSBpbnRfb2ZfY2hhciAnMCdcblxuXG5sZXQgY2hhcl9mb3JfaGV4YWRlY2ltYWxfY29kZSBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxNiAqIGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzEgK1xuICAgICAgICAgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMiBpblxuICBpZiBjIDwgMCB8fCBjID4gMjU1IHRoZW5cbiAgICBiYWRfaW5wdXRcbiAgICAgIChQcmludGYuc3ByaW50ZiBcImJhZCBjaGFyYWN0ZXIgaGV4YWRlY2ltYWwgZW5jb2RpbmcgXFxcXCVjJWNcIiBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogQ2FsbGVkIGluIHBhcnRpY3VsYXIgd2hlbiBlbmNvdW50ZXJpbmcgJ1xcXFwnIGFzIHN0YXJ0ZXIgb2YgYSBjaGFyLlxuICAgU3RvcHMgYmVmb3JlIHRoZSBjb3JyZXNwb25kaW5nICdcXCcnLiAqKVxubGV0IGNoZWNrX25leHRfY2hhciBtZXNzYWdlIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlIGVsc2VcbiAgY1xuXG5cbmxldCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgPSBjaGVja19uZXh0X2NoYXIgXCJhIENoYXJcIlxubGV0IGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nID0gY2hlY2tfbmV4dF9jaGFyIFwiYSBTdHJpbmdcIlxuXG5sZXQgc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYiA9XG4gIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gIHwgJ1xcXFwnIHwgJ1xcJycgfCAnXFxcIicgfCAnbicgfCAndCcgfCAnYicgfCAncicgYXMgYyAtPlxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKGNoYXJfZm9yX2JhY2tzbGFzaCBjKVxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCBnZXRfZGlnaXQgKCkgPVxuICAgICAgbGV0IGMgPSBTY2FubmluZy5uZXh0X2NoYXIgaWIgaW5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMCA9IGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9kZWNpbWFsX2NvZGUgYzAgYzEgYzIpXG4gIHwgJ3gnIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIHwgJ2EnIC4uICdmJyBhcyBjIC0+IGNcbiAgICAgIHwgYyAtPiBiYWRfaW5wdXRfZXNjYXBlIGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyKVxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXRfZXNjYXBlIGNcblxuXG4oKiBTY2FuIGEgY2hhcmFjdGVyIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX2NoYXIgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcJycgLT4gZmluZF9jaGFyIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXCcnIGNcblxuICBhbmQgZmluZF9jaGFyIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXFwnIC0+XG4gICAgICBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKSBpYilcbiAgICB8IGMgLT5cbiAgICAgIGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgYyBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgZGVsaW1pdGVkIHN0cmluZyAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxcIicgY1xuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXFwiJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgJ1xcXFwnIC0+IHNjYW5fYmFja3NsYXNoIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIHNjYW5fYmFja3NsYXNoIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxyJyAtPiBza2lwX25ld2xpbmUgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgd2lkdGggaWIpXG5cbiAgYW5kIHNraXBfbmV3bGluZSB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgJ1xccicpXG5cbiAgYW5kIHNraXBfc3BhY2VzIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnICcgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3Agd2lkdGggaW5cblxuICBmaW5kX3N0YXJ0IHdpZHRoXG5cblxuKCogU2NhbiBhIGJvb2xlYW4gKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2Jvb2wgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGxldCBtID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICd0JyAtPiA0XG4gICAgfCAnZicgLT4gNVxuICAgIHwgYyAtPlxuICAgICAgYmFkX2lucHV0XG4gICAgICAgIChQcmludGYuc3ByaW50ZiBcInRoZSBjaGFyYWN0ZXIgJUMgY2Fubm90IHN0YXJ0IGEgYm9vbGVhblwiIGMpIGluXG4gIHNjYW5fc3RyaW5nIE5vbmUgbSBpYlxuXG5cbigqIFNjYW4gYSBzdHJpbmcgY29udGFpbmluZyBlbGVtZW50cyBpbiBjaGFyX3NldCBhbmQgdGVybWluYXRlZCBieSBzY2FuX2luZGljXG4gICBpZiBwcm92aWRlZC4gKilcbmxldCBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IHNjYW5faW5kaWMgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fY2hhcnMgaSBzdHAgPVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgaSA+IDAgJiYgbm90IChTY2FubmluZy5lb2YgaWIpICYmXG4gICAgICAgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyAmJlxuICAgICAgIGludF9vZl9jaGFyIGMgPD4gc3RwIHRoZW5cbiAgICAgIGxldCBfID0gU2Nhbm5pbmcuc3RvcmVfY2hhciBtYXhfaW50IGliIGMgaW5cbiAgICAgIHNjYW5fY2hhcnMgKGkgLSAxKSBzdHAgaW5cbiAgbWF0Y2ggc2Nhbl9pbmRpYyB3aXRoXG4gIHwgTm9uZSAtPiBzY2FuX2NoYXJzIHdpZHRoICgtMSk7XG4gIHwgU29tZSBjIC0+XG4gICAgc2Nhbl9jaGFycyB3aWR0aCAoaW50X29mX2NoYXIgYyk7XG4gICAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW5cbiAgICAgIGxldCBjaSA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgICAgaWYgYyA9IGNpXG4gICAgICB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gICAgICBlbHNlIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cblxuKCogVGhlIGdsb2JhbCBlcnJvciByZXBvcnQgZnVuY3Rpb24gZm9yIFtTY2FuZl0uICopXG5sZXQgc2NhbmZfYmFkX2lucHV0IGliID0gZnVuY3Rpb25cbiAgfCBTY2FuX2ZhaWx1cmUgcyB8IEZhaWx1cmUgcyAtPlxuICAgIGxldCBpID0gU2Nhbm5pbmcuY2hhcl9jb3VudCBpYiBpblxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJzY2FuZjogYmFkIGlucHV0IGF0IGNoYXIgbnVtYmVyICVpOiAlc1wiIGkgcylcbiAgfCB4IC0+IHJhaXNlIHhcblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgYSBjb3VudGVyIGZyb20gYW4gaW5wdXQgYnVmZmVyLiAqKVxubGV0IGdldF9jb3VudGVyIGliIGNvdW50ZXIgPVxuICBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgLT4gU2Nhbm5pbmcubGluZV9jb3VudCBpYlxuICB8IENoYXJfY291bnRlciAtPiBTY2FubmluZy5jaGFyX2NvdW50IGliXG4gIHwgVG9rZW5fY291bnRlciAtPiBTY2FubmluZy50b2tlbl9jb3VudCBpYlxuXG5cbigqIENvbXB1dGUgdGhlIHdpZHRoIG9mIGEgcGFkZGluZyBvcHRpb24gKHNlZSBcIiU0MntcIiBhbmQgXCIlMTIzKFwiKS4gKilcbmxldCB3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IG1heF9pbnRcbiAgfCBTb21lIHdpZHRoIC0+IHdpZHRoXG5cblxubGV0IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nID1cbiAgaWYgZm10aW5nID0gRXNjYXBlZF9wZXJjZW50IHRoZW4gJyUnLCBcIlwiIGVsc2VcbiAgICBsZXQgc3RyID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZyBpblxuICAgIGxldCBzdHAgPSBzdHIuWzFdIGluXG4gICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciAyIChTdHJpbmcubGVuZ3RoIHN0ciAtIDIpIGluXG4gICAgc3RwLCBzdWJfc3RyXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFJlYWRlciBtYW5hZ2VtZW50ICopXG5cbigqIEEgY2FsbCB0byB0YWtlX2Zvcm1hdF9yZWFkZXJzIG9uIGEgZm9ybWF0IGlzIGV2YWx1YXRlZCBpbnRvIGZ1bmN0aW9uc1xuICAgdGFraW5nIHJlYWRlcnMgYXMgYXJndW1lbnRzIGFuZCBhZ2dyZWdhdGUgdGhlbSBpbnRvIGFuIGhldGVyb2dlbmVvdXMgbGlzdCAqKVxuKCogV2hlbiBhbGwgcmVhZGVycyBhcmUgdGFrZW4sIGZpbmFsbHkgcGFzcyB0aGUgbGlzdCBvZiB0aGUgcmVhZGVycyB0byB0aGVcbiAgIGNvbnRpbnVhdGlvbiBrLiAqKVxubGV0IHJlYyB0YWtlX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgZCA9XG5mdW4gayBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdFxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENhbWxfc3RyaW5nIChfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQzMiAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IE5hdGl2ZWludCAoXywgXywgXywgcmVzdCkgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50NjQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGbG9hdCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEJvb2wgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEN1c3RvbSAoXywgXywgcmVzdCkgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSwgcmVzdCkgLT5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdCBmbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgICAgLT5cbiAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKSByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgICAgICAgLT4gdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIGsgaWduIHJlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgICAgICAgIC0+IGsgTmlsXG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGZtdHR5IGNvbWluZyBmcm9tIGEgRm9ybWF0X3N1YnN0IFwiJSguLi4lKVwiLiAqKVxuYW5kIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIHggeSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgeCwgeSkgZm10dHkgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFJlYWRlcl90eSBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGlnbm9yZWQgcGFyYW1ldGVyLiAqKVxuYW5kIHRha2VfaWdub3JlZF9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBpZ25vcmVkIC0+XG4gICAgICAoeSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgeCwgZSwgZikgZm10IC0+IGQgPVxuZnVuIGsgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10XG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgZm10dHkgZm10XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgc2Nhbm5pbmcgKilcblxuKCogTWFrZSBhIGdlbmVyaWMgc2Nhbm5pbmcgZnVuY3Rpb24uICopXG4oKiBTY2FuIGEgc3RyZWFtIGFjY29yZGluZyB0byBhIGZvcm1hdCBhbmQgcmVhZGVycyBvYnRhaW5lZCBieVxuICAgdGFrZV9mb3JtYXRfcmVhZGVycywgYW5kIGFnZ3JlZ2F0ZSBzY2FubmVkIHZhbHVlcyBpbnRvIGFuXG4gICBoZXRlcm9nZW5lb3VzIGxpc3QuICopXG4oKiBSZXR1cm4gdGhlIGhldGVyb2dlbmVvdXMgbGlzdCBvZiBzY2FubmVkIHZhbHVlcy4gKilcbmxldCByZWMgbWFrZV9zY2FuZiA6IHR5cGUgYSBjIGQgZSBmLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKGEsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NoYXIgMCBpYiBpblxuICAgIGxldCBjID0gdG9rZW5fY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSBzdHApIHdpZHRoIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICd7Jykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpKSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSAnWycpIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhblxuICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyBOb25lIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcblxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50IGMpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludDMyIGMpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9uYXRpdmVpbnQgYylcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50NjQgYylcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9GIHwgRmxvYXRfQ0YpKSwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2NhbWxfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRykpLFxuICAgICAgICAgICBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9oIHwgRmxvYXRfSCkpLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5faGV4X2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIF8gXyBpYiA9IHNjYW5fYm9vbCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fYm9vbFxuICB8IEFscGhhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJWFcXFwiXCJcbiAgfCBUaGV0YSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiV0XFxcIlwiXG4gIHwgQ3VzdG9tIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJT9cXFwiIChjdXN0b20gY29udmVydGVyKVwiXG4gIHwgUmVhZGVyIGZtdF9yZXN0IC0+XG4gICAgYmVnaW4gbWF0Y2ggcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkgLT5cbiAgICAgICAgbGV0IHggPSByZWFkZXIgaWIgaW5cbiAgICAgICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXRfcmVzdCByZWFkZXJzX3Jlc3QpXG4gICAgfCBOaWwgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgXCJzY2FuZjogbWlzc2luZyByZWFkZXJcIlxuICAgIGVuZFxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBpZiBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICAgIGVsc2UgYmFkX2lucHV0IFwiZW5kIG9mIGlucHV0IG5vdCBmb3VuZFwiXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZy5pdGVyIChjaGVja19jaGFyIGliKSBzdHI7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliIGNocjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuXG4gIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10ID1cbiAgICAgIHRyeSBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHMgZm10dHlcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZ1xuICAgIGluXG4gICAgQ29ucyAoZm10LCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyAod2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0KSBpYiBpblxuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCwgZm10JyA9XG4gICAgICB0cnlcbiAgICAgICAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgcyBpblxuICAgICAgICBsZXQgRm10X0VCQiBmbXQnID0gZm10X2ViYl9vZl9zdHJpbmcgcyBpblxuICAgICAgICAoKiBUT0RPOiBmaW5kIGEgd2F5IHRvIGF2b2lkIHJlcGFyc2luZyB0d2ljZSAqKVxuXG4gICAgICAgICgqIFRPRE86IHRoZXNlIHR5cGUtY2hlY2tzIGJlbG93ICpjYW4qIGZhaWwgYmVjYXVzZSBvZiB0eXBlXG4gICAgICAgICAgIGFtYmlndWl0eSBpbiBwcmVzZW5jZSBvZiBpZ25vcmVkLXJlYWRlcnM6IFwiJV9yJWRcIiBhbmQgXCIlZCVfclwiXG4gICAgICAgICAgIGFyZSB0eXBlZCBpbiB0aGUgc2FtZSB3YXkuXG5cbiAgICAgICAgICAgIyBTY2FuZi5zc2NhbmYgXCJcXFwiJV9yJWRcXFwiM1wiIFwiJSglZCVfciUpXCIgaWdub3JlXG4gICAgICAgICAgICAgKGZ1biBmbXQgbiAtPiBzdHJpbmdfb2ZfZm9ybWF0IGZtdCwgbilcbiAgICAgICAgICAgRXhjZXB0aW9uOiBDYW1saW50ZXJuYWxGb3JtYXQuVHlwZV9taXNtYXRjaC5cblxuICAgICAgICAgICBXZSBzaG91bGQgcHJvcGVybHkgY2F0Y2ggdGhpcyBleGNlcHRpb24uXG4gICAgICAgICopXG4gICAgICAgIHR5cGVfZm9ybWF0IGZtdCAoZXJhc2VfcmVsIGZtdHR5KSxcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10JyAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSlcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZ1xuICAgIGluXG4gICAgQ29ucyAoRm9ybWF0IChmbXQsIHMpLFxuICAgICAgICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCAoU29tZSBzdHApIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBDb25zIChzLCBtYWtlX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBsZXQgd2lkdGggPSB3aWR0aF9vZl9wYWRfb3B0IHdpZHRoX29wdCBpblxuICAgIHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgTm9uZSB3aWR0aCBpYjtcbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgbGV0IGNvdW50ID0gZ2V0X2NvdW50ZXIgaWIgY291bnRlciBpblxuICAgIENvbnMgKGNvdW50LCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCByZXN0KSAtPlxuICAgIFN0cmluZy5pdGVyIChjaGVja19jaGFyIGliKSAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0KTtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiAnQCc7IGNoZWNrX2NoYXIgaWIgJ3snO1xuICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAnWyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcblxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBsZXQgUGFyYW1fZm9ybWF0X0VCQiBmbXQnID0gcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0IGluXG4gICAgYmVnaW4gbWF0Y2ggbWFrZV9zY2FuZiBpYiBmbXQnIHJlYWRlcnMgd2l0aFxuICAgIHwgQ29ucyAoXywgYXJnX3Jlc3QpIC0+IGFyZ19yZXN0XG4gICAgfCBOaWwgLT4gYXNzZXJ0IGZhbHNlXG4gICAgZW5kXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgTmlsXG5cbigqIENhc2UgYW5hbHlzaXMgb24gcGFkZGluZyBhbmQgcHJlY2lzaW9uLiAqKVxuKCogUmVqZWN0IGZvcm1hdHMgY29udGFpbmluZyBcIiUqXCIgb3IgXCIlLipcIi4gKilcbigqIFBhc3MgcGFkZGluZyBhbmQgcHJlY2lzaW9uIHRvIHRoZSBnZW5lcmljIHNjYW5uZXIgYHNjYW4nLiAqKVxuYW5kIHBhZF9wcmVjX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYgeCB5IHogdCAuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT5cbiAgICAgIChpbnQgLT4gaW50IC0+IFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gdCkgLT5cbiAgICAgIChTY2FubmluZy5pbl9jaGFubmVsIC0+IHopIC0+XG4gICAgICAoeCwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgcGFkIHByZWMgc2NhbiB0b2tlbiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IG1heF9pbnQgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gbWF4X2ludCBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGxldCBfID0gc2NhbiB3IG1heF9pbnQgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgcCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nIChMZWZ0LCBfKSwgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlLVxcXCJcIlxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIF8pLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgQXJnX3BhZGRpbmcgXywgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICgqIERlZmluaW5nIFtzY2FuZl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbc2NhbmZdICopXG5cbnR5cGUgJ2Ega3NjYW5mX3Jlc3VsdCA9IEFyZ3Mgb2YgJ2EgfCBFeGMgb2YgZXhuXG5cbmxldCBrc2NhbmYgaWIgZWYgKEZvcm1hdCAoZm10LCBzdHIpKSA9XG4gIGxldCByZWMgYXBwbHkgOiB0eXBlIGEgYiAuIGEgLT4gKGEsIGIpIGhldGVyX2xpc3QgLT4gYiA9XG4gICAgZnVuIGYgYXJncyAtPiBtYXRjaCBhcmdzIHdpdGhcbiAgICB8IENvbnMgKHgsIHIpIC0+IGFwcGx5IChmIHgpIHJcbiAgICB8IE5pbCAtPiBmXG4gIGluXG4gIGxldCBrIHJlYWRlcnMgZiA9XG4gICAgU2Nhbm5pbmcucmVzZXRfdG9rZW4gaWI7XG4gICAgbWF0Y2ggdHJ5IEFyZ3MgKG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpIHdpdGhcbiAgICAgIHwgKFNjYW5fZmFpbHVyZSBfIHwgRmFpbHVyZSBfIHwgRW5kX29mX2ZpbGUpIGFzIGV4YyAtPiBFeGMgZXhjXG4gICAgICB8IEludmFsaWRfYXJndW1lbnQgbXNnIC0+XG4gICAgICAgIGludmFsaWRfYXJnIChtc2cgXiBcIiBpbiBmb3JtYXQgXFxcIlwiIF4gU3RyaW5nLmVzY2FwZWQgc3RyIF4gXCJcXFwiXCIpXG4gICAgd2l0aFxuICAgICAgfCBBcmdzIGFyZ3MgLT4gYXBwbHkgZiBhcmdzXG4gICAgICB8IEV4YyBleGMgLT4gZWYgaWIgZXhjXG4gIGluXG4gIHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxuKCoqKilcblxubGV0IGtic2NhbmYgPSBrc2NhbmZcbmxldCBic2NhbmYgaWIgZm10ID0ga2JzY2FuZiBpYiBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBrc3NjYW5mIHMgZWYgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZWYgZm10XG5sZXQgc3NjYW5mIHMgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG5sZXQgc2NhbmYgZm10ID0ga3NjYW5mIFNjYW5uaW5nLnN0ZGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxuKCoqKilcblxuKCogU2Nhbm5pbmcgZm9ybWF0IHN0cmluZ3MuICopXG5sZXQgYnNjYW5mX2Zvcm1hdCA6XG4gIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAgKCgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICdnKSAtPiAnZyA9XG4gIGZ1biBpYiBmb3JtYXQgZiAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyBtYXhfaW50IGliIGluXG4gICAgbGV0IHN0ciA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQnID1cbiAgICAgIHRyeSBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgZm9ybWF0XG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2cgaW5cbiAgICBmIGZtdCdcblxuXG5sZXQgc3NjYW5mX2Zvcm1hdCA6XG4gIHN0cmluZyAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIHMgZm9ybWF0IGYgLT4gYnNjYW5mX2Zvcm1hdCAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZm9ybWF0IGZcblxuXG5sZXQgZm9ybWF0X2Zyb21fc3RyaW5nIHMgZm10ID1cbiAgc3NjYW5mX2Zvcm1hdCAoXCJcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzIF4gXCJcXFwiXCIpIGZtdCAoZnVuIHggLT4geClcblxuXG5sZXQgdW5lc2NhcGVkIHMgPVxuICBzc2NhbmYgKFwiXFxcIlwiIF4gcyBeIFwiXFxcIlwiKSBcIiVTJSFcIiAoZnVuIHggLT4geClcblxuXG4oKiBEZXByZWNhdGVkICopXG5sZXQga2ZzY2FuZiBpYyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5tZW1vX2Zyb21fY2hhbm5lbCBpYykgZWYgZm10XG5sZXQgZnNjYW5mIGljIGZtdCA9IGtzY2FuZiAoU2Nhbm5pbmcubWVtb19mcm9tX2NoYW5uZWwgaWMpIHNjYW5mX2JhZF9pbnB1dCBmbXRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY3N0X2NoYXJhY3RlciIsImNzdF9zY2FuZl9tbCIsImNzdF9zY2FuZl9iYWRfY29udmVyc2lvbiIsImNzdF9zY2FubmluZ19vZiIsImNhbWxfYnl0ZXNfZ2V0IiwiY2FtbF9pbnRfb2Zfc3RyaW5nIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfZ2V0IiwiY2FtbF90cmFtcG9saW5lIiwiY2FtbF90cmFtcG9saW5lX3JldHVybiIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJjc3Rfbm90X2FfdmFsaWRfZmxvYXRfaW5faGV4YWQiLCJjc3Rfbm9fZG90X29yX2V4cG9uZW50X3BhcnRfZm8iLCJjc3RfYmluYXJ5IiwiY3N0X29jdGFsIiwiY3N0X2hleGFkZWNpbWFsIiwiY3N0X2FfQ2hhciIsImNzdF9hX1N0cmluZyIsIkNhbWxpbnRlcm5hbEZvcm1hdCIsIkNhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcyIsIlN0ZGxpYl9TdHJpbmciLCJTdGRsaWIiLCJBc3NlcnRfZmFpbHVyZSIsIlN0ZGxpYl9QcmludGYiLCJTdGRsaWJfSW50IiwiU3RkbGliX0xpc3QiLCJTdGRsaWJfQnVmZmVyIiwibnVsbF9jaGFyIiwiY3N0X3VubmFtZWRfZnVuY3Rpb24iLCJjc3RfdW5uYW1lZF9jaGFyYWN0ZXJfc3RyaW5nIiwiY3N0X3VubmFtZWRfU3RkbGliX2lucHV0X2NoYW5uIiwibmV4dF9jaGFyIiwiaWIiLCJjIiwiZXhuIiwicGVla19jaGFyIiwiY2hlY2tlZF9wZWVrX2NoYXIiLCJlbmRfb2ZfaW5wdXQiLCJiZWdpbm5pbmdfb2ZfaW5wdXQiLCJuYW1lX29mX2lucHV0IiwibWF0Y2giLCJmbmFtZSIsImNoYXJfY291bnQiLCJpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciIsInRva2VuX3N0cmluZyIsInRva2VuX2J1ZmZlciIsInRvayIsImlnbm9yZV9jaGFyIiwid2lkdGgiLCJzdG9yZV9jaGFyIiwiZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSIsImNyZWF0ZSIsImluYW1lIiwibmV4dCIsImZyb21fc3RyaW5nIiwicyIsImkiLCJsZW4iLCJwYXJhbSIsImZyb21fZnVuY3Rpb24iLCJzY2FuX2Nsb3NlX2F0X2VuZCIsImljIiwic2Nhbl9yYWlzZV9hdF9lbmQiLCJmcm9tX2ljIiwic2Nhbl9jbG9zZV9pYyIsImJ1ZiIsImxpbSIsImVvZiIsInN0ZGluIiwib3Blbl9pbl9maWxlIiwib3Blbl9pbiIsIm9wZW5faW5fYmluIiwiZnJvbV9jaGFubmVsIiwiY2xvc2VfaW4iLCJtZW1vIiwibWVtb19mcm9tX2NoYW5uZWwiLCJTY2FuX2ZhaWx1cmUiLCJjc3RfMGIiLCJjc3RfMG8iLCJjc3RfMHUiLCJjc3RfMHgiLCJjc3RfZGVjaW1hbF9kaWdpdHMiLCJjc3RfZGlnaXRzIiwiY3N0X2FuIiwiY3N0X25maW5pdHkiLCJjc3RfeCIsImNzdF9lbmRfb2ZfaW5wdXRfbm90X2ZvdW5kIiwiY3N0X3NjYW5mX2JhZF9jb252ZXJzaW9uX2EiLCJjc3Rfc2NhbmZfYmFkX2NvbnZlcnNpb25fdCIsImNzdF9zY2FuZl9taXNzaW5nX3JlYWRlciIsImNzdF9zY2FuZl9iYWRfY29udmVyc2lvbl9jdXN0byIsImNzdF9pbl9mb3JtYXQiLCJiYWRfaW5wdXQiLCJiYWRfaW5wdXRfZXNjYXBlIiwiYmFkX3Rva2VuX2xlbmd0aCIsIm1lc3NhZ2UiLCJiYWRfaGV4X2Zsb2F0IiwiY2hhcmFjdGVyX21pc21hdGNoIiwiY2kiLCJjaGVja19jaGFyIiwiY2hlY2tfdGhpc19jaGFyIiwidG9rZW5fY2hhciIsInRva2VuX2Jvb2wiLCJpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciIsInN3aXRjaGVyIiwidG9rZW5faW50X2xpdGVyYWwiLCJjb252IiwibCIsInRva2VuX2Zsb2F0Iiwic2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIiLCJzY2FuX2RlY2ltYWxfZGlnaXRfcGx1cyIsInNjYW5fZGlnaXRfcGx1cyIsImJhc2lzIiwiZGlnaXRwIiwiaXNfYmluYXJ5X2RpZ2l0IiwiaXNfb2N0YWxfZGlnaXQiLCJpc19oZXhhX2RpZ2l0Iiwic2Nhbl9zaWduIiwic2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsIiwic2Nhbl9pbnRfY29udmVyc2lvbiIsInNjYW5fZnJhY3Rpb25hbF9wYXJ0Iiwic2Nhbl9leHBvbmVudF9wYXJ0Iiwic2Nhbl9mbG9hdCIsInByZWNpc2lvbiIsImNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIiwiZXJyb3IiLCJzdHIiLCJsb3dlcmNhc2UiLCJzY2FuX2hleF9mbG9hdCIsInNjYW5fY2FtbF9mbG9hdF9yZXN0Iiwid2lkdGhfcHJlY2lzaW9uIiwiZnJhY193aWR0aCIsInNjYW5fY2FtbF9mbG9hdCIsInNjYW5fc3RyaW5nIiwic3RwIiwiaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciIsImNoZWNrX25leHRfY2hhciIsInNjYW5fYmFja3NsYXNoX2NoYXIiLCJjMCIsImdldF9kaWdpdCIsImMxIiwiYzIiLCJzY2FuX2NhbWxfc3RyaW5nIiwiZmluZF9zdG9wIiwiY291bnRlciIsInNraXBfc3BhY2VzIiwic2Nhbl9jaGFyc19pbl9jaGFyX3NldCIsImNoYXJfc2V0Iiwic2Nhbl9pbmRpYyIsInNjYW5fY2hhcnMiLCJzY2FuZl9iYWRfaW5wdXQiLCJ4IiwidGFnIiwid2lkdGhfb2ZfcGFkX29wdCIsInBhZF9vcHQiLCJzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IiwiZm10aW5nIiwic3ViX3N0ciIsInRha2VfZm9ybWF0X3JlYWRlcnMiLCJrIiwiZm10IiwicmVzdCIsImZtdHR5IiwiaWduIiwicmVhZGVyIiwibmV3X2siLCJyZWFkZXJzX3Jlc3QiLCJmbXRfcmVzdCIsInRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMiLCJ0eTIiLCJ0eTEiLCJ0eSIsIm1ha2Vfc2NhbmYiLCJyZWFkZXJzIiwicHJlYyIsInBhZCIsImNociIsIm1zZyIsImZvcm1hdHRpbmdfbGl0IiwiY291bnQiLCJhcmdfcmVzdCIsIndpZHRoX29wdCIsImZtdGluZ19saXQiLCJzdHJfcmVzdCIsInNjYW4iLCJtIiwiaWNvbnYiLCJwYWRfcHJlY19zY2FuZiIsInRva2VuIiwicCIsInciLCJrc2NhbmYiLCJlZiIsImV4YyIsImFyZ3MiLCJic2NhbmYiLCJrc3NjYW5mIiwic3NjYW5mIiwic2NhbmYiLCJic2NhbmZfZm9ybWF0IiwiZm9ybWF0Iiwic3NjYW5mX2Zvcm1hdCIsImZvcm1hdF9mcm9tX3N0cmluZyIsInVuZXNjYXBlZCIsImtmc2NhbmYiLCJmc2NhbmYiLCJTdGRsaWJfU2NhbmYiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFB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O0FBQUE7QUFBQSxZQUFBc0MsTUFBQXRDLEtBRXZELDBDQUF5QztBQUFBLFlBQUF1QyxjQUFBdkssSUFBQXdLLFFBQUFwTTtBQUFBQSxJQVM3QztBQUFBLFFBQUEwSCxNQUNFO0FBQUEsSUFDVixZQUNNLGdEQUFBa0MsTUFBQTtBQUFBLFVBQUE5SDtBQUFBQSxTQUFBQSxNRGhnRFYsNEJBQUFzSCxNQUFBO0FBQUE7QUFBQSxTQUFBeUIsTUFBQSxRQUFBakIsTUNpZ0QwQjtBQUFBO0FBQUEsSUFDdEIseUJBQU07QUFBQTtBQUFBLFlBQUF5QyxjQUFBbEosR0FBQWlKLFFBQUFwTTtBQUFBQSxJQU13QixPQUF3QixjQUF4QiwwQkFBaUM7QUFBQTtBQUFBLFlBQUFzTSxtQkFBQW5KLEdBQUF5RztBQUFBQTtBQUFBQSxLQUFBLElBSTNDO0FBQUE7QUFBQSxJQUFSLE9BQWdDO0FBQUEsYUFBaEMsK0NBQUFULEdBQStDLFNBQUMsRUFBQztBQUFBO0FBQUEsWUFBQW9ELFVBQUFwSjtBQUFBQSxRQUFBLElBSWhEO0FBQUEsSUFBUixPQUFpQjtBQUFBLG9CQUFqQjtBQUFBLHNCQUFBZ0csR0FBbUMsU0FBQyxFQUFDO0FBQUE7QUFBQSxZQUFBcUQsUUFBQS9JLElBQUFtSSxJQUFBaEM7QUFBQUEsSUFJZCxPQUErQixPQUEvQiwrQkFBc0M7QUFBQTtBQUFBLFlBQUE2QyxPQUFBaEosSUFBQW1HO0FBQUFBLElBQzNDLE9BQStCLE9BQS9CLDRDQUFtRDtBQUFBO0FBQUE7QUFBQSxJQUFBOEM7QUFBQUEsTUFyZ0JuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURoaEMzRCIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIxNjQ0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvY2FsbGJhY2subWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFJlZ2lzdGVyaW5nIE9DYW1sIHZhbHVlcyB3aXRoIHRoZSBDIHJ1bnRpbWUgZm9yIGxhdGVyIGNhbGxiYWNrcyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiBPYmoudCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCByZWdpc3RlciBuYW1lIHYgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIChPYmoucmVwciB2KVxuXG5sZXQgcmVnaXN0ZXJfZXhjZXB0aW9uIG5hbWUgKGV4biA6IGV4bikgPVxuICBsZXQgZXhuID0gT2JqLnJlcHIgZXhuIGluXG4gIGxldCBzbG90ID0gaWYgT2JqLnRhZyBleG4gPSBPYmoub2JqZWN0X3RhZyB0aGVuIGV4biBlbHNlIE9iai5maWVsZCBleG4gMCBpblxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIHNsb3RcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSIsImdsb2JhbF9kYXRhIiwiU3RkbGliX09iaiIsInJlZ2lzdGVyIiwicmVnaXN0ZXJfZXhjZXB0aW9uIiwibmFtZSIsImV4biIsInNsb3QiLCJTdGRsaWJfQ2FsbGJhY2siXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxZQUFBQyxtQkFBQUMsTUFBQUM7QUFBQUE7QUFBQUEsS0FBQSxJQ3lCZ0I7QUFBQSxLQUFBQyxPQUFBO0FBQUEsSUFDZCw0Q0FBOEI7QUFBQTtBQUFBLE9BQUFDLGtCRDFCaEMiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMTY2OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL2NhbWxpbnRlcm5hbE9PLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgSmVyb21lIFZvdWlsbG9uLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIE9ialxuXG4oKioqKiBPYmplY3QgcmVwcmVzZW50YXRpb24gKioqKilcblxuZXh0ZXJuYWwgc2V0X2lkOiAnYSAtPiAnYSA9IFwiY2FtbF9zZXRfb29faWRcIiBbQEBub2FsbG9jXVxuXG4oKioqKiBPYmplY3QgY29weSAqKioqKVxuXG5sZXQgY29weSBvID1cbiAgbGV0IG8gPSAoT2JqLm9iaiAoT2JqLmR1cCAoT2JqLnJlcHIgbykpKSBpblxuICBzZXRfaWQgb1xuXG4oKioqKiBDb21wcmVzc2lvbiBvcHRpb25zICoqKiopXG4oKiBQYXJhbWV0ZXJzICopXG50eXBlIHBhcmFtcyA9IHtcbiAgICBtdXRhYmxlIGNvbXBhY3RfdGFibGUgOiBib29sO1xuICAgIG11dGFibGUgY29weV9wYXJlbnQgOiBib29sO1xuICAgIG11dGFibGUgY2xlYW5fd2hlbl9jb3B5aW5nIDogYm9vbDtcbiAgICBtdXRhYmxlIHJldHJ5X2NvdW50IDogaW50O1xuICAgIG11dGFibGUgYnVja2V0X3NtYWxsX3NpemUgOiBpbnRcbiAgfVxuXG5sZXQgcGFyYW1zID0ge1xuICBjb21wYWN0X3RhYmxlID0gdHJ1ZTtcbiAgY29weV9wYXJlbnQgPSB0cnVlO1xuICBjbGVhbl93aGVuX2NvcHlpbmcgPSB0cnVlO1xuICByZXRyeV9jb3VudCA9IDM7XG4gIGJ1Y2tldF9zbWFsbF9zaXplID0gMTZcbn1cblxuKCoqKiogUGFyYW1ldGVycyAqKioqKVxuXG5sZXQgaW5pdGlhbF9vYmplY3Rfc2l6ZSA9IDJcblxuKCoqKiogSXRlbXMgKioqKilcblxudHlwZSBpdGVtID0gRHVtbXlBIHwgRHVtbXlCIHwgRHVtbXlDIG9mIGludFxubGV0IF8gPSBbRHVtbXlBOyBEdW1teUI7IER1bW15QyAwXSAoKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxuXG5sZXQgZHVtbXlfaXRlbSA9IChtYWdpYyAoKSA6IGl0ZW0pXG5cbigqKioqIFR5cGVzICoqKiopXG5cbnR5cGUgdGFnXG50eXBlIGxhYmVsID0gaW50XG50eXBlIGNsb3N1cmUgPSBpdGVtXG50eXBlIHQgPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbnR5cGUgb2JqID0gdCBhcnJheVxuZXh0ZXJuYWwgcmV0IDogKG9iaiAtPiAnYSkgLT4gY2xvc3VyZSA9IFwiJWlkZW50aXR5XCJcblxuKCoqKiogTGFiZWxzICoqKiopXG5cbmxldCBwdWJsaWNfbWV0aG9kX2xhYmVsIHMgOiB0YWcgPVxuICBsZXQgYWNjdSA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgYWNjdSA6PSAyMjMgKiAhYWNjdSArIENoYXIuY29kZSBzLltpXVxuICBkb25lO1xuICAoKiByZWR1Y2UgdG8gMzEgYml0cyAqKVxuICBhY2N1IDo9ICFhY2N1IGxhbmQgKDEgbHNsIDMxIC0gMSk7XG4gICgqIG1ha2UgaXQgc2lnbmVkIGZvciA2NCBiaXRzIGFyY2hpdGVjdHVyZXMgKilcbiAgbGV0IHRhZyA9IGlmICFhY2N1ID4gMHgzRkZGRkZGRiB0aGVuICFhY2N1IC0gKDEgbHNsIDMxKSBlbHNlICFhY2N1IGluXG4gICgqIFByaW50Zi5lcHJpbnRmIFwiJXMgPSAlZFxcblwiIHMgdGFnOyBmbHVzaCBzdGRlcnI7ICopXG4gIG1hZ2ljIHRhZ1xuXG4oKioqKiBTcGFyc2UgYXJyYXkgKioqKilcblxubW9kdWxlIFZhcnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIHZhcnMgPSBpbnQgVmFycy50XG5cbm1vZHVsZSBNZXRocyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbWV0aHMgPSBsYWJlbCBNZXRocy50XG5tb2R1bGUgTGFicyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBsYWJlbCBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBsYWJzID0gYm9vbCBMYWJzLnRcblxuKCogVGhlIGNvbXBpbGVyIGFzc3VtZXMgdGhhdCB0aGUgZmlyc3QgZmllbGQgb2YgdGhpcyBzdHJ1Y3R1cmUgaXMgW3NpemVdLiAqKVxudHlwZSB0YWJsZSA9XG4geyBtdXRhYmxlIHNpemU6IGludDtcbiAgIG11dGFibGUgbWV0aG9kczogY2xvc3VyZSBhcnJheTtcbiAgIG11dGFibGUgbWV0aG9kc19ieV9uYW1lOiBtZXRocztcbiAgIG11dGFibGUgbWV0aG9kc19ieV9sYWJlbDogbGFicztcbiAgIG11dGFibGUgcHJldmlvdXNfc3RhdGVzOlxuICAgICAobWV0aHMgKiBsYWJzICogKGxhYmVsICogaXRlbSkgbGlzdCAqIHZhcnMgKlxuICAgICAgbGFiZWwgbGlzdCAqIHN0cmluZyBsaXN0KSBsaXN0O1xuICAgbXV0YWJsZSBoaWRkZW5fbWV0aHM6IChsYWJlbCAqIGl0ZW0pIGxpc3Q7XG4gICBtdXRhYmxlIHZhcnM6IHZhcnM7XG4gICBtdXRhYmxlIGluaXRpYWxpemVyczogKG9iaiAtPiB1bml0KSBsaXN0IH1cblxubGV0IGR1bW15X3RhYmxlID1cbiAgeyBtZXRob2RzID0gW3wgZHVtbXlfaXRlbSB8XTtcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gMCB9XG5cbmxldCB0YWJsZV9jb3VudCA9IHJlZiAwXG5cbigqIGR1bW15X21ldCBzaG91bGQgYmUgYSBwb2ludGVyLCBzbyB1c2UgYW4gYXRvbSAqKVxubGV0IGR1bW15X21ldCA6IGl0ZW0gPSBvYmogKE9iai5uZXdfYmxvY2sgMCAwKVxuKCogaWYgZGVidWdnaW5nIGlzIG5lZWRlZCwgdGhpcyBjb3VsZCBiZSBhIGdvb2QgaWRlYTogKilcbigqIGxldCBkdW1teV9tZXQgKCkgPSBmYWlsd2l0aCBcIlVuZGVmaW5lZCBtZXRob2RcIiAqKVxuXG5sZXQgcmVjIGZpdF9zaXplIG4gPVxuICBpZiBuIDw9IDIgdGhlbiBuIGVsc2VcbiAgZml0X3NpemUgKChuKzEpLzIpICogMlxuXG5sZXQgbmV3X3RhYmxlIHB1Yl9sYWJlbHMgPVxuICBpbmNyIHRhYmxlX2NvdW50O1xuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHB1Yl9sYWJlbHMgaW5cbiAgbGV0IG1ldGhvZHMgPSBBcnJheS5tYWtlIChsZW4qMisyKSBkdW1teV9tZXQgaW5cbiAgbWV0aG9kcy4oMCkgPC0gbWFnaWMgbGVuO1xuICBtZXRob2RzLigxKSA8LSBtYWdpYyAoZml0X3NpemUgbGVuICogU3lzLndvcmRfc2l6ZSAvIDggLSAxKTtcbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG8gbWV0aG9kcy4oaSoyKzMpIDwtIG1hZ2ljIHB1Yl9sYWJlbHMuKGkpIGRvbmU7XG4gIHsgbWV0aG9kcyA9IG1ldGhvZHM7XG4gICAgbWV0aG9kc19ieV9uYW1lID0gTWV0aHMuZW1wdHk7XG4gICAgbWV0aG9kc19ieV9sYWJlbCA9IExhYnMuZW1wdHk7XG4gICAgcHJldmlvdXNfc3RhdGVzID0gW107XG4gICAgaGlkZGVuX21ldGhzID0gW107XG4gICAgdmFycyA9IFZhcnMuZW1wdHk7XG4gICAgaW5pdGlhbGl6ZXJzID0gW107XG4gICAgc2l6ZSA9IGluaXRpYWxfb2JqZWN0X3NpemUgfVxuXG5sZXQgcmVzaXplIGFycmF5IG5ld19zaXplID1cbiAgbGV0IG9sZF9zaXplID0gQXJyYXkubGVuZ3RoIGFycmF5Lm1ldGhvZHMgaW5cbiAgaWYgbmV3X3NpemUgPiBvbGRfc2l6ZSB0aGVuIGJlZ2luXG4gICAgbGV0IG5ld19idWNrID0gQXJyYXkubWFrZSBuZXdfc2l6ZSBkdW1teV9tZXQgaW5cbiAgICBBcnJheS5ibGl0IGFycmF5Lm1ldGhvZHMgMCBuZXdfYnVjayAwIG9sZF9zaXplO1xuICAgIGFycmF5Lm1ldGhvZHMgPC0gbmV3X2J1Y2tcbiBlbmRcblxubGV0IHB1dCBhcnJheSBsYWJlbCBlbGVtZW50ID1cbiAgcmVzaXplIGFycmF5IChsYWJlbCArIDEpO1xuICBhcnJheS5tZXRob2RzLihsYWJlbCkgPC0gZWxlbWVudFxuXG4oKioqKiBDbGFzc2VzICoqKiopXG5cbmxldCBtZXRob2RfY291bnQgPSByZWYgMFxubGV0IGluc3RfdmFyX2NvdW50ID0gcmVmIDBcblxuKCogdHlwZSB0ICopXG50eXBlIG1ldGggPSBpdGVtXG5cbmxldCBuZXdfbWV0aG9kIHRhYmxlID1cbiAgbGV0IGluZGV4ID0gQXJyYXkubGVuZ3RoIHRhYmxlLm1ldGhvZHMgaW5cbiAgcmVzaXplIHRhYmxlIChpbmRleCArIDEpO1xuICBpbmRleFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBuYW1lID1cbiAgdHJ5XG4gICAgTWV0aHMuZmluZCBuYW1lIHRhYmxlLm1ldGhvZHNfYnlfbmFtZVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBsYWJlbCA9IG5ld19tZXRob2QgdGFibGUgaW5cbiAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gTWV0aHMuYWRkIG5hbWUgbGFiZWwgdGFibGUubWV0aG9kc19ieV9uYW1lO1xuICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiZWwgdHJ1ZSB0YWJsZS5tZXRob2RzX2J5X2xhYmVsO1xuICAgIGxhYmVsXG5cbmxldCBnZXRfbWV0aG9kX2xhYmVscyB0YWJsZSBuYW1lcyA9XG4gIEFycmF5Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgbmFtZXNcblxubGV0IHNldF9tZXRob2QgdGFibGUgbGFiZWwgZWxlbWVudCA9XG4gIGluY3IgbWV0aG9kX2NvdW50O1xuICBpZiBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB0aGVuXG4gICAgcHV0IHRhYmxlIGxhYmVsIGVsZW1lbnRcbiAgZWxzZVxuICAgIHRhYmxlLmhpZGRlbl9tZXRocyA8LSAobGFiZWwsIGVsZW1lbnQpIDo6IHRhYmxlLmhpZGRlbl9tZXRoc1xuXG5sZXQgZ2V0X21ldGhvZCB0YWJsZSBsYWJlbCA9XG4gIHRyeSBMaXN0LmFzc29jIGxhYmVsIHRhYmxlLmhpZGRlbl9tZXRoc1xuICB3aXRoIE5vdF9mb3VuZCAtPiB0YWJsZS5tZXRob2RzLihsYWJlbClcblxubGV0IHRvX2xpc3QgYXJyID1cbiAgaWYgYXJyID09IG1hZ2ljIDAgdGhlbiBbXSBlbHNlIEFycmF5LnRvX2xpc3QgYXJyXG5cbmxldCBuYXJyb3cgdGFibGUgdmFycyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzID1cbiAgbGV0IHZhcnMgPSB0b19saXN0IHZhcnNcbiAgYW5kIHZpcnRfbWV0aHMgPSB0b19saXN0IHZpcnRfbWV0aHNcbiAgYW5kIGNvbmNyX21ldGhzID0gdG9fbGlzdCBjb25jcl9tZXRocyBpblxuICBsZXQgdmlydF9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgdmlydF9tZXRocyBpblxuICBsZXQgY29uY3JfbWV0aF9sYWJzID0gTGlzdC5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIGNvbmNyX21ldGhzIGluXG4gIHRhYmxlLnByZXZpb3VzX3N0YXRlcyA8LVxuICAgICAodGFibGUubWV0aG9kc19ieV9uYW1lLCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsLCB0YWJsZS5oaWRkZW5fbWV0aHMsXG4gICAgICB0YWJsZS52YXJzLCB2aXJ0X21ldGhfbGFicywgdmFycylcbiAgICAgOjogdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgVmFycy5mb2xkXG4gICAgICAoZnVuIGxhYiBpbmZvIHR2YXJzIC0+XG4gICAgICAgIGlmIExpc3QubWVtIGxhYiB2YXJzIHRoZW4gVmFycy5hZGQgbGFiIGluZm8gdHZhcnMgZWxzZSB0dmFycylcbiAgICAgIHRhYmxlLnZhcnMgVmFycy5lbXB0eTtcbiAgbGV0IGJ5X25hbWUgPSByZWYgTWV0aHMuZW1wdHkgaW5cbiAgbGV0IGJ5X2xhYmVsID0gcmVmIExhYnMuZW1wdHkgaW5cbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9XG4gICAgICAgICAgTGFicy5hZGQgbGFiZWxcbiAgICAgICAgICAgICh0cnkgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgd2l0aCBOb3RfZm91bmQgLT4gdHJ1ZSlcbiAgICAgICAgICAgICFieV9sYWJlbClcbiAgICBjb25jcl9tZXRocyBjb25jcl9tZXRoX2xhYnM7XG4gIExpc3QuaXRlcjJcbiAgICAoZnVuIG1ldCBsYWJlbCAtPlxuICAgICAgIGJ5X25hbWUgOj0gTWV0aHMuYWRkIG1ldCBsYWJlbCAhYnlfbmFtZTtcbiAgICAgICBieV9sYWJlbCA6PSBMYWJzLmFkZCBsYWJlbCBmYWxzZSAhYnlfbGFiZWwpXG4gICAgdmlydF9tZXRocyB2aXJ0X21ldGhfbGFicztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtICFieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtICFieV9sYWJlbDtcbiAgdGFibGUuaGlkZGVuX21ldGhzIDwtXG4gICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgIChmdW4gKChsYWIsIF8pIGFzIG1ldCkgaG0gLT5cbiAgICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmlydF9tZXRoX2xhYnMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgW11cblxubGV0IHdpZGVuIHRhYmxlID1cbiAgbGV0IChieV9uYW1lLCBieV9sYWJlbCwgc2F2ZWRfaGlkZGVuX21ldGhzLCBzYXZlZF92YXJzLCB2aXJ0X21ldGhzLCB2YXJzKSA9XG4gICAgTGlzdC5oZCB0YWJsZS5wcmV2aW91c19zdGF0ZXNcbiAgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtIExpc3QudGwgdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAgKGZ1biBzIHYgLT4gVmFycy5hZGQgdiAoVmFycy5maW5kIHYgdGFibGUudmFycykgcylcbiAgICAgICBzYXZlZF92YXJzIHZhcnM7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIGJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhzIHRoZW4gaG0gZWxzZSBtZXQ6OmhtKVxuICAgICAgIHRhYmxlLmhpZGRlbl9tZXRoc1xuICAgICAgIHNhdmVkX2hpZGRlbl9tZXRoc1xuXG5sZXQgbmV3X3Nsb3QgdGFibGUgPVxuICBsZXQgaW5kZXggPSB0YWJsZS5zaXplIGluXG4gIHRhYmxlLnNpemUgPC0gaW5kZXggKyAxO1xuICBpbmRleFxuXG5sZXQgbmV3X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFyc1xuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBpbmRleCA9IG5ld19zbG90IHRhYmxlIGluXG4gICAgaWYgbmFtZSA8PiBcIlwiIHRoZW4gdGFibGUudmFycyA8LSBWYXJzLmFkZCBuYW1lIGluZGV4IHRhYmxlLnZhcnM7XG4gICAgaW5kZXhcblxubGV0IHRvX2FycmF5IGFyciA9XG4gIGlmIGFyciA9IE9iai5tYWdpYyAwIHRoZW4gW3x8XSBlbHNlIGFyclxuXG5sZXQgbmV3X21ldGhvZHNfdmFyaWFibGVzIHRhYmxlIG1ldGhzIHZhbHMgPVxuICBsZXQgbWV0aHMgPSB0b19hcnJheSBtZXRocyBpblxuICBsZXQgbm1ldGhzID0gQXJyYXkubGVuZ3RoIG1ldGhzIGFuZCBudmFscyA9IEFycmF5Lmxlbmd0aCB2YWxzIGluXG4gIGxldCByZXMgPSBBcnJheS5tYWtlIChubWV0aHMgKyBudmFscykgMCBpblxuICBmb3IgaSA9IDAgdG8gbm1ldGhzIC0gMSBkb1xuICAgIHJlcy4oaSkgPC0gZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBtZXRocy4oaSlcbiAgZG9uZTtcbiAgZm9yIGkgPSAwIHRvIG52YWxzIC0gMSBkb1xuICAgIHJlcy4oaStubWV0aHMpIDwtIG5ld192YXJpYWJsZSB0YWJsZSB2YWxzLihpKVxuICBkb25lO1xuICByZXNcblxubGV0IGdldF92YXJpYWJsZSB0YWJsZSBuYW1lID1cbiAgdHJ5IFZhcnMuZmluZCBuYW1lIHRhYmxlLnZhcnMgd2l0aCBOb3RfZm91bmQgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBnZXRfdmFyaWFibGVzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfdmFyaWFibGUgdGFibGUpIG5hbWVzXG5cbmxldCBhZGRfaW5pdGlhbGl6ZXIgdGFibGUgZiA9XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBmOjp0YWJsZS5pbml0aWFsaXplcnNcblxuKCpcbm1vZHVsZSBLZXlzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHRhZyBhcnJheSBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxubGV0IGtleV9tYXAgPSByZWYgS2V5cy5lbXB0eVxubGV0IGdldF9rZXkgdGFncyA6IGl0ZW0gPVxuICB0cnkgbWFnaWMgKEtleXMuZmluZCB0YWdzICFrZXlfbWFwIDogdGFnIGFycmF5KVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGtleV9tYXAgOj0gS2V5cy5hZGQgdGFncyB0YWdzICFrZXlfbWFwO1xuICAgIG1hZ2ljIHRhZ3NcbiopXG5cbmxldCBjcmVhdGVfdGFibGUgcHVibGljX21ldGhvZHMgPVxuICBpZiBwdWJsaWNfbWV0aG9kcyA9PSBtYWdpYyAwIHRoZW4gbmV3X3RhYmxlIFt8fF0gZWxzZVxuICAoKiBbcHVibGljX21ldGhvZHNdIG11c3QgYmUgaW4gYXNjZW5kaW5nIG9yZGVyIGZvciBieXRlY29kZSAqKVxuICBsZXQgdGFncyA9IEFycmF5Lm1hcCBwdWJsaWNfbWV0aG9kX2xhYmVsIHB1YmxpY19tZXRob2RzIGluXG4gIGxldCB0YWJsZSA9IG5ld190YWJsZSB0YWdzIGluXG4gIEFycmF5Lml0ZXJpXG4gICAgKGZ1biBpIG1ldCAtPlxuICAgICAgbGV0IGxhYiA9IGkqMisyIGluXG4gICAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgIDwtIE1ldGhzLmFkZCBtZXQgbGFiIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbClcbiAgICBwdWJsaWNfbWV0aG9kcztcbiAgdGFibGVcblxubGV0IGluaXRfY2xhc3MgdGFibGUgPVxuICBpbnN0X3Zhcl9jb3VudCA6PSAhaW5zdF92YXJfY291bnQgKyB0YWJsZS5zaXplIC0gMTtcbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIExpc3QucmV2IHRhYmxlLmluaXRpYWxpemVycztcbiAgcmVzaXplIHRhYmxlICgzICsgbWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemUpXG5cbmxldCBpbmhlcml0cyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzIChfLCBzdXBlciwgXywgZW52KSB0b3AgPVxuICBuYXJyb3cgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocztcbiAgbGV0IGluaXQgPVxuICAgIGlmIHRvcCB0aGVuIHN1cGVyIGNsYSBlbnYgZWxzZSBPYmoucmVwciAoc3VwZXIgY2xhKSBpblxuICB3aWRlbiBjbGE7XG4gIEFycmF5LmNvbmNhdFxuICAgIFtbfCByZXByIGluaXQgfF07XG4gICAgIG1hZ2ljIChBcnJheS5tYXAgKGdldF92YXJpYWJsZSBjbGEpICh0b19hcnJheSB2YWxzKSA6IGludCBhcnJheSk7XG4gICAgIEFycmF5Lm1hcFxuICAgICAgIChmdW4gbm0gLT4gcmVwciAoZ2V0X21ldGhvZCBjbGEgKGdldF9tZXRob2RfbGFiZWwgY2xhIG5tKSA6IGNsb3N1cmUpKVxuICAgICAgICh0b19hcnJheSBjb25jcl9tZXRocykgXVxuXG5sZXQgbWFrZV9jbGFzcyBwdWJfbWV0aHMgY2xhc3NfaW5pdCA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICAoZW52X2luaXQgKE9iai5yZXByIDApLCBjbGFzc19pbml0LCBlbnZfaW5pdCwgT2JqLnJlcHIgMClcblxudHlwZSBpbml0X3RhYmxlID0geyBtdXRhYmxlIGVudl9pbml0OiB0OyBtdXRhYmxlIGNsYXNzX2luaXQ6IHRhYmxlIC0+IHQgfVxuW0BAd2FybmluZyBcIi11bnVzZWQtZmllbGRcIl1cblxubGV0IG1ha2VfY2xhc3Nfc3RvcmUgcHViX21ldGhzIGNsYXNzX2luaXQgaW5pdF90YWJsZSA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICBpbml0X3RhYmxlLmNsYXNzX2luaXQgPC0gY2xhc3NfaW5pdDtcbiAgaW5pdF90YWJsZS5lbnZfaW5pdCA8LSBlbnZfaW5pdFxuXG5sZXQgZHVtbXlfY2xhc3MgbG9jID1cbiAgbGV0IHVuZGVmID0gZnVuIF8gLT4gcmFpc2UgKFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIGxvYykgaW5cbiAgKE9iai5tYWdpYyB1bmRlZiwgdW5kZWYsIHVuZGVmLCBPYmoucmVwciAwKVxuXG4oKioqKiBPYmplY3RzICoqKiopXG5cbmxldCBjcmVhdGVfb2JqZWN0IHRhYmxlID1cbiAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgT2JqLm9iaiAoc2V0X2lkIG9iailcblxubGV0IGNyZWF0ZV9vYmplY3Rfb3B0IG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gICAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gICAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gICAgT2JqLm9iaiAoc2V0X2lkIG9iailcbiAgZW5kXG5cbmxldCByZWMgaXRlcl9mIG9iaiA9XG4gIGZ1bmN0aW9uXG4gICAgW10gICAtPiAoKVxuICB8IGY6OmwgLT4gZiBvYmo7IGl0ZXJfZiBvYmogbFxuXG5sZXQgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGUgPVxuICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgaWYgaW5pdHMgPD4gW10gdGhlblxuICAgIGl0ZXJfZiBvYmogaW5pdHNcblxubGV0IHJ1bl9pbml0aWFsaXplcnNfb3B0IG9ial8wIG9iaiB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9iaiBlbHNlIGJlZ2luXG4gICAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gICAgaWYgaW5pdHMgPD4gW10gdGhlbiBpdGVyX2Ygb2JqIGluaXRzO1xuICAgIG9ialxuICBlbmRcblxubGV0IGNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaXplcnMgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgbGV0IG9iaiA9IGNyZWF0ZV9vYmplY3QgdGFibGUgaW5cbiAgICBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZTtcbiAgICBvYmpcbiAgZW5kXG5cbigqIEVxdWl2YWxlbnQgcHJpbWl0aXZlIGJlbG93XG5sZXQgc2VuZHNlbGYgb2JqIGxhYiA9XG4gIChtYWdpYyBvYmogOiAob2JqIC0+IHQpIGFycmF5IGFycmF5KS4oMCkuKGxhYikgb2JqXG4qKVxuZXh0ZXJuYWwgc2VuZCA6IG9iaiAtPiB0YWcgLT4gJ2EgPSBcIiVzZW5kXCJcbmV4dGVybmFsIHNlbmRjYWNoZSA6IG9iaiAtPiB0YWcgLT4gdCAtPiBpbnQgLT4gJ2EgPSBcIiVzZW5kY2FjaGVcIlxuZXh0ZXJuYWwgc2VuZHNlbGYgOiBvYmogLT4gbGFiZWwgLT4gJ2EgPSBcIiVzZW5kc2VsZlwiXG5leHRlcm5hbCBnZXRfcHVibGljX21ldGhvZCA6IG9iaiAtPiB0YWcgLT4gY2xvc3VyZVxuICAgID0gXCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kXCIgW0BAbm9hbGxvY11cblxuKCoqKiogdGFibGUgY29sbGVjdGlvbiBhY2Nlc3MgKioqKilcblxudHlwZSB0YWJsZXMgPVxuICB8IEVtcHR5XG4gIHwgQ29ucyBvZiB7a2V5IDogY2xvc3VyZTsgbXV0YWJsZSBkYXRhOiB0YWJsZXM7IG11dGFibGUgbmV4dDogdGFibGVzfVxuXG5sZXQgc2V0X2RhdGEgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhIDwtIHZcbmxldCBzZXRfbmV4dCB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHQgPC0gdlxubGV0IGdldF9rZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5rZXlcbmxldCBnZXRfZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGFcbmxldCBnZXRfbmV4dCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHRcblxubGV0IGJ1aWxkX3BhdGggbiBrZXlzIHRhYmxlcyA9XG4gIGxldCByZXMgPSBDb25zIHtrZXkgPSBPYmoubWFnaWMgMDsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gIGxldCByID0gcmVmIHJlcyBpblxuICBmb3IgaSA9IDAgdG8gbiBkb1xuICAgIHIgOj0gQ29ucyB7a2V5ID0ga2V5cy4oaSk7IGRhdGEgPSAhcjsgbmV4dCA9IEVtcHR5fVxuICBkb25lO1xuICBzZXRfZGF0YSB0YWJsZXMgIXI7XG4gIHJlc1xuXG5sZXQgcmVjIGxvb2t1cF9rZXlzIGkga2V5cyB0YWJsZXMgPVxuICBpZiBpIDwgMCB0aGVuIHRhYmxlcyBlbHNlXG4gIGxldCBrZXkgPSBrZXlzLihpKSBpblxuICBsZXQgcmVjIGxvb2t1cF9rZXkgKHRhYmxlczp0YWJsZXMpID1cbiAgICBpZiBnZXRfa2V5IHRhYmxlcyA9PSBrZXkgdGhlblxuICAgICAgbWF0Y2ggZ2V0X2RhdGEgdGFibGVzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IENvbnMgXyBhcyB0YWJsZXNfZGF0YSAtPlxuICAgICAgICAgIGxvb2t1cF9rZXlzIChpLTEpIGtleXMgdGFibGVzX2RhdGFcbiAgICBlbHNlXG4gICAgICBtYXRjaCBnZXRfbmV4dCB0YWJsZXMgd2l0aFxuICAgICAgfCBDb25zIF8gYXMgbmV4dCAtPiBsb29rdXBfa2V5IG5leHRcbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBsZXQgbmV4dCA6IHRhYmxlcyA9IENvbnMge2tleTsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gICAgICAgICAgc2V0X25leHQgdGFibGVzIG5leHQ7XG4gICAgICAgICAgYnVpbGRfcGF0aCAoaS0xKSBrZXlzIG5leHRcbiAgaW5cbiAgbG9va3VwX2tleSB0YWJsZXNcblxubGV0IGxvb2t1cF90YWJsZXMgcm9vdCBrZXlzID1cbiAgbWF0Y2ggZ2V0X2RhdGEgcm9vdCB3aXRoXG4gIHwgQ29ucyBfIGFzIHJvb3RfZGF0YSAtPlxuICAgIGxvb2t1cF9rZXlzIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdF9kYXRhXG4gIHwgRW1wdHkgLT5cbiAgICBidWlsZF9wYXRoIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdFxuXG4oKioqKiBidWlsdGluIG1ldGhvZHMgKioqKilcblxubGV0IGdldF9jb25zdCB4ID0gcmV0IChmdW4gX29iaiAtPiB4KVxubGV0IGdldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIC0+IEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pXG5sZXQgZ2V0X2VudiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKVxubGV0IGdldF9tZXRoIG4gID0gcmV0IChmdW4gb2JqIC0+IHNlbmRzZWxmIG9iaiBuKVxubGV0IHNldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIHggLT4gQXJyYXkudW5zYWZlX3NldCBvYmogbiB4KVxubGV0IGFwcF9jb25zdCBmIHggPSByZXQgKGZ1biBfb2JqIC0+IGYgeClcbmxldCBhcHBfdmFyIGYgbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9lbnYgZiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfbWV0aCBmIG4gID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfY29uc3RfY29uc3QgZiB4IHkgPSByZXQgKGZ1biBfb2JqIC0+IGYgeCB5KVxubGV0IGFwcF9jb25zdF92YXIgZiB4IG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIHggKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9tZXRoIGYgeCBuID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF92YXJfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgeClcbmxldCBhcHBfbWV0aF9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikgeClcbmxldCBhcHBfY29uc3RfZW52IGYgeCBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIHggKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9lbnZfY29uc3QgZiBlIG4geCA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIHgpXG5sZXQgbWV0aF9hcHBfY29uc3QgbiB4ID0gcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgeClcbmxldCBtZXRoX2FwcF92YXIgbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG0pKVxubGV0IG1ldGhfYXBwX2VudiBuIGUgbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbSkpXG5sZXQgbWV0aF9hcHBfbWV0aCBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoc2VuZHNlbGYgb2JqIG0pKVxubGV0IHNlbmRfY29uc3QgbSB4IGMgPVxuICByZXQgKGZ1biBvYmogLT4gc2VuZGNhY2hlIHggbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX3ZhciBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSA6IG9iaikgbVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9lbnYgbSBlIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZVxuICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldFxuICAgICAgICAgICAgICAgICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgOiBvYmopXG4gICAgICBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfbWV0aCBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoc2VuZHNlbGYgb2JqIG4pIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgbmV3X2NhY2hlIHRhYmxlID1cbiAgbGV0IG4gPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gIGxldCBuID1cbiAgICBpZiBuIG1vZCAyID0gMCB8fCBuID4gMiArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplXG4gICAgdGhlbiBuIGVsc2UgbmV3X21ldGhvZCB0YWJsZVxuICBpblxuICB0YWJsZS5tZXRob2RzLihuKSA8LSBPYmoubWFnaWMgMDtcbiAgblxuXG50eXBlIGltcGwgPVxuICAgIEdldENvbnN0XG4gIHwgR2V0VmFyXG4gIHwgR2V0RW52XG4gIHwgR2V0TWV0aFxuICB8IFNldFZhclxuICB8IEFwcENvbnN0XG4gIHwgQXBwVmFyXG4gIHwgQXBwRW52XG4gIHwgQXBwTWV0aFxuICB8IEFwcENvbnN0Q29uc3RcbiAgfCBBcHBDb25zdFZhclxuICB8IEFwcENvbnN0RW52XG4gIHwgQXBwQ29uc3RNZXRoXG4gIHwgQXBwVmFyQ29uc3RcbiAgfCBBcHBFbnZDb25zdFxuICB8IEFwcE1ldGhDb25zdFxuICB8IE1ldGhBcHBDb25zdFxuICB8IE1ldGhBcHBWYXJcbiAgfCBNZXRoQXBwRW52XG4gIHwgTWV0aEFwcE1ldGhcbiAgfCBTZW5kQ29uc3RcbiAgfCBTZW5kVmFyXG4gIHwgU2VuZEVudlxuICB8IFNlbmRNZXRoXG4gIHwgQ2xvc3VyZSBvZiBjbG9zdXJlXG5cbmxldCBtZXRob2RfaW1wbCB0YWJsZSBpIGFyciA9XG4gIGxldCBuZXh0ICgpID0gaW5jciBpOyBtYWdpYyBhcnIuKCFpKSBpblxuICBtYXRjaCBuZXh0KCkgd2l0aFxuICAgIEdldENvbnN0IC0+IGxldCB4IDogdCA9IG5leHQoKSBpbiBnZXRfY29uc3QgeFxuICB8IEdldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF92YXIgblxuICB8IEdldEVudiAgIC0+IGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGdldF9lbnYgZSBuXG4gIHwgR2V0TWV0aCAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X21ldGggblxuICB8IFNldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIHNldF92YXIgblxuICB8IEFwcENvbnN0IC0+IGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGFwcF9jb25zdCBmIHhcbiAgfCBBcHBWYXIgICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX3ZhciBmIG5cbiAgfCBBcHBFbnYgICAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52IGYgZSBuXG4gIHwgQXBwTWV0aCAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF9tZXRoIGYgblxuICB8IEFwcENvbnN0Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCB5ID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfY29uc3QgZiB4IHlcbiAgfCBBcHBDb25zdFZhciAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF92YXIgZiB4IG5cbiAgfCBBcHBDb25zdEVudiAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfZW52IGYgeCBlIG5cbiAgfCBBcHBDb25zdE1ldGggLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfbWV0aCBmIHggblxuICB8IEFwcFZhckNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX3Zhcl9jb25zdCBmIG4geFxuICB8IEFwcEVudkNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnZfY29uc3QgZiBlIG4geFxuICB8IEFwcE1ldGhDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9tZXRoX2NvbnN0IGYgbiB4XG4gIHwgTWV0aEFwcENvbnN0IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBtZXRoX2FwcF9jb25zdCBuIHhcbiAgfCBNZXRoQXBwVmFyIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF92YXIgbiBtXG4gIHwgTWV0aEFwcEVudiAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW5cbiAgICAgIG1ldGhfYXBwX2VudiBuIGUgbVxuICB8IE1ldGhBcHBNZXRoIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF9tZXRoIG4gbVxuICB8IFNlbmRDb25zdCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gc2VuZF9jb25zdCBtIHggKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kVmFyIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF92YXIgbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZEVudiAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIHNlbmRfZW52IG0gZSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZE1ldGggLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX21ldGggbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgQ2xvc3VyZSBfIGFzIGNsbyAtPiBtYWdpYyBjbG9cblxubGV0IHNldF9tZXRob2RzIHRhYmxlIG1ldGhvZHMgPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIG1ldGhvZHMgaW4gbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiBkb1xuICAgIGxldCBsYWJlbCA9IG1ldGhvZHMuKCFpKSBpbiBsZXQgY2xvID0gbWV0aG9kX2ltcGwgdGFibGUgaSBtZXRob2RzIGluXG4gICAgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBjbG87XG4gICAgaW5jciBpXG4gIGRvbmVcblxuKCoqKiogU3RhdGlzdGljcyAqKioqKVxuXG50eXBlIHN0YXRzID1cbiAgeyBjbGFzc2VzOiBpbnQ7IG1ldGhvZHM6IGludDsgaW5zdF92YXJzOiBpbnQ7IH1cblxubGV0IHN0YXRzICgpID1cbiAgeyBjbGFzc2VzID0gIXRhYmxlX2NvdW50O1xuICAgIG1ldGhvZHMgPSAhbWV0aG9kX2NvdW50OyBpbnN0X3ZhcnMgPSAhaW5zdF92YXJfY291bnQ7IH1cbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X2NhbWxpbnRlcm5hbE9PX21sIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfZGl2IiwiY2FtbF9nZXRfcHVibGljX21ldGhvZCIsImNhbWxfbWFrZV92ZWN0IiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9vYmpfYmxvY2siLCJjYW1sX3NldF9vb19pZCIsImNhbWxfc3RyaW5nX2NvbXBhcmUiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfU3lzIiwiU3RkbGliX09iaiIsIlN0ZGxpYiIsIlN0ZGxpYl9BcnJheSIsIlN0ZGxpYl9MaXN0IiwiU3RkbGliX01hcCIsImNvcHkiLCJvIiwicGFyYW1zIiwicHVibGljX21ldGhvZF9sYWJlbCIsInMiLCJhY2N1IiwiaSIsInRhZyIsImNvbXBhcmUiLCJWYXJzIiwiTWV0aHMiLCJMYWJzIiwiZHVtbXlfdGFibGUiLCJ0YWJsZV9jb3VudCIsImR1bW15X21ldCIsImluaXRpYWxfb2JqZWN0X3NpemUiLCJmaXRfc2l6ZSIsIm4iLCJuZXdfdGFibGUiLCJwdWJfbGFiZWxzIiwibGVuIiwibWV0aG9kcyIsInJlc2l6ZSIsImFycmF5IiwibmV3X3NpemUiLCJvbGRfc2l6ZSIsIm5ld19idWNrIiwibWV0aG9kX2NvdW50IiwiaW5zdF92YXJfY291bnQiLCJuZXdfbWV0aG9kIiwidGFibGUiLCJpbmRleCIsImdldF9tZXRob2RfbGFiZWwiLCJuYW1lIiwiZXhuIiwibGFiZWwiLCJnZXRfbWV0aG9kX2xhYmVscyIsIm5hbWVzIiwic2V0X21ldGhvZCIsImVsZW1lbnQiLCJnZXRfbWV0aG9kIiwidG9fbGlzdCIsImFyciIsIm5hcnJvdyIsInZhcnMiLCJ2aXJ0X21ldGhzIiwiY29uY3JfbWV0aHMiLCJ2aXJ0X21ldGhfbGFicyIsImNvbmNyX21ldGhfbGFicyIsImxhYiIsImluZm8iLCJ0dmFycyIsImJ5X25hbWUiLCJieV9sYWJlbCIsIm1ldCIsImhtIiwid2lkZW4iLCJtYXRjaCIsInNhdmVkX3ZhcnMiLCJzYXZlZF9oaWRkZW5fbWV0aHMiLCJ2IiwibmV3X3ZhcmlhYmxlIiwidG9fYXJyYXkiLCJuZXdfbWV0aG9kc192YXJpYWJsZXMiLCJtZXRocyIsInZhbHMiLCJubWV0aHMiLCJudmFscyIsInJlcyIsImdldF92YXJpYWJsZSIsImdldF92YXJpYWJsZXMiLCJhZGRfaW5pdGlhbGl6ZXIiLCJjcmVhdGVfdGFibGUiLCJwdWJsaWNfbWV0aG9kcyIsInRhZ3MiLCJpbml0X2NsYXNzIiwiaW5oZXJpdHMiLCJjbGEiLCJwYXJhbSIsInRvcCIsImVudiIsInN1cGVyJCIsImluaXQiLCJubSIsIm1ha2VfY2xhc3MiLCJwdWJfbWV0aHMiLCJjbGFzc19pbml0IiwiZW52X2luaXQiLCJtYWtlX2NsYXNzX3N0b3JlIiwiaW5pdF90YWJsZSIsImR1bW15X2NsYXNzIiwibG9jIiwidW5kZWYiLCJjcmVhdGVfb2JqZWN0Iiwib2JqIiwiY3JlYXRlX29iamVjdF9vcHQiLCJvYmpfMCIsIml0ZXJfZiIsImwiLCJydW5faW5pdGlhbGl6ZXJzIiwiaW5pdHMiLCJydW5faW5pdGlhbGl6ZXJzX29wdCIsImNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaSIsImdldF9kYXRhIiwiYnVpbGRfcGF0aCIsImtleXMiLCJ0YWJsZXMiLCJyIiwibG9va3VwX3RhYmxlcyIsInJvb3QiLCJyb290X2RhdGEiLCJrZXkiLCJ0YWJsZXNfZGF0YSIsIm5leHQiLCJuZXdfY2FjaGUiLCJtZXRob2RfaW1wbCIsImNsbyIsIngiLCJlIiwieSIsIm0iLCJzZXRfbWV0aG9kcyIsInN0YXRzIiwiQ2FtbGludGVybmFsT08iXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsWUFBQUMsS0FBQUM7QUFBQUEsUUFBQUEsTUN3Qm1CO0FBQUEsSUFDakIsMEJBQVE7QUFBQTtBQUFBLE9BQUFDLFNEekJWO0FBQUEsWUFB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TGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjIzMjYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsImdsb2JhbF9kYXRhIiwiQ2FtbGludGVybmFsT08iLCJjb3B5IiwibmV3X21ldGhvZCIsInB1YmxpY19tZXRob2RfbGFiZWwiLCJTdGRsaWJfT28iXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLFlBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMjM0NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL2NhbWxpbnRlcm5hbE1vZC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBzaGFwZSA9XG4gIHwgRnVuY3Rpb25cbiAgfCBMYXp5XG4gIHwgQ2xhc3NcbiAgfCBNb2R1bGUgb2Ygc2hhcGUgYXJyYXlcbiAgfCBWYWx1ZSBvZiBPYmoudFxuXG5sZXQgcmVjIGluaXRfbW9kX2ZpZWxkIG1vZHUgaSBsb2Mgc2hhcGUgPVxuICBsZXQgaW5pdCA9XG4gICAgbWF0Y2ggc2hhcGUgd2l0aFxuICAgIHwgRnVuY3Rpb24gLT5cbiAgICAgICBsZXQgcmVjIGZuICh4IDogJ2EpID1cbiAgICAgICAgIGxldCBmbicgOiAnYSAtPiAnYiA9IE9iai5vYmogKE9iai5maWVsZCBtb2R1IGkpIGluXG4gICAgICAgICBpZiBmbiA9PSBmbicgdGhlblxuICAgICAgICAgICByYWlzZSAoVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgbG9jKVxuICAgICAgICAgZWxzZVxuICAgICAgICAgICBmbicgeCBpblxuICAgICAgIE9iai5yZXByIGZuXG4gICAgfCBMYXp5IC0+XG4gICAgICAgbGV0IHJlYyBsID1cbiAgICAgICAgIGxhenkgKFxuICAgICAgICAgICBsZXQgbCcgPSBPYmoub2JqIChPYmouZmllbGQgbW9kdSBpKSBpblxuICAgICAgICAgICBpZiBsID09IGwnIHRoZW5cbiAgICAgICAgICAgICByYWlzZSAoVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgbG9jKVxuICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgTGF6eS5mb3JjZSBsJykgaW5cbiAgICAgICBPYmoucmVwciBsXG4gICAgfCBDbGFzcyAtPlxuICAgICAgIE9iai5yZXByIChDYW1saW50ZXJuYWxPTy5kdW1teV9jbGFzcyBsb2MpXG4gICAgfCBNb2R1bGUgY29tcHMgLT5cbiAgICAgICBPYmoucmVwciAoaW5pdF9tb2RfYmxvY2sgbG9jIGNvbXBzKVxuICAgIHwgVmFsdWUgdiAtPiB2XG4gIGluXG4gIE9iai5zZXRfZmllbGQgbW9kdSBpIGluaXRcblxuYW5kIGluaXRfbW9kX2Jsb2NrIGxvYyBjb21wcyA9XG4gIGxldCBsZW5ndGggPSBBcnJheS5sZW5ndGggY29tcHMgaW5cbiAgbGV0IG1vZHUgPSBPYmoubmV3X2Jsb2NrIDAgbGVuZ3RoIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggLSAxIGRvXG4gICAgaW5pdF9tb2RfZmllbGQgbW9kdSBpIGxvYyBjb21wcy4oaSlcbiAgZG9uZTtcbiAgbW9kdVxuXG5sZXQgaW5pdF9tb2QgbG9jIHNoYXBlID1cbiAgbWF0Y2ggc2hhcGUgd2l0aFxuICB8IE1vZHVsZSBjb21wcyAtPlxuICAgICBPYmoucmVwciAoaW5pdF9tb2RfYmxvY2sgbG9jIGNvbXBzKVxuICB8IF8gLT4gZmFpbHdpdGggXCJDYW1saW50ZXJuYWxNb2QuaW5pdF9tb2Q6IG5vdCBhIG1vZHVsZVwiXG5cbmxldCByZWMgdXBkYXRlX21vZF9maWVsZCBtb2R1IGkgc2hhcGUgbiA9XG4gIG1hdGNoIHNoYXBlIHdpdGhcbiAgfCBGdW5jdGlvbiB8IExhenkgLT5cbiAgICAgT2JqLnNldF9maWVsZCBtb2R1IGkgblxuICB8IFZhbHVlIF8gLT5cbiAgICAgKCkgKCogdGhlIHZhbHVlIGlzIGFscmVhZHkgdGhlcmUgKilcbiAgfCBDbGFzcyAtPlxuICAgICBhc3NlcnQgKE9iai50YWcgbiA9IDAgJiYgT2JqLnNpemUgbiA9IDQpO1xuICAgICBsZXQgY2wgPSBPYmouZmllbGQgbW9kdSBpIGluXG4gICAgIGZvciBqID0gMCB0byAzIGRvXG4gICAgICAgT2JqLnNldF9maWVsZCBjbCBqIChPYmouZmllbGQgbiBqKVxuICAgICBkb25lXG4gIHwgTW9kdWxlIGNvbXBzIC0+XG4gICAgIHVwZGF0ZV9tb2RfYmxvY2sgY29tcHMgKE9iai5maWVsZCBtb2R1IGkpIG5cblxuYW5kIHVwZGF0ZV9tb2RfYmxvY2sgY29tcHMgbyBuID1cbiAgYXNzZXJ0IChPYmoudGFnIG4gPSAwICYmIE9iai5zaXplIG4gPj0gQXJyYXkubGVuZ3RoIGNvbXBzKTtcbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBjb21wcyAtIDEgZG9cbiAgICB1cGRhdGVfbW9kX2ZpZWxkIG8gaSBjb21wcy4oaSkgKE9iai5maWVsZCBuIGkpXG4gIGRvbmVcblxubGV0IHVwZGF0ZV9tb2Qgc2hhcGUgbyBuID1cbiAgbWF0Y2ggc2hhcGUgd2l0aFxuICB8IE1vZHVsZSBjb21wcyAtPlxuICAgICB1cGRhdGVfbW9kX2Jsb2NrIGNvbXBzIG8gblxuICB8IF8gLT4gZmFpbHdpdGggXCJDYW1saW50ZXJuYWxNb2QudXBkYXRlX21vZDogbm90IGEgbW9kdWxlXCJcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X2NhbWxpbnRlcm5hbE1vZF9tbCIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX29ial90YWciLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJDYW1saW50ZXJuYWxMYXp5IiwiQ2FtbGludGVybmFsT08iLCJBc3NlcnRfZmFpbHVyZSIsImNzdF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2RfbiIsImNzdF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZCIsImluaXRfbW9kX2Jsb2NrIiwibG9jIiwiY29tcHMiLCJsZW5ndGgiLCJtb2R1IiwiaSIsInNoYXBlIiwiZm4iLCJ4IiwiaW5pdCIsImwiLCJwYXJhbSIsInYiLCJpbml0X21vZCIsInVwZGF0ZV9tb2RfYmxvY2siLCJuIiwiY2wiLCJqIiwidXBkYXRlX21vZCIsIm8iLCJDYW1saW50ZXJuYWxNb2QiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLFlBQUFDLGVBQUFDLEtBQUFDO0FBQUFBO0FBQUFBLEtBQUFDLFNDbURFO0FBQUEsS0FBQUMsT0FDVztBQUFBLFNBQ1g7QUFBQTtBQUFBO0FBQUEsU0FBQUMsSUFBQTtBQUFBO0FBQUEsVUFBQUMsUUFDNEI7QUFBQSxNQS9CNUI7QUFBQTtBQUFBO0FBQUEsY0FBQUQsTUFHSztBQUFBO0FBQUEsV0FBQUU7QUFBQUEsYUFBQSxTQUFBQztBQUFBQSxrQkFBQUQsS0FDK0I7QUFBQSxjQUM3QjtBQUFBLGVBQ0U7QUFBQSxjQUVBLHdCQUFLO0FBQUE7QUFBQSxjQUFBQSxPQUFBO0FBQUEsY0FBQUUsT0FDVDtBQUFBO0FBQUE7QUFBQSxjQUFBQyxJQUVBO0FBQUEsY0FBQUEsTUFBQSxHQUFBTCxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBQUFNO0FBQUFBLGtCQUFBRCxJQUVxQjtBQUFBLGNBQ2pCO0FBQUEsZUFDRTtBQUFBLHNCQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBRCxPQUNOO0FBQUE7QUFBQSxzQkFBQUEsT0FFUztBQUFBO0FBQUE7QUFBQSxXQUFBUCxRQXBCZCxVQUFBTyxPQXNCYztBQUFBO0FBQUEsV0FBQUcsSUF0QmQsVUFBQUgsT0F1QmU7QUFBQSxNQUVmO0FBQUEsY0FNcUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRXJDO0FBQUEsR0FBSTtBQUFBLFlBQUFJLFNBQUFaLEtBQUFLO0FBQUFBLElBR0o7QUFBQSxTQUFBSixRQUFBO0FBQUEsS0FFRyxpQ0FDcUQ7QUFBQTtBQUFBLElBQWpELDJEQUFpRDtBQUFBO0FBQUEsWUFBQVksaUJBQUFaLFNBQUFFLE1BQUFXO0FBQUFBLElBa0JoRDtBQUFBLGFBQ1I7QUFBQTtBQUFBLFVBQUFWLElBQUE7QUFBQTtBQUFBLFdBQUFVLE1BQ2lDLFVBQUFULFFBQVY7QUFBQTtBQUFBO0FBQUEsUUFqQnZCO0FBQUEsU0FNVztBQUFBLGNBQUFVLEtBQ0MsYUFBQUMsSUFDVDtBQUFBO0FBQUEsV0FDRTtBQUFBLG1CQUFrQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FIbkI7QUFBQTtBQUFBLFFBSmpCO0FBQUE7QUFBQTtBQUFBLFlBQUFmLFFBRkg7QUFBQSxRQVk0QztBQUFBO0FBQUEsZUFLSTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FEaEQ7QUFBQTtBQUFBLElBRGlCO0FBQUEsR0FHYjtBQUFBLFlBQUFnQixXQUFBWixPQUFBYSxHQUFBSjtBQUFBQSxJQUdKO0FBQUEsU0FBQWIsUUFBQTtBQUFBLEtBRUcsb0NBQ3VEO0FBQUE7QUFBQSxJQUFuRCwyREFBbUQ7QUFBQTtBQUFBLE9BQUFrQixrQkR6RjVEIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjI0ODUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9nZW5sZXgubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl0gKCogaWdub3JlIGRlcHJlY2F0aW9uIHdhcm5pbmcgYWJvdXQgbW9kdWxlIFN0cmVhbSAqKVxuXG50eXBlIHRva2VuID1cbiAgICBLd2Qgb2Ygc3RyaW5nXG4gIHwgSWRlbnQgb2Ygc3RyaW5nXG4gIHwgSW50IG9mIGludFxuICB8IEZsb2F0IG9mIGZsb2F0XG4gIHwgU3RyaW5nIG9mIHN0cmluZ1xuICB8IENoYXIgb2YgY2hhclxuXG4oKiBUaGUgc3RyaW5nIGJ1ZmZlcmluZyBtYWNoaW5lcnkgKilcblxubGV0IGluaXRpYWxfYnVmZmVyID0gQnl0ZXMuY3JlYXRlIDMyXG5cbmxldCBidWZmZXIgPSByZWYgaW5pdGlhbF9idWZmZXJcbmxldCBidWZwb3MgPSByZWYgMFxuXG5sZXQgcmVzZXRfYnVmZmVyICgpID0gYnVmZmVyIDo9IGluaXRpYWxfYnVmZmVyOyBidWZwb3MgOj0gMFxuXG5sZXQgc3RvcmUgYyA9XG4gIGlmICFidWZwb3MgPj0gQnl0ZXMubGVuZ3RoICFidWZmZXIgdGhlbiBiZWdpblxuICAgIGxldCBuZXdidWZmZXIgPSBCeXRlcy5jcmVhdGUgKDIgKiAhYnVmcG9zKSBpblxuICAgIEJ5dGVzLmJsaXQgIWJ1ZmZlciAwIG5ld2J1ZmZlciAwICFidWZwb3M7XG4gICAgYnVmZmVyIDo9IG5ld2J1ZmZlclxuICBlbmQ7XG4gIEJ5dGVzLnNldCAhYnVmZmVyICFidWZwb3MgYztcbiAgaW5jciBidWZwb3NcblxubGV0IGdldF9zdHJpbmcgKCkgPVxuICBsZXQgcyA9IEJ5dGVzLnN1Yl9zdHJpbmcgIWJ1ZmZlciAwICFidWZwb3MgaW4gYnVmZmVyIDo9IGluaXRpYWxfYnVmZmVyOyBzXG5cbigqIFRoZSBsZXhlciAqKVxuXG5sZXQgbWFrZV9sZXhlciBrZXl3b3JkcyA9XG4gIGxldCBrd2RfdGFibGUgPSBIYXNodGJsLmNyZWF0ZSAxNyBpblxuICBMaXN0Lml0ZXIgKGZ1biBzIC0+IEhhc2h0YmwuYWRkIGt3ZF90YWJsZSBzIChLd2QgcykpIGtleXdvcmRzO1xuICBsZXQgaWRlbnRfb3Jfa2V5d29yZCBpZCA9XG4gICAgdHJ5IEhhc2h0YmwuZmluZCBrd2RfdGFibGUgaWQgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IElkZW50IGlkXG4gIGFuZCBrZXl3b3JkX29yX2Vycm9yIGMgPVxuICAgIGxldCBzID0gU3RyaW5nLm1ha2UgMSBjIGluXG4gICAgdHJ5IEhhc2h0YmwuZmluZCBrd2RfdGFibGUgcyB3aXRoXG4gICAgICBOb3RfZm91bmQgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciAoXCJJbGxlZ2FsIGNoYXJhY3RlciBcIiBeIHMpKVxuICBpblxuICBsZXQgcmVjIG5leHRfdG9rZW4gKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJyAnIHwgJ1xcMDEwJyB8ICdcXDAxMycgfCAnXFwwMDknIHwgJ1xcMDI2JyB8ICdcXDAxMicpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbmV4dF90b2tlbiBzdHJtX19cbiAgICB8IFNvbWUgKCdBJy4uJ1onIHwgJ2EnLi4neicgfCAnXycgfCAnXFwxOTInLi4nXFwyNTUnIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBTb21lXG4gICAgICAgICgnIScgfCAnJScgfCAnJicgfCAnJCcgfCAnIycgfCAnKycgfCAnLycgfCAnOicgfCAnPCcgfCAnPScgfCAnPicgfFxuICAgICAgICAgJz8nIHwgJ0AnIHwgJ1xcXFwnIHwgJ34nIHwgJ14nIHwgJ3wnIHwgJyonIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBTb21lICdcXCcnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIHRyeSBjaGFyIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAnXFwnJyAtPiBTdHJlYW0uanVuayBzdHJtX187IFNvbWUgKENoYXIgYylcbiAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lICdcXFwiJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgU29tZSAoU3RyaW5nIChzdHJpbmcgcykpXG4gICAgfCBTb21lICctJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG5lZ19udW1iZXIgc3RybV9fXG4gICAgfCBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChrZXl3b3JkX29yX2Vycm9yIGMpXG4gICAgfCBfIC0+IE5vbmVcbiAgYW5kIGlkZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCdBJy4uJ1onIHwgJ2EnLi4neicgfCAnXFwxOTInLi4nXFwyNTUnIHwgJzAnLi4nOScgfCAnXycgfCAnXFwnJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGlkZW50IHNcbiAgICB8IF8gLT4gU29tZSAoaWRlbnRfb3Jfa2V5d29yZCAoZ2V0X3N0cmluZyAoKSkpXG4gIGFuZCBpZGVudDIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy0nIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHxcbiAgICAgICAgICc+JyB8ICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGlkZW50MiBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgbmVnX251bWJlciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgJy0nOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgXyAtPiBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgaWRlbnQyIHNcbiAgYW5kIG51bWJlciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBTb21lICcuJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICcuJzsgZGVjaW1hbF9wYXJ0IHNcbiAgICB8IFNvbWUgKCdlJyB8ICdFJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnRSc7IGV4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChJbnQgKGludF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGRlY2ltYWxfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoRmxvYXQgKGZsb2F0X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgZXhwb25lbnRfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnKycgfCAnLScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBlbmRfZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IGVuZF9leHBvbmVudF9wYXJ0IHN0cm1fX1xuICBhbmQgZW5kX2V4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBlbmRfZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIHN0cmluZyAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFwiJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGdldF9zdHJpbmcgKClcbiAgICB8IFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgc3RyaW5nIHNcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBjaGFyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgYmVnaW4gdHJ5IGVzY2FwZSBzdHJtX18gd2l0aFxuICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBlc2NhcGUgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnbicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFxuJ1xuICAgIHwgU29tZSAncicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFxyJ1xuICAgIHwgU29tZSAndCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFx0J1xuICAgIHwgU29tZSAoJzAnLi4nOScgYXMgYzEpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMikgLT5cbiAgICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMzKSAtPlxuICAgICAgICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgICAgICAgICBDaGFyLmNoclxuICAgICAgICAgICAgICAgICAgKChDaGFyLmNvZGUgYzEgLSA0OCkgKiAxMDAgKyAoQ2hhci5jb2RlIGMyIC0gNDgpICogMTAgK1xuICAgICAgICAgICAgICAgICAgICAgKENoYXIuY29kZSBjMyAtIDQ4KSlcbiAgICAgICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyonIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gY29tbWVudCBzOyBuZXh0X3Rva2VuIHNcbiAgICB8IF8gLT4gU29tZSAoa2V5d29yZF9vcl9lcnJvciAnKCcpXG4gIGFuZCBjb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJygnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfbmVzdGVkX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2VuZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX25lc3RlZF9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gY29tbWVudCBzOyBjb21tZW50IHNcbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9lbmRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcpJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICgpXG4gICAgfCBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2VuZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgaW5cbiAgZnVuIGlucHV0IC0+IFN0cmVhbS5mcm9tIChmdW4gX2NvdW50IC0+IG5leHRfdG9rZW4gaW5wdXQpXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9mbG9hdF9vZl9zdHJpbmciLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9TdHJlYW0iLCJTdGRsaWJfQ2hhciIsIlN0ZGxpYl9TdHJpbmciLCJTdGRsaWJfSGFzaHRibCIsIlN0ZGxpYiIsIlN0ZGxpYl9MaXN0IiwiU3RkbGliX0J5dGVzIiwiaW5pdGlhbF9idWZmZXIiLCJidWZmZXIiLCJidWZwb3MiLCJjc3RfSWxsZWdhbF9jaGFyYWN0ZXIiLCJyZXNldF9idWZmZXIiLCJwYXJhbSIsInN0b3JlIiwiYyIsIm5ld2J1ZmZlciIsImdldF9zdHJpbmciLCJzIiwibWFrZV9sZXhlciIsImtleXdvcmRzIiwia3dkX3RhYmxlIiwiaWRlbnRfb3Jfa2V5d29yZCIsImlkIiwiZXhuIiwia2V5d29yZF9vcl9lcnJvciIsIm5leHRfdG9rZW4iLCJzdHJtIiwibWF0Y2giLCJpZGVudDIiLCJudW1iZXIiLCJleHBvbmVudF9wYXJ0IiwiZW5kX2V4cG9uZW50X3BhcnQiLCJlc2NhcGUiLCJjMSIsInN3aXRjaGVyIiwiYzIiLCJjMyIsImNvbW1lbnQiLCJpbnB1dCIsImNvdW50IiwiU3RkbGliX0dlbmxleCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFOLE1BQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFPLGdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFB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QWtCO0FBQUEsYUFBQVMsS0FBQTtBQUFBO0FBQUEsVUFFMUI7QUFBQSxVQUFrQjtBQUFBO0FBQUE7QUFBQTtBQUFBLHVCQVNIO0FBQUE7QUFBQTtBQUFBLFFBTFo7QUFBQTtBQUFBO0FBQUEsTUFFSjtBQUFBO0FBQUEsS0FFQztBQUFBLEtBQWtCO0FBQUEsSUFDSDtBQUFBLGFBQUFDLFFBQUFYO0FBQUFBO0FBQUFBLEtBTzNCO0FBQUEsVUFBQUMsUUFBTTtBQUFBLE1BQWtCLFlBSWpCO0FBQUEsVUFBQU8sV0FKaUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUNWO0FBQUEsY0FBQVAsVUFLUjtBQUFBLFVBQWtCO0FBQUEsV0FHakI7QUFBQSxVQUhpQjtBQUFBLFdBQ1Y7QUFBQSxXQUFzQztBQUFBO0FBQUE7QUFBQSxVQUN4QztBQUFBO0FBQUE7QUFBQSxVQU5FO0FBQUEsVUFTZDtBQUFBLGVBQUFBLFVBQU07QUFBQSxXQUFrQjtBQUFBLFlBSWpCO0FBQUEsZUFBQUEsVUFKaUI7QUFBQSw4QkFDVixvQ0FBa0I7QUFBQSxXQURSLG1CQUdaO0FBQUEsV0FERTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BVkY7QUFBQTtBQUFBLElBQ2U7QUFBQSxJQWE3QixnQkFBQVc7QUFBQUEsS0FBYTtBQUFBLDZCQUFBQyxPQUEyQix3QkFBZ0IsR0FBQyxFQUF6RDtBQUFBLEdBQXlEO0FBQUEsT0FBQUMsZ0JBL0t2QjtBQUFBO0FBQUE7QUFBQSxFRDNCcEMiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMjk0NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL2VwaGVtZXJvbi5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuW0BAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9IHNpZ1xuXG4gIHR5cGUga2V5XG4gIHR5cGUgISdhIHRcbiAgdmFsIGNyZWF0ZSA6ID9yYW5kb20gKCp0aHdhcnQgdG9vbHMvc3luY19zdGRsaWJfZG9jcyopIDogYm9vbCAtPiBpbnQgLT4gJ2EgdFxuICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSB0XG4gIHZhbCBhZGQgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gIHZhbCByZW1vdmUgOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gIHZhbCBmaW5kIDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgdmFsIGZpbmRfb3B0IDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gIHZhbCBmaW5kX2FsbCA6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gIHZhbCBpdGVyIDogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlIDogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIFtAQGFsZXJ0IG9sZF9lcGhlbWVyb25fYXBpIFwiVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBhdmFpbGFibGUgaW4gNS4wXCJdXG4gIHZhbCBmb2xkIDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIFtAQGFsZXJ0IG9sZF9lcGhlbWVyb25fYXBpIFwiVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBhdmFpbGFibGUgaW4gNS4wXCJdXG4gIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICB2YWwgc3RhdHMgOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIHRvX3NlcV9rZXlzIDogXyB0IC0+IGtleSBTZXEudFxuICAgIFtAQGFsZXJ0IG9sZF9lcGhlbWVyb25fYXBpIFwiVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBhdmFpbGFibGUgaW4gNS4wXCJdXG4gIHZhbCB0b19zZXFfdmFsdWVzIDogJ2EgdCAtPiAnYSBTZXEudFxuICAgIFtAQGFsZXJ0IG9sZF9lcGhlbWVyb25fYXBpIFwiVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBhdmFpbGFibGUgaW4gNS4wXCJdXG4gIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICB2YWwgY2xlYW46ICdhIHQgLT4gdW5pdFxuICB2YWwgc3RhdHNfYWxpdmU6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gICAgKCoqIHNhbWUgYXMgeyFzdGF0c30gYnV0IG9ubHkgY291bnQgdGhlIGFsaXZlIGJpbmRpbmdzICopXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuXG4gIHR5cGUga2V5XG4gIHR5cGUgISdhIHRcbiAgdmFsIGNyZWF0ZSA6IGludCAtPiAnYSB0XG4gIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIHRcbiAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgdmFsIGZpbmQgOiAnYSB0IC0+IGtleSAtPiAnYVxuICB2YWwgZmluZF9vcHQgOiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgdmFsIGZpbmRfYWxsIDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIFtAQGFsZXJ0IG9sZF9lcGhlbWVyb25fYXBpIFwiVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBhdmFpbGFibGUgaW4gNS4wXCJdXG4gIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2UgOiAoa2V5IC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiB1bml0XG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIGZvbGQgOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gIHZhbCBzdGF0cyA6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgR2VuSGFzaFRhYmxlID0gc3RydWN0XG5cbiAgdHlwZSBlcXVhbCA9XG4gIHwgRVRydWUgfCBFRmFsc2VcbiAgfCBFRGVhZCAoKiogdGhlIGdhcmJhZ2UgY29sbGVjdG9yIHJlY2xhaW1lZCB0aGUgZGF0YSAqKVxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkKEg6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgJ2EgY29udGFpbmVyXG4gICAgdmFsIGNyZWF0ZTogdCAtPiAnYSAtPiAnYSBjb250YWluZXJcbiAgICB2YWwgaGFzaDogaW50IC0+IHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAnYSBjb250YWluZXIgLT4gdCAtPiBlcXVhbFxuICAgIHZhbCBnZXRfZGF0YTogJ2EgY29udGFpbmVyIC0+ICdhIG9wdGlvblxuICAgIHZhbCBnZXRfa2V5OiAnYSBjb250YWluZXIgLT4gdCBvcHRpb25cbiAgICB2YWwgc2V0X2tleV9kYXRhOiAnYSBjb250YWluZXIgLT4gdCAtPiAnYSAtPiB1bml0XG4gICAgdmFsIGNoZWNrX2tleTogJ2EgY29udGFpbmVyIC0+IGJvb2xcbiAgZW5kKSA6IFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudFxuICA9IHN0cnVjdFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICAgICAgbXV0YWJsZSBkYXRhOiAnYSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICAgICAgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICAgICAgaW5pdGlhbF9zaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gICAgICB9XG5cbiAgICBhbmQgJ2EgYnVja2V0bGlzdCA9XG4gICAgfCBFbXB0eVxuICAgIHwgQ29ucyBvZiBpbnQgKCogaGFzaCBvZiB0aGUga2V5ICopICogJ2EgSC5jb250YWluZXIgKiAnYSBidWNrZXRsaXN0XG5cbiAgICAoKiogdGhlIGhhc2ggb2YgdGhlIGtleSBpcyBrZXB0IGluIG9yZGVyIHRvIHRlc3QgdGhlIGVxdWFsaXR5IG9mIHRoZSBoYXNoXG4gICAgICBiZWZvcmUgdGhlIGtleS4gU2FtZSByZWFzb24gYXMgZm9yIFdlYWsuTWFrZSAqKVxuXG4gICAgdHlwZSBrZXkgPSBILnRcblxuICAgIGxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICAgICAgaWYgeCA+PSBuIHRoZW4geFxuICAgICAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICAgICAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG4gICAgbGV0IHBybmcgPSBsYXp5IChSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQoKSlcblxuICAgIGxldCBjcmVhdGUgPyhyYW5kb20gPSAoSGFzaHRibC5pc19yYW5kb21pemVkICgpKSkgaW5pdGlhbF9zaXplID1cbiAgICAgIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgICAgIGxldCBzZWVkID0gaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZykgZWxzZSAwIGluXG4gICAgICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbiAgICBsZXQgY2xlYXIgaCA9XG4gICAgICBoLnNpemUgPC0gMDtcbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICBkb25lXG5cbiAgICBsZXQgcmVzZXQgaCA9XG4gICAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICAgICAgaWYgbGVuID0gaC5pbml0aWFsX3NpemUgdGhlblxuICAgICAgICBjbGVhciBoXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSBoLmluaXRpYWxfc2l6ZSBFbXB0eVxuICAgICAgZW5kXG5cbiAgICBsZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5LmNvcHkgaC5kYXRhIH1cblxuICAgIGxldCBrZXlfaW5kZXggaCBoa2V5ID1cbiAgICAgIGhrZXkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgY2xlYW4gaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIEVtcHR5XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIG5vdCAoSC5jaGVja19rZXkgYykgLT5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgfCBDb25zKGhrZXksIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBDb25zKGhrZXksIGMsIGRvX2J1Y2tldCByZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGQuKGkpIDwtIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgKCoqIHJlc2l6ZSBpcyB0aGUgb25seSBmdW5jdGlvbiB0byBkbyB0aGUgYWN0dWFsIGNsZWFuaW5nIG9mIGRlYWQga2V5c1xuICAgICAgICAocmVtb3ZlIGRvZXMgaXQganVzdCBiZWNhdXNlIGl0IGNvdWxkKS5cblxuICAgICAgICBUaGUgZ29hbCBpcyB0bzpcblxuICAgICAgICAtIG5vdCByZXNpemUgaW5maW5pdGVseSB3aGVuIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGFsaXZlIGtleXMgaXNcbiAgICAgICAgYm91bmRlZCBidXQga2V5cyBhcmUgY29udGludW91c2x5IGFkZGVkLiBUaGF0IHdvdWxkIGhhcHBlbiBpZlxuICAgICAgICB0aGlzIGZ1bmN0aW9uIGFsd2F5cyByZXNpemUuXG4gICAgICAgIC0gbm90IGNhbGwgdGhpcyBmdW5jdGlvbiBhZnRlciBlYWNoIGFkZGl0aW9uLCB0aGF0IHdvdWxkIGhhcHBlbiBpZiB0aGlzXG4gICAgICAgIGZ1bmN0aW9uIGRvbid0IHJlc2l6ZSBldmVuIHdoZW4gb25seSBvbmUga2V5IGlzIGRlYWQuXG5cbiAgICAgICAgU28gdGhlIGFsZ29yaXRobTpcbiAgICAgICAgLSBjbGVhbiB0aGUga2V5cyBiZWZvcmUgcmVzaXppbmdcbiAgICAgICAgLSBpZiB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyBrZXlzIGlzIGxlc3MgdGhhbiBoYWxmIHRoZSBzaXplIG9mIHRoZVxuICAgICAgICBhcnJheSwgZG9uJ3QgcmVzaXplLlxuICAgICAgICAtIGlmIGl0IGlzIG1vcmUsIHJlc2l6ZS5cblxuICAgICAgICBUaGUgc2Vjb25kIHByb2JsZW0gcmVtYWlucyBpZiB0aGUgdGFibGUgcmVhY2hlcyB7IVN5cy5tYXhfYXJyYXlfbGVuZ3RofS5cblxuICAgICopXG4gICAgbGV0IHJlc2l6ZSBoID1cbiAgICAgIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICAgICAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gICAgICBsZXQgbnNpemUgPSBvc2l6ZSAqIDIgaW5cbiAgICAgIGNsZWFuIGg7XG4gICAgICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoICYmIGguc2l6ZSA+PSBvc2l6ZSBsc3IgMSB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICAgICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAoKiBzbyB0aGF0IGtleV9pbmRleCBzZWVzIHRoZSBuZXcgYnVja2V0IGNvdW50ICopXG4gICAgICAgIGxldCByZWMgaW5zZXJ0X2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgICAgIHwgQ29ucyhoa2V5LCBkYXRhLCByZXN0KSAtPlxuICAgICAgICAgICAgICBpbnNlcnRfYnVja2V0IHJlc3Q7ICgqIHByZXNlcnZlIG9yaWdpbmFsIG9yZGVyIG9mIGVsZW1lbnRzICopXG4gICAgICAgICAgICAgIGxldCBuaWR4ID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgICAgICAgICBuZGF0YS4obmlkeCkgPC0gQ29ucyhoa2V5LCBkYXRhLCBuZGF0YS4obmlkeCkpIGluXG4gICAgICAgIGZvciBpID0gMCB0byBvc2l6ZSAtIDEgZG9cbiAgICAgICAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICAgICAgICBkb25lXG4gICAgICBlbmRcblxuICAgIGxldCBhZGQgaCBrZXkgaW5mbyA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnMoaGtleSwgY29udGFpbmVyLCBoLmRhdGEuKGkpKSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBoLnNpemUgPC0gaC5zaXplIC0gMTsgbmV4dFxuICAgICAgICAgICAgfCBFRmFsc2UgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KVxuICAgICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICAgICgqIFRoZSBkZWFkIGtleSBpcyBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuIEl0IGlzIGFjY2VwdGFibGVcbiAgICAgICAgICAgICAgICAgICAgZm9yIHRoaXMgZnVuY3Rpb24gc2luY2UgaXQgYWxyZWFkeSByZW1vdmVzIGEgYmluZGluZyAqKVxuICAgICAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgICAgIHJlbW92ZV9idWNrZXQgbmV4dFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgQ29ucyhoayxjLG5leHQpIC0+IENvbnMoaGssIGMsIHJlbW92ZV9idWNrZXQgbmV4dCkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgaC5kYXRhLihpKSA8LSByZW1vdmVfYnVja2V0IGguZGF0YS4oaSlcblxuICAgICgqKiB7IWZpbmR9IGRvbid0IHJlbW92ZSBkZWFkIGtleXMgYmVjYXVzZSBpdCB3b3VsZCBiZSBzdXJwcmlzaW5nIGZvclxuICAgICAgICB0aGUgdXNlciB0aGF0IGEgcmVhZC1vbmx5IGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHN0YXRlIChlZy4gY29uY3VycmVudFxuICAgICAgICBhY2Nlc3MpLiBTYW1lIGZvciB7IWl0ZXJ9LCB7IWZvbGR9LCB7IW1lbX0uXG4gICAgKilcbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgKCogVE9ETyBpbmxpbmUgMyBpdGVyYXRpb25zICopXG4gICAgICBmaW5kX3JlYyBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT5cbiAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAoKiBUaGlzIGNhc2UgaXMgbm90IGltcG9zc2libGUgYmVjYXVzZSB0aGUgZ2MgY2FuIHJ1biBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgSC5lcXVhbCBhbmQgSC5nZXRfZGF0YSAqKVxuICAgICAgICAgICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIF8gYXMgZCAtPiBkXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gW11cbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZDo6ZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICB8IENvbnMoaGssIGMsIG5leHQpIHdoZW4gaGtleSA9IGhrIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICAgIHwgRVRydWUgLT4gSC5zZXRfa2V5X2RhdGEgYyBrZXkgaW5mb1xuICAgICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKF8sXyxuZXh0KSAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIHRyeVxuICAgICAgICByZXBsYWNlX2J1Y2tldCBsXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICBsZXQgY29udGFpbmVyID0gSC5jcmVhdGUga2V5IGluZm8gaW5cbiAgICAgICAgaC5kYXRhLihpKSA8LSBDb25zKGhrZXksIGNvbnRhaW5lciwgbCk7XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGhcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrID0gaGtleSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT4gdHJ1ZVxuICAgICAgICAgIHwgRUZhbHNlIHwgRURlYWQgLT4gbWVtX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoX2hrLCBfYywgcmVzdCkgLT4gbWVtX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGggaGtleSlcblxuICAgIGxldCBpdGVyIGYgaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgICgpXG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+ICgpXG4gICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+IGYgayBkXG4gICAgICAgICAgICBlbmQ7IGRvX2J1Y2tldCByZXN0IGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgIGxldCBmb2xkIGYgaCBpbml0ID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgICAgIG1hdGNoIGIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgICBhY2N1XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgbGV0IGFjY3UgPSBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBhY2N1XG4gICAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT4gZiBrIGQgYWNjdVxuICAgICAgICAgICAgZW5kIGluXG4gICAgICAgICAgICBkb19idWNrZXQgcmVzdCBhY2N1ICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgYWNjdSA6PSBkb19idWNrZXQgZC4oaSkgIWFjY3VcbiAgICAgIGRvbmU7XG4gICAgICAhYWNjdVxuXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBFbXB0eVxuICAgICAgICB8IENvbnMoaGssIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT5cbiAgICAgICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPlxuICAgICAgICAgICAgICAgIG1hdGNoIGYgayBkIHdpdGhcbiAgICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgICB8IFNvbWUgbmV3X2QgLT5cbiAgICAgICAgICAgICAgICAgICAgSC5zZXRfa2V5X2RhdGEgYyBrIG5ld19kO1xuICAgICAgICAgICAgICAgICAgICBDb25zKGhrLCBjLCBkb19idWNrZXQgcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkLihpKSA8LSBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgIGxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIHJlc3RcblxuICAgIGxldCBzdGF0cyBoID1cbiAgICAgIGxldCBtYmwgPVxuICAgICAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gSW50Lm1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gICAgICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gICAgICBBcnJheS5pdGVyXG4gICAgICAgIChmdW4gYiAtPlxuICAgICAgICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGggMCBiIGluXG4gICAgICAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgICAgICBoLmRhdGE7XG4gICAgICB7IEhhc2h0YmwubnVtX2JpbmRpbmdzID0gaC5zaXplO1xuICAgICAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgICAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoX2FsaXZlIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgYywgcmVzdCkgd2hlbiBILmNoZWNrX2tleSBjIC0+XG4gICAgICAgICAgYnVja2V0X2xlbmd0aF9hbGl2ZSAoYWNjdSArIDEpIHJlc3RcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPiBidWNrZXRfbGVuZ3RoX2FsaXZlIGFjY3UgcmVzdFxuXG4gICAgbGV0IHN0YXRzX2FsaXZlIGggPVxuICAgICAgbGV0IHNpemUgPSByZWYgMCBpblxuICAgICAgbGV0IG1ibCA9XG4gICAgICAgIEFycmF5LmZvbGRfbGVmdFxuICAgICAgICAgIChmdW4gbSBiIC0+IEludC5tYXggbSAoYnVja2V0X2xlbmd0aF9hbGl2ZSAwIGIpKSAwIGguZGF0YVxuICAgICAgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aF9hbGl2ZSAwIGIgaW5cbiAgICAgICAgICAgc2l6ZSA6PSAhc2l6ZSArIGw7XG4gICAgICAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgICAgICBoLmRhdGE7XG4gICAgICB7IEhhc2h0YmwubnVtX2JpbmRpbmdzID0gIXNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbiAgICBsZXQgdG9fc2VxIHRibCA9XG4gICAgICAoKiBjYXB0dXJlIGN1cnJlbnQgYXJyYXksIHNvIHRoYXQgZXZlbiBpZiB0aGUgdGFibGUgaXMgcmVzaXplZCB3ZVxuICAgICAgICAga2VlcCBpdGVyYXRpbmcgb24gdGhlIHNhbWUgYXJyYXkgKilcbiAgICAgIGxldCB0YmxfZGF0YSA9IHRibC5kYXRhIGluXG4gICAgICAoKiBzdGF0ZTogaW5kZXggKiBuZXh0IGJ1Y2tldCB0byB0cmF2ZXJzZSAqKVxuICAgICAgbGV0IHJlYyBhdXggaSBidWNrICgpID0gbWF0Y2ggYnVjayB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdGJsX2RhdGFcbiAgICAgICAgICAgIHRoZW4gU2VxLk5pbFxuICAgICAgICAgICAgZWxzZSBhdXgoaSsxKSB0YmxfZGF0YS4oaSkgKClcbiAgICAgICAgfCBDb25zIChfLCBjLCBuZXh0KSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gYXV4IGkgbmV4dCAoKVxuICAgICAgICAgICAgICB8IFNvbWUga2V5LCBTb21lIGRhdGEgLT5cbiAgICAgICAgICAgICAgICAgIFNlcS5Db25zICgoa2V5LCBkYXRhKSwgYXV4IGkgbmV4dClcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIGF1eCAwIEVtcHR5XG5cbiAgICBsZXQgdG9fc2VxX2tleXMgbSA9IFNlcS5tYXAgZnN0ICh0b19zZXEgbSlcblxuICAgIGxldCB0b19zZXFfdmFsdWVzIG0gPSBTZXEubWFwIHNuZCAodG9fc2VxIG0pXG5cbiAgICBsZXQgYWRkX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbiAgICBsZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiByZXBsYWNlIHRibCBrIHYpIGlcblxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBPYmpFcGggPSBPYmouRXBoZW1lcm9uXG5cbmxldCBfb2JqX29wdCA6IE9iai50IG9wdGlvbiAtPiAnYSBvcHRpb24gPSBmdW4geCAtPlxuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHhcbiAgfCBTb21lIHYgLT4gU29tZSAoT2JqLm9iaiB2KVxuXG4oKiogVGhlIHByZXZpb3VzIGZ1bmN0aW9uIGlzIHR5cGVkIHNvIHRoaXMgb25lIGlzIGFsc28gY29ycmVjdCAqKVxubGV0IG9ial9vcHQgOiBPYmoudCBvcHRpb24gLT4gJ2Egb3B0aW9uID0gZnVuIHggLT4gT2JqLm1hZ2ljIHhcblxuXG5tb2R1bGUgSzEgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgKCkgOiAoJ2ssJ2QpIHQgPSBPYmpFcGguY3JlYXRlIDFcblxuICBsZXQgZ2V0X2tleSAodDooJ2ssJ2QpIHQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAwKVxuICBsZXQgZ2V0X2tleV9jb3B5ICh0OignaywnZCkgdCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMClcbiAgbGV0IHNldF9rZXkgKHQ6KCdrLCdkKSB0KSAoazonaykgOiB1bml0ID0gT2JqRXBoLnNldF9rZXkgdCAwIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5ICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDBcbiAgbGV0IGNoZWNrX2tleSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAwXG5cbiAgbGV0IGJsaXRfa2V5ICh0MTooJ2ssJ2QpIHQpICh0MjooJ2ssJ2QpIHQpOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDFcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignaywnZCkgdCkgKGQ6J2QpIDogdW5pdCA9IE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLCdkKSB0KSAodDI6KF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBsZXQgbWFrZSBrZXkgZGF0YSA9XG4gICAgbGV0IGVwaCA9IGNyZWF0ZSAoKSBpblxuICAgIHNldF9kYXRhIGVwaCBkYXRhO1xuICAgIHNldF9rZXkgZXBoIGtleTtcbiAgICBlcGhcblxuICBsZXQgcXVlcnkgZXBoIGtleSA9XG4gICAgbWF0Y2ggZ2V0X2tleSBlcGggd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGsgd2hlbiBrID09IGtleSAtPiBnZXRfZGF0YSBlcGhcbiAgICB8IFNvbWUgXyAtPiBOb25lXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQgKEg6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChILnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgbGV0IGNyZWF0ZSBrIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIHNldF9rZXkgYyBrO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCA9IEguaGFzaFxuICAgICAgbGV0IGVxdWFsIGMgayA9XG4gICAgICAgICgqIHshZ2V0X2tleV9jb3B5fSBpcyBub3QgdXNlZCBiZWNhdXNlIHRoZSBlcXVhbGl0eSBvZiB0aGUgdXNlciBjYW4gYmVcbiAgICAgICAgICAgIHRoZSBwaHlzaWNhbCBlcXVhbGl0eSAqKVxuICAgICAgICBtYXRjaCBnZXRfa2V5IGMgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgIHwgU29tZSBrJyAtPlxuICAgICAgICAgICAgaWYgSC5lcXVhbCBrIGsnIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5ID0gZ2V0X2tleVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIGsgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgc2V0X2tleSBjIGs7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSA9IGNoZWNrX2tleVxuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIOiBIYXNodGJsLkhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuICBtb2R1bGUgQnVja2V0ID0gc3RydWN0XG5cbiAgICB0eXBlIG5vbnJlYyAoJ2ssICdkKSB0ID0gKCdrLCAnZCkgdCBsaXN0IHJlZlxuICAgIGxldCBrMV9tYWtlID0gbWFrZVxuICAgIGxldCBtYWtlICgpID0gcmVmIFtdXG4gICAgbGV0IGFkZCBiIGsgZCA9IGIgOj0gazFfbWFrZSBrIGQgOjogIWJcblxuICAgIGxldCB0ZXN0X2tleSBrIGUgPVxuICAgICAgbWF0Y2ggZ2V0X2tleSBlIHdpdGhcbiAgICAgIHwgU29tZSB4IHdoZW4geCA9PSBrIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlbW92ZSBiIGsgPVxuICAgICAgbGV0IHJlYyBsb29wIGwgYWNjID1cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgIHwgW10gLT4gKClcbiAgICAgICAgfCBoIDo6IHQgd2hlbiB0ZXN0X2tleSBrIGggLT4gYiA6PSBMaXN0LnJldl9hcHBlbmQgYWNjIHRcbiAgICAgICAgfCBoIDo6IHQgLT4gbG9vcCB0IChoIDo6IGFjYylcbiAgICAgIGluXG4gICAgICBsb29wICFiIFtdXG5cbiAgICBsZXQgZmluZCBiIGsgPVxuICAgICAgbWF0Y2ggTGlzdC5maW5kX29wdCAodGVzdF9rZXkgaykgIWIgd2l0aFxuICAgICAgfCBTb21lIGUgLT4gZ2V0X2RhdGEgZVxuICAgICAgfCBOb25lIC0+IE5vbmVcblxuICAgIGxldCBsZW5ndGggYiA9IExpc3QubGVuZ3RoICFiXG4gICAgbGV0IGNsZWFyIGIgPSBiIDo9IFtdXG5cbiAgZW5kXG5cbmVuZFxuXG5tb2R1bGUgSzIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2sxLCAnazIsICdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlICgpIDogKCdrMSwnazIsJ2QpIHQgPSBPYmpFcGguY3JlYXRlIDJcblxuICBsZXQgZ2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2sxIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMClcbiAgbGV0IGdldF9rZXkxX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2sxIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDApXG4gIGxldCBzZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgKGs6J2sxKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgMCAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAwXG4gIGxldCBjaGVja19rZXkxICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMFxuXG4gIGxldCBnZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazIgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAxKVxuICBsZXQgZ2V0X2tleTJfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazIgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMSlcbiAgbGV0IHNldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSAoazonazIpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAxIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDFcbiAgbGV0IGNoZWNrX2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAxXG5cblxuICBsZXQgYmxpdF9rZXkxICh0MTooJ2sxLF8sXykgdCkgKHQyOignazEsXyxfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMVxuICBsZXQgYmxpdF9rZXkyICh0MTooXywnazIsXykgdCkgKHQyOihfLCdrMixfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAxIHQyIDEgMVxuICBsZXQgYmxpdF9rZXkxMiAodDE6KCdrMSwnazIsXykgdCkgKHQyOignazEsJ2syLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAyXG5cbiAgbGV0IGdldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnZCBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgKGQ6J2QpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLF8sJ2QpIHQpICh0MjooXyxfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbGV0IG1ha2Uga2V5MSBrZXkyIGRhdGEgPVxuICAgIGxldCBlcGggPSBjcmVhdGUgKCkgaW5cbiAgICBzZXRfZGF0YSBlcGggZGF0YTtcbiAgICBzZXRfa2V5MSBlcGgga2V5MTtcbiAgICBzZXRfa2V5MiBlcGgga2V5MjtcbiAgICBpZ25vcmUgKFN5cy5vcGFxdWVfaWRlbnRpdHkga2V5MSk7XG4gICAgZXBoXG5cbiAgbGV0IHF1ZXJ5IGVwaCBrZXkxIGtleTIgPVxuICAgIG1hdGNoIGdldF9rZXkxIGVwaCB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgayB3aGVuIGsgPT0ga2V5MSAtPlxuICAgICAgICBiZWdpbiBtYXRjaCBnZXRfa2V5MiBlcGggd2l0aFxuICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgayB3aGVuIGsgPT0ga2V5MiAtPiBnZXRfZGF0YSBlcGhcbiAgICAgICAgfCBTb21lIF8gLT4gTm9uZVxuICAgICAgICBlbmRcbiAgICB8IFNvbWUgXyAtPiBOb25lXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWRcbiAgICAgIChIMTpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpXG4gICAgICAoSDI6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChIMS50LEgyLnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgxLnQgKiBIMi50XG4gICAgICBsZXQgY3JlYXRlIChrMSxrMikgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgc2V0X2tleTEgYyBrMTsgc2V0X2tleTIgYyBrMjtcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggc2VlZCAoazEsazIpID1cbiAgICAgICAgSDEuaGFzaCBzZWVkIGsxICsgSDIuaGFzaCBzZWVkIGsyICogNjU1OTlcbiAgICAgIGxldCBlcXVhbCBjIChrMSxrMikgPVxuICAgICAgICBtYXRjaCBnZXRfa2V5MSBjLCBnZXRfa2V5MiBjIHdpdGhcbiAgICAgICAgfCBOb25lLCBfIHwgXyAsIE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgIHwgU29tZSBrMScsIFNvbWUgazInIC0+XG4gICAgICAgICAgICBpZiBIMS5lcXVhbCBrMSBrMScgJiYgSDIuZXF1YWwgazIgazInXG4gICAgICAgICAgICB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZSBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSBjID1cbiAgICAgICAgbWF0Y2ggZ2V0X2tleTEgYywgZ2V0X2tleTIgYyB3aXRoXG4gICAgICAgIHwgTm9uZSwgXyB8IF8gLCBOb25lIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIGsxJywgU29tZSBrMicgLT4gU29tZSAoazEnLCBrMicpXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgKGsxLGsyKSBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgYyA9IGNoZWNrX2tleTEgYyAmJiBjaGVja19rZXkyIGNcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDE6IEhhc2h0YmwuSGFzaGVkVHlwZSkoSDI6IEhhc2h0YmwuSGFzaGVkVHlwZSk6XG4gICAgKFMgd2l0aCB0eXBlIGtleSA9IEgxLnQgKiBIMi50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZFxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID0gSDEudFxuICAgICAgICAgIGxldCBlcXVhbCA9IEgxLmVxdWFsXG4gICAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBIMS5oYXNoIHhcbiAgICAgICAgZW5kKVxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID0gSDIudFxuICAgICAgICAgIGxldCBlcXVhbCA9IEgyLmVxdWFsXG4gICAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBIMi5oYXNoIHhcbiAgICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuICBtb2R1bGUgQnVja2V0ID0gc3RydWN0XG5cbiAgICB0eXBlIG5vbnJlYyAoJ2sxLCAnazIsICdkKSB0ID0gKCdrMSwgJ2syLCAnZCkgdCBsaXN0IHJlZlxuICAgIGxldCBrMl9tYWtlID0gbWFrZVxuICAgIGxldCBtYWtlICgpID0gcmVmIFtdXG4gICAgbGV0IGFkZCBiIGsxIGsyIGQgPSBiIDo9IGsyX21ha2UgazEgazIgZCA6OiAhYlxuXG4gICAgbGV0IHRlc3Rfa2V5cyBrMSBrMiBlID1cbiAgICAgIG1hdGNoIGdldF9rZXkxIGUsIGdldF9rZXkyIGUgd2l0aFxuICAgICAgfCBTb21lIHgxLCBTb21lIHgyIHdoZW4geDEgPT0gazEgJiYgeDIgPT0gazIgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVtb3ZlIGIgazEgazIgPVxuICAgICAgbGV0IHJlYyBsb29wIGwgYWNjID1cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgIHwgW10gLT4gKClcbiAgICAgICAgfCBoIDo6IHQgd2hlbiB0ZXN0X2tleXMgazEgazIgaCAtPiBiIDo9IExpc3QucmV2X2FwcGVuZCBhY2MgdFxuICAgICAgICB8IGggOjogdCAtPiBsb29wIHQgKGggOjogYWNjKVxuICAgICAgaW5cbiAgICAgIGxvb3AgIWIgW11cblxuICAgIGxldCBmaW5kIGIgazEgazIgPVxuICAgICAgbWF0Y2ggTGlzdC5maW5kX29wdCAodGVzdF9rZXlzIGsxIGsyKSAhYiB3aXRoXG4gICAgICB8IFNvbWUgZSAtPiBnZXRfZGF0YSBlXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuXG4gICAgbGV0IGxlbmd0aCBiID0gTGlzdC5sZW5ndGggIWJcbiAgICBsZXQgY2xlYXIgYiA9IGIgOj0gW11cblxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLbiA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSBuIDogKCdrLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSBuXG4gIGxldCBsZW5ndGggKGs6KCdrLCdkKSB0KSA6IGludCA9IE9iakVwaC5sZW5ndGgga1xuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgbilcbiAgbGV0IGdldF9rZXlfY29weSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiAnayBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCBuKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgKGs6J2spIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCBuIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgblxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgblxuXG4gIGxldCBibGl0X2tleSAodDE6KCdrLCdkKSB0KSAobzE6aW50KSAodDI6KCdrLCdkKSB0KSAobzI6aW50KSAobDppbnQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIG8xIHQyIG8yIGxcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignaywnZCkgdCkgKGQ6J2QpIDogdW5pdCA9IE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLCdkKSB0KSAodDI6KF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBsZXQgbWFrZSBrZXlzIGRhdGEgPVxuICAgIGxldCBsID0gQXJyYXkubGVuZ3RoIGtleXMgaW5cbiAgICBsZXQgZXBoID0gY3JlYXRlIGwgaW5cbiAgICBzZXRfZGF0YSBlcGggZGF0YTtcbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gc2V0X2tleSBlcGggaSBrZXlzLihpKSBkb25lO1xuICAgIGVwaFxuXG4gIGxldCBxdWVyeSBlcGgga2V5cyA9XG4gICAgbGV0IGwgPSBsZW5ndGggZXBoIGluXG4gICAgdHJ5XG4gICAgICBpZiBsIDw+IEFycmF5Lmxlbmd0aCBrZXlzIHRoZW4gcmFpc2UgRXhpdDtcbiAgICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgICBtYXRjaCBnZXRfa2V5IGVwaCBpIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHJhaXNlIEV4aXRcbiAgICAgICAgfCBTb21lIGsgd2hlbiBrID09IGtleXMuKGkpIC0+ICgpXG4gICAgICAgIHwgU29tZSBfIC0+IHJhaXNlIEV4aXRcbiAgICAgIGRvbmU7XG4gICAgICBnZXRfZGF0YSBlcGhcbiAgICB3aXRoIEV4aXQgLT4gTm9uZVxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkIChIOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSC50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBILnQgYXJyYXlcbiAgICAgIGxldCBjcmVhdGUgayBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKEFycmF5Lmxlbmd0aCBrKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBzZXRfa2V5IGMgaSBrLihpKTtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggc2VlZCBrID1cbiAgICAgICAgbGV0IGggPSByZWYgMCBpblxuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgaCA6PSBILmhhc2ggc2VlZCBrLihpKSAqIDY1NTk5ICsgIWg7XG4gICAgICAgIGRvbmU7XG4gICAgICAgICFoXG4gICAgICBsZXQgZXF1YWwgYyBrID1cbiAgICAgICAgbGV0IGxlbiAgPSBBcnJheS5sZW5ndGggayBpblxuICAgICAgICBsZXQgbGVuJyA9IGxlbmd0aCBjIGluXG4gICAgICAgIGlmIGxlbiAhPSBsZW4nIHRoZW4gR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IHJlYyBlcXVhbF9hcnJheSBrIGMgaSA9XG4gICAgICAgICAgICBpZiBpIDwgMCB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgaSB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgICAgICAgfCBTb21lIGtpIC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGsuKGkpIGtpXG4gICAgICAgICAgICAgICAgICB0aGVuIGVxdWFsX2FycmF5IGsgYyAoaS0xKVxuICAgICAgICAgICAgICAgICAgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICAgICAgaW5cbiAgICAgICAgICBlcXVhbF9hcnJheSBrIGMgKGxlbi0xKVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5IGMgPVxuICAgICAgICBsZXQgbGVuID0gbGVuZ3RoIGMgaW5cbiAgICAgICAgaWYgbGVuID0gMCB0aGVuIFNvbWUgW3x8XVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIDAgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgfCBTb21lIGswIC0+XG4gICAgICAgICAgICAgIGxldCByZWMgZmlsbCBhIGkgPVxuICAgICAgICAgICAgICAgIGlmIGkgPCAxIHRoZW4gU29tZSBhXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIGkgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICAgICAgICAgIHwgU29tZSBraSAtPlxuICAgICAgICAgICAgICAgICAgICAgIGEuKGkpIDwtIGtpO1xuICAgICAgICAgICAgICAgICAgICAgIGZpbGwgYSAoaS0xKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBsZXQgYSA9IEFycmF5Lm1ha2UgbGVuIGswIGluXG4gICAgICAgICAgICAgIGZpbGwgYSAobGVuLTEpXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgayBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgc2V0X2tleSBjIGkgay4oaSk7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID1cbiAgICAgICAgbGV0IHJlYyBjaGVjayBjIGkgPVxuICAgICAgICAgIGkgPCAwIHx8IChjaGVja19rZXkgYyBpICYmIGNoZWNrIGMgKGktMSkpIGluXG4gICAgICAgIGNoZWNrIGMgKGxlbmd0aCBjIC0gMSlcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDogSGFzaHRibC5IYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCBhcnJheSkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbiAgbW9kdWxlIEJ1Y2tldCA9IHN0cnVjdFxuXG4gICAgdHlwZSBub25yZWMgKCdrLCAnZCkgdCA9ICgnaywgJ2QpIHQgbGlzdCByZWZcbiAgICBsZXQga25fbWFrZSA9IG1ha2VcbiAgICBsZXQgbWFrZSAoKSA9IHJlZiBbXVxuICAgIGxldCBhZGQgYiBrIGQgPSBiIDo9IGtuX21ha2UgayBkIDo6ICFiXG5cbiAgICBsZXQgdGVzdF9rZXlzIGsgZSA9XG4gICAgICB0cnlcbiAgICAgICAgaWYgbGVuZ3RoIGUgPD4gQXJyYXkubGVuZ3RoIGsgdGhlbiByYWlzZSBFeGl0O1xuICAgICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGsgLSAxIGRvXG4gICAgICAgICAgbWF0Y2ggZ2V0X2tleSBlIGkgd2l0aFxuICAgICAgICAgIHwgU29tZSB4IHdoZW4geCA9PSBrLihpKSAtPiAoKVxuICAgICAgICAgIHwgXyAtPiByYWlzZSBFeGl0XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHRydWVcbiAgICAgIHdpdGggRXhpdCAtPiBmYWxzZVxuXG4gICAgbGV0IHJlbW92ZSBiIGsgPVxuICAgICAgbGV0IHJlYyBsb29wIGwgYWNjID1cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgIHwgW10gLT4gKClcbiAgICAgICAgfCBoIDo6IHQgd2hlbiB0ZXN0X2tleXMgayBoIC0+IGIgOj0gTGlzdC5yZXZfYXBwZW5kIGFjYyB0XG4gICAgICAgIHwgaCA6OiB0IC0+IGxvb3AgdCAoaCA6OiBhY2MpXG4gICAgICBpblxuICAgICAgbG9vcCAhYiBbXVxuXG4gICAgbGV0IGZpbmQgYiBrID1cbiAgICAgIG1hdGNoIExpc3QuZmluZF9vcHQgKHRlc3Rfa2V5cyBrKSAhYiB3aXRoXG4gICAgICB8IFNvbWUgZSAtPiBnZXRfZGF0YSBlXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuXG4gICAgbGV0IGxlbmd0aCBiID0gTGlzdC5sZW5ndGggIWJcbiAgICBsZXQgY2xlYXIgYiA9IGIgOj0gW11cblxuICBlbmRcblxuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX21ha2VfdmVjdCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNSIsImEzIiwiYTQiLCJkdW1teSIsImdsb2JhbF9kYXRhIiwiU3RkbGliX0xpc3QiLCJTdGRsaWIiLCJTdGRsaWJfT2JqIiwiU3RkbGliX1N5cyIsIlN0ZGxpYl9TZXEiLCJTdGRsaWJfSW50IiwiU3RkbGliX0FycmF5IiwiU3RkbGliX0hhc2h0YmwiLCJDYW1saW50ZXJuYWxMYXp5IiwiU3RkbGliX1JhbmRvbSIsIk1ha2VTZWVkZWQiLCJIIiwicHJuZyIsImNyZWF0ZSIsIm9wdCIsImluaXRpYWxfc2l6ZSIsInN0aCIsInJhbmRvbSIsIngiLCJzZWVkIiwiY2xlYXIiLCJoIiwibGVuIiwiaSIsInJlc2V0IiwiY29weSIsImtleV9pbmRleCIsImhrZXkiLCJjbGVhbiIsImRvX2J1Y2tldCIsInBhcmFtIiwicmVzdCIsImMiLCJkIiwicmVzaXplIiwib2RhdGEiLCJvc2l6ZSIsIm5zaXplIiwibmRhdGEiLCJpbnNlcnRfYnVja2V0IiwiZGF0YSIsIm5pZHgiLCJhZGQiLCJrZXkiLCJpbmZvIiwiY29udGFpbmVyIiwiYnVja2V0IiwicmVtb3ZlIiwicmVtb3ZlX2J1Y2tldCIsImhrIiwibmV4dCIsImZpbmQiLCJtYXRjaCIsImZpbmRfb3B0IiwiZmluZF9hbGwiLCJmaW5kX2luX2J1Y2tldCIsInJlcGxhY2UiLCJsIiwiZXhuIiwibWVtIiwiaXRlciIsImsiLCJmb2xkIiwiaW5pdCIsImFjY3UiLCJiIiwiZmlsdGVyX21hcF9pbnBsYWNlIiwibmV3X2QiLCJsZW5ndGgiLCJidWNrZXRfbGVuZ3RoIiwic3RhdHMiLCJtYmwiLCJtIiwiaGlzdG8iLCJidWNrZXRfbGVuZ3RoX2FsaXZlIiwic3RhdHNfYWxpdmUiLCJzaXplIiwidG9fc2VxIiwidGJsIiwidGJsX2RhdGEiLCJhdXgiLCJidWNrIiwidG9fc2VxX2tleXMiLCJ0b19zZXFfdmFsdWVzIiwiYWRkX3NlcSIsInYiLCJyZXBsYWNlX3NlcSIsIm9mX3NlcSIsImdldF9rZXkiLCJ0IiwiZ2V0X2tleV9jb3B5Iiwic2V0X2tleSIsInVuc2V0X2tleSIsImNoZWNrX2tleSIsImJsaXRfa2V5IiwidDEiLCJ0MiIsImdldF9kYXRhIiwiZ2V0X2RhdGFfY29weSIsInNldF9kYXRhIiwidW5zZXRfZGF0YSIsImNoZWNrX2RhdGEiLCJibGl0X2RhdGEiLCJtYWtlIiwiZXBoIiwicXVlcnkiLCJoYXNoIiwiZXF1YWwiLCJzZXRfa2V5X2RhdGEiLCJNYWtlIiwiaW5jbHVkZSIsInN6IiwidGVzdF9rZXkiLCJlIiwiYWNjIiwiZ2V0X2tleTEiLCJnZXRfa2V5MV9jb3B5Iiwic2V0X2tleTEiLCJ1bnNldF9rZXkxIiwiY2hlY2tfa2V5MSIsImdldF9rZXkyIiwiZ2V0X2tleTJfY29weSIsInNldF9rZXkyIiwidW5zZXRfa2V5MiIsImNoZWNrX2tleTIiLCJibGl0X2tleTEiLCJibGl0X2tleTIiLCJibGl0X2tleTEyIiwia2V5MSIsImtleTIiLCJIMSIsIkgyIiwiazIiLCJrMSIsInRlc3Rfa2V5cyIsIngyIiwieDEiLCJuIiwibzEiLCJvMiIsImtleXMiLCJraSIsImswIiwiYSIsIlN0ZGxpYl9FcGhlbWVyb24iXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElB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QUFBLElBQ0M7QUFBQTtBQUFBLElBQVc7QUFBQSxHQUFNO0FBQUEsWUFBQXFHLFlBQUF6RSxHQUFBb0Q7QUFBQUEsSUFHcEM7QUFBQSxLQUNLO0FBQUEsTUFBZ0M7QUFBQSxhQUNuQztBQUFBO0FBQUEsVUFBQTFGLElBQUE7QUFBQTtBQUFBLFdBQUE2QixRQUNRO0FBQUEsT0FBVztBQUFBLFlBQUFsQyxJQUFBO0FBQUEsUUFDRTtBQUFBLGlCQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BQ2pCO0FBQUE7QUFBQTtBQUFBLGFBRVQ7QUFBQTtBQUFBO0FBQUEsVUFBQXdDO0FBQUFBLFNBQUFBLE1EOTJCUjtBQUFBLDJCQysyQm1CO0FBQUEsS0QvMkJuQjtBQUFBO0FBQUEsR0MrMkJ3QjtBQUFBLFlBQUFYLFNBQUFrQixHQUFBSjtBQUFBQSxRQUFBSixNQVNsQixNQUFBQSxJQUFBLEtBQUF5RCxNQUFBO0FBQUE7QUFBQSxLQUxFLFFBQ1E7QUFBQSxTQUFBN0YsSUFEUixNQUFBb0UsSUFBQTtBQUFBLEtBRWM7QUFBQSxNQUFzQjtBQUFBLE1BQXFCO0FBQUE7QUFBQSxTQUFBQSxNQUE5QixNQUFBeUIsUUFDZjtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBRUo7QUFBQSxZQUFBL0QsT0FBQWMsR0FBQUo7QUFBQUE7QUFBQUEsS0FBQVQ7QUFBQUEsT0FHSjtBQUFBLDJCQUFjO0FBQUEsSUFBZ0IsWUFFMUI7QUFBQSxRQUFBNkQsSUFGMEI7QUFBQSxJQUN4QixvQkFDRTtBQUFBO0FBQUEsWUFBQTdDLFNBQUFILEdBRUQsc0NBQWM7QUFBQSxZQUFBN0MsUUFBQTZDLEdBQ2YsbUJBQU87QUFBQTtBQUFBLElBQUErRTtBQUFBQSxNRGg0QnpCIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjQyMzgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9maWxlbmFtZS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBYYXZpZXIgTGVyb3kgYW5kIERhbWllbiBEb2xpZ2V6LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGdlbmVyaWNfcXVvdGUgcXVvdGVxdW90ZSBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBpZiBzLltpXSA9ICdcXCcnXG4gICAgdGhlbiBCdWZmZXIuYWRkX3N0cmluZyBiIHF1b3RlcXVvdGVcbiAgICBlbHNlIEJ1ZmZlci5hZGRfY2hhciBiICBzLltpXVxuICBkb25lO1xuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1sxXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Jhc2VuYW1lLmh0bWxcbiAgSW4gc3RlcCAxIG9mIFtbMV1dLCB3ZSBjaG9vc2UgdG8gcmV0dXJuIFwiLlwiIGZvciBlbXB0eSBpbnB1dC5cbiAgICAoZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBPQ2FtbClcbiAgSW4gc3RlcCAyLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4gIFN0ZXAgNiBpcyBub3QgaW1wbGVtZW50ZWQ6IHdlIGNvbnNpZGVyIHRoYXQgdGhlIFtzdWZmaXhdIG9wZXJhbmQgaXNcbiAgICBhbHdheXMgYWJzZW50LiAgU3VmZml4ZXMgYXJlIGhhbmRsZWQgYnkgW2Nob3Bfc3VmZml4XSBhbmQgW2Nob3BfZXh0ZW5zaW9uXS5cbiopXG5sZXQgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgZmluZF9lbmQgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGZpbmRfZW5kIChuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIG4gKG4gKyAxKVxuICBhbmQgZmluZF9iZWcgbiBwID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIHBcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gU3RyaW5nLnN1YiBuYW1lIChuICsgMSkgKHAgLSBuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIChuIC0gMSkgcFxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSBmaW5kX2VuZCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1syXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Rpcm5hbWUuaHRtbFxuICBJbiBzdGVwIDYgb2YgW1syXV0sIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiopXG5sZXQgZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyB0cmFpbGluZ19zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIHRyYWlsaW5nX3NlcCAobiAtIDEpXG4gICAgZWxzZSBiYXNlIG5cbiAgYW5kIGJhc2UgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgblxuICAgIGVsc2UgYmFzZSAobiAtIDEpXG4gIGFuZCBpbnRlcm1lZGlhdGVfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIChuIC0gMSlcbiAgICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChuICsgMSlcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgdHJhaWxpbmdfc2VwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5tb2R1bGUgdHlwZSBTWVNERVBTID0gc2lnXG4gIHZhbCBudWxsIDogc3RyaW5nXG4gIHZhbCBjdXJyZW50X2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBwYXJlbnRfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIGRpcl9zZXAgOiBzdHJpbmdcbiAgdmFsIGlzX2Rpcl9zZXAgOiBzdHJpbmcgLT4gaW50IC0+IGJvb2xcbiAgdmFsIGlzX3JlbGF0aXZlIDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGlzX2ltcGxpY2l0IDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGNoZWNrX3N1ZmZpeCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgY2hvcF9zdWZmaXhfb3B0IDogc3VmZml4OnN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nIG9wdGlvblxuICB2YWwgdGVtcF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgcXVvdGUgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBxdW90ZV9jb21tYW5kIDpcbiAgICBzdHJpbmcgLT4gP3N0ZGluOiBzdHJpbmcgLT4gP3N0ZG91dDogc3RyaW5nIC0+ID9zdGRlcnI6IHN0cmluZ1xuICAgICAgICAgICAtPiBzdHJpbmcgbGlzdCAtPiBzdHJpbmdcbiAgdmFsIGJhc2VuYW1lIDogc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgZGlybmFtZSA6IHN0cmluZyAtPiBzdHJpbmdcbmVuZFxuXG5tb2R1bGUgVW5peCA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIi9kZXYvbnVsbFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IHMuW2ldID0gJy8nXG4gIGxldCBpc19yZWxhdGl2ZSBuID0gU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLydcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgICBTdHJpbmcuZW5kc193aXRoIH5zdWZmaXg6c3VmZiBuYW1lXG5cbiAgbGV0IGNob3Bfc3VmZml4X29wdCB+c3VmZml4IGZpbGVuYW1lID1cbiAgICBsZXQgbGVuX3MgPSBTdHJpbmcubGVuZ3RoIHN1ZmZpeCBhbmQgbGVuX2YgPSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgaWYgbGVuX2YgPj0gbGVuX3MgdGhlblxuICAgICAgbGV0IHIgPSBTdHJpbmcuc3ViIGZpbGVuYW1lIChsZW5fZiAtIGxlbl9zKSBsZW5fcyBpblxuICAgICAgaWYgciA9IHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVE1QRElSXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIvdG1wXCJcbiAgbGV0IHF1b3RlID0gZ2VuZXJpY19xdW90ZSBcIidcXFxcJydcIlxuICBsZXQgcXVvdGVfY29tbWFuZCBjbWQgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBhcmdzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiIFwiIChMaXN0Lm1hcCBxdW90ZSAoY21kIDo6IGFyZ3MpKVxuICAgIF4gKG1hdGNoIHN0ZGluICB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA8XCIgXiBxdW90ZSBmKVxuICAgIF4gKG1hdGNoIHN0ZG91dCB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA+XCIgXiBxdW90ZSBmKVxuICAgIF4gKG1hdGNoIHN0ZGVyciB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBpZiBzdGRlcnIgPSBzdGRvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gXCIgMj4mMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFwiIDI+XCIgXiBxdW90ZSBmKVxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgV2luMzIgOiBTWVNERVBTID0gc3RydWN0XG4gIGxldCBudWxsID0gXCJOVUxcIlxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIlxcXFxcIlxuICBsZXQgaXNfZGlyX3NlcCBzIGkgPSBsZXQgYyA9IHMuW2ldIGluIGMgPSAnLycgfHwgYyA9ICdcXFxcJyB8fCBjID0gJzonXG4gIGxldCBpc19yZWxhdGl2ZSBuID1cbiAgICAoU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLycpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJ1xcXFwnKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IG4uWzFdIDw+ICc6JylcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLlxcXFxcIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uXFxcXFwiKVxuICBsZXQgY2hlY2tfc3VmZml4IG5hbWUgc3VmZiA9XG4gICBTdHJpbmcubGVuZ3RoIG5hbWUgPj0gU3RyaW5nLmxlbmd0aCBzdWZmICYmXG4gICAobGV0IHMgPSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBzdWZmKSBpblxuICAgIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgcyA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgc3VmZilcblxuICBsZXQgY2hvcF9zdWZmaXhfb3B0IH5zdWZmaXggZmlsZW5hbWUgPVxuICAgIGxldCBsZW5fcyA9IFN0cmluZy5sZW5ndGggc3VmZml4IGFuZCBsZW5fZiA9IFN0cmluZy5sZW5ndGggZmlsZW5hbWUgaW5cbiAgICBpZiBsZW5fZiA+PSBsZW5fcyB0aGVuXG4gICAgICBsZXQgciA9IFN0cmluZy5zdWIgZmlsZW5hbWUgKGxlbl9mIC0gbGVuX3MpIGxlbl9zIGluXG4gICAgICBpZiBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHIgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cblxuICBsZXQgdGVtcF9kaXJfbmFtZSA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJURU1QXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIuXCJcbiAgbGV0IHF1b3RlIHMgPVxuICAgIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInIGVsc2VcbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJ1xcXCInIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8IGMgICAgLT4gQnVmZmVyLmFkZF9jaGFyIGIgYzsgbG9vcCAoaSsxKTtcbiAgICBhbmQgbG9vcF9icyBuIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBiZWdpblxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgICAgIGFkZF9icyBuO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgICB8ICdcXFwiJyAtPiBhZGRfYnMgKDIqbisxKTsgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInOyBsb29wIChpKzEpO1xuICAgICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIChuKzEpIChpKzEpO1xuICAgICAgICB8IF8gICAgLT4gYWRkX2JzIG47IGxvb3AgaVxuICAgICAgZW5kXG4gICAgYW5kIGFkZF9icyBuID0gZm9yIF9qID0gMSB0byBuIGRvIEJ1ZmZlci5hZGRfY2hhciBiICdcXFxcJzsgZG9uZVxuICAgIGluXG4gICAgbG9vcCAwO1xuICAgIEJ1ZmZlci5jb250ZW50cyBiXG4oKlxuUXVvdGluZyBjb21tYW5kcyBmb3IgZXhlY3V0aW9uIGJ5IGNtZC5leGUgaXMgZGlmZmljdWx0LlxuMS0gRWFjaCBhcmd1bWVudCBpcyBmaXJzdCBxdW90ZWQgdXNpbmcgdGhlIFwicXVvdGVcIiBmdW5jdGlvbiBhYm92ZSwgdG9cbiAgIHByb3RlY3QgaXQgYWdhaW5zdCB0aGUgcHJvY2Vzc2luZyBwZXJmb3JtZWQgYnkgdGhlIEMgcnVudGltZSBzeXN0ZW0sXG4gICB0aGVuIGNtZC5leGUncyBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQgd2l0aCAnXicsIHVzaW5nXG4gICB0aGUgXCJxdW90ZV9jbWRcIiBmdW5jdGlvbiBiZWxvdy4gIEZvciBtb3JlIGRldGFpbHMsIHNlZVxuICAgaHR0cHM6Ly9ibG9ncy5tc2RuLm1pY3Jvc29mdC5jb20vdHdpc3R5bGl0dGxlcGFzc2FnZXNhbGxhbGlrZS8yMDExLzA0LzIzXG4yLSBUaGUgY29tbWFuZCBhbmQgdGhlIHJlZGlyZWN0aW9uIGZpbGVzLCBpZiBhbnksIG11c3QgYmUgZG91YmxlLXF1b3RlZFxuICAgaW4gY2FzZSB0aGV5IGNvbnRhaW4gc3BhY2VzLiAgVGhpcyBxdW90aW5nIGlzIGludGVycHJldGVkIGJ5IGNtZC5leGUsXG4gICBub3QgYnkgdGhlIEMgcnVudGltZSBzeXN0ZW0sIGhlbmNlIHRoZSBcInF1b3RlXCIgZnVuY3Rpb24gYWJvdmVcbiAgIGNhbm5vdCBiZSB1c2VkLiAgVGhlIHR3byBjaGFyYWN0ZXJzIHdlIGRvbid0IGtub3cgaG93IHRvIHF1b3RlXG4gICBpbnNpZGUgYSBkb3VibGUtcXVvdGVkIGNtZC5leGUgc3RyaW5nIGFyZSBkb3VibGUtcXVvdGUgYW5kIHBlcmNlbnQuXG4gICBXZSBqdXN0IGZhaWwgaWYgdGhlIGNvbW1hbmQgbmFtZSBvciB0aGUgcmVkaXJlY3Rpb24gZmlsZSBuYW1lc1xuICAgY29udGFpbiBhIGRvdWJsZSBxdW90ZSAobm90IGFsbG93ZWQgaW4gV2luZG93cyBmaWxlIG5hbWVzLCBhbnl3YXkpXG4gICBvciBhIHBlcmNlbnQuICBTZWUgZnVuY3Rpb24gXCJxdW90ZV9jbWRfZmlsZW5hbWVcIiBiZWxvdy5cbjMtIFRoZSB3aG9sZSBzdHJpbmcgcGFzc2VkIHRvIFN5cy5jb21tYW5kIGlzIHRoZW4gZW5jbG9zZWQgaW4gZG91YmxlXG4gICBxdW90ZXMsIHdoaWNoIGFyZSBpbW1lZGlhdGVseSBzdHJpcHBlZCBieSBjbWQuZXhlLiAgT3RoZXJ3aXNlLFxuICAgc29tZSBvZiB0aGUgZG91YmxlIHF1b3RlcyBmcm9tIHN0ZXAgMiBhYm92ZSBjYW4gYmUgbWlzcGFyc2VkLlxuICAgU2VlIGUuZy4gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk5NjUxNDFcbiopXG4gIGxldCBxdW90ZV9jbWQgcyA9XG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMgKyAyMCkgaW5cbiAgICBTdHJpbmcuaXRlclxuICAgICAgKGZ1biBjIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcoJyB8ICcpJyB8ICchJyB8ICdeJyB8ICclJyB8ICdcXFwiJyB8ICc8JyB8ICc+JyB8ICcmJyB8ICd8JyAtPlxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgJ14nOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgYylcbiAgICAgIHM7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbiAgbGV0IHF1b3RlX2NtZF9maWxlbmFtZSBmID1cbiAgICBpZiBTdHJpbmcuY29udGFpbnMgZiAnXFxcIicgfHwgU3RyaW5nLmNvbnRhaW5zIGYgJyUnIHRoZW5cbiAgICAgIGZhaWx3aXRoIChcIkZpbGVuYW1lLnF1b3RlX2NvbW1hbmQ6IGJhZCBmaWxlIG5hbWUgXCIgXiBmKVxuICAgIGVsc2UgaWYgU3RyaW5nLmNvbnRhaW5zIGYgJyAnIHRoZW5cbiAgICAgIFwiXFxcIlwiIF4gZiBeIFwiXFxcIlwiXG4gICAgZWxzZVxuICAgICAgZlxuICAoKiBSZWRpcmVjdGlvbnMgaW4gY21kLmV4ZTogc2VlIGh0dHBzOi8vc3M2NC5jb20vbnQvc3ludGF4LXJlZGlyZWN0aW9uLmh0bWxcbiAgICAgYW5kIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3ByZXZpb3VzLXZlcnNpb25zL3dpbmRvd3MvaXQtcHJvL3dpbmRvd3MteHAvYmI0OTA5ODIodj10ZWNobmV0LjEwKVxuICAqKVxuICBsZXQgcXVvdGVfY29tbWFuZCBjbWQgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBhcmdzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiXCIgW1xuICAgICAgXCJcXFwiXCI7XG4gICAgICBxdW90ZV9jbWRfZmlsZW5hbWUgY21kO1xuICAgICAgXCIgXCI7XG4gICAgICBxdW90ZV9jbWQgKFN0cmluZy5jb25jYXQgXCIgXCIgKExpc3QubWFwIHF1b3RlIGFyZ3MpKTtcbiAgICAgIChtYXRjaCBzdGRpbiAgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPFwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgKG1hdGNoIHN0ZG91dCB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA+XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICAobWF0Y2ggc3RkZXJyIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgc3RkZXJyID0gc3Rkb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBcIiAyPiYxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFwiIDI+XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICBcIlxcXCJcIlxuICAgIF1cbiAgbGV0IGhhc19kcml2ZSBzID1cbiAgICBsZXQgaXNfbGV0dGVyID0gZnVuY3Rpb25cbiAgICAgIHwgJ0EnIC4uICdaJyB8ICdhJyAuLiAneicgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBTdHJpbmcubGVuZ3RoIHMgPj0gMiAmJiBpc19sZXR0ZXIgcy5bMF0gJiYgcy5bMV0gPSAnOidcbiAgbGV0IGRyaXZlX2FuZF9wYXRoIHMgPVxuICAgIGlmIGhhc19kcml2ZSBzXG4gICAgdGhlbiAoU3RyaW5nLnN1YiBzIDAgMiwgU3RyaW5nLnN1YiBzIDIgKFN0cmluZy5sZW5ndGggcyAtIDIpKVxuICAgIGVsc2UgKFwiXCIsIHMpXG4gIGxldCBkaXJuYW1lIHMgPVxuICAgIGxldCAoZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGxldCBkaXIgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGggaW5cbiAgICBkcml2ZSBeIGRpclxuICBsZXQgYmFzZW5hbWUgcyA9XG4gICAgbGV0IChfZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGhcbmVuZFxuXG5tb2R1bGUgQ3lnd2luIDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiL2Rldi9udWxsXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCIvXCJcbiAgbGV0IGlzX2Rpcl9zZXAgPSBXaW4zMi5pc19kaXJfc2VwXG4gIGxldCBpc19yZWxhdGl2ZSA9IFdpbjMyLmlzX3JlbGF0aXZlXG4gIGxldCBpc19pbXBsaWNpdCA9IFdpbjMyLmlzX2ltcGxpY2l0XG4gIGxldCBjaGVja19zdWZmaXggPSBXaW4zMi5jaGVja19zdWZmaXhcbiAgbGV0IGNob3Bfc3VmZml4X29wdCA9IFdpbjMyLmNob3Bfc3VmZml4X29wdFxuICBsZXQgdGVtcF9kaXJfbmFtZSA9IFVuaXgudGVtcF9kaXJfbmFtZVxuICBsZXQgcXVvdGUgPSBVbml4LnF1b3RlXG4gIGxldCBxdW90ZV9jb21tYW5kID0gVW5peC5xdW90ZV9jb21tYW5kXG4gIGxldCBiYXNlbmFtZSA9IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG4gIGxldCBkaXJuYW1lID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuZW5kXG5cbm1vZHVsZSBTeXNkZXBzID1cbiAgKHZhbCAobWF0Y2ggU3lzLm9zX3R5cGUgd2l0aFxuICAgICAgIHwgXCJXaW4zMlwiIC0+IChtb2R1bGUgV2luMzI6IFNZU0RFUFMpXG4gICAgICAgfCBcIkN5Z3dpblwiIC0+IChtb2R1bGUgQ3lnd2luOiBTWVNERVBTKVxuICAgICAgIHwgXyAtPiAobW9kdWxlIFVuaXg6IFNZU0RFUFMpKSlcblxuaW5jbHVkZSBTeXNkZXBzXG5cbmxldCBjb25jYXQgZGlybmFtZSBmaWxlbmFtZSA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBkaXJuYW1lIGluXG4gIGlmIGwgPSAwIHx8IGlzX2Rpcl9zZXAgZGlybmFtZSAobC0xKVxuICB0aGVuIGRpcm5hbWUgXiBmaWxlbmFtZVxuICBlbHNlIGRpcm5hbWUgXiBkaXJfc2VwIF4gZmlsZW5hbWVcblxubGV0IGNob3Bfc3VmZml4IG5hbWUgc3VmZiA9XG4gIGlmIGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmZcbiAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmKVxuICBlbHNlIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9zdWZmaXhcIlxuXG5sZXQgZXh0ZW5zaW9uX2xlbiBuYW1lID1cbiAgbGV0IHJlYyBjaGVjayBpMCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaTAgKGkgLSAxKVxuICAgIGVsc2UgU3RyaW5nLmxlbmd0aCBuYW1lIC0gaTBcbiAgaW5cbiAgbGV0IHJlYyBzZWFyY2hfZG90IGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpIChpIC0gMSlcbiAgICBlbHNlIHNlYXJjaF9kb3QgKGkgLSAxKVxuICBpblxuICBzZWFyY2hfZG90IChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5sZXQgZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIFwiXCIgZWxzZSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpIGxcblxubGV0IGNob3BfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9leHRlbnNpb25cIlxuICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5sZXQgcmVtb3ZlX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBuYW1lIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmV4dGVybmFsIG9wZW5fZGVzYzogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuZXh0ZXJuYWwgY2xvc2VfZGVzYzogaW50IC0+IHVuaXQgPSBcImNhbWxfc3lzX2Nsb3NlXCJcblxubGV0IHBybmcgPSBsYXp5KFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcm5kID0gKFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpKSBsYW5kIDB4RkZGRkZGIGluXG4gIGNvbmNhdCB0ZW1wX2RpciAoUHJpbnRmLnNwcmludGYgXCIlcyUwNnglc1wiIHByZWZpeCBybmQgc3VmZml4KVxuXG5cbmxldCBjdXJyZW50X3RlbXBfZGlyX25hbWUgPSByZWYgdGVtcF9kaXJfbmFtZVxuXG5sZXQgc2V0X3RlbXBfZGlyX25hbWUgcyA9IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSA6PSBzXG5sZXQgZ2V0X3RlbXBfZGlyX25hbWUgKCkgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lXG5cbmxldCB0ZW1wX2ZpbGUgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgY2xvc2VfZGVzYyhvcGVuX2Rlc2MgbmFtZSBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fZXhjbF0gMG82MDApO1xuICAgICAgbmFtZVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuXG5sZXQgb3Blbl90ZW1wX2ZpbGUgPyhtb2RlID0gW09wZW5fdGV4dF0pID8ocGVybXMgPSAwbzYwMClcbiAgICAgICAgICAgICAgICAgICA/KHRlbXBfZGlyID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZSkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICAobmFtZSxcbiAgICAgICBvcGVuX291dF9nZW4gKE9wZW5fd3Jvbmx5OjpPcGVuX2NyZWF0OjpPcGVuX2V4Y2w6Om1vZGUpIHBlcm1zIG5hbWUpXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF8yIiwiY3N0XzJfMSIsImNzdF9kZXZfbnVsbCIsImNhbWxfZXF1YWwiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX3N5c19nZXRlbnYiLCJjYW1sX3RyYW1wb2xpbmUiLCJjYW1sX3RyYW1wb2xpbmVfcmV0dXJuIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIm51bGwkIiwiY3VycmVudF9kaXJfbmFtZSIsInBhcmVudF9kaXJfbmFtZSIsImRpcl9zZXAiLCJxdW90ZXF1b3RlIiwiU3RkbGliIiwiQ2FtbGludGVybmFsTGF6eSIsIlN0ZGxpYl9SYW5kb20iLCJTdGRsaWJfUHJpbnRmIiwiU3RkbGliX1N0cmluZyIsIlN0ZGxpYl9MaXN0IiwiU3RkbGliX0J1ZmZlciIsIlN0ZGxpYl9TeXMiLCJnZW5lcmljX2Jhc2VuYW1lIiwiaXNfZGlyX3NlcCIsIm5hbWUiLCJuIiwicCIsImdlbmVyaWNfZGlybmFtZSIsInMiLCJpIiwiaXNfcmVsYXRpdmUiLCJpc19pbXBsaWNpdCIsImNoZWNrX3N1ZmZpeCIsInN1ZmYiLCJjaG9wX3N1ZmZpeF9vcHQiLCJzdWZmaXgiLCJmaWxlbmFtZSIsImxlbl9zIiwibGVuX2YiLCJyIiwiZHVtbXkiLCJjc3RfRmlsZW5hbWVfY2hvcF9leHRlbnNpb24iLCJjc3RfRmlsZW5hbWVfY2hvcF9zdWZmaXgiLCJjc3RfRmlsZW5hbWVfcXVvdGVfY29tbWFuZF9iYWQiLCJjc3RfdG1wIiwidGVtcF9kaXJfbmFtZSIsImV4biIsInF1b3RlIiwibCIsImIiLCJxdW90ZV9jb21tYW5kIiwiY21kIiwic3RkaW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJhcmdzIiwiYmFzZW5hbWUiLCJkaXJuYW1lIiwiVW5peCIsImMiLCJsb29wIiwiY291bnRlciIsImxvb3BfYnMiLCJtYXRjaCIsImFkZF9icyIsImoiLCJxdW90ZV9jbWRfZmlsZW5hbWUiLCJkcml2ZV9hbmRfcGF0aCIsInBhcmFtIiwicGF0aCIsImRyaXZlIiwiZGlyIiwiV2luMzIiLCJDeWd3aW4iLCJTeXNkZXBzIiwiY29uY2F0IiwiY2hvcF9zdWZmaXgiLCJleHRlbnNpb25fbGVuIiwiaTAiLCJleHRlbnNpb24iLCJjaG9wX2V4dGVuc2lvbiIsInJlbW92ZV9leHRlbnNpb24iLCJwcm5nIiwidGVtcF9maWxlX25hbWUiLCJ0ZW1wX2RpciIsInByZWZpeCIsInJuZCIsImN1cnJlbnRfdGVtcF9kaXJfbmFtZSIsInNldF90ZW1wX2Rpcl9uYW1lIiwiZ2V0X3RlbXBfZGlyX25hbWUiLCJ0ZW1wX2ZpbGUiLCJvcHQiLCJzdGgiLCJlIiwidGFnIiwib3Blbl90ZW1wX2ZpbGUiLCJtb2RlIiwicGVybXMiLCJTdGRsaWJfRmlsZW5hbWUiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFGLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUcsZUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFuQixTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLE1BQUE7QUFBQSxJQUFBQSxR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O0FBQUE7QUFBQTtBQUFBLFNBRUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBQUFxRTtBQUFBQSxVQUFBQSxJRHBXUCwwQkFBQUMsTUFBQTtBQUFBO0FBQUEsTUNzV00sb0JBQXdCO0FBQUEsVUFBQWpDLFlBQWE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUM1QjtBQUFBO0FBQUEsSUFBQXFDO0FBQUFBLE1BbEY0QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEclIzRCIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0OTc4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvY29tcGxleC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQ29tcGxleCBudW1iZXJzICopXG5cbnR5cGUgdCA9IHsgcmU6IGZsb2F0OyBpbTogZmxvYXQgfVxuXG5sZXQgemVybyA9IHsgcmUgPSAwLjA7IGltID0gMC4wIH1cbmxldCBvbmUgPSB7IHJlID0gMS4wOyBpbSA9IDAuMCB9XG5sZXQgaSA9IHsgcmUgPSAwLjA7IGltID0gMS4wIH1cblxubGV0IGFkZCB4IHkgPSB7IHJlID0geC5yZSArLiB5LnJlOyBpbSA9IHguaW0gKy4geS5pbSB9XG5cbmxldCBzdWIgeCB5ID0geyByZSA9IHgucmUgLS4geS5yZTsgaW0gPSB4LmltIC0uIHkuaW0gfVxuXG5sZXQgbmVnIHggPSB7IHJlID0gLS4geC5yZTsgaW0gPSAtLiB4LmltIH1cblxubGV0IGNvbmogeCA9IHsgcmUgPSB4LnJlOyBpbSA9IC0uIHguaW0gfVxuXG5sZXQgbXVsIHggeSA9IHsgcmUgPSB4LnJlICouIHkucmUgLS4geC5pbSAqLiB5LmltO1xuICAgICAgICAgICAgICAgIGltID0geC5yZSAqLiB5LmltICsuIHguaW0gKi4geS5yZSB9XG5cbmxldCBkaXYgeCB5ID1cbiAgaWYgYWJzX2Zsb2F0IHkucmUgPj0gYWJzX2Zsb2F0IHkuaW0gdGhlblxuICAgIGxldCByID0geS5pbSAvLiB5LnJlIGluXG4gICAgbGV0IGQgPSB5LnJlICsuIHIgKi4geS5pbSBpblxuICAgIHsgcmUgPSAoeC5yZSArLiByICouIHguaW0pIC8uIGQ7XG4gICAgICBpbSA9ICh4LmltIC0uIHIgKi4geC5yZSkgLy4gZCB9XG4gIGVsc2VcbiAgICBsZXQgciA9IHkucmUgLy4geS5pbSBpblxuICAgIGxldCBkID0geS5pbSArLiByICouIHkucmUgaW5cbiAgICB7IHJlID0gKHIgKi4geC5yZSArLiB4LmltKSAvLiBkO1xuICAgICAgaW0gPSAociAqLiB4LmltIC0uIHgucmUpIC8uIGQgfVxuXG5sZXQgaW52IHggPSBkaXYgb25lIHhcblxubGV0IG5vcm0yIHggPSB4LnJlICouIHgucmUgKy4geC5pbSAqLiB4LmltXG5cbmxldCBub3JtIHggPVxuICAoKiBXYXRjaCBvdXQgZm9yIG92ZXJmbG93IGluIGNvbXB1dGluZyByZV4yICsgaW1eMiAqKVxuICBsZXQgciA9IGFic19mbG9hdCB4LnJlIGFuZCBpID0gYWJzX2Zsb2F0IHguaW0gaW5cbiAgaWYgciA9IDAuMCB0aGVuIGlcbiAgZWxzZSBpZiBpID0gMC4wIHRoZW4gclxuICBlbHNlIGlmIHIgPj0gaSB0aGVuXG4gICAgbGV0IHEgPSBpIC8uIHIgaW4gciAqLiBzcXJ0KDEuMCArLiBxICouIHEpXG4gIGVsc2VcbiAgICBsZXQgcSA9IHIgLy4gaSBpbiBpICouIHNxcnQoMS4wICsuIHEgKi4gcSlcblxubGV0IGFyZyB4ID0gYXRhbjIgeC5pbSB4LnJlXG5cbmxldCBwb2xhciBuIGEgPSB7IHJlID0gY29zIGEgKi4gbjsgaW0gPSBzaW4gYSAqLiBuIH1cblxubGV0IHNxcnQgeCA9XG4gIGlmIHgucmUgPSAwLjAgJiYgeC5pbSA9IDAuMCB0aGVuIHsgcmUgPSAwLjA7IGltID0gMC4wIH1cbiAgZWxzZSBiZWdpblxuICAgIGxldCByID0gYWJzX2Zsb2F0IHgucmUgYW5kIGkgPSBhYnNfZmxvYXQgeC5pbSBpblxuICAgIGxldCB3ID1cbiAgICAgIGlmIHIgPj0gaSB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBxID0gaSAvLiByIGluXG4gICAgICAgIHNxcnQocikgKi4gc3FydCgwLjUgKi4gKDEuMCArLiBzcXJ0KDEuMCArLiBxICouIHEpKSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBxID0gciAvLiBpIGluXG4gICAgICAgIHNxcnQoaSkgKi4gc3FydCgwLjUgKi4gKHEgKy4gc3FydCgxLjAgKy4gcSAqLiBxKSkpXG4gICAgICBlbmQgaW5cbiAgICBpZiB4LnJlID49IDAuMFxuICAgIHRoZW4geyByZSA9IHc7ICBpbSA9IDAuNSAqLiB4LmltIC8uIHcgfVxuICAgIGVsc2UgeyByZSA9IDAuNSAqLiBpIC8uIHc7ICBpbSA9IGlmIHguaW0gPj0gMC4wIHRoZW4gdyBlbHNlIC0uIHcgfVxuICBlbmRcblxubGV0IGV4cCB4ID1cbiAgbGV0IGUgPSBleHAgeC5yZSBpbiB7IHJlID0gZSAqLiBjb3MgeC5pbTsgaW0gPSBlICouIHNpbiB4LmltIH1cblxubGV0IGxvZyB4ID0geyByZSA9IGxvZyAobm9ybSB4KTsgaW0gPSBhdGFuMiB4LmltIHgucmUgfVxuXG5sZXQgcG93IHggeSA9IGV4cCAobXVsIHkgKGxvZyB4KSlcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiemVybyIsIm9uZSIsImkiLCJhZGQiLCJ4IiwieSIsInN1YiIsIm5lZyIsImNvbmoiLCJtdWwiLCJkaXYiLCJyIiwiZCIsImludiIsIm5vcm0yIiwibm9ybSIsInEiLCJhcmciLCJwb2xhciIsIm4iLCJhIiwic3FydCIsInciLCJleHAiLCJlIiwibG9nIiwicG93IiwiU3RkbGliX0NvbXBsZXgiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxJQUFBO0FBQUE7QUFBQSxZQUFBQyxJQUFBQyxHQUFBQyxHQ3VCaUMsdUNBQXFCO0FBQUEsWUFBQUMsSUFBQUYsR0FBQUMsR0FFckIsdUNBQXFCO0FBQUEsWUFBQUUsSUFBQUgsR0FFNUIsNkJBQWdCO0FBQUEsWUFBQUksS0FBQUosR0FFSiwyQkFBRTtBQUFBLFlBQUFLLElBQUFMLEdBQUFDO0FBQUFBLElBRVM7QUFBQSxHQUNFO0FBQUEsWUFBQUssSUFBQU4sR0FBQUM7QUFBQUEsSUFHaEMsR0FBSSxrQkFBbEI7QUFBQSxTQUFBTSxJQUNPLGFBQUFDLElBQ0E7QUFBQSxLQUN1QjtBQUFBO0FBQUEsUUFBQUQsTUFHdkIsYUFBQUMsTUFDQTtBQUFBLElBQ3VCO0FBQUEsR0FDRTtBQUFBLFlBQUFDLElBQUFULEdBRXpCLGtCQUFTO0FBQUEsWUFBQVUsTUFBQVYsR0FFcUI7QUFBQSxZQUFBVyxLQUFBWDtBQUFBQSxRQUFBTyxJQUloQyxnQkFBQVQsSUFBdUI7QUFBQSxJQUMvQixhQUFnQjtBQUFBLElBQ1gsYUFBZ0I7QUFBQSxJQUNoQixlQUFBYyxJQUNLLE9BQWtDLFdBQW5CLHFCQUFtQjtBQUFBLFFBQUFBLE1BRWxDO0FBQUEsSUFBa0MsV0FBbkIseUJBQW1CO0FBQUE7QUFBQSxZQUFBQyxJQUFBYixHQUVuQixPQUFmLHNCQUFlO0FBQUEsWUFBQWMsTUFBQUMsR0FBQUMsR0FFTSxhQUFWLGlCQUFpQixnQkFBUCxDQUFtQjtBQUFBLFlBQUFDLEtBQUFqQjtBQUFBQSxJQUdsRCwrQkFBaUM7QUFBQSxRQUFBTyxJQUV2QixnQkFBQVQsSUFBdUI7QUFBQSxJQUMvQjtBQUFBO0FBQUEsTUFBQWMsSUFFWTtBQUFBLE1BQUFNLElBQ1IsZUFBVyxzQkFBb0I7QUFBQTtBQUFBO0FBQUEsTUFBQU4sTUFFdkI7QUFBQSxNQUFBTSxJQUNSLGVBQVcsdUJBQWtCO0FBQUEsSUFFakMsZUFDcUM7QUFBQSxRQUFBQSxNQUNoQztBQUFBLElBQW9CO0FBQUEsR0FDeEI7QUFBQSxZQUFBQyxJQUFBbkI7QUFBQUEsUUFBQW9CLElBR0s7QUFBQSxJQUFnQyxpQkFBUixvQkFBb0IsZUFBWjtBQUFBLEdBQXNCO0FBQUEsWUFBQUMsSUFBQXJCO0FBQUFBLFFBQUEsSUFFMUI7QUFBQSxJQUFmLGFBQUosU0FBSSxZQUFRO0FBQUEsR0FBd0I7QUFBQSxZQUFBc0IsSUFBQXRCLEdBQUFDLEdBRTlCLE9BQVEsSUFBZixPQUFPLFFBQVE7QUFBQTtBQUFBLElBQUFzQjtBQUFBQSxNRHRGakMiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNTA2NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfQXJyYXkiLCJtYWtlX2Zsb2F0IiwiaW5pdCIsIm1ha2VfbWF0cml4IiwiY3JlYXRlX21hdHJpeCIsImFwcGVuZCIsImNvbmNhdCIsInN1YiIsImNvcHkiLCJmaWxsIiwiYmxpdCIsInRvX2xpc3QiLCJvZl9saXN0IiwiaXRlciIsIml0ZXJpIiwibWFwIiwibWFwaSIsImZvbGRfbGVmdCIsImZvbGRfbGVmdF9tYXAiLCJmb2xkX3JpZ2h0IiwiaXRlcjIiLCJtYXAyIiwiZm9yX2FsbCIsImV4aXN0cyIsImZvcl9hbGwyIiwiZXhpc3RzMiIsIm1lbSIsIm1lbXEiLCJmaW5kX29wdCIsImZpbmRfbWFwIiwic3BsaXQiLCJjb21iaW5lIiwic29ydCIsInN0YWJsZV9zb3J0IiwiZmFzdF9zb3J0IiwidG9fc2VxIiwidG9fc2VxaSIsIm9mX3NlcSIsIkZsb2F0YXJyYXkiLCJTdGRsaWJfQXJyYXlMYWJlbHMiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MTYwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9MaXN0IiwibGVuZ3RoIiwiY29tcGFyZV9sZW5ndGhzIiwiY29tcGFyZV9sZW5ndGhfd2l0aCIsImNvbnMiLCJoZCIsInRsIiwibnRoIiwibnRoX29wdCIsInJldiIsImluaXQiLCJhcHBlbmQiLCJyZXZfYXBwZW5kIiwiY29uY2F0IiwiZmxhdHRlbiIsImVxdWFsIiwiY29tcGFyZSIsIml0ZXIiLCJpdGVyaSIsIm1hcCIsIm1hcGkiLCJyZXZfbWFwIiwiZmlsdGVyX21hcCIsImNvbmNhdF9tYXAiLCJmb2xkX2xlZnRfbWFwIiwiZm9sZF9sZWZ0IiwiZm9sZF9yaWdodCIsIml0ZXIyIiwibWFwMiIsInJldl9tYXAyIiwiZm9sZF9sZWZ0MiIsImZvbGRfcmlnaHQyIiwiZm9yX2FsbCIsImV4aXN0cyIsImZvcl9hbGwyIiwiZXhpc3RzMiIsIm1lbSIsIm1lbXEiLCJmaW5kIiwiZmluZF9vcHQiLCJmaW5kX21hcCIsImZpbHRlciIsImZpbmRfYWxsIiwiZmlsdGVyaSIsInBhcnRpdGlvbiIsInBhcnRpdGlvbl9tYXAiLCJhc3NvYyIsImFzc29jX29wdCIsImFzc3EiLCJhc3NxX29wdCIsIm1lbV9hc3NvYyIsIm1lbV9hc3NxIiwicmVtb3ZlX2Fzc29jIiwicmVtb3ZlX2Fzc3EiLCJzcGxpdCIsImNvbWJpbmUiLCJzb3J0Iiwic3RhYmxlX3NvcnQiLCJmYXN0X3NvcnQiLCJzb3J0X3VuaXEiLCJtZXJnZSIsInRvX3NlcSIsIm9mX3NlcSIsIlN0ZGxpYl9MaXN0TGFiZWxzIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsS0FBQTtBQUFBLElBQUFDLEtBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MzAxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9CeXRlcyIsIm1ha2UiLCJpbml0IiwiZW1wdHkiLCJjb3B5Iiwib2Zfc3RyaW5nIiwidG9fc3RyaW5nIiwic3ViIiwic3ViX3N0cmluZyIsImV4dGVuZCIsImZpbGwiLCJibGl0IiwiYmxpdF9zdHJpbmciLCJjb25jYXQiLCJjYXQiLCJpdGVyIiwiaXRlcmkiLCJtYXAiLCJtYXBpIiwiZm9sZF9sZWZ0IiwiZm9sZF9yaWdodCIsImZvcl9hbGwiLCJleGlzdHMiLCJ0cmltIiwiZXNjYXBlZCIsImluZGV4IiwiaW5kZXhfb3B0IiwicmluZGV4IiwicmluZGV4X29wdCIsImluZGV4X2Zyb20iLCJpbmRleF9mcm9tX29wdCIsInJpbmRleF9mcm9tIiwicmluZGV4X2Zyb21fb3B0IiwiY29udGFpbnMiLCJjb250YWluc19mcm9tIiwicmNvbnRhaW5zX2Zyb20iLCJ1cHBlcmNhc2UiLCJsb3dlcmNhc2UiLCJjYXBpdGFsaXplIiwidW5jYXBpdGFsaXplIiwidXBwZXJjYXNlX2FzY2lpIiwibG93ZXJjYXNlX2FzY2lpIiwiY2FwaXRhbGl6ZV9hc2NpaSIsInVuY2FwaXRhbGl6ZV9hc2NpaSIsImNvbXBhcmUiLCJlcXVhbCIsInN0YXJ0c193aXRoIiwiZW5kc193aXRoIiwidW5zYWZlX3RvX3N0cmluZyIsInVuc2FmZV9vZl9zdHJpbmciLCJzcGxpdF9vbl9jaGFyIiwidG9fc2VxIiwidG9fc2VxaSIsIm9mX3NlcSIsImdldF91dGZfOF91Y2hhciIsInNldF91dGZfOF91Y2hhciIsImlzX3ZhbGlkX3V0Zl84IiwiZ2V0X3V0Zl8xNmJlX3VjaGFyIiwic2V0X3V0Zl8xNmJlX3VjaGFyIiwiaXNfdmFsaWRfdXRmXzE2YmUiLCJnZXRfdXRmXzE2bGVfdWNoYXIiLCJzZXRfdXRmXzE2bGVfdWNoYXIiLCJpc192YWxpZF91dGZfMTZsZSIsImdldF91aW50OCIsImdldF9pbnQ4IiwiZ2V0X3VpbnQxNl9uZSIsImdldF91aW50MTZfYmUiLCJnZXRfdWludDE2X2xlIiwiZ2V0X2ludDE2X25lIiwiZ2V0X2ludDE2X2JlIiwiZ2V0X2ludDE2X2xlIiwiZ2V0X2ludDMyX25lIiwiZ2V0X2ludDMyX2JlIiwiZ2V0X2ludDMyX2xlIiwiZ2V0X2ludDY0X25lIiwiZ2V0X2ludDY0X2JlIiwiZ2V0X2ludDY0X2xlIiwic2V0X3VpbnQ4Iiwic2V0X2ludDgiLCJzZXRfdWludDE2X25lIiwic2V0X3VpbnQxNl9iZSIsInNldF91aW50MTZfbGUiLCJzZXRfaW50MTZfbmUiLCJzZXRfaW50MTZfYmUiLCJzZXRfaW50MTZfbGUiLCJzZXRfaW50MzJfbmUiLCJzZXRfaW50MzJfYmUiLCJzZXRfaW50MzJfbGUiLCJzZXRfaW50NjRfbmUiLCJzZXRfaW50NjRfYmUiLCJzZXRfaW50NjRfbGUiLCJTdGRsaWJfQnl0ZXNMYWJlbHMiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNTQ5OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfU3RyaW5nIiwibWFrZSIsImluaXQiLCJlbXB0eSIsIm9mX2J5dGVzIiwidG9fYnl0ZXMiLCJjb25jYXQiLCJjYXQiLCJlcXVhbCIsImNvbXBhcmUiLCJzdGFydHNfd2l0aCIsImVuZHNfd2l0aCIsImNvbnRhaW5zX2Zyb20iLCJyY29udGFpbnNfZnJvbSIsImNvbnRhaW5zIiwic3ViIiwic3BsaXRfb25fY2hhciIsIm1hcCIsIm1hcGkiLCJmb2xkX2xlZnQiLCJmb2xkX3JpZ2h0IiwiZm9yX2FsbCIsImV4aXN0cyIsInRyaW0iLCJlc2NhcGVkIiwidXBwZXJjYXNlX2FzY2lpIiwibG93ZXJjYXNlX2FzY2lpIiwiY2FwaXRhbGl6ZV9hc2NpaSIsInVuY2FwaXRhbGl6ZV9hc2NpaSIsIml0ZXIiLCJpdGVyaSIsImluZGV4X2Zyb20iLCJpbmRleF9mcm9tX29wdCIsInJpbmRleF9mcm9tIiwicmluZGV4X2Zyb21fb3B0IiwiaW5kZXgiLCJpbmRleF9vcHQiLCJyaW5kZXgiLCJyaW5kZXhfb3B0IiwidG9fc2VxIiwidG9fc2VxaSIsIm9mX3NlcSIsImdldF91dGZfOF91Y2hhciIsImlzX3ZhbGlkX3V0Zl84IiwiZ2V0X3V0Zl8xNmJlX3VjaGFyIiwiaXNfdmFsaWRfdXRmXzE2YmUiLCJnZXRfdXRmXzE2bGVfdWNoYXIiLCJpc192YWxpZF91dGZfMTZsZSIsImJsaXQiLCJjb3B5IiwiZmlsbCIsInVwcGVyY2FzZSIsImxvd2VyY2FzZSIsImNhcGl0YWxpemUiLCJ1bmNhcGl0YWxpemUiLCJnZXRfdWludDgiLCJnZXRfaW50OCIsImdldF91aW50MTZfbmUiLCJnZXRfdWludDE2X2JlIiwiZ2V0X3VpbnQxNl9sZSIsImdldF9pbnQxNl9uZSIsImdldF9pbnQxNl9iZSIsImdldF9pbnQxNl9sZSIsImdldF9pbnQzMl9uZSIsImdldF9pbnQzMl9iZSIsImdldF9pbnQzMl9sZSIsImdldF9pbnQ2NF9uZSIsImdldF9pbnQ2NF9iZSIsImdldF9pbnQ2NF9sZSIsIlN0ZGxpYl9TdHJpbmdMYWJlbHMiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjU2NTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsImdsb2JhbF9kYXRhIiwiU3RkbGliX1NldCIsIlN0ZGxpYl9NYXAiLCJTdGRsaWJfSGFzaHRibCIsIlN0ZGxpYl9Nb3JlTGFiZWxzIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsb0JBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNTY2OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiU3RkbGliX1N0ZExhYmVscyJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLG1CQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjU2ODEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RkbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9jb2Rlc3BhY2UvLm9wYW0vNC4xNC4yL2xpYi9vY2FtbC9iaWdhcnJheS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBNYW51ZWwgU2VycmFubyBldCBYYXZpZXIgTGVyb3ksIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDAgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtCaWdhcnJheV06IGxhcmdlLCBtdWx0aS1kaW1lbnNpb25hbCwgbnVtZXJpY2FsIGFycmF5cyAqKVxuXG4oKiBUaGVzZSB0eXBlcyBpbiBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSB0YWJsZXMgaW5cbiAgIC4uL3R5cGluZy90eXBlb3B0Lm1sICopXG5cbnR5cGUgZmxvYXQzMl9lbHQgPSBGbG9hdDMyX2VsdFxudHlwZSBmbG9hdDY0X2VsdCA9IEZsb2F0NjRfZWx0XG50eXBlIGludDhfc2lnbmVkX2VsdCA9IEludDhfc2lnbmVkX2VsdFxudHlwZSBpbnQ4X3Vuc2lnbmVkX2VsdCA9IEludDhfdW5zaWduZWRfZWx0XG50eXBlIGludDE2X3NpZ25lZF9lbHQgPSBJbnQxNl9zaWduZWRfZWx0XG50eXBlIGludDE2X3Vuc2lnbmVkX2VsdCA9IEludDE2X3Vuc2lnbmVkX2VsdFxudHlwZSBpbnQzMl9lbHQgPSBJbnQzMl9lbHRcbnR5cGUgaW50NjRfZWx0ID0gSW50NjRfZWx0XG50eXBlIGludF9lbHQgPSBJbnRfZWx0XG50eXBlIG5hdGl2ZWludF9lbHQgPSBOYXRpdmVpbnRfZWx0XG50eXBlIGNvbXBsZXgzMl9lbHQgPSBDb21wbGV4MzJfZWx0XG50eXBlIGNvbXBsZXg2NF9lbHQgPSBDb21wbGV4NjRfZWx0XG5cbnR5cGUgKCdhLCAnYikga2luZCA9XG4gICAgRmxvYXQzMiA6IChmbG9hdCwgZmxvYXQzMl9lbHQpIGtpbmRcbiAgfCBGbG9hdDY0IDogKGZsb2F0LCBmbG9hdDY0X2VsdCkga2luZFxuICB8IEludDhfc2lnbmVkIDogKGludCwgaW50OF9zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50OF91bnNpZ25lZCA6IChpbnQsIGludDhfdW5zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MTZfc2lnbmVkIDogKGludCwgaW50MTZfc2lnbmVkX2VsdCkga2luZFxuICB8IEludDE2X3Vuc2lnbmVkIDogKGludCwgaW50MTZfdW5zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MzIgOiAoaW50MzIsIGludDMyX2VsdCkga2luZFxuICB8IEludDY0IDogKGludDY0LCBpbnQ2NF9lbHQpIGtpbmRcbiAgfCBJbnQgOiAoaW50LCBpbnRfZWx0KSBraW5kXG4gIHwgTmF0aXZlaW50IDogKG5hdGl2ZWludCwgbmF0aXZlaW50X2VsdCkga2luZFxuICB8IENvbXBsZXgzMiA6IChDb21wbGV4LnQsIGNvbXBsZXgzMl9lbHQpIGtpbmRcbiAgfCBDb21wbGV4NjQgOiAoQ29tcGxleC50LCBjb21wbGV4NjRfZWx0KSBraW5kXG4gIHwgQ2hhciA6IChjaGFyLCBpbnQ4X3Vuc2lnbmVkX2VsdCkga2luZFxuXG50eXBlIGNfbGF5b3V0ID0gQ19sYXlvdXRfdHlwXG50eXBlIGZvcnRyYW5fbGF5b3V0ID0gRm9ydHJhbl9sYXlvdXRfdHlwICgqKilcblxudHlwZSAnYSBsYXlvdXQgPVxuICAgIENfbGF5b3V0OiBjX2xheW91dCBsYXlvdXRcbiAgfCBGb3J0cmFuX2xheW91dDogZm9ydHJhbl9sYXlvdXQgbGF5b3V0XG5cbigqIEtlZXAgdGhvc2UgY29uc3RhbnRzIGluIHN5bmMgd2l0aCB0aGUgY2FtbF9iYV9raW5kIGVudW1lcmF0aW9uXG4gICBpbiBiaWdhcnJheS5oICopXG5cbmxldCBmbG9hdDMyID0gRmxvYXQzMlxubGV0IGZsb2F0NjQgPSBGbG9hdDY0XG5sZXQgaW50OF9zaWduZWQgPSBJbnQ4X3NpZ25lZFxubGV0IGludDhfdW5zaWduZWQgPSBJbnQ4X3Vuc2lnbmVkXG5sZXQgaW50MTZfc2lnbmVkID0gSW50MTZfc2lnbmVkXG5sZXQgaW50MTZfdW5zaWduZWQgPSBJbnQxNl91bnNpZ25lZFxubGV0IGludDMyID0gSW50MzJcbmxldCBpbnQ2NCA9IEludDY0XG5sZXQgaW50ID0gSW50XG5sZXQgbmF0aXZlaW50ID0gTmF0aXZlaW50XG5sZXQgY29tcGxleDMyID0gQ29tcGxleDMyXG5sZXQgY29tcGxleDY0ID0gQ29tcGxleDY0XG5sZXQgY2hhciA9IENoYXJcblxubGV0IGtpbmRfc2l6ZV9pbl9ieXRlcyA6IHR5cGUgYSBiLiAoYSwgYikga2luZCAtPiBpbnQgPSBmdW5jdGlvblxuICB8IEZsb2F0MzIgLT4gNFxuICB8IEZsb2F0NjQgLT4gOFxuICB8IEludDhfc2lnbmVkIC0+IDFcbiAgfCBJbnQ4X3Vuc2lnbmVkIC0+IDFcbiAgfCBJbnQxNl9zaWduZWQgLT4gMlxuICB8IEludDE2X3Vuc2lnbmVkIC0+IDJcbiAgfCBJbnQzMiAtPiA0XG4gIHwgSW50NjQgLT4gOFxuICB8IEludCAtPiBTeXMud29yZF9zaXplIC8gOFxuICB8IE5hdGl2ZWludCAtPiBTeXMud29yZF9zaXplIC8gOFxuICB8IENvbXBsZXgzMiAtPiA4XG4gIHwgQ29tcGxleDY0IC0+IDE2XG4gIHwgQ2hhciAtPiAxXG5cbigqIEtlZXAgdGhvc2UgY29uc3RhbnRzIGluIHN5bmMgd2l0aCB0aGUgY2FtbF9iYV9sYXlvdXQgZW51bWVyYXRpb25cbiAgIGluIGJpZ2FycmF5LmggKilcblxubGV0IGNfbGF5b3V0ID0gQ19sYXlvdXRcbmxldCBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0XG5cbm1vZHVsZSBHZW5hcnJheSA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0XG4gIGV4dGVybmFsIGNyZWF0ZTogKCdhLCAnYikga2luZCAtPiAnYyBsYXlvdXQgLT4gaW50IGFycmF5IC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgID0gXCJjYW1sX2JhX2NyZWF0ZVwiXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IGFycmF5IC0+ICdhXG4gICAgID0gXCJjYW1sX2JhX2dldF9nZW5lcmljXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgYXJyYXkgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9iYV9zZXRfZ2VuZXJpY1wiXG5cbiAgbGV0IHJlYyBjbG9vcCBhcnIgaWR4IGYgY29sIG1heCA9XG4gICAgaWYgY29sID0gQXJyYXkubGVuZ3RoIGlkeCB0aGVuIHNldCBhcnIgaWR4IChmIGlkeClcbiAgICBlbHNlIGZvciBqID0gMCB0byBwcmVkIG1heC4oY29sKSBkb1xuICAgICAgICAgICBpZHguKGNvbCkgPC0gajtcbiAgICAgICAgICAgY2xvb3AgYXJyIGlkeCBmIChzdWNjIGNvbCkgbWF4XG4gICAgICAgICBkb25lXG4gIGxldCByZWMgZmxvb3AgYXJyIGlkeCBmIGNvbCBtYXggPVxuICAgIGlmIGNvbCA8IDAgdGhlbiBzZXQgYXJyIGlkeCAoZiBpZHgpXG4gICAgZWxzZSBmb3IgaiA9IDEgdG8gbWF4Lihjb2wpIGRvXG4gICAgICAgICAgIGlkeC4oY29sKSA8LSBqO1xuICAgICAgICAgICBmbG9vcCBhcnIgaWR4IGYgKHByZWQgY29sKSBtYXhcbiAgICAgICAgIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbXMgZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW1zIGluXG4gICAgbWF0Y2ggQXJyYXkubGVuZ3RoIGRpbXMsIGxheW91dCB3aXRoXG4gICAgfCAwLCBfIC0+IGFyclxuICAgIHwgZGxlbiwgQ19sYXlvdXQgLT4gY2xvb3AgYXJyIChBcnJheS5tYWtlIGRsZW4gMCkgZiAwIGRpbXM7IGFyclxuICAgIHwgZGxlbiwgRm9ydHJhbl9sYXlvdXQgLT4gZmxvb3AgYXJyIChBcnJheS5tYWtlIGRsZW4gMSkgZiAocHJlZCBkbGVuKSBkaW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyXG5cbiAgZXh0ZXJuYWwgbnVtX2RpbXM6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiY2FtbF9iYV9udW1fZGltc1wiXG4gIGV4dGVybmFsIG50aF9kaW06ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfYmFfZGltXCJcbiAgbGV0IGRpbXMgYSA9XG4gICAgbGV0IG4gPSBudW1fZGltcyBhIGluXG4gICAgbGV0IGQgPSBBcnJheS5tYWtlIG4gMCBpblxuICAgIGZvciBpID0gMCB0byBuLTEgZG8gZC4oaSkgPC0gbnRoX2RpbSBhIGkgZG9uZTtcbiAgICBkXG5cbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChBcnJheS5mb2xkX2xlZnQgKCAqICkgMSAoZGltcyBhcnIpKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDogKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzbGljZV9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgYXJyYXkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc2xpY2VcIlxuICBleHRlcm5hbCBzbGljZV9yaWdodDogKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IGFycmF5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3NsaWNlXCJcbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbmVuZFxuXG5tb2R1bGUgQXJyYXkwID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0ID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3x8XVxuICBsZXQgZ2V0IGFyciA9IEdlbmFycmF5LmdldCBhcnIgW3x8XVxuICBsZXQgc2V0IGFyciA9IEdlbmFycmF5LnNldCBhcnIgW3x8XVxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9IGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpXG5cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcblxuICBsZXQgb2ZfdmFsdWUga2luZCBsYXlvdXQgdiA9XG4gICAgbGV0IGEgPSBjcmVhdGUga2luZCBsYXlvdXQgaW5cbiAgICBzZXQgYSB2O1xuICAgIGFcbiAgbGV0IGluaXQgPSBvZl92YWx1ZVxuZW5kXG5cbm1vZHVsZSBBcnJheTEgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW18XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzFcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlY2FtbF9iYV9zZXRfMVwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8xXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfMVwiXG4gIGV4dGVybmFsIGRpbTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbSBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsICdjKSB0ID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZSAodHlwZSB0KSAoYSA6IChfLCBfLCB0KSBHZW5hcnJheS50KSBuID1cbiAgICBtYXRjaCBsYXlvdXQgYSB3aXRoXG4gICAgfCBDX2xheW91dCAtPiAoR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdIDogKF8sIF8sIHQpIEdlbmFycmF5LnQpXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiAoR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG58XTogKF8sIF8sIHQpIEdlbmFycmF5LnQpXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBjX2luaXQgYXJyIGRpbSBmID1cbiAgICBmb3IgaSA9IDAgdG8gcHJlZCBkaW0gZG8gdW5zYWZlX3NldCBhcnIgaSAoZiBpKSBkb25lXG4gIGxldCBmb3J0cmFuX2luaXQgYXJyIGRpbSBmID1cbiAgICBmb3IgaSA9IDEgdG8gZGltIGRvIHVuc2FmZV9zZXQgYXJyIGkgKGYgaSkgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltIGluXG4gICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IGNfaW5pdCBhcnIgZGltIGY7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZm9ydHJhbl9pbml0IGFyciBkaW0gZjsgYXJyXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgKEFycmF5Lmxlbmd0aCBkYXRhKSBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGRhdGEgLSAxIGRvIHVuc2FmZV9zZXQgYmEgKGkgKyBvZnMpIGRhdGEuKGkpIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5tb2R1bGUgQXJyYXkyID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltMTsgZGltMnxdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzJcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWNhbWxfYmFfc2V0XzJcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhXG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzJcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfMlwiXG4gIGV4dGVybmFsIGRpbTE6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBkaW0yOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8yXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltMSBhcnIpICogKGRpbTIgYXJyKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDpcbiAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZV9sZWZ0IGEgbiA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XVxuICBsZXQgc2xpY2VfcmlnaHQgYSBuID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG58XVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgY19pbml0IGFyciBkaW0xIGRpbTIgZiA9XG4gICAgZm9yIGkgPSAwIHRvIHByZWQgZGltMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIHByZWQgZGltMiBkb1xuICAgICAgICB1bnNhZmVfc2V0IGFyciBpIGogKGYgaSBqKVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgbGV0IGZvcnRyYW5faW5pdCBhcnIgZGltMSBkaW0yIGYgPVxuICAgIGZvciBqID0gMSB0byBkaW0yIGRvXG4gICAgICBmb3IgaSA9IDEgdG8gZGltMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IGFyciBpIGogKGYgaSBqKVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbTEgZGltMiBmID1cbiAgICBsZXQgYXJyID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBpblxuICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgfCBDX2xheW91dCAtPiBjX2luaXQgYXJyIGRpbTEgZGltMiBmOyBhcnJcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IGZvcnRyYW5faW5pdCBhcnIgZGltMSBkaW0yIGY7IGFyclxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGRpbTEgPSBBcnJheS5sZW5ndGggZGF0YSBpblxuICAgIGxldCBkaW0yID0gaWYgZGltMSA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApIGluXG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gZGltMSAtIDEgZG9cbiAgICAgIGxldCByb3cgPSBkYXRhLihpKSBpblxuICAgICAgaWYgQXJyYXkubGVuZ3RoIHJvdyA8PiBkaW0yIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTIub2ZfYXJyYXk6IG5vbi1yZWN0YW5ndWxhciBkYXRhXCIpO1xuICAgICAgZm9yIGogPSAwIHRvIGRpbTIgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYmEgKGkgKyBvZnMpIChqICsgb2ZzKSByb3cuKGopXG4gICAgICBkb25lXG4gICAgZG9uZTtcbiAgICBiYVxuZW5kXG5cbm1vZHVsZSBBcnJheTMgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbTE7IGRpbTI7IGRpbTN8XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfM1wiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfc2V0XzNcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYVxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8zXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8zXCJcbiAgZXh0ZXJuYWwgZGltMTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGRpbTI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzJcIlxuICBleHRlcm5hbCBkaW0zOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8zXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltMSBhcnIpICogKGRpbTIgYXJyKSAqIChkaW0zIGFycilcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6XG4gICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlX2xlZnRfMSBhIG4gbSA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG47IG18XVxuICBsZXQgc2xpY2VfcmlnaHRfMSBhIG4gbSA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xuOyBtfF1cbiAgbGV0IHNsaWNlX2xlZnRfMiBhIG4gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF1cbiAgbGV0IHNsaWNlX3JpZ2h0XzIgYSBuID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG58XVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgY19pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmID1cbiAgICBmb3IgaSA9IDAgdG8gcHJlZCBkaW0xIGRvXG4gICAgICBmb3IgaiA9IDAgdG8gcHJlZCBkaW0yIGRvXG4gICAgICAgIGZvciBrID0gMCB0byBwcmVkIGRpbTMgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGFyciBpIGogayAoZiBpIGogaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgbGV0IGZvcnRyYW5faW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZiA9XG4gICAgZm9yIGsgPSAxIHRvIGRpbTMgZG9cbiAgICAgIGZvciBqID0gMSB0byBkaW0yIGRvXG4gICAgICAgIGZvciBpID0gMSB0byBkaW0xIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIGsgKGYgaSBqIGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW0xIGRpbTIgZGltMyBmID1cbiAgICBsZXQgYXJyID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zIGluXG4gICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IGNfaW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZjsgYXJyXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGY7IGFyclxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGRpbTEgPSBBcnJheS5sZW5ndGggZGF0YSBpblxuICAgIGxldCBkaW0yID0gaWYgZGltMSA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApIGluXG4gICAgbGV0IGRpbTMgPSBpZiBkaW0yID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkuKDApIGluXG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBkaW0xIC0gMSBkb1xuICAgICAgbGV0IHJvdyA9IGRhdGEuKGkpIGluXG4gICAgICBpZiBBcnJheS5sZW5ndGggcm93IDw+IGRpbTIgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5My5vZl9hcnJheTogbm9uLWN1YmljIGRhdGFcIik7XG4gICAgICBmb3IgaiA9IDAgdG8gZGltMiAtIDEgZG9cbiAgICAgICAgbGV0IGNvbCA9IHJvdy4oaikgaW5cbiAgICAgICAgaWYgQXJyYXkubGVuZ3RoIGNvbCA8PiBkaW0zIHRoZW5cbiAgICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5My5vZl9hcnJheTogbm9uLWN1YmljIGRhdGFcIik7XG4gICAgICAgIGZvciBrID0gMCB0byBkaW0zIC0gMSBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgYmEgKGkgKyBvZnMpIChqICsgb2ZzKSAoayArIG9mcykgY29sLihrKVxuICAgICAgICBkb25lXG4gICAgICBkb25lXG4gICAgZG9uZTtcbiAgICBiYVxuZW5kXG5cbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MDogKCdhLCAnYiwgJ2MpIEFycmF5MC50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MTogKCdhLCAnYiwgJ2MpIEFycmF5MS50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MjogKCdhLCAnYiwgJ2MpIEFycmF5Mi50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MzogKCdhLCAnYiwgJ2MpIEFycmF5My50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmxldCBhcnJheTBfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAwIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkwX29mX2dlbmFycmF5XCJcbmxldCBhcnJheTFfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAxIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkxX29mX2dlbmFycmF5XCJcbmxldCBhcnJheTJfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAyIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkyX29mX2dlbmFycmF5XCJcbmxldCBhcnJheTNfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAzIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkzX29mX2dlbmFycmF5XCJcblxuZXh0ZXJuYWwgcmVzaGFwZTpcbiAgICgnYSwgJ2IsICdjKSBHZW5hcnJheS50IC0+IGludCBhcnJheSAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcImNhbWxfYmFfcmVzaGFwZVwiXG5sZXQgcmVzaGFwZV8wIGEgPSByZXNoYXBlIGEgW3x8XVxubGV0IHJlc2hhcGVfMSBhIGRpbTEgPSByZXNoYXBlIGEgW3xkaW0xfF1cbmxldCByZXNoYXBlXzIgYSBkaW0xIGRpbTIgPSByZXNoYXBlIGEgW3xkaW0xO2RpbTJ8XVxubGV0IHJlc2hhcGVfMyBhIGRpbTEgZGltMiBkaW0zID0gcmVzaGFwZSBhIFt8ZGltMTtkaW0yO2RpbTN8XVxuXG4oKiBGb3JjZSBjYW1sX2JhX2dldF97MSwyLDMsTn0gdG8gYmUgbGlua2VkIGluLCBzaW5jZSB3ZSBkb24ndCByZWZlclxuICAgdG8gdGhvc2UgcHJpbWl0aXZlcyBkaXJlY3RseSBpbiB0aGlzIGZpbGUgKilcblxubGV0IF8gPVxuICBsZXQgXyA9IEdlbmFycmF5LmdldCBpblxuICBsZXQgXyA9IEFycmF5MS5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTIuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkzLmdldCBpblxuICAoKVxuXG5bQEBAb2NhbWwud2FybmluZyBcIi0zMlwiXVxuZXh0ZXJuYWwgZ2V0MTogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8xXCJcbmV4dGVybmFsIGdldDI6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfMlwiXG5leHRlcm5hbCBnZXQzOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzNcIlxuZXh0ZXJuYWwgc2V0MTogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8xXCJcbmV4dGVybmFsIHNldDI6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfMlwiXG5leHRlcm5hbCBzZXQzOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzNcIlxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfQmlnYXJyYXlfQXJyYXkzX29mX2FycmF5X24iLCJjYW1sX2JhX2NoYW5nZV9sYXlvdXQiLCJjYW1sX2JhX2NyZWF0ZSIsImNhbWxfYmFfZGltXzEiLCJjYW1sX2JhX2RpbV8yIiwiY2FtbF9iYV9raW5kIiwiY2FtbF9iYV9udW1fZGltcyIsImNhbWxfYmFfcmVzaGFwZSIsImNhbWxfYmFfc2V0XzEiLCJjYW1sX2JhX3NldF8yIiwiY2FtbF9iYV9zZXRfMyIsImNhbWxfYmFfc2V0X2dlbmVyaWMiLCJjYW1sX2JhX3NsaWNlIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfbWFrZV92ZWN0IiwiY2FtbF9tdWwiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsIlN0ZGxpYl9BcnJheSIsIlN0ZGxpYl9TeXMiLCJraW5kX3NpemVfaW5fYnl0ZXMiLCJwYXJhbSIsImNzdF9CaWdhcnJheV9BcnJheTJfb2ZfYXJyYXlfbiIsImNzdF9CaWdhcnJheV9hcnJheTBfb2ZfZ2VuYXJyYSIsImNzdF9CaWdhcnJheV9hcnJheTFfb2ZfZ2VuYXJyYSIsImNzdF9CaWdhcnJheV9hcnJheTJfb2ZfZ2VuYXJyYSIsImNzdF9CaWdhcnJheV9hcnJheTNfb2ZfZ2VuYXJyYSIsImNsb29wIiwiYXJyIiwiaWR4IiwiY29sIiwibWF4IiwiaiIsImZsb29wIiwiaW5pdCIsImtpbmQiLCJsYXlvdXQiLCJkaW1zIiwibWF0Y2giLCJhIiwibiIsImQiLCJpIiwic2l6ZV9pbl9ieXRlcyIsImNyZWF0ZSIsImdldCIsInNldCIsIm9mX3ZhbHVlIiwidiIsImRpbSIsInNsaWNlIiwib2ZfYXJyYXkiLCJkYXRhIiwiYmEiLCJvZnMiLCJkaW0xIiwiZGltMiIsInNsaWNlX2xlZnQiLCJzbGljZV9yaWdodCIsInJvdyIsImRpbTMiLCJzbGljZV9sZWZ0XzEiLCJtIiwic2xpY2VfcmlnaHRfMSIsInNsaWNlX2xlZnRfMiIsInNsaWNlX3JpZ2h0XzIiLCJrIiwiYXJyYXkwX29mX2dlbmFycmF5IiwiYXJyYXkxX29mX2dlbmFycmF5IiwiYXJyYXkyX29mX2dlbmFycmF5IiwiYXJyYXkzX29mX2dlbmFycmF5IiwicmVzaGFwZV8wIiwicmVzaGFwZV8xIiwicmVzaGFwZV8yIiwicmVzaGFwZV8zIiwiU3RkbGliX0JpZ2FycmF5Il0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLFlBQUFDLG1CQUFBQztBQUFBQSxJQ3dFSTtBQUFBO0FBQUEsT0FZYTtBQUFBO0FBQUE7QUFBQSxPQVpiO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FhUztBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTURyRmI7QUFBQSxJQUFBOUIsaUNBQUE7QUFBQSxJQUFBQSxtQ0FBQTtBQUFBLElBQUErQixpQ0FBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLFlBQUFDLE1BQUFDLEtBQUFDLEtBQUFwQixHQUFBcUIsS0FBQUM7QUFBQUEsSUN1R0k7QUFBQSxLQUErQiw4QkFBWTtBQUFBLEtBQU87QUFBQTtBQUFBLFlBQzNCLGlEQUFTO0FBQUE7QUFBQSxTQUFBQyxJQUFBO0FBQUE7QUFBQSxNQUN6QjtBQUFBLE1BQ0E7QUFBQSxjQUE4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FDNUI7QUFBQSxZQUFBQyxNQUFBTCxLQUFBQyxLQUFBcEIsR0FBQXFCLEtBQUFDO0FBQUFBLElBRVQsWUFBZ0IsOEJBQVkscUJBQU87QUFBQSxZQUNqQix5Q0FBUztBQUFBO0FBQUEsU0FBQUMsSUFBQTtBQUFBO0FBQUEsTUFDcEI7QUFBQSxNQUNBO0FBQUEsY0FBOEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQzVCO0FBQUEsWUFBQUUsS0FBQUMsTUFBQUMsUUFBQUMsTUFBQTVCO0FBQUFBLFFBQUFtQixNQUVDLG9DQUFBVSxRQUNWO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBRzBCO0FBQUEsdUJBQVU7QUFBQTtBQUFBLGlCQURoQixXQUFVLDJDQUVEO0FBQUE7QUFBQSxZQUFBRCxLQUFBRTtBQUFBQTtBQUFBQSxLQUFBQyxJQUtyQjtBQUFBLEtBQUFDLElBQ0E7QUFBQSxTQUNSO0FBQUE7QUFBQTtBQUFBLFNBQUFDLElBQUE7QUFBQTtBQUFBLGNBQTZCO0FBQUEsTUFBVDtBQUFBLGNBQW9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUN4QztBQUFBLEdBQUM7QUFBQSxZQUFBQyxjQUFBZjtBQUFBQSxRQUFBLElBUTBELGVBQXpCO0FBQUEsSUFBZCxPQUFXLFNBQS9CLG1CQUFvQixzQkFBa0Q7QUFBQTtBQUFBLFlBQUFnQixPQUFBVCxNQUFBQyxRQXFCdEUsd0NBQWdDO0FBQUEsWUFBQVMsSUFBQWpCLEtBQ3BCLDRDQUFxQjtBQUFBLFlBQUFrQixJQUFBbEI7QUFBQUEsUUFBQSxJQUNyQjtBQUFBLHVCRC9KaEIsdUNDK0pnQjtBQUFBLEdBQXFCO0FBQUEsWUFBQWUsZ0JBQUFmO0FBQUFBLElBT1EsT0FBVSxtQkFBVixrQkFBVTtBQUFBO0FBQUEsWUFBQW1CLFNBQUFaLE1BQUFDLFFBQUFZO0FBQUFBLFFBQUFULElBTTNDO0FBQUEsSUFDUjtBQUFBLElBQU87QUFBQSxHQUNOO0FBQUEsWUFBQUssU0FBQVQsTUFBQUMsUUFBQWE7QUFBQUEsSUFPRCw2Q0FBbUM7QUFBQTtBQUFBLFlBQUFOLGdCQUFBZjtBQUFBQSxRQUFBLElBY0Q7QUFBQSxJQUFkLE9BQVcsU0FBL0IsbUJBQW9CLHNCQUF1QjtBQUFBO0FBQUEsWUFBQXNCLE1BQUFYLEdBQUFDO0FBQUFBLElBSXJDO0FBQUEsY0FFZTtBQUFBLGNBRE4sd0JBQ3lEO0FBQUE7QUFBQSxZQUFBTixPQUFBQyxNQUFBQyxRQUFBYSxLQUFBeEM7QUFBQUEsUUFBQW1CLE1BUTlEO0FBQUEsSUFDVjtBQUFBLGFBSEE7QUFBQTtBQUFBLFVBQUFjLE1BQUE7QUFBQTtBQUFBLE9BQW9CLHdCQUFpQjtBQUFBLGVBQUs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBS0E7QUFBQTtBQUFBLFlBUDFDO0FBQUE7QUFBQSxTQUFBQSxJQUFBO0FBQUE7QUFBQSxNQUF5QixzQkFBaUI7QUFBQSxjQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQU1qQjtBQUFBLEdBQ2lCO0FBQUEsWUFBQVMsU0FBQWhCLE1BQUFDLFFBQUFnQjtBQUFBQTtBQUFBQSxLQUFBQyxLQUV0QztBQUFBLEtBQUFDLE1BQ1Q7QUFBQSxTQUtBO0FBQUE7QUFBQTtBQUFBLFNBQUFaLElBQUE7QUFBQTtBQUFBLE1BQXNDLCtCQUF3QjtBQUFBLGNBQVE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQ3RFO0FBQUEsR0FBRTtBQUFBLFlBQUFFLFNBQUFULE1BQUFDLFFBQUFtQixNQUFBQztBQUFBQSxJQU1GLG9EQUEwQztBQUFBO0FBQUEsWUFBQWIsZ0JBQUFmO0FBQUFBLFFBQUEsSUFnQkssd0JBQWI7QUFBQSxJQUFkLE9BQVcsa0JBQS9CLG1CQUFvQiwwQkFBcUM7QUFBQTtBQUFBLFlBQUE2QixXQUFBbEIsR0FBQUMsR0FPdEMsK0JBQTJCO0FBQUEsWUFBQWtCLFlBQUFuQixHQUFBQyxHQUMxQiwrQkFBNEI7QUFBQSxZQUFBTixPQUFBQyxNQUFBQyxRQUFBbUIsTUFBQUMsTUFBQS9DO0FBQUFBLFFBQUFtQixNQWdCdEM7QUFBQSxJQUNWO0FBQUEsYUFQQTtBQUFBO0FBQUEsVUFBQUksTUFBQTtBQUFBO0FBQUEsZUFDRTtBQUFBO0FBQUEsWUFBQVUsTUFBQTtBQUFBO0FBQUEsU0FDRSw2QkFBbUI7QUFBQSxpQkFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFENUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBUThDO0FBQUE7QUFBQSxZQWZoRDtBQUFBO0FBQUEsU0FBQUEsSUFBQTtBQUFBO0FBQUEsY0FDRTtBQUFBO0FBQUEsV0FBQVYsSUFBQTtBQUFBO0FBQUEsUUFDRSx5QkFBbUI7QUFBQSxnQkFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FENUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBYWtDO0FBQUEsR0FDaUI7QUFBQSxZQUFBbUIsV0FBQWhCLE1BQUFDLFFBQUFnQjtBQUFBQTtBQUFBQSxLQUFBRyxPQUVyRDtBQUFBLEtBQUFDLE9BQ0EsaUJBQWdEO0FBQUEsS0FBQUgsS0FDdkM7QUFBQSxLQUFBQyxNQUNUO0FBQUEsU0FLQTtBQUFBO0FBQUE7QUFBQSxTQUFBWixJQUFBO0FBQUE7QUFBQSxVQUFBaUIsTUFDWTtBQUFBLE1BQ1Y7QUFBQSxPQUNFO0FBQUEsY0FDRjtBQUFBO0FBQUEsV0FBQTNCLElBQUE7QUFBQTtBQUFBLFFBQ0U7QUFBQSx3Q0FBa0M7QUFBQSxnQkFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FEM0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBSUY7QUFBQSxHQUFFO0FBQUEsWUFBQVksU0FBQVQsTUFBQUMsUUFBQW1CLE1BQUFDLE1BQUFJO0FBQUFBLElBTUYsMERBQWdEO0FBQUE7QUFBQSxZQUFBakIsZ0JBQUFmO0FBQUFBO0FBQUFBLEtBQUEsSUFrQlk7QUFBQSxTQUFiO0FBQUEsU0FBYjtBQUFBLElBQWQsT0FBVztBQUFBLCtCQUEvQixtQkFBb0I7QUFBQSxlQUFrRDtBQUFBO0FBQUEsWUFBQWlDLGFBQUF0QixHQUFBQyxHQUFBc0IsR0FPL0Msa0NBQThCO0FBQUEsWUFBQUMsY0FBQXhCLEdBQUFDLEdBQUFzQixHQUM3QixrQ0FBK0I7QUFBQSxZQUFBRSxhQUFBekIsR0FBQUMsR0FDbEMsK0JBQTJCO0FBQUEsWUFBQXlCLGNBQUExQixHQUFBQyxHQUMxQiwrQkFBNEI7QUFBQSxZQUFBTixPQUFBQyxNQUFBQyxRQUFBbUIsTUFBQUMsTUFBQUksTUFBQW5EO0FBQUFBLFFBQUFtQixNQW9CeEM7QUFBQSxJQUNWO0FBQUEsYUFUQTtBQUFBO0FBQUEsVUFBQXNDLE1BQUE7QUFBQTtBQUFBLGVBQ0U7QUFBQTtBQUFBLFlBQUFsQyxNQUFBO0FBQUE7QUFBQSxpQkFDRTtBQUFBO0FBQUEsY0FBQVUsTUFBQTtBQUFBO0FBQUEsV0FDRSxrQ0FBcUI7QUFBQSxtQkFBUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBRGhDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQURGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQVVtRDtBQUFBO0FBQUEsWUFuQnJEO0FBQUE7QUFBQSxTQUFBQSxJQUFBO0FBQUE7QUFBQSxjQUNFO0FBQUE7QUFBQSxXQUFBVixJQUFBO0FBQUE7QUFBQSxnQkFDRTtBQUFBO0FBQUEsYUFBQWtDLElBQUE7QUFBQTtBQUFBLFVBQ0UsNEJBQXFCO0FBQUEsa0JBQVM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQURoQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FERjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFpQnVDO0FBQUEsR0FDaUI7QUFBQSxZQUFBZixXQUFBaEIsTUFBQUMsUUFBQWdCO0FBQUFBO0FBQUFBLEtBQUFHLE9BRTFEO0FBQUEsS0FBQUMsT0FDQSxpQkFBZ0Q7QUFBQSxLQUFBSTtBQUFBQSxPQUNoRDtBQUFBO0FBQUEsVUFBZ0Q7QUFBQSxLQUFBUCxLQUN2QztBQUFBLEtBQUFDLE1BQ1Q7QUFBQSxTQUtBO0FBQUE7QUFBQTtBQUFBLFNBQUFaLElBQUE7QUFBQTtBQUFBLFVBQUFpQixNQUNZO0FBQUEsTUFDVjtBQUFBLE9BQ0U7QUFBQSxjQUNGO0FBQUE7QUFBQSxXQUFBM0IsSUFBQTtBQUFBO0FBQUEsWUFBQUYsTUFDWTtBQUFBLFFBQ1Y7QUFBQSxTQUNFO0FBQUEsZ0JBQ0Y7QUFBQTtBQUFBLGFBQUFvQyxJQUFBO0FBQUE7QUFBQSxVQUNFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUE0QztBQUFBLGtCQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFEckQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBSkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBU0Y7QUFBQSxHQUFFO0FBQUEsWUFBQUMsbUJBQUE1QjtBQUFBQSxJQVlEO0FBQUE7QUFBQSxjQUNFLG9EQUF5QztBQUFBO0FBQUEsWUFBQTZCLG1CQUFBN0I7QUFBQUEsSUFFM0M7QUFBQTtBQUFBLGNBQ0Usb0RBQXlDO0FBQUE7QUFBQSxZQUFBOEIsbUJBQUE5QjtBQUFBQSxJQUUzQztBQUFBO0FBQUEsY0FDRSxvREFBeUM7QUFBQTtBQUFBLFlBQUErQixtQkFBQS9CO0FBQUFBLElBRTNDO0FBQUE7QUFBQSxjQUNFLG9EQUF5QztBQUFBO0FBQUEsWUFBQWdDLFVBQUFoQyxHQUs5Qiw4QkFBYztBQUFBLFlBQUFpQyxVQUFBakMsR0FBQWdCLE1BQ1Qsb0NBQWtCO0FBQUEsWUFBQWtCLFVBQUFsQyxHQUFBZ0IsTUFBQUM7QUFBQUEsSUFDYiwwQ0FBdUI7QUFBQTtBQUFBLFlBQUFrQixVQUFBbkMsR0FBQWdCLE1BQUFDLE1BQUFJO0FBQUFBLElBQ2xCLGdEQUE0QjtBQUFBO0FBQUE7QUFBQSxJQUFBZTtBQUFBQSxNQVUzRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUR6WkYiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNjIwMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2NvZGVzcGFjZS8ub3BhbS80LjE0LjIvbGliL29jYW1sL2luX2NoYW5uZWwubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIxIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGluX2NoYW5uZWxcblxudHlwZSBvcGVuX2ZsYWcgPSBTdGRsaWIub3Blbl9mbGFnID1cbiAgfCBPcGVuX3Jkb25seVxuICB8IE9wZW5fd3Jvbmx5XG4gIHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0XG4gIHwgT3Blbl90cnVuY1xuICB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5XG4gIHwgT3Blbl90ZXh0XG4gIHwgT3Blbl9ub25ibG9ja1xuXG5sZXQgc3RkaW4gPSBTdGRsaWIuc3RkaW5cbmxldCBvcGVuX2JpbiA9IFN0ZGxpYi5vcGVuX2luX2JpblxubGV0IG9wZW5fdGV4dCA9IFN0ZGxpYi5vcGVuX2luXG5sZXQgb3Blbl9nZW4gPSBTdGRsaWIub3Blbl9pbl9nZW5cblxubGV0IHdpdGhfb3BlbiBvcGVuZnVuIHMgZiA9XG4gIGxldCBpYyA9IG9wZW5mdW4gcyBpblxuICBGdW4ucHJvdGVjdCB+ZmluYWxseTooZnVuICgpIC0+IFN0ZGxpYi5jbG9zZV9pbl9ub2VyciBpYylcbiAgICAoZnVuICgpIC0+IGYgaWMpXG5cbmxldCB3aXRoX29wZW5fYmluIHMgZiA9XG4gIHdpdGhfb3BlbiBTdGRsaWIub3Blbl9pbl9iaW4gcyBmXG5cbmxldCB3aXRoX29wZW5fdGV4dCBzIGYgPVxuICB3aXRoX29wZW4gU3RkbGliLm9wZW5faW4gcyBmXG5cbmxldCB3aXRoX29wZW5fZ2VuIGZsYWdzIHBlcm0gcyBmID1cbiAgd2l0aF9vcGVuIChTdGRsaWIub3Blbl9pbl9nZW4gZmxhZ3MgcGVybSkgcyBmXG5cbmxldCBzZWVrID0gU3RkbGliLkxhcmdlRmlsZS5zZWVrX2luXG5sZXQgcG9zID0gU3RkbGliLkxhcmdlRmlsZS5wb3NfaW5cbmxldCBsZW5ndGggPSBTdGRsaWIuTGFyZ2VGaWxlLmluX2NoYW5uZWxfbGVuZ3RoXG5sZXQgY2xvc2UgPSBTdGRsaWIuY2xvc2VfaW5cbmxldCBjbG9zZV9ub2VyciA9IFN0ZGxpYi5jbG9zZV9pbl9ub2VyclxuXG5sZXQgaW5wdXRfY2hhciBpYyA9XG4gIG1hdGNoIFN0ZGxpYi5pbnB1dF9jaGFyIGljIHdpdGhcbiAgfCBjIC0+IFNvbWUgY1xuICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPiBOb25lXG5cbmxldCBpbnB1dF9ieXRlIGljID1cbiAgbWF0Y2ggU3RkbGliLmlucHV0X2J5dGUgaWMgd2l0aFxuICB8IG4gLT4gU29tZSBuXG4gIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+IE5vbmVcblxubGV0IGlucHV0X2xpbmUgaWMgPVxuICBtYXRjaCBTdGRsaWIuaW5wdXRfbGluZSBpYyB3aXRoXG4gIHwgcyAtPiBTb21lIHNcbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gTm9uZVxuXG5sZXQgaW5wdXQgPSBTdGRsaWIuaW5wdXRcblxubGV0IHJlYWxseV9pbnB1dCBpYyBidWYgcG9zIGxlbiA9XG4gIG1hdGNoIFN0ZGxpYi5yZWFsbHlfaW5wdXQgaWMgYnVmIHBvcyBsZW4gd2l0aFxuICB8ICgpIC0+IFNvbWUgKClcbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gTm9uZVxuXG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyBpYyBsZW4gPVxuICBtYXRjaCBTdGRsaWIucmVhbGx5X2lucHV0X3N0cmluZyBpYyBsZW4gd2l0aFxuICB8IHMgLT4gU29tZSBzXG4gIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+IE5vbmVcblxuKCogUmVhZCB1cCB0byBbbGVuXSBieXRlcyBpbnRvIFtidWZdLCBzdGFydGluZyBhdCBbb2ZzXS4gUmV0dXJuIHRvdGFsIGJ5dGVzXG4gICByZWFkLiAqKVxubGV0IHJlYWRfdXB0byBpYyBidWYgb2ZzIGxlbiA9XG4gIGxldCByZWMgbG9vcCBvZnMgbGVuID1cbiAgICBpZiBsZW4gPSAwIHRoZW4gb2ZzXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBTdGRsaWIuaW5wdXQgaWMgYnVmIG9mcyBsZW4gaW5cbiAgICAgIGlmIHIgPSAwIHRoZW5cbiAgICAgICAgb2ZzXG4gICAgICBlbHNlXG4gICAgICAgIGxvb3AgKG9mcyArIHIpIChsZW4gLSByKVxuICAgIGVuZFxuICBpblxuICBsb29wIG9mcyBsZW4gLSBvZnNcblxuKCogQmVzdCBlZmZvcnQgYXR0ZW1wdCB0byByZXR1cm4gYSBidWZmZXIgd2l0aCA+PSAob2ZzICsgbikgYnl0ZXMgb2Ygc3RvcmFnZSxcbiAgIGFuZCBzdWNoIHRoYXQgaXQgY29pbmNpZGVzIHdpdGggW2J1Zl0gYXQgaW5kaWNlcyA8IFtvZnNdLlxuXG4gICBUaGUgcmV0dXJuZWQgYnVmZmVyIGlzIGVxdWFsIHRvIFtidWZdIGl0c2VsZiBpZiBpdCBhbHJlYWR5IGhhcyBzdWZmaWNpZW50XG4gICBmcmVlIHNwYWNlLlxuXG4gICBUaGUgcmV0dXJuZWQgYnVmZmVyIG1heSBoYXZlICpmZXdlciogdGhhbiBbb2ZzICsgbl0gYnl0ZXMgb2Ygc3RvcmFnZSBpZiB0aGlzXG4gICBudW1iZXIgaXMgPiBbU3lzLm1heF9zdHJpbmdfbGVuZ3RoXS4gSG93ZXZlciB0aGUgcmV0dXJuZWQgYnVmZmVyIHdpbGxcbiAgICphbHdheXMqIGhhdmUgPiBbb2ZzXSBieXRlcyBvZiBzdG9yYWdlLiBJbiB0aGUgbGltaXRpbmcgY2FzZSB3aGVuIFtvZnMgPSBsZW5cbiAgID0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXSAoc28gdGhhdCBpdCBpcyBub3QgcG9zc2libGUgdG8gcmVzaXplIHRoZSBidWZmZXIgYXRcbiAgIGFsbCksIGFuIGV4Y2VwdGlvbiBpcyByYWlzZWQuICopXG5cbmxldCBlbnN1cmUgYnVmIG9mcyBuID1cbiAgbGV0IGxlbiA9IEJ5dGVzLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuID49IG9mcyArIG4gdGhlbiBidWZcbiAgZWxzZSBiZWdpblxuICAgIGxldCBuZXdfbGVuID0gcmVmIGxlbiBpblxuICAgIHdoaWxlICFuZXdfbGVuIDwgb2ZzICsgbiBkb1xuICAgICAgbmV3X2xlbiA6PSAyICogIW5ld19sZW4gKyAxXG4gICAgZG9uZTtcbiAgICBsZXQgbmV3X2xlbiA9ICFuZXdfbGVuIGluXG4gICAgbGV0IG5ld19sZW4gPVxuICAgICAgaWYgbmV3X2xlbiA8PSBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBuZXdfbGVuXG4gICAgICBlbHNlIGlmIG9mcyA8IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuXG4gICAgICAgIFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgICAgZWxzZVxuICAgICAgICBmYWlsd2l0aCBcIkluX2NoYW5uZWwuaW5wdXRfYWxsOiBjaGFubmVsIGNvbnRlbnQgXFxcbiAgICAgICAgICAgICAgICAgIGlzIGxhcmdlciB0aGFuIG1heGltdW0gc3RyaW5nIGxlbmd0aFwiXG4gICAgaW5cbiAgICBsZXQgbmV3X2J1ZiA9IEJ5dGVzLmNyZWF0ZSBuZXdfbGVuIGluXG4gICAgQnl0ZXMuYmxpdCBidWYgMCBuZXdfYnVmIDAgb2ZzO1xuICAgIG5ld19idWZcbiAgZW5kXG5cbmxldCBpbnB1dF9hbGwgaWMgPVxuICBsZXQgY2h1bmtfc2l6ZSA9IDY1NTM2IGluICgqIElPX0JVRkZFUl9TSVpFICopXG4gIGxldCBpbml0aWFsX3NpemUgPVxuICAgIHRyeVxuICAgICAgU3RkbGliLmluX2NoYW5uZWxfbGVuZ3RoIGljIC0gU3RkbGliLnBvc19pbiBpY1xuICAgIHdpdGggU3lzX2Vycm9yIF8gLT5cbiAgICAgIC0xXG4gIGluXG4gIGxldCBpbml0aWFsX3NpemUgPSBpZiBpbml0aWFsX3NpemUgPCAwIHRoZW4gY2h1bmtfc2l6ZSBlbHNlIGluaXRpYWxfc2l6ZSBpblxuICBsZXQgaW5pdGlhbF9zaXplID1cbiAgICBpZiBpbml0aWFsX3NpemUgPD0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW5cbiAgICAgIGluaXRpYWxfc2l6ZVxuICAgIGVsc2VcbiAgICAgIFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICBpblxuICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIGluaXRpYWxfc2l6ZSBpblxuICBsZXQgbnJlYWQgPSByZWFkX3VwdG8gaWMgYnVmIDAgaW5pdGlhbF9zaXplIGluXG4gIGlmIG5yZWFkIDwgaW5pdGlhbF9zaXplIHRoZW4gKCogRU9GIHJlYWNoZWQsIGJ1ZmZlciBwYXJ0aWFsbHkgZmlsbGVkICopXG4gICAgQnl0ZXMuc3ViX3N0cmluZyBidWYgMCBucmVhZFxuICBlbHNlIGJlZ2luICgqIG5yZWFkID0gaW5pdGlhbF9zaXplLCBtYXliZSBFT0YgcmVhY2hlZCAqKVxuICAgIG1hdGNoIFN0ZGxpYi5pbnB1dF9jaGFyIGljIHdpdGhcbiAgICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPlxuICAgICAgICAoKiBFT0YgcmVhY2hlZCwgYnVmZmVyIGlzIGNvbXBsZXRlbHkgZmlsbGVkICopXG4gICAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYnVmXG4gICAgfCBjIC0+XG4gICAgICAgICgqIEVPRiBub3QgcmVhY2hlZCAqKVxuICAgICAgICBsZXQgcmVjIGxvb3AgYnVmIG9mcyA9XG4gICAgICAgICAgbGV0IGJ1ZiA9IGVuc3VyZSBidWYgb2ZzIGNodW5rX3NpemUgaW5cbiAgICAgICAgICBsZXQgcmVtID0gQnl0ZXMubGVuZ3RoIGJ1ZiAtIG9mcyBpblxuICAgICAgICAgICgqIFtyZW1dIGNhbiBiZSA8IFtjaHVua19zaXplXSBpZiBidWZmZXIgc2l6ZSBjbG9zZSB0b1xuICAgICAgICAgICAgIFtTeXMubWF4X3N0cmluZ19sZW5ndGhdICopXG4gICAgICAgICAgbGV0IHIgPSByZWFkX3VwdG8gaWMgYnVmIG9mcyByZW0gaW5cbiAgICAgICAgICBpZiByIDwgcmVtIHRoZW4gKCogRU9GIHJlYWNoZWQgKilcbiAgICAgICAgICAgIEJ5dGVzLnN1Yl9zdHJpbmcgYnVmIDAgKG9mcyArIHIpXG4gICAgICAgICAgZWxzZSAoKiByID0gcmVtICopXG4gICAgICAgICAgICBsb29wIGJ1ZiAob2ZzICsgcmVtKVxuICAgICAgICBpblxuICAgICAgICBsZXQgYnVmID0gZW5zdXJlIGJ1ZiBucmVhZCAoY2h1bmtfc2l6ZSArIDEpIGluXG4gICAgICAgIEJ5dGVzLnNldCBidWYgbnJlYWQgYztcbiAgICAgICAgbG9vcCBidWYgKG5yZWFkICsgMSlcbiAgZW5kXG5cbmxldCBzZXRfYmluYXJ5X21vZGUgPSBTdGRsaWIuc2V0X2JpbmFyeV9tb2RlX2luXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImdsb2JhbF9kYXRhIiwiU3RkbGliX0J5dGVzIiwiU3RkbGliIiwiU3RkbGliX1N5cyIsIlN0ZGxpYl9GdW4iLCJzdGRpbiIsIm9wZW5fYmluIiwib3Blbl90ZXh0Iiwib3Blbl9nZW4iLCJ3aXRoX29wZW4iLCJvcGVuZnVuIiwicyIsImljIiwicGFyYW0iLCJ3aXRoX29wZW5fYmluIiwid2l0aF9vcGVuX3RleHQiLCJ3aXRoX29wZW5fZ2VuIiwiZmxhZ3MiLCJwZXJtIiwic2VlayIsInBvcyIsImxlbmd0aCIsImNsb3NlIiwiY2xvc2Vfbm9lcnIiLCJpbnB1dF9jaGFyIiwiYyIsImV4biIsImlucHV0X2J5dGUiLCJuIiwiaW5wdXRfbGluZSIsImlucHV0IiwiY3N0X0luX2NoYW5uZWxfaW5wdXRfYWxsX2NoYW5uIiwicmVhbGx5X2lucHV0IiwiYnVmIiwibGVuIiwicmVhbGx5X2lucHV0X3N0cmluZyIsInJlYWRfdXB0byIsIm9mcyIsInIiLCJlbnN1cmUiLCJuZXdfbGVuIiwibmV3X2J1ZiIsImlucHV0X2FsbCIsImNodW5rX3NpemUiLCJpbml0aWFsX3NpemUiLCJ0YWciLCJucmVhZCIsInJlbSIsInNldF9iaW5hcnlfbW9kZSIsIlN0ZGxpYl9Jbl9jaGFubmVsIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFD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QUFBLDhCQ3lKUSx1Q0FpQkg7QUFBQSxLRDFLTDtBQUFBO0FBQUEsUUFBQU8sUUN1S2tCO0FBQUEsSUFDVjtBQUFBLFFBQUFJLFFBQXFCLGVBQUFKLFFBQUEsT0FBQUksTUFBQTtBQUFBO0FBQUE7QUFBQSxNQUFBSixRQVhUO0FBQUEsTUFBQWMsTUFDVjtBQUFBLE1BQUFULElBR1E7QUFBQSxLQUNSLFlBQ0Usd0RBT1A7QUFBQSxTQUFBRCxRQUxPO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FLUDtBQUFBO0FBQUEsSUFBQVcsa0JEMUtMO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2NDAxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InN0ZGxpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvY29kZXNwYWNlLy5vcGFtLzQuMTQuMi9saWIvb2NhbWwvb3V0X2NoYW5uZWwubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIxIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IG91dF9jaGFubmVsXG5cbnR5cGUgb3Blbl9mbGFnID0gU3RkbGliLm9wZW5fZmxhZyA9XG4gIHwgT3Blbl9yZG9ubHlcbiAgfCBPcGVuX3dyb25seVxuICB8IE9wZW5fYXBwZW5kXG4gIHwgT3Blbl9jcmVhdFxuICB8IE9wZW5fdHJ1bmNcbiAgfCBPcGVuX2V4Y2xcbiAgfCBPcGVuX2JpbmFyeVxuICB8IE9wZW5fdGV4dFxuICB8IE9wZW5fbm9uYmxvY2tcblxubGV0IHN0ZG91dCA9IFN0ZGxpYi5zdGRvdXRcbmxldCBzdGRlcnIgPSBTdGRsaWIuc3RkZXJyXG5sZXQgb3Blbl9iaW4gPSBTdGRsaWIub3Blbl9vdXRfYmluXG5sZXQgb3Blbl90ZXh0ID0gU3RkbGliLm9wZW5fb3V0XG5sZXQgb3Blbl9nZW4gPSBTdGRsaWIub3Blbl9vdXRfZ2VuXG5cbmxldCB3aXRoX29wZW4gb3BlbmZ1biBzIGYgPVxuICBsZXQgb2MgPSBvcGVuZnVuIHMgaW5cbiAgRnVuLnByb3RlY3QgfmZpbmFsbHk6KGZ1biAoKSAtPiBTdGRsaWIuY2xvc2Vfb3V0X25vZXJyIG9jKVxuICAgIChmdW4gKCkgLT4gZiBvYylcblxubGV0IHdpdGhfb3Blbl9iaW4gcyBmID1cbiAgd2l0aF9vcGVuIFN0ZGxpYi5vcGVuX291dF9iaW4gcyBmXG5cbmxldCB3aXRoX29wZW5fdGV4dCBzIGYgPVxuICB3aXRoX29wZW4gU3RkbGliLm9wZW5fb3V0IHMgZlxuXG5sZXQgd2l0aF9vcGVuX2dlbiBmbGFncyBwZXJtIHMgZiA9XG4gIHdpdGhfb3BlbiAoU3RkbGliLm9wZW5fb3V0X2dlbiBmbGFncyBwZXJtKSBzIGZcblxubGV0IHNlZWsgPSBTdGRsaWIuTGFyZ2VGaWxlLnNlZWtfb3V0XG5sZXQgcG9zID0gU3RkbGliLkxhcmdlRmlsZS5wb3Nfb3V0XG5sZXQgbGVuZ3RoID0gU3RkbGliLkxhcmdlRmlsZS5vdXRfY2hhbm5lbF9sZW5ndGhcbmxldCBjbG9zZSA9IFN0ZGxpYi5jbG9zZV9vdXRcbmxldCBjbG9zZV9ub2VyciA9IFN0ZGxpYi5jbG9zZV9vdXRfbm9lcnJcbmxldCBmbHVzaCA9IFN0ZGxpYi5mbHVzaFxubGV0IGZsdXNoX2FsbCA9IFN0ZGxpYi5mbHVzaF9hbGxcbmxldCBvdXRwdXRfY2hhciA9IFN0ZGxpYi5vdXRwdXRfY2hhclxubGV0IG91dHB1dF9ieXRlID0gU3RkbGliLm91dHB1dF9ieXRlXG5sZXQgb3V0cHV0X3N0cmluZyA9IFN0ZGxpYi5vdXRwdXRfc3RyaW5nXG5sZXQgb3V0cHV0X2J5dGVzID0gU3RkbGliLm91dHB1dF9ieXRlc1xubGV0IG91dHB1dCA9IFN0ZGxpYi5vdXRwdXRcbmxldCBvdXRwdXRfc3Vic3RyaW5nID0gU3RkbGliLm91dHB1dF9zdWJzdHJpbmdcbmxldCBzZXRfYmluYXJ5X21vZGUgPSBTdGRsaWIuc2V0X2JpbmFyeV9tb2RlX291dFxuXG5leHRlcm5hbCBzZXRfYnVmZmVyZWQgOiB0IC0+IGJvb2wgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZXRfYnVmZmVyZWRcIlxuXG5leHRlcm5hbCBpc19idWZmZXJlZCA6IHQgLT4gYm9vbCA9IFwiY2FtbF9tbF9pc19idWZmZXJlZFwiXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsIlN0ZGxpYl9GdW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJvcGVuX2JpbiIsIm9wZW5fdGV4dCIsIm9wZW5fZ2VuIiwid2l0aF9vcGVuIiwib3BlbmZ1biIsInMiLCJvYyIsInBhcmFtIiwid2l0aF9vcGVuX2JpbiIsIndpdGhfb3Blbl90ZXh0Iiwid2l0aF9vcGVuX2dlbiIsImZsYWdzIiwicGVybSIsInNlZWsiLCJwb3MiLCJsZW5ndGgiLCJjbG9zZSIsImNsb3NlX25vZXJyIiwiZmx1c2giLCJmbHVzaF9hbGwiLCJvdXRwdXRfY2hhciIsIm91dHB1dF9ieXRlIiwib3V0cHV0X3N0cmluZyIsIm91dHB1dF9ieXRlcyIsIm91dHB1dCIsIm91dHB1dF9zdWJzdHJpbmciLCJzZXRfYmluYXJ5X21vZGUiLCJTdGRsaWJfT3V0X2NoYW5uZWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxZQUFBQyxVQUFBQyxTQUFBQyxHQUFBWjtBQUFBQSxRQUFBYSxLQ21DVztBQUFBLElBQ1Q7QUFBQTtBQUFBLHNCQUFBQyxPQUFnQyxnQ0FBeUI7QUFBQSxzQkFBQUEsT0FDNUMsd0JBQUksR0FBQztBQUFBO0FBQUEsWUFBQUMsY0FBQUgsR0FBQVosR0FHbEIsa0NBQWlDO0FBQUEsWUFBQWdCLGVBQUFKLEdBQUFaLEdBR2pDLGtDQUE2QjtBQUFBLFlBQUFpQixjQUFBQyxPQUFBQyxNQUFBUCxHQUFBWjtBQUFBQSxRQUFBLElBR25CO0FBQUEsSUFBZ0MsNkJBQWhDLGlDQUFvQztBQUFBO0FBQUE7QUFBQSxJQUFBb0IsT0Q5Q2hEO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJpZ25vcmVMaXN0IjpbMF19fV19
