// Generated by js_of_ocaml
//# buildInfo:effects=disabled, kind=cma, use-js-string=true, version=6.2.0

//# unitInfo: Provides: Poker
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Hashtbl, Stdlib__List, Stdlib__Option, Stdlib__Random, Stdlib__Seq
//# shape: Poker:[[],F(1),[],F(2),F(1),F(3),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_int_compare = runtime.caml_int_compare,
    caml_list_of_js_array = runtime.caml_list_of_js_array,
    global_data = runtime.caml_get_global_data(),
    all_ranks =
      caml_list_of_js_array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
    all_suits = [0, 0, [0, 1, [0, 2, [0, 3, 0]]]],
    Stdlib = global_data.Stdlib,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Random = global_data.Stdlib__Random;
   Stdlib_Random[3].call(null, 0);
   var
    Create_error = [0],
    Move_error = [0],
    a = [0, 0],
    b = [0, 2, [0, 3, [0, 4, [0, 5, [0, 14, 0]]]]],
    c = [0, 1, [0, 2, [0, 3, [0, 4, [0, 5, 0]]]]],
    d = [0, 0, 0],
    e = [0, 0],
    f = [0, 0],
    g = [0, 0],
    h = [1, 0],
    i = [0, 0],
    j = [0, 0],
    k = [1, 1],
    l = [1, 1],
    m = [0, 0],
    n = [1, 1],
    o = [1, 0],
    p = [0, 5];
   function rank_to_int(param){
    switch(param){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      case 3:
       return 5;
      case 4:
       return 6;
      case 5:
       return 7;
      case 6:
       return 8;
      case 7:
       return 9;
      case 8:
       return 10;
      case 9:
       return 11;
      case 10:
       return 12;
      case 11:
       return 13;
      default: return 14;
    }
   }
   function create(param){
    var
     c =
       Stdlib_List[19].call
        (null,
         function(s){
          return Stdlib_List[19].call
                  (null, function(r){return [0, r, s];}, all_ranks);
         },
         all_suits),
     lst = Stdlib_List[13].call(null, c),
     a$0 = Stdlib_Array[12].call(null, lst),
     b = a$0.length - 2 | 0;
    if(b >= 1){
     var i = b;
     for(;;){
      var
       j = Stdlib_Random[5].call(null, i + 1 | 0),
       tmp = caml_check_bound(a$0, i)[i + 1];
      a$0[i + 1] = caml_check_bound(a$0, j)[j + 1];
      a$0[j + 1] = tmp;
      var e = i - 1 | 0;
      if(1 === i) break;
      i = e;
     }
    }
    var d = Stdlib_Array[11].call(null, a$0);
    return [0, [0, d, 0, 0, 0, 0, 0, 0, a, 0]];
   }
   function eval_hand(cards){
    if(cards)
     var
      cs = cards[2],
      c$0 = cards[1],
      flush =
        Stdlib_List[32].call
         (null, function(x){return x[2] === c$0[2] ? 1 : 0;}, cs);
    else
     var flush = 0;
    var
     n =
       Stdlib_List[19].call
        (null, function(c){return rank_to_int(c[1]);}, cards),
     rs$0 = Stdlib_List[56].call(null, caml_int_compare, n),
     rs = runtime.caml_equal(rs$0, b) ? c : rs$0,
     o = Stdlib_List[9].call(null, rs),
     hi = Stdlib_List[5].call(null, o),
     d = 5 === Stdlib_List[1].call(null, rs) ? 1 : 0;
    if(d){
     var param = rs;
     for(;;){
      if(param){
       var match$0 = param[2], a = param[1];
       if(! match$0){var straight = 1; break;}
       var rest = match$0[2], b$0 = match$0[1];
       if(b$0 === (a + 1 | 0)){param = [0, b$0, rest]; continue;}
      }
      var straight = 0;
      break;
     }
    }
    else
     var straight = d;
    if(flush && straight) return [8, hi];
    var tbl = Stdlib_Hashtbl[1].call(null, 0, 16);
    Stdlib_List[17].call
     (null,
      function(c){
       var
        k = rank_to_int(c[1]),
        match = Stdlib_Hashtbl[7].call(null, tbl, k);
       if(match) var n = match[1], n$0 = n; else var n$0 = 0;
       return Stdlib_Hashtbl[11].call(null, tbl, k, 1 + n$0 | 0);
      },
      cards);
    var
     pairs =
       Stdlib_Hashtbl[14].call
        (null, function(k, v, acc){return [0, [0, k, v], acc];}, tbl, 0),
     match =
       Stdlib_List[56].call
        (null,
         function(param, a){
          var
           v2 = a[2],
           k2 = a[1],
           v1 = param[2],
           k1 = param[1],
           c = caml_int_compare(v2, v1);
          return 0 === c ? caml_int_compare(k2, k1) : c;
         },
         pairs);
    if(match){
     var e = match[1], f = e[2], k = e[1];
     if(3 === f){
      var g = match[2];
      if(g){var h = g[1]; if(2 === h[2]){var k2 = h[1]; return [6, k, k2];}}
     }
     else if(4 === f){
      var l = match[2];
      if(l){
       var m = l[1];
       if(1 === m[2]){var k2$1 = m[1]; return [7, k, k2$1];}
      }
     }
    }
    if(flush){
     var
      p =
        Stdlib_List[19].call
         (null, function(c){return rank_to_int(c[1]);}, cards),
      q = Stdlib_List[56].call(null, caml_int_compare, p),
      ks = Stdlib_List[9].call(null, q);
     return [5, ks];
    }
    if(straight) return [4, hi];
    if(match){
     var i = match[1], match$1 = i[2], k3 = i[1];
     if(2 === match$1){
      var rest$0 = match[2];
      if(rest$0){
       var j = rest$0[1];
       if(2 === j[2]){
        var
         rest$1 = rest$0[2],
         k2$0 = j[1],
         hi$0 = Stdlib[17].call(null, k3, k2$0),
         lo = Stdlib[16].call(null, k3, k2$0);
        if(rest$1) var k$0 = rest$1[1][1], kicker = k$0; else var kicker = 0;
        return [2, hi$0, lo, kicker];
       }
      }
      var
       t = Stdlib_List[19].call(null, function(a){return a[1];}, rest$0),
       u = Stdlib_List[56].call(null, caml_int_compare, t),
       kickers = Stdlib_List[9].call(null, u);
      return [1, k3, kickers];
     }
     if(3 === match$1){
      var
       rest$2 = match[2],
       r = Stdlib_List[19].call(null, function(a){return a[1];}, rest$2),
       s = Stdlib_List[56].call(null, caml_int_compare, r),
       kickers$0 = Stdlib_List[9].call(null, s);
      return [3, k3, kickers$0];
     }
    }
    var
     v =
       Stdlib_List[19].call
        (null, function(c){return rank_to_int(c[1]);}, cards),
     w = Stdlib_List[56].call(null, caml_int_compare, v),
     ks$0 = Stdlib_List[9].call(null, w);
    return [0, ks$0];
   }
   function compare_lists(xs, ys){
    var a = xs, b = ys;
    for(;;){
     if(a){
      if(b){
       var
        by = b[2],
        y = b[1],
        ax = a[2],
        x = a[1],
        c = runtime.caml_compare(x, y);
       if(0 !== c) return c;
       a = ax;
       b = by;
       continue;
      }
     }
     else if(! b) return 0;
     return 0;
    }
   }
   function compare_5(h1, h2){
    var r1 = eval_hand(h1), r2 = eval_hand(h2);
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           switch(r1[0]){
             case 0:
              var xs = r1[1];
              switch(r2[0]){
                case 0:
                 var ys = r2[1], ord = compare_lists(xs, ys); break a;
                case 1:
                 var ord = -1; break a;
                case 8:
                 break b;
                case 7:
                 break c;
                case 6:
                 break d;
                case 5:
                 break e;
                case 4:
                 break f;
                case 3:
                 break g;
              }
              break;
             case 1:
              var kx = r1[2], p1 = r1[1];
              switch(r2[0]){
                case 0:
                 var ord = 1; break a;
                case 1:
                 var ky = r2[2], p2 = r2[1], c = caml_int_compare(p1, p2);
                 if(0 === c){var ord = compare_lists(kx, ky); break a;}
                 var ord = c;
                 break a;
                case 8:
                 break b;
                case 7:
                 break c;
                case 6:
                 break d;
                case 5:
                 break e;
                case 4:
                 break f;
                case 3:
                 break g;
              }
              break;
             case 2:
              var k1 = r1[3], b1 = r1[2], a1 = r1[1];
              switch(r2[0]){
                case 2:
                 var
                  k2 = r2[3],
                  b2 = r2[2],
                  a2 = r2[1],
                  c$0 = caml_int_compare(a1, a2);
                 if(0 !== c$0){var ord = c$0; break a;}
                 var d = caml_int_compare(b1, b2);
                 if(0 === d){var ord = caml_int_compare(k1, k2); break a;}
                 var ord = d;
                 break a;
                case 8:
                 break b;
                case 7:
                 break c;
                case 6:
                 break d;
                case 5:
                 break e;
                case 4:
                 break f;
                case 3:
                 break g;
                default: var ord = 1; break a;
              }
             case 3:
              var kx$0 = r1[2], a = r1[1];
              switch(r2[0]){
                case 3:
                 var ky$0 = r2[2], b = r2[1], c$1 = caml_int_compare(a, b);
                 if(0 === c$1){var ord = compare_lists(kx$0, ky$0); break a;}
                 var ord = c$1;
                 break a;
                case 8:
                 break b;
                case 7:
                 break c;
                case 6:
                 break d;
                case 5:
                 break e;
                case 4:
                 break f;
                default: var ord = 1; break a;
              }
             case 4:
              var a$0 = r1[1];
              switch(r2[0]){
                case 4:
                 var b$0 = r2[1], ord = caml_int_compare(a$0, b$0); break a;
                case 8:
                 break b;
                case 7:
                 break c;
                case 6:
                 break d;
                case 5:
                 break e;
                default: var ord = 1; break a;
              }
             case 5:
              var xs$0 = r1[1];
              switch(r2[0]){
                case 5:
                 var ys$0 = r2[1], ord = compare_lists(xs$0, ys$0); break a;
                case 8:
                 break b;
                case 7:
                 break c;
                case 6:
                 break d;
                default: var ord = 1; break a;
              }
             case 6:
              var b1$0 = r1[2], a1$0 = r1[1];
              switch(r2[0]){
                case 6:
                 var
                  b2$0 = r2[2],
                  a2$0 = r2[1],
                  c$2 = caml_int_compare(a1$0, a2$0);
                 if(0 === c$2){
                  var ord = caml_int_compare(b1$0, b2$0);
                  break a;
                 }
                 var ord = c$2;
                 break a;
                case 8:
                 break b;
                case 7:
                 break c;
                default: var ord = 1; break a;
              }
             case 7:
              var ka = r1[2], a$1 = r1[1];
              switch(r2[0]){
                case 7:
                 var
                  kb = r2[2],
                  b$1 = r2[1],
                  c$3 = caml_int_compare(a$1, b$1);
                 if(0 === c$3){var ord = caml_int_compare(ka, kb); break a;}
                 var ord = c$3;
                 break a;
                case 8:
                 break b;
                default: var ord = 1; break a;
              }
             default:
              var a$2 = r1[1];
              if(8 === r2[0]){
               var b$2 = r2[1], ord = caml_int_compare(a$2, b$2);
               break a;
              }
              var ord = 1;
              break a;
           }
           var ord = -1;
           break a;
          }
          var ord = -1;
          break a;
         }
         var ord = -1;
         break a;
        }
        var ord = -1;
        break a;
       }
       var ord = -1;
       break a;
      }
      var ord = -1;
      break a;
     }
     var ord = -1;
    }
    return ord;
   }
   function combos_5(lst){
    function choose(k, xs){
     if(0 === k) return d;
     if(! xs) return 0;
     var
      xt = xs[2],
      x = xs[1],
      a = choose(k - 1 | 0, xt),
      with_x =
        Stdlib_List[19].call(null, function(rest){return [0, x, rest];}, a),
      without_x = choose(k, xt);
     return Stdlib[37].call(null, with_x, without_x);
    }
    return choose(5, lst);
   }
   function compare_holes_with_board(h1, h2, board){
    var
     pool1 = Stdlib[37].call(null, h1, board),
     pool2 = Stdlib[37].call(null, h2, board),
     a = combos_5(pool1),
     c =
       Stdlib_List[25].call
        (null,
         function(acc, cand){
          if(! acc) return [0, cand];
          var cur = acc[1];
          return 0 < compare_5(cand, cur) ? [0, cand] : acc;
         },
         0,
         a),
     best1 = Stdlib_Option[4].call(null, c),
     b = combos_5(pool2),
     d =
       Stdlib_List[25].call
        (null,
         function(acc, cand){
          if(! acc) return [0, cand];
          var cur = acc[1];
          return 0 < compare_5(cand, cur) ? [0, cand] : acc;
         },
         0,
         b),
     best2 = Stdlib_Option[4].call(null, d);
    return compare_5(best1, best2);
   }
   function draw_n(n, deck){
    var k = n, d = deck, acc = 0;
    for(;;){
     if(0 === k) return [0, Stdlib_List[9].call(null, acc), d];
     if(! d) return [0, Stdlib_List[9].call(null, acc), 0];
     var xs = d[2], x = d[1], acc$0 = [0, x, acc], k$0 = k - 1 | 0;
     k = k$0;
     d = xs;
     acc = acc$0;
    }
   }
   function to_other(param){return param ? 0 : 1;}
   function advance_street(st){
    switch(st[7]){
      case 1:
       var match = draw_n(3, st[1]), d1 = match[2], flop = match[1];
       return [0, d1, st[2], st[3], flop, st[5], 0, 2, e, 0];
      case 2:
       var
        match$0 = draw_n(1, st[1]),
        d1$0 = match$0[2],
        t = match$0[1],
        a = st[5],
        b = Stdlib[37].call(null, st[4], t);
       return [0, d1$0, st[2], st[3], b, a, 0, 3, f, 0];
      case 3:
       var
        match$1 = draw_n(1, st[1]),
        d1$1 = match$1[2],
        r = match$1[1],
        c = st[5],
        d = Stdlib[37].call(null, st[4], r);
       return [0, d1$1, st[2], st[3], d, c, 0, 4, g, 0];
      case 4:
       return [0, st[1], st[2], st[3], st[4], st[5], st[6], 5, st[8], st[9]];
      default: return st;
    }
   }
   function showdown(st){
    var
     c = compare_holes_with_board(st[2], st[3], st[4]),
     winner = 0 < c ? 0 : 0 <= c ? 0 : 1;
    return [0,
            st[1],
            st[2],
            st[3],
            st[4],
            st[5],
            st[6],
            6,
            [1, winner],
            st[9]];
   }
   function make_move(st, mv){
    var match$1 = st[8];
    if(typeof match$1 !== "number" && 0 === match$1[0]){
     var whose_turn = match$1[1];
     switch(st[7]){
       case 0:
        var
         match = draw_n(2, st[1]),
         d1 = match[2],
         p1h = match[1],
         match$0 = draw_n(2, d1),
         d2 = match$0[2],
         p2h = match$0[1];
        return [0, [0, d2, p1h, p2h, st[4], 0, 0, 1, i, 0]];
       case 5:
        return [0, showdown(st)];
       case 6:
        return o;
       default:
        if(typeof mv === "number")
         switch(mv){
           case 0:
            var winner = to_other(whose_turn);
            return [0,
                    [0,
                     st[1],
                     st[2],
                     st[3],
                     st[4],
                     st[5],
                     st[6],
                     6,
                     [1, winner],
                     st[9]]];
           case 1:
            if(0 !== st[6]) return k;
            if(st[9]){
             var st$0 = advance_street(st);
             return 5 === st$0[7]
                     ? [0, showdown(st$0)]
                     : [0,
                       [0,
                        st$0[1],
                        st$0[2],
                        st$0[3],
                        st$0[4],
                        st$0[5],
                        st$0[6],
                        st$0[7],
                        j,
                        0]];
            }
            var a = [0, to_other(whose_turn)];
            return [0,
                    [0, st[1], st[2], st[3], st[4], st[5], st[6], st[7], a, 1]];
           default:
            if(0 === st[6]) return l;
            var
             st$1 =
               [0,
                st[1],
                st[2],
                st[3],
                st[4],
                st[5] + st[6] | 0,
                0,
                st[7],
                st[8],
                st[9]],
             st$2 = advance_street(st$1);
            return 5 === st$2[7]
                    ? [0, showdown(st$2)]
                    : [0,
                      [0,
                       st$2[1],
                       st$2[2],
                       st$2[3],
                       st$2[4],
                       st$2[5],
                       st$2[6],
                       st$2[7],
                       m,
                       0]];
         }
        var n$0 = mv[1];
        if(0 < n$0 && 0 === st[6]){
         var b = [0, to_other(whose_turn)];
         return [0,
                 [0,
                  st[1],
                  st[2],
                  st[3],
                  st[4],
                  st[5] + n$0 | 0,
                  n$0,
                  st[7],
                  b,
                  0]];
        }
        return n;
     }
    }
    return h;
   }
   function has_pair(cards){
    var tbl = Stdlib_Hashtbl[1].call(null, 0, 8);
    Stdlib_List[17].call
     (null,
      function(c){
       var
        k = rank_to_int(c[1]),
        match = Stdlib_Hashtbl[7].call(null, tbl, k);
       if(match) var n = match[1], n$0 = n; else var n$0 = 0;
       return Stdlib_Hashtbl[11].call(null, tbl, k, 1 + n$0 | 0);
      },
      cards);
    var a = Stdlib_Hashtbl[20].call(null, tbl);
    return Stdlib_Seq[9].call
            (null,
             function(param){var v = param[2]; return 2 <= v ? 1 : 0;},
             a);
   }
   function choose_move(st){
    if(3 < st[7] - 1 >>> 0) return 1;
    if(0 === st[6]){
     var a = st[8];
     a:
     {
      if(typeof a !== "number" && 0 === a[0] && ! a[1]){var my = st[2]; break a;}
      var my = st[3];
     }
     return has_pair(Stdlib[37].call(null, my, st[4])) ? p : 1;
    }
    var b = st[8];
    a:
    {
     if(typeof b !== "number" && 0 === b[0] && ! b[1]){var my$0 = st[2]; break a;}
     var my$0 = st[3];
    }
    return has_pair(Stdlib[37].call(null, my$0, st[4])) ? 2 : 0;
   }
   var
    Poker =
      [0,
       Create_error,
       create,
       Move_error,
       make_move,
       eval_hand,
       compare_holes_with_board,
       choose_move];
   runtime.caml_register_global(25, Poker, "Poker");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLnBva2VyLm9ianMvanNvby9kZWZhdWx0L3Bva2VyLmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6MTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLnBva2VyLm9ianMvanNvby9kZWZhdWx0L3Bva2VyLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvd29ya3NwYWNlX3Jvb3QvbGliL3Bva2VyLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwibGV0ICgpID0gUmFuZG9tLnNlbGZfaW5pdCAoKVxuXG50eXBlIHJhbmsgPSBUd298VGhyZWV8Rm91cnxGaXZlfFNpeHxTZXZlbnxFaWdodHxOaW5lfFRlbnxKYWNrfFF1ZWVufEtpbmd8QWNlXG50eXBlIHN1aXQgPSBDbHVic3xEaWFtb25kc3xIZWFydHN8U3BhZGVzXG50eXBlIGNhcmQgPSB7IHJhbms6IHJhbms7IHN1aXQ6IHN1aXQgfVxuXG50eXBlIHBsYXllciA9IFAxIHwgUDJcblxudHlwZSBzdGFnZSA9IFByZWRlYWwgfCBQcmVmbG9wIHwgRmxvcCB8IFR1cm4gfCBSaXZlciB8IFNob3dkb3duIHwgRmluaXNoZWRcblxudHlwZSBkZWNpc2lvbiA9XG4gIHwgSW5fcHJvZ3Jlc3Mgb2YgeyB3aG9zZV90dXJuOiBwbGF5ZXIgfVxuICB8IFdpbm5lciBvZiBwbGF5ZXJcbiAgfCBTdGFsZW1hdGVcblxudHlwZSBtb3ZlID0gRm9sZCB8IENoZWNrIHwgQ2FsbCB8IEJldCBvZiBpbnRcblxudHlwZSB0ID0ge1xuICBkZWNrOiBjYXJkIGxpc3Q7XG4gIHAxOiBjYXJkIGxpc3Q7XG4gIHAyOiBjYXJkIGxpc3Q7XG4gIGJvYXJkOiBjYXJkIGxpc3Q7XG4gIHBvdDogaW50O1xuICB0b19jYWxsOiBpbnQ7XG4gIHN0YWdlOiBzdGFnZTtcbiAgZGVjaXNpb246IGRlY2lzaW9uO1xuICBsYXN0X2NoZWNrOiBib29sO1xufVxuXG5tb2R1bGUgQ3JlYXRlX2Vycm9yID0gc3RydWN0XG4gIHR5cGUgdCA9IHwgSW52YWxpZF9kZWNrXG5lbmRcblxubW9kdWxlIE1vdmVfZXJyb3IgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gfCBHYW1lX292ZXIgfCBJbGxlZ2FsX21vdmVcbmVuZFxuXG5sZXQgYWxsX3JhbmtzID0gW1R3bztUaHJlZTtGb3VyO0ZpdmU7U2l4O1NldmVuO0VpZ2h0O05pbmU7VGVuO0phY2s7UXVlZW47S2luZztBY2VdXG5sZXQgYWxsX3N1aXRzID0gW0NsdWJzO0RpYW1vbmRzO0hlYXJ0cztTcGFkZXNdXG5cbmxldCByYW5rX3RvX2ludCA9IGZ1bmN0aW9uXG4gIHwgVHdvLT4yIHwgVGhyZWUtPjMgfCBGb3VyLT40IHwgRml2ZS0+NSB8IFNpeC0+NiB8IFNldmVuLT43IHwgRWlnaHQtPjhcbiAgfCBOaW5lLT45IHwgVGVuLT4xMCB8IEphY2stPjExIHwgUXVlZW4tPjEyIHwgS2luZy0+MTMgfCBBY2UtPjE0XG5cbmxldCBidWlsZF9kZWNrICgpID1cbiAgTGlzdC5jb25jYXQgKExpc3QubWFwIChmdW4gcyAtPlxuICAgIExpc3QubWFwIChmdW4gciAtPiB7cmFuaz1yOyBzdWl0PXN9KSBhbGxfcmFua3MpIGFsbF9zdWl0cylcblxubGV0IHNodWZmbGUgbHN0ID1cbiAgbGV0IGEgPSBBcnJheS5vZl9saXN0IGxzdCBpblxuICBmb3IgaSA9IEFycmF5Lmxlbmd0aCBhIC0gMSBkb3dudG8gMSBkb1xuICAgIGxldCBqID0gUmFuZG9tLmludCAoaSsxKSBpblxuICAgIGxldCB0bXAgPSBhLihpKSBpblxuICAgIGEuKGkpIDwtIGEuKGopOyBhLihqKSA8LSB0bXBcbiAgZG9uZTtcbiAgQXJyYXkudG9fbGlzdCBhXG5cbmxldCBjcmVhdGUgKCkgPVxuICBsZXQgZCA9IHNodWZmbGUgKGJ1aWxkX2RlY2sgKCkpIGluXG4gIE9rIHtcbiAgICBkZWNrID0gZDsgcDEgPSBbXTsgcDIgPSBbXTsgYm9hcmQgPSBbXTtcbiAgICBwb3QgPSAwOyB0b19jYWxsID0gMDtcbiAgICBzdGFnZSA9IFByZWRlYWw7IGRlY2lzaW9uID0gSW5fcHJvZ3Jlc3MgeyB3aG9zZV90dXJuID0gUDEgfTtcbiAgICBsYXN0X2NoZWNrID0gZmFsc2U7XG4gIH1cblxuKCogLS0tLS0tLS0gNS1jYXJkIGhhbmQgcmFua2luZyAtLS0tLS0tLSAqKVxudHlwZSBoYW5kX3JhbmsgPVxuICB8IEhpZ2hfY2FyZCBvZiBpbnQgbGlzdFxuICB8IFBhaXIgb2YgaW50ICogaW50IGxpc3RcbiAgfCBUd29fcGFpciBvZiBpbnQgKiBpbnQgKiBpbnRcbiAgfCBUaHJlZV9raW5kIG9mIGludCAqIGludCBsaXN0XG4gIHwgU3RyYWlnaHQgb2YgaW50XG4gIHwgRmx1c2ggb2YgaW50IGxpc3RcbiAgfCBGdWxsX2hvdXNlIG9mIGludCAqIGludFxuICB8IEZvdXJfa2luZCBvZiBpbnQgKiBpbnRcbiAgfCBTdHJhaWdodF9mbHVzaCBvZiBpbnRcblxubGV0IGNvdW50c19ieV9yYW5rIGNhcmRzID1cbiAgbGV0IHRibCA9IEhhc2h0YmwuY3JlYXRlIDE2IGluXG4gIExpc3QuaXRlciAoZnVuIGMgLT5cbiAgICBsZXQgayA9IHJhbmtfdG9faW50IGMucmFuayBpblxuICAgIEhhc2h0YmwucmVwbGFjZSB0YmwgayAoMSArIChtYXRjaCBIYXNodGJsLmZpbmRfb3B0IHRibCBrIHdpdGggU29tZSBuLT5uIHwgTm9uZS0+MCkpXG4gICkgY2FyZHM7XG4gIGxldCBwYWlycyA9IEhhc2h0YmwuZm9sZCAoZnVuIGsgdiBhY2MgLT4gKGssdik6OmFjYykgdGJsIFtdIGluXG4gIExpc3Quc29ydCAoZnVuIChrMSx2MSkgKGsyLHYyKSAtPlxuICAgIGxldCBjID0gY29tcGFyZSB2MiB2MSBpbiBpZiBjPD4wIHRoZW4gYyBlbHNlIGNvbXBhcmUgazIgazEpIHBhaXJzXG5cbmxldCBpc19mbHVzaCBjYXJkcyA9XG4gIG1hdGNoIGNhcmRzIHdpdGhcbiAgfCBbXSAtPiBmYWxzZVxuICB8IGM6OmNzIC0+IExpc3QuZm9yX2FsbCAoZnVuIHggLT4geC5zdWl0ID0gYy5zdWl0KSBjc1xuXG5sZXQgaXNfc3RyYWlnaHQgY2FyZHMgPVxuICBsZXQgcnMgPSBMaXN0Lm1hcCAoZnVuIGMgLT4gcmFua190b19pbnQgYy5yYW5rKSBjYXJkcyB8PiBMaXN0LnNvcnQgY29tcGFyZSBpblxuICAoKiB3aGVlbDogQTIzNDUgKilcbiAgbGV0IHJzID0gaWYgcnMgPSBbMjszOzQ7NTsxNF0gdGhlbiBbMTsyOzM7NDs1XSBlbHNlIHJzIGluXG4gIGxldCByZWMgYXV4ID0gZnVuY3Rpb25cbiAgICB8IGE6OmI6OnJlc3Qgd2hlbiBiID0gYSsxIC0+IGF1eCAoYjo6cmVzdClcbiAgICB8IFtfXSAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG4gIGluXG4gIChMaXN0Lmxlbmd0aCBycyA9IDUpICYmIGF1eCBycywgTGlzdC5oZCAoTGlzdC5yZXYgcnMpXG5cbmxldCBldmFsX2hhbmQgY2FyZHMgPVxuICBsZXQgZmx1c2ggPSBpc19mbHVzaCBjYXJkcyBpblxuICBsZXQgc3RyYWlnaHQsIGhpID0gaXNfc3RyYWlnaHQgY2FyZHMgaW5cbiAgaWYgZmx1c2ggJiYgc3RyYWlnaHQgdGhlbiBTdHJhaWdodF9mbHVzaCBoaVxuICBlbHNlXG4gICAgbWF0Y2ggY291bnRzX2J5X3JhbmsgY2FyZHMgd2l0aFxuICAgIHwgKGssNCk6OihrMiwxKTo6XyAtPiBGb3VyX2tpbmQgKGssIGsyKVxuICAgIHwgKGszLDMpOjooazIsMik6Ol8gLT4gRnVsbF9ob3VzZSAoazMsazIpXG4gICAgfCBfIHdoZW4gZmx1c2ggLT5cbiAgICAgICAgbGV0IGtzID0gY2FyZHMgfD4gTGlzdC5tYXAgKGZ1biBjIC0+IHJhbmtfdG9faW50IGMucmFuaylcbiAgICAgICAgICAgICAgICAgICAgICAgfD4gTGlzdC5zb3J0IGNvbXBhcmUgfD4gTGlzdC5yZXYgaW5cbiAgICAgICAgRmx1c2gga3NcbiAgICB8IF8gd2hlbiBzdHJhaWdodCAtPiBTdHJhaWdodCBoaVxuICAgIHwgKGszLDMpOjpyZXN0IC0+XG4gICAgICAgIGxldCBraWNrZXJzID0gcmVzdCB8PiBMaXN0Lm1hcCBmc3QgfD4gTGlzdC5zb3J0IGNvbXBhcmUgfD4gTGlzdC5yZXYgaW5cbiAgICAgICAgVGhyZWVfa2luZCAoazMsIGtpY2tlcnMpXG4gICAgfCAoazEsMik6OihrMiwyKTo6cmVzdCAtPlxuICAgICAgICBsZXQgaGkgPSBtYXggazEgazIgYW5kIGxvID0gbWluIGsxIGsyIGluXG4gICAgICAgIGxldCBraWNrZXIgPSBtYXRjaCByZXN0IHdpdGggKGssXyk6Ol8gLT4gayB8IF8gLT4gMCBpblxuICAgICAgICBUd29fcGFpciAoaGksIGxvLCBraWNrZXIpXG4gICAgfCAoazEsMik6OnJlc3QgLT5cbiAgICAgICAgbGV0IGtpY2tlcnMgPSByZXN0IHw+IExpc3QubWFwIGZzdCB8PiBMaXN0LnNvcnQgY29tcGFyZSB8PiBMaXN0LnJldiBpblxuICAgICAgICBQYWlyIChrMSwga2lja2VycylcbiAgICB8IF8gLT5cbiAgICAgICAgbGV0IGtzID0gY2FyZHMgfD4gTGlzdC5tYXAgKGZ1biBjIC0+IHJhbmtfdG9faW50IGMucmFuaylcbiAgICAgICAgICAgICAgICAgICAgICAgfD4gTGlzdC5zb3J0IGNvbXBhcmUgfD4gTGlzdC5yZXYgaW5cbiAgICAgICAgSGlnaF9jYXJkIGtzXG5cbmxldCBjb21wYXJlX2xpc3RzIHhzIHlzID1cbiAgbGV0IHJlYyBnbyBhIGIgPVxuICAgIG1hdGNoIGEsYiB3aXRoXG4gICAgfCBbXSxbXSAtPiAwXG4gICAgfCB4OjpheCwgeTo6YnkgLT4gbGV0IGMgPSBjb21wYXJlIHggeSBpbiBpZiBjPD4wIHRoZW4gYyBlbHNlIGdvIGF4IGJ5XG4gICAgfCBfIC0+IDBcbiAgaW4gZ28geHMgeXNcblxubGV0IGNvbXBhcmVfNSBoMSBoMiA9XG4gIGxldCByMSA9IGV2YWxfaGFuZCBoMSBhbmQgcjIgPSBldmFsX2hhbmQgaDIgaW5cbiAgbGV0IG9yZCA9IG1hdGNoIHIxLCByMiB3aXRoXG4gIHwgU3RyYWlnaHRfZmx1c2ggYSwgU3RyYWlnaHRfZmx1c2ggYiAtPiBjb21wYXJlIGEgYlxuICB8IEZvdXJfa2luZCAoYSxrYSksIEZvdXJfa2luZCAoYixrYikgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZSBhIGIgaW4gaWYgYzw+MCB0aGVuIGMgZWxzZSBjb21wYXJlIGthIGtiXG4gIHwgRnVsbF9ob3VzZSAoYTEsYjEpLCBGdWxsX2hvdXNlIChhMixiMikgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZSBhMSBhMiBpbiBpZiBjPD4wIHRoZW4gYyBlbHNlIGNvbXBhcmUgYjEgYjJcbiAgfCBGbHVzaCB4cywgRmx1c2ggeXMgLT4gY29tcGFyZV9saXN0cyB4cyB5c1xuICB8IFN0cmFpZ2h0IGEsIFN0cmFpZ2h0IGIgLT4gY29tcGFyZSBhIGJcbiAgfCBUaHJlZV9raW5kIChhLGt4KSwgVGhyZWVfa2luZCAoYixreSkgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZSBhIGIgaW4gaWYgYzw+MCB0aGVuIGMgZWxzZSBjb21wYXJlX2xpc3RzIGt4IGt5XG4gIHwgVHdvX3BhaXIgKGExLGIxLGsxKSwgVHdvX3BhaXIgKGEyLGIyLGsyKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlIGExIGEyIGluIGlmIGM8PjAgdGhlbiBjIGVsc2VcbiAgICAgIGxldCBkID0gY29tcGFyZSBiMSBiMiBpbiBpZiBkPD4wIHRoZW4gZCBlbHNlIGNvbXBhcmUgazEgazJcbiAgfCBQYWlyIChwMSxreCksIFBhaXIgKHAyLGt5KSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlIHAxIHAyIGluIGlmIGM8PjAgdGhlbiBjIGVsc2UgY29tcGFyZV9saXN0cyBreCBreVxuICB8IEhpZ2hfY2FyZCB4cywgSGlnaF9jYXJkIHlzIC0+IGNvbXBhcmVfbGlzdHMgeHMgeXNcbiAgfCBTdHJhaWdodF9mbHVzaCBfLCBfIC0+IDFcbiAgfCBfLCBTdHJhaWdodF9mbHVzaCBfIC0+IC0xXG4gIHwgRm91cl9raW5kIF8sIF8gLT4gMVxuICB8IF8sIEZvdXJfa2luZCBfIC0+IC0xXG4gIHwgRnVsbF9ob3VzZSBfLCBfIC0+IDFcbiAgfCBfLCBGdWxsX2hvdXNlIF8gLT4gLTFcbiAgfCBGbHVzaCBfLCBfIC0+IDFcbiAgfCBfLCBGbHVzaCBfIC0+IC0xXG4gIHwgU3RyYWlnaHQgXywgXyAtPiAxXG4gIHwgXywgU3RyYWlnaHQgXyAtPiAtMVxuICB8IFRocmVlX2tpbmQgXywgXyAtPiAxXG4gIHwgXywgVGhyZWVfa2luZCBfIC0+IC0xXG4gIHwgVHdvX3BhaXIgXywgXyAtPiAxXG4gIHwgXywgVHdvX3BhaXIgXyAtPiAtMVxuICB8IFBhaXIgXywgXyAtPiAxXG4gIHwgXywgUGFpciBfIC0+IC0xXG4gIGluXG4gIG9yZFxuXG4oKiBjaG9vc2UgYmVzdCA1IG91dCBvZiB1cCB0byA3IGNhcmRzICopXG5sZXQgY29tYm9zXzUgbHN0ID1cbiAgbGV0IHJlYyBjaG9vc2UgayB4cyA9XG4gICAgbWF0Y2ggaywgeHMgd2l0aFxuICAgIHwgMCwgXyAtPiBbIFtdIF1cbiAgICB8IF8sIFtdIC0+IFtdXG4gICAgfCBrLCB4Ojp4dCAtPlxuICAgICAgICBsZXQgd2l0aF94ID0gTGlzdC5tYXAgKGZ1biByZXN0IC0+IHg6OnJlc3QpIChjaG9vc2UgKGstMSkgeHQpIGluXG4gICAgICAgIGxldCB3aXRob3V0X3ggPSBjaG9vc2UgayB4dCBpblxuICAgICAgICB3aXRoX3ggQCB3aXRob3V0X3hcbiAgaW5cbiAgY2hvb3NlIDUgbHN0XG5cbmxldCBjb21wYXJlX2hvbGVzX3dpdGhfYm9hcmQgaDEgaDIgYm9hcmQgPVxuICBsZXQgcG9vbDEgPSBoMSBAIGJvYXJkIGluXG4gIGxldCBwb29sMiA9IGgyIEAgYm9hcmQgaW5cbiAgbGV0IGJlc3QxID1cbiAgICBjb21ib3NfNSBwb29sMSB8PiBMaXN0LmZvbGRfbGVmdCAoZnVuIGFjYyBjYW5kIC0+XG4gICAgICBtYXRjaCBhY2Mgd2l0aCBOb25lIC0+IFNvbWUgY2FuZFxuICAgICAgfCBTb21lIGN1ciAtPiBpZiBjb21wYXJlXzUgY2FuZCBjdXIgPiAwIHRoZW4gU29tZSBjYW5kIGVsc2UgYWNjXG4gICAgKSBOb25lIHw+IE9wdGlvbi5nZXRcbiAgaW5cbiAgbGV0IGJlc3QyID1cbiAgICBjb21ib3NfNSBwb29sMiB8PiBMaXN0LmZvbGRfbGVmdCAoZnVuIGFjYyBjYW5kIC0+XG4gICAgICBtYXRjaCBhY2Mgd2l0aCBOb25lIC0+IFNvbWUgY2FuZFxuICAgICAgfCBTb21lIGN1ciAtPiBpZiBjb21wYXJlXzUgY2FuZCBjdXIgPiAwIHRoZW4gU29tZSBjYW5kIGVsc2UgYWNjXG4gICAgKSBOb25lIHw+IE9wdGlvbi5nZXRcbiAgaW5cbiAgY29tcGFyZV81IGJlc3QxIGJlc3QyXG5cbmxldCBkcmF3X24gbiBkZWNrID1cbiAgbGV0IHJlYyB0YWtlIGsgZCBhY2MgPVxuICAgIGlmIGs9MCB0aGVuIChMaXN0LnJldiBhY2MsIGQpXG4gICAgZWxzZSBtYXRjaCBkIHdpdGhcbiAgICAgIHwgeDo6eHMgLT4gdGFrZSAoay0xKSB4cyAoeDo6YWNjKVxuICAgICAgfCBbXSAtPiAoTGlzdC5yZXYgYWNjLCBbXSlcbiAgaW4gdGFrZSBuIGRlY2sgW11cblxubGV0IHRvX290aGVyID0gZnVuY3Rpb24gUDEgLT4gUDIgfCBQMiAtPiBQMVxuXG5sZXQgZGVhbF9ob2xlcyBzdCA9XG4gIGxldCAocDFoLCBkMSkgPSBkcmF3X24gMiBzdC5kZWNrIGluXG4gIGxldCAocDJoLCBkMikgPSBkcmF3X24gMiBkMSBpblxuICB7IHN0IHdpdGggZGVjayA9IGQyOyBwMSA9IHAxaDsgcDIgPSBwMmggfVxuXG5sZXQgcmV2ZWFsX2Zsb3Agc3QgPVxuICBsZXQgKGZsb3AsIGQxKSA9IGRyYXdfbiAzIHN0LmRlY2sgaW5cbiAgeyBzdCB3aXRoIGRlY2sgPSBkMTsgYm9hcmQgPSBmbG9wIH1cblxubGV0IHJldmVhbF90dXJuIHN0ID1cbiAgbGV0ICh0LCBkMSkgPSBkcmF3X24gMSBzdC5kZWNrIGluXG4gIHsgc3Qgd2l0aCBkZWNrID0gZDE7IGJvYXJkID0gc3QuYm9hcmQgQCB0IH1cblxubGV0IHJldmVhbF9yaXZlciBzdCA9XG4gIGxldCAociwgZDEpID0gZHJhd19uIDEgc3QuZGVjayBpblxuICB7IHN0IHdpdGggZGVjayA9IGQxOyBib2FyZCA9IHN0LmJvYXJkIEAgciB9XG5cbmxldCBhZHZhbmNlX3N0cmVldCBzdCA9XG4gIG1hdGNoIHN0LnN0YWdlIHdpdGhcbiAgfCBQcmVmbG9wIC0+XG4gICAgICBsZXQgc3QgPSByZXZlYWxfZmxvcCBzdCBpblxuICAgICAgeyBzdCB3aXRoIHN0YWdlID0gRmxvcDsgdG9fY2FsbCA9IDA7IGxhc3RfY2hlY2sgPSBmYWxzZTsgZGVjaXNpb24gPSBJbl9wcm9ncmVzcyB7IHdob3NlX3R1cm4gPSBQMSB9IH1cbiAgfCBGbG9wIC0+XG4gICAgICBsZXQgc3QgPSByZXZlYWxfdHVybiBzdCBpblxuICAgICAgeyBzdCB3aXRoIHN0YWdlID0gVHVybjsgdG9fY2FsbCA9IDA7IGxhc3RfY2hlY2sgPSBmYWxzZTsgZGVjaXNpb24gPSBJbl9wcm9ncmVzcyB7IHdob3NlX3R1cm4gPSBQMSB9IH1cbiAgfCBUdXJuIC0+XG4gICAgICBsZXQgc3QgPSByZXZlYWxfcml2ZXIgc3QgaW5cbiAgICAgIHsgc3Qgd2l0aCBzdGFnZSA9IFJpdmVyOyB0b19jYWxsID0gMDsgbGFzdF9jaGVjayA9IGZhbHNlOyBkZWNpc2lvbiA9IEluX3Byb2dyZXNzIHsgd2hvc2VfdHVybiA9IFAxIH0gfVxuICB8IFJpdmVyIC0+XG4gICAgICB7IHN0IHdpdGggc3RhZ2UgPSBTaG93ZG93biB9XG4gIHwgXyAtPiBzdFxuXG5sZXQgc2hvd2Rvd24gc3QgPVxuICBsZXQgYyA9IGNvbXBhcmVfaG9sZXNfd2l0aF9ib2FyZCBzdC5wMSBzdC5wMiBzdC5ib2FyZCBpblxuICBsZXQgd2lubmVyID0gaWYgYyA+IDAgdGhlbiBQMSBlbHNlIGlmIGMgPCAwIHRoZW4gUDIgZWxzZSBQMSBpblxuICB7IHN0IHdpdGggc3RhZ2UgPSBGaW5pc2hlZDsgZGVjaXNpb24gPSBXaW5uZXIgd2lubmVyIH1cblxubGV0IG1ha2VfbW92ZSBzdCBtdiA9XG4gIG1hdGNoIHN0LmRlY2lzaW9uIHdpdGhcbiAgfCBXaW5uZXIgXyB8IFN0YWxlbWF0ZSAtPiBFcnJvciBNb3ZlX2Vycm9yLkdhbWVfb3ZlclxuICB8IEluX3Byb2dyZXNzIHsgd2hvc2VfdHVybiB9IC0+XG4gICAgYmVnaW4gbWF0Y2ggc3Quc3RhZ2UsIG12IHdpdGhcbiAgICB8IFByZWRlYWwsIF8gLT5cbiAgICAgICAgbGV0IHN0ID0gZGVhbF9ob2xlcyBzdCBpblxuICAgICAgICBPayB7IHN0IHdpdGggc3RhZ2UgPSBQcmVmbG9wOyBkZWNpc2lvbiA9IEluX3Byb2dyZXNzIHsgd2hvc2VfdHVybiA9IFAxIH07XG4gICAgICAgICAgICAgICAgICAgICB0b19jYWxsID0gMDsgbGFzdF9jaGVjayA9IGZhbHNlOyBwb3QgPSAwIH1cbiAgICB8IChQcmVmbG9wIHwgRmxvcCB8IFR1cm4gfCBSaXZlciksIEZvbGQgLT5cbiAgICAgICAgbGV0IHdpbm5lciA9IHRvX290aGVyIHdob3NlX3R1cm4gaW5cbiAgICAgICAgT2sgeyBzdCB3aXRoIHN0YWdlID0gRmluaXNoZWQ7IGRlY2lzaW9uID0gV2lubmVyIHdpbm5lciB9XG4gICAgfCAoUHJlZmxvcCB8IEZsb3AgfCBUdXJuIHwgUml2ZXIpLCBDaGVjayAtPlxuICAgICAgICBpZiBzdC50b19jYWxsIDw+IDAgdGhlbiBFcnJvciBNb3ZlX2Vycm9yLklsbGVnYWxfbW92ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgaWYgc3QubGFzdF9jaGVjayB0aGVuXG4gICAgICAgICAgICBsZXQgc3QnID0gYWR2YW5jZV9zdHJlZXQgc3QgaW5cbiAgICAgICAgICAgIGlmIHN0Jy5zdGFnZSA9IFNob3dkb3duIHRoZW4gT2sgKHNob3dkb3duIHN0JylcbiAgICAgICAgICAgIGVsc2UgT2sgeyBzdCcgd2l0aCBkZWNpc2lvbiA9IEluX3Byb2dyZXNzIHsgd2hvc2VfdHVybiA9IFAxIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2NoZWNrID0gZmFsc2UgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIE9rIHsgc3Qgd2l0aCBkZWNpc2lvbiA9IEluX3Byb2dyZXNzIHsgd2hvc2VfdHVybiA9IHRvX290aGVyIHdob3NlX3R1cm4gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfY2hlY2sgPSB0cnVlIH1cbiAgICB8IChQcmVmbG9wIHwgRmxvcCB8IFR1cm4gfCBSaXZlciksIEJldCBuIC0+XG4gICAgICAgIGlmIG4gPD0gMCB8fCBzdC50b19jYWxsIDw+IDAgdGhlbiBFcnJvciBNb3ZlX2Vycm9yLklsbGVnYWxfbW92ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgT2sgeyBzdCB3aXRoIHBvdCA9IHN0LnBvdCArIG47IHRvX2NhbGwgPSBuOyBsYXN0X2NoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgZGVjaXNpb24gPSBJbl9wcm9ncmVzcyB7IHdob3NlX3R1cm4gPSB0b19vdGhlciB3aG9zZV90dXJuIH0gfVxuICAgIHwgKFByZWZsb3AgfCBGbG9wIHwgVHVybiB8IFJpdmVyKSwgQ2FsbCAtPlxuICAgICAgICBpZiBzdC50b19jYWxsID0gMCB0aGVuIEVycm9yIE1vdmVfZXJyb3IuSWxsZWdhbF9tb3ZlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgc3QnID0geyBzdCB3aXRoIHBvdCA9IHN0LnBvdCArIHN0LnRvX2NhbGw7IHRvX2NhbGwgPSAwIH0gaW5cbiAgICAgICAgICBsZXQgc3QnJyA9IGFkdmFuY2Vfc3RyZWV0IHN0JyBpblxuICAgICAgICAgIGlmIHN0Jycuc3RhZ2UgPSBTaG93ZG93biB0aGVuIE9rIChzaG93ZG93biBzdCcnKVxuICAgICAgICAgIGVsc2UgT2sgeyBzdCcnIHdpdGggZGVjaXNpb24gPSBJbl9wcm9ncmVzcyB7IHdob3NlX3R1cm4gPSBQMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2NoZWNrID0gZmFsc2UgfVxuICAgIHwgU2hvd2Rvd24sIF8gLT5cbiAgICAgICAgT2sgKHNob3dkb3duIHN0KVxuICAgIHwgRmluaXNoZWQsIF8gLT5cbiAgICAgICAgRXJyb3IgTW92ZV9lcnJvci5HYW1lX292ZXJcbiAgICBlbmRcblxuKCogLS0tIE5haXZlIGJvdCAtLS0gKilcbmxldCBoYXNfcGFpciBjYXJkcyA9XG4gIGxldCB0YmwgPSBIYXNodGJsLmNyZWF0ZSA4IGluXG4gIExpc3QuaXRlciAoZnVuIGMgLT5cbiAgICBsZXQgayA9IHJhbmtfdG9faW50IGMucmFuayBpblxuICAgIEhhc2h0YmwucmVwbGFjZSB0YmwgayAoMSArIChtYXRjaCBIYXNodGJsLmZpbmRfb3B0IHRibCBrIHdpdGggU29tZSBuLT5uIHwgTm9uZS0+MCkpXG4gICkgY2FyZHM7XG4gIEhhc2h0YmwudG9fc2VxIHRibCB8PiBTZXEuZXhpc3RzIChmdW4gKF8sdiktPiB2Pj0yKVxuXG5sZXQgY2hvb3NlX21vdmUgc3QgPVxuICBtYXRjaCBzdC5zdGFnZSB3aXRoXG4gIHwgUHJlZmxvcCB8IEZsb3AgfCBUdXJuIHwgUml2ZXIgLT5cbiAgICAgIGlmIHN0LnRvX2NhbGwgPSAwIHRoZW5cbiAgICAgICAgbGV0IG15ID1cbiAgICAgICAgICBtYXRjaCBzdC5kZWNpc2lvbiB3aXRoXG4gICAgICAgICAgfCBJbl9wcm9ncmVzcyB7IHdob3NlX3R1cm4gPSBQMSB9IC0+IHN0LnAxXG4gICAgICAgICAgfCBfIC0+IHN0LnAyXG4gICAgICAgIGluXG4gICAgICAgIGlmIGhhc19wYWlyIChteSBAIHN0LmJvYXJkKSB0aGVuIEJldCA1IGVsc2UgQ2hlY2tcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IG15ID1cbiAgICAgICAgICBtYXRjaCBzdC5kZWNpc2lvbiB3aXRoXG4gICAgICAgICAgfCBJbl9wcm9ncmVzcyB7IHdob3NlX3R1cm4gPSBQMSB9IC0+IHN0LnAxXG4gICAgICAgICAgfCBfIC0+IHN0LnAyXG4gICAgICAgIGluXG4gICAgICAgIGlmIGhhc19wYWlyIChteSBAIHN0LmJvYXJkKSB0aGVuIENhbGwgZWxzZSBGb2xkXG4gIHwgXyAtPiBDaGVja1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9pbnRfY29tcGFyZSIsImNhbWxfbGlzdF9vZl9qc19hcnJheSIsImdsb2JhbF9kYXRhIiwiYWxsX3JhbmtzIiwiYWxsX3N1aXRzIiwiU3RkbGliIiwiU3RkbGliX0hhc2h0YmwiLCJTdGRsaWJfTGlzdCIsIlN0ZGxpYl9TZXEiLCJTdGRsaWJfT3B0aW9uIiwiU3RkbGliX0FycmF5IiwiU3RkbGliX1JhbmRvbSIsIkNyZWF0ZV9lcnJvciIsIk1vdmVfZXJyb3IiLCJyYW5rX3RvX2ludCIsInBhcmFtIiwiY3JlYXRlIiwicyIsInIiLCJsc3QiLCJhIiwiaSIsImoiLCJ0bXAiLCJkIiwiZXZhbF9oYW5kIiwiY2FyZHMiLCJjcyIsImMiLCJmbHVzaCIsIngiLCJycyIsImhpIiwibWF0Y2giLCJzdHJhaWdodCIsInJlc3QiLCJiIiwidGJsIiwiayIsIm4iLCJwYWlycyIsInYiLCJhY2MiLCJ2MiIsImsyIiwidjEiLCJrMSIsImtzIiwiazMiLCJsbyIsImtpY2tlciIsImtpY2tlcnMiLCJjb21wYXJlX2xpc3RzIiwieHMiLCJ5cyIsImJ5IiwieSIsImF4IiwiY29tcGFyZV81IiwiaDEiLCJoMiIsInIxIiwicjIiLCJvcmQiLCJreCIsInAxIiwia3kiLCJwMiIsImIxIiwiYTEiLCJiMiIsImEyIiwia2EiLCJrYiIsImNvbWJvc181IiwiY2hvb3NlIiwieHQiLCJ3aXRoX3giLCJ3aXRob3V0X3giLCJjb21wYXJlX2hvbGVzX3dpdGhfYm9hcmQiLCJib2FyZCIsInBvb2wxIiwicG9vbDIiLCJjYW5kIiwiY3VyIiwiYmVzdDEiLCJiZXN0MiIsImRyYXdfbiIsImRlY2siLCJ0b19vdGhlciIsImFkdmFuY2Vfc3RyZWV0Iiwic3QiLCJkMSIsImZsb3AiLCJ0Iiwic2hvd2Rvd24iLCJ3aW5uZXIiLCJtYWtlX21vdmUiLCJtdiIsIndob3NlX3R1cm4iLCJwMWgiLCJkMiIsInAyaCIsImhhc19wYWlyIiwiY2hvb3NlX21vdmUiLCJteSIsIlBva2VyIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxHQ0FTO0FBQUE7QUFBQSxJQUFBQyxlQUFtQjtBQUFBLElBQUFDLGFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFlBQUFDO0FBQUFBLElBd0NWO0FBQUE7QUFBQSxPQUNUO0FBQUE7QUFBQSxPQUFXO0FBQUE7QUFBQSxPQUFVO0FBQUE7QUFBQSxPQUFVO0FBQUE7QUFBQSxPQUFTO0FBQUE7QUFBQSxPQUFXO0FBQUE7QUFBQSxPQUFXO0FBQUE7QUFBQSxPQUM3RDtBQUFBO0FBQUEsT0FBUztBQUFBO0FBQUEsT0FBVztBQUFBO0FBQUEsT0FBWTtBQUFBO0FBQUEsT0FBVztBQUFBLGVBQVU7QUFBQTtBQUFBLEdBQUU7QUFBQSxZQUFBQyxPQUFBRDtBQUFBQTtBQUFBQSxLQUFBO0FBQUEsT0FHbkQ7QUFBQTtBQUFBLGtCQUFBRTtBQUFBQSxVQUNWO0FBQUEsa0NBQUFDLEdBQW1CLGlCQUFnQixhQUFXO0FBQUE7QUFBQTtBQUFBLEtBQUFDLE1BQVk7QUFBQSxLQUFBQyxNQUdwRDtBQUFBLFNBQ1I7QUFBQTtBQUFBLFNBQUFDLElBQUE7QUFBQTtBQUFBO0FBQUEsT0FBQUMsSUFDVTtB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TixTQU1pQjtBQUFBLFlBQ2I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFFQSxnQkFBd0I7QUFBQSxZQUV0QjtBQUFBLGlCQUFBTCxPQUNZO0FBQUEsYUFDVjtBQUFBLDJCQUFnQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMkJBdUJyQztBQUFBO0FBQUEsb0JBbkJ3RDtBQUFBLFlBQW1CO0FBQUE7QUFBQTtBQUFBLFlBUTFFLGdCQUF1QjtBQUFBO0FBQUEsYUFBQUE7QUFBQUEsZUFFckI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQUFBQSxPQUNXO0FBQUEsWUFDWDtBQUFBLDBCQUFpQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMEJBT3BDO0FBQUE7QUFBQSxZQUFBcEQsTUFwQ0g7QUFBQSxRQW9CSTtBQUFBLGlCQUdvRDtBQUFBLFNBQW1CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBSHJDO0FBQUE7QUFBQTtBQUFBLElBdEJkO0FBQUEsR0FzQ3JCO0FBQUEsWUFBQWdFLFNBQUE3RTtBQUFBQSxRQUFBVyxNQUlLO0FBQUEsSUFDVjtBQUFBO0FBQUEsZUFBQVQ7QUFBQUE7QUFBQUEsUUFBQVUsSUFDVTtBQUFBLFFBQUFMLFFBQzBCO0FBQUEsT0FBc0IsY0FBQU0sSUFBQSxVQUFBQSxNQUFjLFlBQUFBLE1BQVU7QUFBQSxPQUF4Qix5REFBMkI7QUFBQTtBQUFBO0FBQUEsWUFFckY7QUFBQSxJQUFzQjtBQUFBO0FBQUEsc0JBQUF4QixXQUFBMEIsSUFBVyxVQUFhLHNCQUFLO0FBQUE7QUFBQTtBQUFBLFlBQUErRCxZQUFBYjtBQUFBQSxJQUduRCx3QkFnQk87QUFBQSxJQWRIO0FBQUEsYUFDRTtBQUFBO0FBQUE7QUFBQSw0REFBQWMsS0FFdUM7QUFBQSxVQUFBQSxLQUM5QjtBQUFBO0FBQUEsS0FFRyxPQUFULFNBQVMseUNBUU47QUFBQTtBQUFBLFlBTk47QUFBQTtBQUFBO0FBQUEsMkRBQUFBLE9BRXVDO0FBQUEsU0FBQUEsT0FDOUI7QUFBQTtBQUFBLElBRUcsT0FBVCxTQUFTLDJDQUNOO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BbFVjO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURBNUIiLCJpZ25vcmVMaXN0IjpbMF19fV19
